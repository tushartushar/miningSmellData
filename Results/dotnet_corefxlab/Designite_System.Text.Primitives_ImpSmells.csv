Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The method has 245 lines of code.
Long Method,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The method has 285 lines of code.
Long Method,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The method has 487 lines of code.
Long Method,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The method has 151 lines of code.
Long Method,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The method has 162 lines of code.
Long Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The method has 105 lines of code.
Complex Method,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,Cyclomatic complexity of the method is 19
Complex Method,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,Cyclomatic complexity of the method is 12
Complex Method,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,Cyclomatic complexity of the method is 24
Complex Method,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,Cyclomatic complexity of the method is 14
Complex Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,Cyclomatic complexity of the method is 19
Complex Method,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,ParsingTrie,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateParsingTrieNodeAndChildren,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers.Text,ParsingTrie,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,Create,Cyclomatic complexity of the method is 8
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormat,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatNumber,The method has 6 parameters. Parameters: value' isSingle' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatInt64,The method has 6 parameters. Parameters: value' mask' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatUInt64,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The method has 5 parameters. Parameters: value' buffer' bytesWritten' format' symbolTable
Long Parameter List,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatCore,The method has 5 parameters. Parameters: value' mask' buffer' bytesWritten' format
Long Parameter List,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The method has 5 parameters. Parameters: value' precision' useLower' buffer' bytesWritten
Long Parameter List,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The method has 5 parameters. Parameters: text' value' bytesConsumed' format' symbolTable
Long Parameter List,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The method has 6 parameters. Parameters: text' ends' begin' end' value' charactersConsumed
Long Identifier,System.Buffers.Text,EncodingHelper,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,,The length of the parameter BasicMultilingualPlaneEndMarker is 31.
Long Identifier,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The length of the parameter pbFinalPosAtWhichCanReadTwoVectors is 34.
Long Identifier,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the parameter inputBufferFinalOffsetAtWhichCanSafelyLoop is 42.
Long Identifier,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The length of the parameter trailingZerosAfterDecimalCount is 30.
Long Statement,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The length of the statement  "                // KEEP THIS IMPLEMENTATION IN SYNC WITH https://github.com/dotnet/corert/blob/master/src/System.Private.CoreLib/src/System/Text/UTF8Encoding.cs " is 144.
Long Statement,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U); " is 121.
Long Statement,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U); " is 122.
Long Statement,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U); " is 125.
Long Statement,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U); " is 122.
Long Statement,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U); " is 126.
Long Statement,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The length of the statement  "                            Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U); " is 125.
Long Statement,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The length of the statement  "                            Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)(((codePoint - 0x010000u) >> 10) + EncodingHelper.HighSurrogateStart); " is 139.
Long Statement,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The length of the statement  "                            Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten + 2)) = (char)((codePoint & 0x3FF) + EncodingHelper.LowSurrogateStart); " is 130.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The length of the statement  "                    if (((Unsafe.Read<Vector<byte>>(pbAlignedBuffer) | Unsafe.Read<Vector<byte>>(pbAlignedBuffer + Vector<byte>.Count)) & mask) != Vector<byte>.Zero) " is 145.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                    if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer))) " is 137.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                        inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong); " is 160.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                    if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer))) " is 136.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                        inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint); " is 157.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read."); " is 129.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                        || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord)))) " is 135.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "                        if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong)))) " is 160.
Long Statement,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The length of the statement  "            scalarCount = tempScalarCount - inputBufferRemainingBytes; // we assumed earlier each byte corresponded to a single scalar' perform fixup now to account for unread bytes " is 169.
Long Statement,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The length of the statement  "                // Count amount of digits before first group separator. It will be reset to groupSize every time digitsLeftInGroup == zero " is 122.
Long Statement,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The length of the statement  "                throw new NotImplementedException("The only supported encodings for hexadecimal parsing are InvariantUtf8 and InvariantUtf16."); " is 128.
Long Statement,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt32(text.Slice(0' 8)' out uint i1' out int justConsumed) || justConsumed != 8) return false; // 8 digits " is 124.
Long Statement,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt16(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4) return false; // next 4 digfits " is 128.
Long Statement,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt16(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4) return false; // next 4 digits " is 128.
Long Statement,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt16(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4) return false; // next 4 digits " is 128.
Long Statement,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The length of the statement  "            if (!Hex.TryParseUInt64(text.Slice(20)' out ulong i5' out justConsumed) || justConsumed != 12) return false; // next 12 digits " is 126.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The length of the statement  "                    // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The length of the statement  "                    // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The length of the statement  "                    // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex " is 120.
Long Statement,System.Buffers.Text,ParsingTrie,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateParsingTrieNodeAndChildren,The length of the statement  "            // Reserve space in list for child nodes. In this algorithm' all parent nodes are created first' leaving gaps for the child nodes " is 129.
Long Statement,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryParse,The length of the statement  "                if (_parsingTrie[trieIndex].ValueOrNumChildren == 0)    // if numChildren == 0' we're on a leaf & we've found our value and completed the code unit " is 147.
Long Statement,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryParse,The length of the statement  "                    int search = BinarySearch(trieIndex' codeUnitIndex' source[codeUnitIndex]);    // we search the _parsingTrie for the nextByte " is 125.
Long Statement,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryEncode,The length of the statement  "                if(Encodings.Utf16.ToUtf8(srcBytes' temp' out int consumed' out int written) == OperationStatus.InvalidData)                     goto ExitFailed; " is 145.
Complex Conditional,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The conditional expression  "(BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord)))"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The conditional expression  "(text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e')"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The conditional expression  "(decimalPlace && signed && charactersConsumed == 2) || ((signed || decimalPlace) && charactersConsumed == 1)"  is complex.
Complex Conditional,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The conditional expression  "(decimalPlace && signed && charactersConsumed == 2) || ((signed || decimalPlace) && charactersConsumed == 1)"  is complex.
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,ToLowerInPlace,The following statement contains a magic number: for (bytesChanged = 0; bytesChanged < ascii.Length; bytesChanged++)                  {                      byte next = ascii[bytesChanged];                      if (next > 127)                      {                          return OperationStatus.InvalidData;                      }                      ascii[bytesChanged] = s_toLower[next];                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,ToLower,The following statement contains a magic number: for (processedBytes = 0; processedBytes < min; processedBytes++)                  {                      byte next = input[processedBytes];                      if (next > 127) return OperationStatus.InvalidData;                      output[processedBytes] = s_toLower[next];                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,ToUpperInPlace,The following statement contains a magic number: for (bytesChanged = 0; bytesChanged < ascii.Length; bytesChanged++)                  {                      byte next = ascii[bytesChanged];                      if (next > 127) return OperationStatus.InvalidData;                      ascii[bytesChanged] = s_toUpper[next];                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,ToUpper,The following statement contains a magic number: for (processedBytes = 0; processedBytes < min; processedBytes++)                  {                      byte next = input[processedBytes];                      if (next > 127) return OperationStatus.InvalidData;                      output[processedBytes] = s_toUpper[next];                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5) | *(input + 6) |                          *(input + 7) | *(input + 8) | *(input + 9) | *(input + 10) |                          *(input + 11);                        i += 12;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      *(output + 6) = (char)*(input + 6);                      *(output + 7) = (char)*(input + 7);                      *(output + 8) = (char)*(input + 8);                      *(output + 9) = (char)*(input + 9);                      *(output + 10) = (char)*(input + 10);                      *(output + 11) = (char)*(input + 11);                      output += 12;                      input += 12;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3) | *(input + 4) | *(input + 5);                        i += 6;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      *(output + 4) = (char)*(input + 4);                      *(output + 5) = (char)*(input + 5);                      output += 6;                      input += 6;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)                  {                      isValid = isValid | *input | *(input + 1) | *(input + 2) |                          *(input + 3);                        i += 4;                      *(output) = (char)*(input);                      *(output + 1) = (char)*(input + 1);                      *(output + 2) = (char)*(input + 2);                      *(output + 3) = (char)*(input + 3);                      output += 4;                      input += 4;                  }
Magic Number,System.Buffers.Text,Ascii,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Ascii\Ascii_casing.cs,TryGetAsciiString,The following statement contains a magic number: return isValid <= 127;
Magic Number,System.Buffers.Text,EncodingHelper,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8DecodedBytes,The following statement contains a magic number: if ((b & b1110_0000U) == b1100_0000U)                  return 2;
Magic Number,System.Buffers.Text,EncodingHelper,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8DecodedBytes,The following statement contains a magic number: if ((b & b1111_0000U) == b1110_0000U)                  return 3;
Magic Number,System.Buffers.Text,EncodingHelper,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8DecodedBytes,The following statement contains a magic number: if ((b & b1111_1000U) == b1111_0000U)                  return 4;
Magic Number,System.Buffers.Text,EncodingHelper,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8EncodedBytes,The following statement contains a magic number: if (codePoint <= 0x7FF)                  return 2;
Magic Number,System.Buffers.Text,EncodingHelper,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8EncodedBytes,The following statement contains a magic number: if (codePoint <= 0xFFFF)                  return 3;
Magic Number,System.Buffers.Text,EncodingHelper,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\EncodingHelper.cs,GetUtf8EncodedBytes,The following statement contains a magic number: if (codePoint <= 0x10FFFF)                  return 4;
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf16CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x10000U && utf16.Length >= 1)              {                  // Scalar is single UTF-16 code unit                  utf16[0] = (char)Value;              }              else if (utf16.Length >= 2)              {                  // Scalar is surrogate pair                  utf16[0] = (char)(0xD7C0U + ((uint)Value >> 10));                  utf16[1] = (char)(0xDC00U | ((uint)Value & 0x3FFU));              }              else              {                  throw new ArgumentException(                      message: "Argument is not long enough to hold output value."'                      paramName: nameof(utf16));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf16CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x10000U && utf16.Length >= 1)              {                  // Scalar is single UTF-16 code unit                  utf16[0] = (char)Value;              }              else if (utf16.Length >= 2)              {                  // Scalar is surrogate pair                  utf16[0] = (char)(0xD7C0U + ((uint)Value >> 10));                  utf16[1] = (char)(0xDC00U | ((uint)Value & 0x3FFU));              }              else              {                  throw new ArgumentException(                      message: "Argument is not long enough to hold output value."'                      paramName: nameof(utf16));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,UnicodeScalar,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\UnicodeScalar.cs,CopyUtf8CodeUnitsTo,The following statement contains a magic number: if ((uint)Value < 0x80U && utf8.Length >= 1)              {                  // Single UTF-8 code unit                  utf8[0] = (byte)Value;              }              else if ((uint)Value < 0x800U && utf8.Length >= 2)              {                  // Two UTF-8 code units                  utf8[0] = (byte)(0xC0U | ((uint)Value >> 6));                  utf8[1] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if ((uint)Value < 0x10000U && utf8.Length >= 3)              {                  // Three UTF-8 code units                  utf8[0] = (byte)(0xE0U | ((uint)Value >> 12));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[2] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else if (utf8.Length >= 4)              {                  // Four UTF-8 code units                  utf8[0] = (byte)(0xF0U | ((uint)Value >> 18));                  utf8[1] = (byte)(0x80U | (((uint)Value >> 12) & 0x3FU));                  utf8[2] = (byte)(0x80U | (((uint)Value >> 6) & 0x3FU));                  utf8[3] = (byte)(0x80U | ((uint)Value & 0x3FU));              }              else              {                  throw new ArgumentException(                    message: "Argument is not long enough to hold output value."'                    paramName: nameof(utf8));              }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf8,The following statement contains a magic number: fixed (byte* chars = &source.DangerousGetPinnableReference())                  fixed (byte* bytes = &destination.DangerousGetPinnableReference())                  {                      char* pSrc = (char*)chars;                      byte* pTarget = bytes;                        char* pEnd = (char*)(chars + source.Length);                      byte* pAllocatedBufferEnd = pTarget + destination.Length;                        // assume that JIT will enregister pSrc' pTarget and ch                        // Entering the fast encoding loop incurs some overhead that does not get amortized for small                      // number of characters' and the slow encoding loop typically ends up running for the last few                      // characters anyway since the fast encoding loop needs 5 characters on input at least.                      // Thus don't use the fast decoding loop at all if we don't have enough characters. The threashold                      // was choosen based on performance testing.                      // Note that if we don't have enough bytes' pStop will prevent us from entering the fast loop.                      while (pEnd - pSrc > 13)                      {                          // we need at least 1 byte per character' but Convert might allow us to convert                          // only part of the input' so try as much as we can.  Reduce charCount if necessary                          int available = Math.Min(EncodingHelper.PtrDiff(pEnd' pSrc)' EncodingHelper.PtrDiff(pAllocatedBufferEnd' pTarget));                            // FASTLOOP:                          // - optimistic range checks                          // - fallbacks to the slow loop for all special cases' exception throwing' etc.                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 5 chars reserve for the unrolled ansi decoding loop and for decoding of surrogates                          // If there aren't enough bytes for the output' then pStop will be <= pSrc and will bypass the loop.                          char* pStop = pSrc + available - 5;                          if (pSrc >= pStop)                              break;                            do                          {                              int ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                                // get pSrc aligned                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                  if (ch > 0x7F)                                  {                                      goto LongCode;                                  }                                  *pTarget = (byte)ch;                                  pTarget++;                              }                                // Run 4 characters at a time!                              while (pSrc < pStop)                              {                                  ch = *(int*)pSrc;                                  int chc = *(int*)(pSrc + 2);                                  if (((ch | chc) & unchecked((int)0xFF80FF80)) != 0)                                  {                                      goto LongCodeWithMask;                                  }                                    // Unfortunately' this is endianess sensitive  #if BIGENDIAN                              *pTarget = (byte)(ch >> 16);                              *(pTarget + 1) = (byte)ch;                              pSrc += 4;                              *(pTarget + 2) = (byte)(chc >> 16);                              *(pTarget + 3) = (byte)chc;                              pTarget += 4;  #else // BIGENDIAN                                  *pTarget = (byte)ch;                                  *(pTarget + 1) = (byte)(ch >> 16);                                  pSrc += 4;                                  *(pTarget + 2) = (byte)chc;                                  *(pTarget + 3) = (byte)(chc >> 16);                                  pTarget += 4;  #endif // BIGENDIAN                              }                              continue;                                LongCodeWithMask:  #if BIGENDIAN                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);  #else // BIGENDIAN                              ch = (char)ch;  #endif // BIGENDIAN                              pSrc++;                                if (ch > 0x7F)                              {                                  goto LongCode;                              }                              *pTarget = (byte)ch;                              pTarget++;                              continue;                                LongCode:                              // use separate helper variables for slow and fast loop so that the jit optimizations                              // won't get confused about the variable lifetimes                              int chd;                              if (ch <= 0x7FF)                              {                                  // 2 byte encoding                                  chd = unchecked((sbyte)0xC0) | (ch >> 6);                              }                              else                              {                                  // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                                  if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // 3 byte encoding                                      chd = unchecked((sbyte)0xE0) | (ch >> 12);                                  }                                  else                                  {                                      // 4 byte encoding - high surrogate + low surrogate                                      // if (!IsHighSurrogate(ch))                                      if (ch > EncodingHelper.HighSurrogateEnd)                                      {                                          // low without high -> bad                                          goto InvalidData;                                      }                                        chd = *pSrc;                                        // if (!IsLowSurrogate(chd)) {                                      if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                      {                                          // high not followed by low -> bad                                          goto InvalidData;                                      }                                        pSrc++;                                        ch = chd + (ch << 10) +                                          (0x10000                                          - EncodingHelper.LowSurrogateStart                                          - (EncodingHelper.HighSurrogateStart << 10));                                        *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                      // pStop - this byte is compensated by the second surrogate character                                      // 2 input chars require 4 output bytes.  2 have been anticipated already                                      // and 2 more will be accounted for by the 2 pStop-- calls below.                                      pTarget++;                                        chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                                  }                                  *pTarget = (byte)chd;                                  pStop--;                    // 3 byte sequence for 1 char' so need pStop-- and the one below too.                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                              }                              *pTarget = (byte)chd;                              pStop--;                        // 2 byte sequence for 1 char so need pStop--.                                *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                              // pStop - this byte is already included                                pTarget += 2;                          }                          while (pSrc < pStop);                            Debug.Assert(pTarget <= pAllocatedBufferEnd' "[UTF8Encoding.GetBytes]pTarget <= pAllocatedBufferEnd");                      }                        while (pSrc < pEnd)                      {                          // SLOWLOOP: does all range checks' handles all special cases' but it is slow                            // read next char. The JIT optimization seems to be getting confused when                          // compiling "ch = *pSrc++;"' so rather use "ch = *pSrc; pSrc++;" instead                          int ch = *pSrc;                          pSrc++;                            if (ch <= 0x7F)                          {                              if (pAllocatedBufferEnd - pTarget <= 0)                                  goto DestinationFull;                                *pTarget = (byte)ch;                              pTarget++;                              continue;                          }                            int chd;                          if (ch <= 0x7FF)                          {                              if (pAllocatedBufferEnd - pTarget <= 1)                                  goto DestinationFull;                                // 2 byte encoding                              chd = unchecked((sbyte)0xC0) | (ch >> 6);                          }                          else                          {                              // if (!IsLowSurrogate(ch) && !IsHighSurrogate(ch))                              if (!EncodingHelper.InRange(ch' EncodingHelper.HighSurrogateStart' EncodingHelper.LowSurrogateEnd))                              {                                  if (pAllocatedBufferEnd - pTarget <= 2)                                      goto DestinationFull;                                    // 3 byte encoding                                  chd = unchecked((sbyte)0xE0) | (ch >> 12);                              }                              else                              {                                  if (pAllocatedBufferEnd - pTarget <= 3)                                      goto DestinationFull;                                    // 4 byte encoding - high surrogate + low surrogate                                  // if (!IsHighSurrogate(ch))                                  if (ch > EncodingHelper.HighSurrogateEnd)                                  {                                      // low without high -> bad                                      goto InvalidData;                                  }                                    if (pSrc >= pEnd)                                      goto NeedMoreData;                                    chd = *pSrc;                                    // if (!IsLowSurrogate(chd)) {                                  if (!EncodingHelper.InRange(chd' EncodingHelper.LowSurrogateStart' EncodingHelper.LowSurrogateEnd))                                  {                                      // high not followed by low -> bad                                      goto InvalidData;                                  }                                    pSrc++;                                    ch = chd + (ch << 10) +                                      (0x10000                                      - EncodingHelper.LowSurrogateStart                                      - (EncodingHelper.HighSurrogateStart << 10));                                    *pTarget = (byte)(unchecked((sbyte)0xF0) | (ch >> 18));                                  pTarget++;                                    chd = unchecked((sbyte)0x80) | (ch >> 12) & 0x3F;                              }                              *pTarget = (byte)chd;                              pTarget++;                                chd = unchecked((sbyte)0x80) | (ch >> 6) & 0x3F;                          }                            *pTarget = (byte)chd;                          *(pTarget + 1) = (byte)(unchecked((sbyte)0x80) | ch & 0x3F);                            pTarget += 2;                      }                        bytesConsumed = (int)((byte*)pSrc - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.Done;                        InvalidData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.InvalidData;                        DestinationFull:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = (int)((byte*)(pSrc - 1) - chars);                      bytesWritten = (int)(pTarget - bytes);                      return OperationStatus.NeedMoreData;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: while (srcLength - srcIndex >= sizeof(char))                  {                      uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - srcIndex < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            srcIndex += 2;                      }                        srcIndex += 2;                      bytesNeeded += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: while (srcLength - srcIndex >= sizeof(char))                  {                      uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - srcIndex < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            srcIndex += 2;                      }                        srcIndex += 2;                      bytesNeeded += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: while (srcLength - srcIndex >= sizeof(char))                  {                      uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - srcIndex < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            srcIndex += 2;                      }                        srcIndex += 2;                      bytesNeeded += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: while (srcLength - srcIndex >= sizeof(char))                  {                      uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - srcIndex < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            srcIndex += 2;                      }                        srcIndex += 2;                      bytesNeeded += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32Length,The following statement contains a magic number: while (srcLength - srcIndex >= sizeof(char))                  {                      uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - srcIndex < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' srcIndex + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            srcIndex += 2;                      }                        srcIndex += 2;                      bytesNeeded += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(char))                  {                      if (dstLength - bytesWritten < sizeof(uint))                          return OperationStatus.DestinationTooSmall;                        uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - bytesConsumed < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            codePoint -= EncodingHelper.HighSurrogateStart;                          lowSurrogate -= EncodingHelper.LowSurrogateStart;                          codePoint = ((codePoint << 10) | lowSurrogate) + 0x010000u;                          bytesConsumed += 2;                      }                        Unsafe.As<byte' uint>(ref Unsafe.Add(ref dst' bytesWritten)) = codePoint;                      bytesConsumed += 2;                      bytesWritten += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(char))                  {                      if (dstLength - bytesWritten < sizeof(uint))                          return OperationStatus.DestinationTooSmall;                        uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - bytesConsumed < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            codePoint -= EncodingHelper.HighSurrogateStart;                          lowSurrogate -= EncodingHelper.LowSurrogateStart;                          codePoint = ((codePoint << 10) | lowSurrogate) + 0x010000u;                          bytesConsumed += 2;                      }                        Unsafe.As<byte' uint>(ref Unsafe.Add(ref dst' bytesWritten)) = codePoint;                      bytesConsumed += 2;                      bytesWritten += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(char))                  {                      if (dstLength - bytesWritten < sizeof(uint))                          return OperationStatus.DestinationTooSmall;                        uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - bytesConsumed < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            codePoint -= EncodingHelper.HighSurrogateStart;                          lowSurrogate -= EncodingHelper.LowSurrogateStart;                          codePoint = ((codePoint << 10) | lowSurrogate) + 0x010000u;                          bytesConsumed += 2;                      }                        Unsafe.As<byte' uint>(ref Unsafe.Add(ref dst' bytesWritten)) = codePoint;                      bytesConsumed += 2;                      bytesWritten += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(char))                  {                      if (dstLength - bytesWritten < sizeof(uint))                          return OperationStatus.DestinationTooSmall;                        uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - bytesConsumed < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            codePoint -= EncodingHelper.HighSurrogateStart;                          lowSurrogate -= EncodingHelper.LowSurrogateStart;                          codePoint = ((codePoint << 10) | lowSurrogate) + 0x010000u;                          bytesConsumed += 2;                      }                        Unsafe.As<byte' uint>(ref Unsafe.Add(ref dst' bytesWritten)) = codePoint;                      bytesConsumed += 2;                      bytesWritten += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(char))                  {                      if (dstLength - bytesWritten < sizeof(uint))                          return OperationStatus.DestinationTooSmall;                        uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - bytesConsumed < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            codePoint -= EncodingHelper.HighSurrogateStart;                          lowSurrogate -= EncodingHelper.LowSurrogateStart;                          codePoint = ((codePoint << 10) | lowSurrogate) + 0x010000u;                          bytesConsumed += 2;                      }                        Unsafe.As<byte' uint>(ref Unsafe.Add(ref dst' bytesWritten)) = codePoint;                      bytesConsumed += 2;                      bytesWritten += 4;                  }
Magic Number,System.Buffers.Text,Utf16,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf16.cs,ToUtf32,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(char))                  {                      if (dstLength - bytesWritten < sizeof(uint))                          return OperationStatus.DestinationTooSmall;                        uint codePoint = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed));                      if (EncodingHelper.IsSurrogate(codePoint))                      {                          if (!EncodingHelper.IsHighSurrogate(codePoint))                              return OperationStatus.InvalidData;                            if (srcLength - bytesConsumed < sizeof(char) * 2)                              return OperationStatus.NeedMoreData;                            uint lowSurrogate = Unsafe.As<byte' char>(ref Unsafe.Add(ref src' bytesConsumed + 2));                          if (!EncodingHelper.IsLowSurrogate(lowSurrogate))                              return OperationStatus.InvalidData;                            codePoint -= EncodingHelper.HighSurrogateStart;                          lowSurrogate -= EncodingHelper.LowSurrogateStart;                          codePoint = ((codePoint << 10) | lowSurrogate) + 0x010000u;                          bytesConsumed += 2;                      }                        Unsafe.As<byte' uint>(ref Unsafe.Add(ref dst' bytesWritten)) = codePoint;                      bytesConsumed += 2;                      bytesWritten += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8Length,The following statement contains a magic number: int utf32Length = source.Length >> 2;
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8Length,The following statement contains a magic number: if (utf32Length << 2 != source.Length)                      return OperationStatus.NeedMoreData;
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf8,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      uint codePoint = Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                      if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int bytesNeeded = EncodingHelper.GetUtf8EncodedBytes(codePoint);                      if (dstLength - bytesWritten < bytesNeeded)                          return OperationStatus.DestinationTooSmall;                        switch (bytesNeeded)                      {                          case 1:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(EncodingHelper.b0111_1111U & codePoint);                              break;                            case 2:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 6) & EncodingHelper.b0001_1111U) | EncodingHelper.b1100_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 3:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 12) & EncodingHelper.b0000_1111U) | EncodingHelper.b1110_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            case 4:                              Unsafe.Add(ref dst' bytesWritten) = (byte)(((codePoint >> 18) & EncodingHelper.b0000_0111U) | EncodingHelper.b1111_0000U);                              Unsafe.Add(ref dst' bytesWritten + 1) = (byte)(((codePoint >> 12) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 2) = (byte)(((codePoint >> 6) & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              Unsafe.Add(ref dst' bytesWritten + 3) = (byte)((codePoint & EncodingHelper.b0011_1111U) | EncodingHelper.b1000_0000U);                              break;                            default:                              return OperationStatus.InvalidData;                      }                        bytesConsumed += 4;                      bytesWritten += bytesNeeded;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16Length,The following statement contains a magic number: while (length - index >= 4)                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' index));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        bytesNeeded += EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      index += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16Length,The following statement contains a magic number: while (length - index >= 4)                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' index));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        bytesNeeded += EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      index += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16Length,The following statement contains a magic number: while (length - index >= 4)                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' index));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        bytesNeeded += EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      index += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16Length,The following statement contains a magic number: while (length - index >= 4)                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' index));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        bytesNeeded += EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      index += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int written = EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      if (dstLength - bytesWritten < written)                          return OperationStatus.DestinationTooSmall;                        unchecked                      {                          if (written == 2)                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)codePoint;                          else                          {                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)(((codePoint - 0x010000u) >> 10) + EncodingHelper.HighSurrogateStart);                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten + 2)) = (char)((codePoint & 0x3FF) + EncodingHelper.LowSurrogateStart);                          }                      }                        bytesWritten += written;                      bytesConsumed += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int written = EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      if (dstLength - bytesWritten < written)                          return OperationStatus.DestinationTooSmall;                        unchecked                      {                          if (written == 2)                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)codePoint;                          else                          {                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)(((codePoint - 0x010000u) >> 10) + EncodingHelper.HighSurrogateStart);                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten + 2)) = (char)((codePoint & 0x3FF) + EncodingHelper.LowSurrogateStart);                          }                      }                        bytesWritten += written;                      bytesConsumed += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int written = EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      if (dstLength - bytesWritten < written)                          return OperationStatus.DestinationTooSmall;                        unchecked                      {                          if (written == 2)                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)codePoint;                          else                          {                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)(((codePoint - 0x010000u) >> 10) + EncodingHelper.HighSurrogateStart);                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten + 2)) = (char)((codePoint & 0x3FF) + EncodingHelper.LowSurrogateStart);                          }                      }                        bytesWritten += written;                      bytesConsumed += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int written = EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      if (dstLength - bytesWritten < written)                          return OperationStatus.DestinationTooSmall;                        unchecked                      {                          if (written == 2)                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)codePoint;                          else                          {                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)(((codePoint - 0x010000u) >> 10) + EncodingHelper.HighSurrogateStart);                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten + 2)) = (char)((codePoint & 0x3FF) + EncodingHelper.LowSurrogateStart);                          }                      }                        bytesWritten += written;                      bytesConsumed += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int written = EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      if (dstLength - bytesWritten < written)                          return OperationStatus.DestinationTooSmall;                        unchecked                      {                          if (written == 2)                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)codePoint;                          else                          {                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)(((codePoint - 0x010000u) >> 10) + EncodingHelper.HighSurrogateStart);                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten + 2)) = (char)((codePoint & 0x3FF) + EncodingHelper.LowSurrogateStart);                          }                      }                        bytesWritten += written;                      bytesConsumed += 4;                  }
Magic Number,System.Buffers.Text,Utf32,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf32.cs,ToUtf16,The following statement contains a magic number: while (srcLength - bytesConsumed >= sizeof(uint))                  {                      ref uint codePoint = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref src' bytesConsumed));                        if (!EncodingHelper.IsValidScalarValue(codePoint))                          return OperationStatus.InvalidData;                        int written = EncodingHelper.IsBmp(codePoint) ? 2 : 4;                      if (dstLength - bytesWritten < written)                          return OperationStatus.DestinationTooSmall;                        unchecked                      {                          if (written == 2)                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)codePoint;                          else                          {                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten)) = (char)(((codePoint - 0x010000u) >> 10) + EncodingHelper.HighSurrogateStart);                              Unsafe.As<byte' char>(ref Unsafe.Add(ref dst' bytesWritten + 2)) = (char)((codePoint & 0x3FF) + EncodingHelper.LowSurrogateStart);                          }                      }                        bytesWritten += written;                      bytesConsumed += 4;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16Length,The following statement contains a magic number: if (Utf8Util.GetIndexOfFirstInvalidUtf8Sequence(source' out int scalarCount' out int surrogatePairCount) < 0)                  {                      // Well-formed UTF-8 string.                        // 'scalarCount + surrogatePairCount' is guaranteed not to overflow because                      // the UTF-16 representation of a string will never have a greater number of                      // of code units than its UTF-8 representation.                      int numCodeUnits = scalarCount + surrogatePairCount;                        // UTF-8 code units are 2 bytes.                      bytesNeeded = checked(numCodeUnits * 2);                      return OperationStatus.Done;                  }                  else                  {                      // Not a well-formed UTF-8 string. Perhaps incomplete' perhaps invalid.                      // Regardless' we can't calculate an answer to return to the caller.                      // Since this API doesn't have a "bytes consumed" out parameter' the                      // input argument has an implicit "isFinalChunk = true"' so we treat                      // incomplete strings identically to invalid strings.                      bytesNeeded = 0;                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf16,The following statement contains a magic number: fixed (byte* pUtf8 = &source.DangerousGetPinnableReference())                  fixed (byte* pUtf16 = &destination.DangerousGetPinnableReference())                  {                      byte* pSrc = pUtf8;                      byte* pSrcEnd = pSrc + source.Length;                      char* pDst = (char*)pUtf16;                      char* pDstEnd = pDst + (destination.Length >> 1);   // Conversion from bytes to chars - div by sizeof(char)                        int ch = 0;                      while (pSrc < pSrcEnd && pDst < pDstEnd)                      {                          // we may need as many as 1 character per byte' so reduce the byte count if necessary.                          // If availableChars is too small' pStop will be before pTarget and we won't do fast loop.                          int availableChars = EncodingHelper.PtrDiff(pDstEnd' pDst);                          int availableBytes = EncodingHelper.PtrDiff(pSrcEnd' pSrc);                            if (availableChars < availableBytes)                              availableBytes = availableChars;                            // don't fall into the fast decoding loop if we don't have enough bytes                          if (availableBytes <= 13)                          {                              // try to get over the remainder of the ascii characters fast though                              byte* pLocalEnd = pSrc + availableBytes;                              while (pSrc < pLocalEnd)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCodeSlow;                                    *pDst = (char)ch;                                  pDst++;                              }                                // we are done                              break;                          }                            // To compute the upper bound' assume that all characters are ASCII characters at this point'                          //  the boundary will be decreased for every non-ASCII character we encounter                          // Also' we need 7 chars reserve for the unrolled ansi decoding loop and for decoding of multibyte sequences                          char* pStop = pDst + availableBytes - 7;                            // Fast loop                          while (pDst < pStop)                          {                              ch = *pSrc;                              pSrc++;                                if (ch > 0x7F)                                  goto LongCode;                                *pDst = (char)ch;                              pDst++;                                // 2-byte align                              if ((unchecked((int)pSrc) & 0x1) != 0)                              {                                  ch = *pSrc;                                  pSrc++;                                    if (ch > 0x7F)                                      goto LongCode;                                    *pDst = (char)ch;                                  pDst++;                              }                                // 4-byte align                              if ((unchecked((int)pSrc) & 0x2) != 0)                              {                                  ch = *(ushort*)pSrc;                                  if ((ch & 0x8080) != 0)                                      goto LongCodeWithMask16;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 8) & 0x7F);                              pSrc += 2;                              *(pDst + 1) = (char)(ch & 0x7F);                              pDst += 2;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  pSrc += 2;                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  pDst += 2;  #endif // BIGENDIAN                              }                                // Run 8 characters at a time!                              while (pDst < pStop)                              {                                  ch = *(int*)pSrc;                                  int chb = *(int*)(pSrc + 4);                                  if (((ch | chb) & unchecked((int)0x80808080)) != 0)                                      goto LongCodeWithMask32;                                    // Unfortunately' endianness sensitive  #if BIGENDIAN                              *pDst = (char)((ch >> 24) & 0x7F);                              *(pDst+1) = (char)((ch >> 16) & 0x7F);                              *(pDst+2) = (char)((ch >> 8) & 0x7F);                              *(pDst+3) = (char)(ch & 0x7F);                              pSrc += 8;                              *(pDst+4) = (char)((chb >> 24) & 0x7F);                              *(pDst+5) = (char)((chb >> 16) & 0x7F);                              *(pDst+6) = (char)((chb >> 8) & 0x7F);                              *(pDst+7) = (char)(chb & 0x7F);                              pDst += 8;  #else // BIGENDIAN                                  *pDst = (char)(ch & 0x7F);                                  *(pDst + 1) = (char)((ch >> 8) & 0x7F);                                  *(pDst + 2) = (char)((ch >> 16) & 0x7F);                                  *(pDst + 3) = (char)((ch >> 24) & 0x7F);                                  pSrc += 8;                                  *(pDst + 4) = (char)(chb & 0x7F);                                  *(pDst + 5) = (char)((chb >> 8) & 0x7F);                                  *(pDst + 6) = (char)((chb >> 16) & 0x7F);                                  *(pDst + 7) = (char)((chb >> 24) & 0x7F);                                  pDst += 8;  #endif // BIGENDIAN                              }                                break;    #if BIGENDIAN                      LongCodeWithMask32:                          // be careful about the sign extension                          ch = (int)(((uint)ch) >> 16);                      LongCodeWithMask16:                          ch = (int)(((uint)ch) >> 8);  #else // BIGENDIAN                              LongCodeWithMask32:                              LongCodeWithMask16:                              ch &= 0xFF;  #endif // BIGENDIAN                              pSrc++;                              if (ch <= 0x7F)                              {                                  *pDst = (char)ch;                                  pDst++;                                  continue;                              }                                LongCode:                              int chc = *pSrc;                              pSrc++;                                // Bit 6 should be 0' and trailing byte should be 10vvvvvv                              if ((ch & 0x40) == 0 || (chc & unchecked((sbyte)0xC0)) != 0x80)                                  goto InvalidData;                                chc &= 0x3F;                                if ((ch & 0x20) != 0)                              {                                  // Handle 3 or 4 byte encoding.                                    // Fold the first 2 bytes together                                  chc |= (ch & 0x0F) << 6;                                    if ((ch & 0x10) != 0)                                  {                                      // 4 byte - surrogate pair                                      ch = *pSrc;                                        // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                      // and the trailing byte should be 10vvvvvv                                      if (!EncodingHelper.InRange(chc >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        // Merge 3rd byte then read the last byte                                      chc = (chc << 6) | (ch & 0x3F);                                      ch = *(pSrc + 1);                                        // The last trailing byte still holds the form 10vvvvvv                                      if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc += 2;                                      ch = (chc << 6) | (ch & 0x3F);                                        *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                      pDst++;                                        ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                                  }                                  else                                  {                                      // 3 byte encoding                                      ch = *pSrc;                                        // Check for non-shortest form of 3 byte sequence                                      // No surrogates                                      // Trailing byte must be in the form 10vvvvvv                                      if ((chc & (0x1F << 5)) == 0 ||                                          (chc & (0xF800 >> 6)) == (0xD800 >> 6) ||                                          (ch & unchecked((sbyte)0xC0)) != 0x80)                                          goto InvalidData;                                        pSrc++;                                      ch = (chc << 6) | (ch & 0x3F);                                  }                                    // extra byte' we're already planning 2 chars for 2 of these bytes'                                  // but the big loop is testing the target against pStop' so we need                                  // to subtract 2 more or we risk overrunning the input.  Subtract                                  // one here and one below.                                  pStop--;                              }                              else                              {                                  // 2 byte encoding                                  ch &= 0x1F;                                    // Check for non-shortest form                                  if (ch <= 1)                                      goto InvalidData;                                    ch = (ch << 6) | chc;                              }                                *pDst = (char)ch;                              pDst++;                                // extra byte' we're only expecting 1 char for each of these 2 bytes'                              // but the loop is testing the target (not source) against pStop.                              // subtract an extra count from pStop so that we don't overrun the input.                              pStop--;                          }                            continue;                            LongCodeSlow:                          if (pSrc >= pSrcEnd)                          {                              // This is a special case where hit the end of the buffer but are in the middle                              // of decoding a long code. The error exit thinks we have read 2 extra bytes already'                              // so we add +1 to pSrc to get the count correct for the bytes consumed value.                              pSrc++;                              goto NeedMoreData;                          }                            int chd = *pSrc;                          pSrc++;                            // Bit 6 should be 0' and trailing byte should be 10vvvvvv                          if ((ch & 0x40) == 0 || (chd & unchecked((sbyte)0xC0)) != 0x80)                              goto InvalidData;                            chd &= 0x3F;                            if ((ch & 0x20) != 0)                          {                              // Handle 3 or 4 byte encoding.                                // Fold the first 2 bytes together                              chd |= (ch & 0x0F) << 6;                                if ((ch & 0x10) != 0)                              {                                  // 4 byte - surrogate pair                                  // We need 2 more bytes                                  if (pSrc >= pSrcEnd - 1)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Bit 4 should be zero + the surrogate should be in the range 0x000000 - 0x10FFFF                                  // and the trailing byte should be 10vvvvvv                                  if (!EncodingHelper.InRange(chd >> 4' 0x01' 0x10) || (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    // Merge 3rd byte then read the last byte                                  chd = (chd << 6) | (ch & 0x3F);                                  ch = *(pSrc + 1);                                    // The last trailing byte still holds the form 10vvvvvv                                  // We only know for sure we have room for one more char' but we need an extra now.                                  if ((ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    if (EncodingHelper.PtrDiff(pDstEnd' pDst) < 2)                                      goto DestinationFull;                                    pSrc += 2;                                  ch = (chd << 6) | (ch & 0x3F);                                    *pDst = (char)(((ch >> 10) & 0x7FF) + unchecked((short)(EncodingHelper.HighSurrogateStart - (0x10000 >> 10))));                                  pDst++;                                    ch = (ch & 0x3FF) + unchecked((short)(EncodingHelper.LowSurrogateStart));                              }                              else                              {                                  // 3 byte encoding                                  if (pSrc >= pSrcEnd)                                      goto NeedMoreData;                                    ch = *pSrc;                                    // Check for non-shortest form of 3 byte sequence                                  // No surrogates                                  // Trailing byte must be in the form 10vvvvvv                                  if ((chd & (0x1F << 5)) == 0 ||                                      (chd & (0xF800 >> 6)) == (0xD800 >> 6) ||                                      (ch & unchecked((sbyte)0xC0)) != 0x80)                                      goto InvalidData;                                    pSrc++;                                  ch = (chd << 6) | (ch & 0x3F);                              }                          }                          else                          {                              // 2 byte encoding                              ch &= 0x1F;                                // Check for non-shortest form                              if (ch <= 1)                                  goto InvalidData;                                ch = (ch << 6) | chd;                          }                            *pDst = (char)ch;                          pDst++;                      }                        DestinationFull:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return EncodingHelper.PtrDiff(pSrcEnd' pSrc) == 0 ? OperationStatus.Done : OperationStatus.DestinationTooSmall;                        NeedMoreData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.NeedMoreData;                        InvalidData:                      bytesConsumed = EncodingHelper.PtrDiff(pSrc - 2' pUtf8);                      bytesWritten = EncodingHelper.PtrDiff((byte*)pDst' pUtf16);                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf32Length,The following statement contains a magic number: if (Utf8Util.GetIndexOfFirstInvalidUtf8Sequence(source' out int scalarCount' out _) < 0)                  {                      // Well-formed UTF-8 string.                      // UTF-32 code units are 4 bytes per scalar.                      bytesNeeded = checked(scalarCount * 4);                      return OperationStatus.Done;                  }                  else                  {                      // Not a well-formed UTF-8 string. Perhaps incomplete' perhaps invalid.                      // Regardless' we can't calculate an answer to return to the caller.                      // Since this API doesn't have a "bytes consumed" out parameter' the                      // input argument has an implicit "isFinalChunk = true"' so we treat                      // incomplete strings identically to invalid strings.                      bytesNeeded = 0;                      return OperationStatus.InvalidData;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf32,The following statement contains a magic number: while (bytesConsumed < srcLength && bytesWritten < dstLength)                  {                      uint codePoint = Unsafe.Add(ref src' bytesConsumed);                        int byteCount = EncodingHelper.GetUtf8DecodedBytes((byte)codePoint);                      if (byteCount == 0)                          goto InvalidData;                      if (srcLength - bytesConsumed < byteCount)                          goto NeedMoreData;                        if (byteCount > 1)                          codePoint &= (byte)(0x7F >> byteCount);                        for (var i = 1; i < byteCount; i++)                      {                          ref byte next = ref Unsafe.Add(ref src' bytesConsumed + i);                          if ((next & EncodingHelper.b1100_0000U) != EncodingHelper.b1000_0000U)                              goto InvalidData;                            codePoint = (codePoint << 6) | (uint)(EncodingHelper.b0011_1111U & next);                      }                        Unsafe.As<byte' uint>(ref Unsafe.Add(ref dst' bytesWritten)) = codePoint;                      bytesWritten += 4;                      bytesConsumed += byteCount;                  }
Magic Number,System.Buffers.Text,Utf8,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8.cs,ToUtf32,The following statement contains a magic number: while (bytesConsumed < srcLength && bytesWritten < dstLength)                  {                      uint codePoint = Unsafe.Add(ref src' bytesConsumed);                        int byteCount = EncodingHelper.GetUtf8DecodedBytes((byte)codePoint);                      if (byteCount == 0)                          goto InvalidData;                      if (srcLength - bytesConsumed < byteCount)                          goto NeedMoreData;                        if (byteCount > 1)                          codePoint &= (byte)(0x7F >> byteCount);                        for (var i = 1; i < byteCount; i++)                      {                          ref byte next = ref Unsafe.Add(ref src' bytesConsumed + i);                          if ((next & EncodingHelper.b1100_0000U) != EncodingHelper.b1000_0000U)                              goto InvalidData;                            codePoint = (codePoint << 6) | (uint)(EncodingHelper.b0011_1111U & next);                      }                        Unsafe.As<byte' uint>(ref Unsafe.Add(ref dst' bytesWritten)) = codePoint;                      bytesWritten += 4;                      bytesConsumed += byteCount;                  }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConvertIntPtrToInt32WithoutOverflowCheck,The following statement contains a magic number: if (IntPtr.Size == 4)              {                  return (int)value;              }              else              {                  return (int)(long)value;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,CountNumberOfLeadingAsciiBytesFrom24BitInteger,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value >>= 7) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }              else              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value = ROL32(value' 1)) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,CountNumberOfLeadingAsciiBytesFrom24BitInteger,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value >>= 7) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }              else              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value = ROL32(value' 1)) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,CountNumberOfLeadingAsciiBytesFrom24BitInteger,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value >>= 7) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }              else              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value = ROL32(value' 1)) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,CountNumberOfLeadingAsciiBytesFrom24BitInteger,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value >>= 7) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }              else              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value = ROL32(value' 1)) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,CountNumberOfLeadingAsciiBytesFrom24BitInteger,The following statement contains a magic number: if (BitConverter.IsLittleEndian)              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value >>= 7) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value >>= 8);                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }              else              {                  // Read first byte                  uint allBytesUpToNowAreAscii = (value = ROL32(value' 1)) & 1;                  uint numAsciiBytes = allBytesUpToNowAreAscii;                    // Read second byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    // Read third byte                  allBytesUpToNowAreAscii &= (value = ROL32(value' 8));                  numAsciiBytes += allBytesUpToNowAreAscii;                    return numAsciiBytes;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The following statement contains a magic number: if (!Vector.IsHardwareAccelerated || length < 3 * Vector<byte>.Count)              {                  return IntPtr.Zero;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The following statement contains a magic number: fixed (byte* pbBuffer = &buffer)              {                  // [Potentially unaligned] single SIMD read and comparison' quick check for non-ASCII data.                    Vector<byte> mask = new Vector<byte>((byte)0x80);                  if ((Unsafe.ReadUnaligned<Vector<byte>>(pbBuffer) & mask) != Vector<byte>.Zero)                  {                      return IntPtr.Zero;                  }                    // Round 'pbBuffer' up to the *next* aligned address. If 'pbBuffer' was already aligned' this                  // just bumps the address up to the next vector. The read above guaranteed that we read all                  // data between 'pbBuffer' and 'pbAlignedBuffer' and checked it for non-ASCII bytes. It's                  // possible we'll duplicate a little bit of work if 'pbBuffer' wasn't already aligned since                  // its tail end may overlap with the immediate upcoming aligned read' but it's faster just to                  // perform the extra work and not worry about checking for this condition.                    // 'pbAlignedBuffer' will be somewhere between 1 and Vector<byte>.Count bytes ahead of 'pbBuffer''                  // hence the check for a length of >= 3 * Vector<byte>.Count at the beginning of this method.                    byte* pbAlignedBuffer;                  if (IntPtr.Size >= 8)                  {                      pbAlignedBuffer = (byte*)(((long)pbBuffer + Vector<byte>.Count) & ~((long)Vector<byte>.Count - 1));                  }                  else                  {                      pbAlignedBuffer = (byte*)(((int)pbBuffer + Vector<byte>.Count) & ~((int)Vector<byte>.Count - 1));                  }                    // Now iterate and read two aligned SIMD vectors at a time. We can skip the first length check on the                  // first iteration of the loop since we already performed a length check at the very beginning of this                  // method.                    byte* pbFinalPosAtWhichCanReadTwoVectors = &pbBuffer[length - 2 * Vector<byte>.Count];                  Debug.Assert(pbAlignedBuffer <= pbFinalPosAtWhichCanReadTwoVectors);                    do                  {                      if (((Unsafe.Read<Vector<byte>>(pbAlignedBuffer) | Unsafe.Read<Vector<byte>>(pbAlignedBuffer + Vector<byte>.Count)) & mask) != Vector<byte>.Zero)                      {                          break; // non-ASCII data incoming                      }                  } while ((pbAlignedBuffer += 2 * Vector<byte>.Count) <= pbFinalPosAtWhichCanReadTwoVectors);                    // We consumed all data up to 'pbAlignedBuffer' and know it to be non-ASCII.                  return (IntPtr)(pbAlignedBuffer - pbBuffer);              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The following statement contains a magic number: fixed (byte* pbBuffer = &buffer)              {                  // [Potentially unaligned] single SIMD read and comparison' quick check for non-ASCII data.                    Vector<byte> mask = new Vector<byte>((byte)0x80);                  if ((Unsafe.ReadUnaligned<Vector<byte>>(pbBuffer) & mask) != Vector<byte>.Zero)                  {                      return IntPtr.Zero;                  }                    // Round 'pbBuffer' up to the *next* aligned address. If 'pbBuffer' was already aligned' this                  // just bumps the address up to the next vector. The read above guaranteed that we read all                  // data between 'pbBuffer' and 'pbAlignedBuffer' and checked it for non-ASCII bytes. It's                  // possible we'll duplicate a little bit of work if 'pbBuffer' wasn't already aligned since                  // its tail end may overlap with the immediate upcoming aligned read' but it's faster just to                  // perform the extra work and not worry about checking for this condition.                    // 'pbAlignedBuffer' will be somewhere between 1 and Vector<byte>.Count bytes ahead of 'pbBuffer''                  // hence the check for a length of >= 3 * Vector<byte>.Count at the beginning of this method.                    byte* pbAlignedBuffer;                  if (IntPtr.Size >= 8)                  {                      pbAlignedBuffer = (byte*)(((long)pbBuffer + Vector<byte>.Count) & ~((long)Vector<byte>.Count - 1));                  }                  else                  {                      pbAlignedBuffer = (byte*)(((int)pbBuffer + Vector<byte>.Count) & ~((int)Vector<byte>.Count - 1));                  }                    // Now iterate and read two aligned SIMD vectors at a time. We can skip the first length check on the                  // first iteration of the loop since we already performed a length check at the very beginning of this                  // method.                    byte* pbFinalPosAtWhichCanReadTwoVectors = &pbBuffer[length - 2 * Vector<byte>.Count];                  Debug.Assert(pbAlignedBuffer <= pbFinalPosAtWhichCanReadTwoVectors);                    do                  {                      if (((Unsafe.Read<Vector<byte>>(pbAlignedBuffer) | Unsafe.Read<Vector<byte>>(pbAlignedBuffer + Vector<byte>.Count)) & mask) != Vector<byte>.Zero)                      {                          break; // non-ASCII data incoming                      }                  } while ((pbAlignedBuffer += 2 * Vector<byte>.Count) <= pbFinalPosAtWhichCanReadTwoVectors);                    // We consumed all data up to 'pbAlignedBuffer' and know it to be non-ASCII.                  return (IntPtr)(pbAlignedBuffer - pbBuffer);              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,ConsumeAsciiBytesVectorized,The following statement contains a magic number: fixed (byte* pbBuffer = &buffer)              {                  // [Potentially unaligned] single SIMD read and comparison' quick check for non-ASCII data.                    Vector<byte> mask = new Vector<byte>((byte)0x80);                  if ((Unsafe.ReadUnaligned<Vector<byte>>(pbBuffer) & mask) != Vector<byte>.Zero)                  {                      return IntPtr.Zero;                  }                    // Round 'pbBuffer' up to the *next* aligned address. If 'pbBuffer' was already aligned' this                  // just bumps the address up to the next vector. The read above guaranteed that we read all                  // data between 'pbBuffer' and 'pbAlignedBuffer' and checked it for non-ASCII bytes. It's                  // possible we'll duplicate a little bit of work if 'pbBuffer' wasn't already aligned since                  // its tail end may overlap with the immediate upcoming aligned read' but it's faster just to                  // perform the extra work and not worry about checking for this condition.                    // 'pbAlignedBuffer' will be somewhere between 1 and Vector<byte>.Count bytes ahead of 'pbBuffer''                  // hence the check for a length of >= 3 * Vector<byte>.Count at the beginning of this method.                    byte* pbAlignedBuffer;                  if (IntPtr.Size >= 8)                  {                      pbAlignedBuffer = (byte*)(((long)pbBuffer + Vector<byte>.Count) & ~((long)Vector<byte>.Count - 1));                  }                  else                  {                      pbAlignedBuffer = (byte*)(((int)pbBuffer + Vector<byte>.Count) & ~((int)Vector<byte>.Count - 1));                  }                    // Now iterate and read two aligned SIMD vectors at a time. We can skip the first length check on the                  // first iteration of the loop since we already performed a length check at the very beginning of this                  // method.                    byte* pbFinalPosAtWhichCanReadTwoVectors = &pbBuffer[length - 2 * Vector<byte>.Count];                  Debug.Assert(pbAlignedBuffer <= pbFinalPosAtWhichCanReadTwoVectors);                    do                  {                      if (((Unsafe.Read<Vector<byte>>(pbAlignedBuffer) | Unsafe.Read<Vector<byte>>(pbAlignedBuffer + Vector<byte>.Count)) & mask) != Vector<byte>.Zero)                      {                          break; // non-ASCII data incoming                      }                  } while ((pbAlignedBuffer += 2 * Vector<byte>.Count) <= pbFinalPosAtWhichCanReadTwoVectors);                    // We consumed all data up to 'pbAlignedBuffer' and know it to be non-ASCII.                  return (IntPtr)(pbAlignedBuffer - pbBuffer);              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: if (Vector.IsHardwareAccelerated)              {                  if (IntPtr.Size >= 8)                  {                      // Test first 16 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(ulong) + 3 * Vector<byte>.Count) && QWordAllBytesAreAscii(ReadAndFoldTwoQWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(ulong))' inputLength - 2 * sizeof(ulong)) + 2 * sizeof(ulong);                      }                  }                  else                  {                      // Test first 8 bytes and check for all-ASCII.                      if ((inputLength >= 2 * sizeof(uint) + 3 * Vector<byte>.Count) && DWordAllBytesAreAscii(ReadAndFoldTwoDWordsUnaligned(ref inputBuffer)))                      {                          inputBufferCurrentOffset = ConsumeAsciiBytesVectorized(ref Unsafe.Add(ref inputBuffer' 2 * sizeof(uint))' inputLength - 2 * sizeof(uint)) + 2 * sizeof(uint);                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes >= sizeof(uint))              {                  // Read 32 bits at a time. This is enough to hold any possible UTF8-encoded scalar.                    Debug.Assert(inputLength - (int)inputBufferCurrentOffset >= sizeof(uint));                  uint thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                    AfterReadDWord:    #if DEBUG                  Debug.Assert(lastOffsetProcessed < (long)inputBufferCurrentOffset' "Algorithm should've made forward progress since last read.");                  lastOffsetProcessed = (long)inputBufferCurrentOffset;  #endif                    // First' check for the common case of all-ASCII bytes.                    if (DWordAllBytesAreAscii(thisDWord))                  {                      // We read an all-ASCII sequence.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                        // If we saw a sequence of all ASCII' there's a good chance a significant amount of following data is also ASCII.                      // Below is basically unrolled loops with poor man's vectorization.                        if (inputBufferRemainingBytes >= 5 * sizeof(uint))                      {                          // The JIT produces better codegen for aligned reads than it does for                          // unaligned reads' and we want the processor to operate at maximum                          // efficiency in the loop that follows' so we'll align the references                          // now. It's OK to do this without pinning because the GC will never                          // move a heap-allocated object in a manner that messes with its                          // alignment.                            {                              ref byte refToCurrentDWord = ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                              thisDWord = Unsafe.ReadUnaligned<uint>(ref refToCurrentDWord);                              if (!DWordAllBytesAreAscii(thisDWord))                              {                                  goto AfterReadDWordSkipAllBytesAsciiCheck;                              }                                int adjustment = GetNumberOfBytesToNextDWordAlignment(ref refToCurrentDWord);                              inputBufferCurrentOffset += adjustment;                              // will adjust 'bytes remaining' value after below loop                          }                            // At this point' the input buffer offset points to an aligned DWORD.                          // We also know that there's enough room to read at least four DWORDs from the stream.                            IntPtr inputBufferFinalOffsetAtWhichCanSafelyLoop = (IntPtr)(inputLength - 4 * sizeof(uint));                          do                          {                              ref uint currentReadPosition = ref Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (!DWordAllBytesAreAscii(currentReadPosition | Unsafe.Add(ref currentReadPosition' 1)))                              {                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                if (!DWordAllBytesAreAscii(Unsafe.Add(ref currentReadPosition' 2) | Unsafe.Add(ref currentReadPosition' 3)))                              {                                  inputBufferCurrentOffset += 2 * sizeof(uint);                                  goto LoopTerminatedEarlyDueToNonAsciiData;                              }                                inputBufferCurrentOffset += 4 * sizeof(uint);                          } while (IntPtrIsLessThanOrEqualTo(inputBufferCurrentOffset' inputBufferFinalOffsetAtWhichCanSafelyLoop));                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          continue; // need to perform a bounds check because we might be running out of data                            LoopTerminatedEarlyDueToNonAsciiData:                            // We know that there's *at least* two DWORDs of data remaining in the buffer.                          // We also know that one of them (or both of them) contains non-ASCII data somewhere.                          // Let's perform a quick check here to bypass the logic at the beginning of the main loop.                            thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          if (DWordAllBytesAreAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4;                              thisDWord = Unsafe.As<byte' uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                          }                            inputBufferRemainingBytes = inputLength - ConvertIntPtrToInt32WithoutOverflowCheck(inputBufferCurrentOffset);                          goto AfterReadDWordSkipAllBytesAsciiCheck;                      }                        continue;                  }                    AfterReadDWordSkipAllBytesAsciiCheck:                    Debug.Assert(!DWordAllBytesAreAscii(thisDWord)); // this should have been handled earlier                    // Next' try stripping off ASCII bytes one at a time.                  // We only handle up to three ASCII bytes here since we handled the four ASCII byte case above.                    {                      uint numLeadingAsciiBytes = CountNumberOfLeadingAsciiBytesFrom24BitInteger(thisDWord);                      inputBufferCurrentOffset += (int)numLeadingAsciiBytes;                      inputBufferRemainingBytes -= (int)numLeadingAsciiBytes;                        if (inputBufferRemainingBytes < sizeof(uint))                      {                          goto ProcessRemainingBytesSlow; // Input buffer doesn't contain enough data to read a DWORD                      }                      else                      {                          // The input buffer at the current offset contains a non-ASCII byte.                          // Read an entire DWORD and fall through to multi-byte consumption logic.                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                      }                  }                    // At this point' we know we're working with a multi-byte code unit'                  // but we haven't yet validated it.                    // The masks and comparands are derived from the Unicode Standard' Table 3-6.                  // Additionally' we need to check for valid byte sequences per Table 3-7.                    // Check the 2-byte case.                    BeforeProcessTwoByteSequence:                    if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                  {                      // Per Table 3-7' valid sequences are:                      // [ C2..DF ] [ 80..BF ]                        if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord)) { goto Error; }                        ProcessTwoByteSequenceSkipOverlongFormCheck:                        // Optimization: If this is a two-byte-per-character language like Cyrillic or Hebrew'                      // there's a good chance that if we see one two-byte run then there's another two-byte                      // run immediately after. Let's check that now.                        // On little-endian platforms' we can check for the two-byte UTF8 mask *and* validate that                      // the value isn't overlong using a single comparison. On big-endian platforms' we'll need                      // to validate the mask and validate that the sequence isn't overlong as two separate comparisons.                        if ((BitConverter.IsLittleEndian && DWordEndsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                          || (!BitConverter.IsLittleEndian && (DWordEndsWithUtf8TwoByteMask(thisDWord) && !DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))))                      {                          ConsumeTwoAdjacentKnownGoodTwoByteSequences:                            // We have two runs of two bytes each.                          inputBufferCurrentOffset += 4;                          inputBufferRemainingBytes -= 4;                          tempScalarCount -= 2; // 4 bytes -> 2 scalars                            if (inputBufferRemainingBytes >= sizeof(uint))                          {                              // Optimization: If we read a long run of two-byte sequences' the next sequence is probably                              // also two bytes. Check for that first before going back to the beginning of the loop.                                thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                if (BitConverter.IsLittleEndian)                              {                                  if (DWordBeginsWithValidUtf8TwoByteSequenceLittleEndian(thisDWord))                                  {                                      // The next sequence is a valid two-byte sequence.                                      goto ProcessTwoByteSequenceSkipOverlongFormCheck;                                  }                              }                              else                              {                                  if (DWordBeginsAndEndsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord) || DWordEndsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was 2x 2-byte sequences but validation failed' go to beginning of loop for error handling                                          goto AfterReadDWord;                                      }                                      else                                      {                                          // Validated next bytes are 2x 2-byte sequences                                          goto ConsumeTwoAdjacentKnownGoodTwoByteSequences;                                      }                                  }                                  else if (DWordBeginsWithUtf8TwoByteMask(thisDWord))                                  {                                      if (DWordBeginsWithOverlongUtf8TwoByteSequence(thisDWord))                                      {                                          // Mask said it was a 2-byte sequence but validation failed                                          goto Error;                                      }                                      else                                      {                                          // Validated next bytes are a single 2-byte sequence with no valid 2-byte sequence following                                          goto ConsumeSingleKnownGoodTwoByteSequence;                                      }                                  }                              }                                // If we reached this point' the next sequence is something other than a valid                              // two-byte sequence' so go back to the beginning of the loop.                              goto AfterReadDWord;                          }                          else                          {                              goto ProcessRemainingBytesSlow; // Running out of data - go down slow path                          }                      }                        ConsumeSingleKnownGoodTwoByteSequence:                        // The buffer contains a 2-byte sequence followed by 2 bytes that aren't a 2-byte sequence.                      // Unlikely that a 3-byte sequence would follow a 2-byte sequence' so perhaps remaining                      // bytes are ASCII?                        if (DWordThirdByteIsAscii(thisDWord))                      {                          if (DWordFourthByteIsAscii(thisDWord))                          {                              inputBufferCurrentOffset += 4; // a 2-byte sequence + 2 ASCII bytes                              inputBufferRemainingBytes -= 4; // a 2-byte sequence + 2 ASCII bytes                              tempScalarCount--; // 2-byte sequence + 2 ASCII bytes -> 3 scalars                          }                          else                          {                              inputBufferCurrentOffset += 3; // a 2-byte sequence + 1 ASCII byte                              inputBufferRemainingBytes -= 3; // a 2-byte sequence + 1 ASCII byte                              tempScalarCount--; // 2-byte sequence + 1 ASCII bytes -> 2 scalars                                // A two-byte sequence followed by an ASCII byte followed by a non-ASCII byte.                              // Read in the next DWORD and jump directly to the start of the multi-byte processing block.                                if (inputBufferRemainingBytes >= sizeof(uint))                              {                                  thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                                  goto BeforeProcessTwoByteSequence;                              }                          }                      }                      else                      {                          inputBufferCurrentOffset += 2;                          inputBufferRemainingBytes -= 2;                          tempScalarCount--; // 2-byte sequence -> 1 scalar                      }                        continue;                  }                    // Check the 3-byte case.                    if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                  {                      ProcessThreeByteSequenceWithCheck:                        // We need to check for overlong or surrogate three-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   E0   ] [ A0..BF ] [ 80..BF ]                      // [ E1..EC ] [ 80..BF ] [ 80..BF ]                      // [   ED   ] [ 80..9F ] [ 80..BF ]                      // [ EE..EF ] [ 80..BF ] [ 80..BF ]                      //                      // Big-endian examples of using the above validation table:                      // E0A0 = 1110 0000 1010 0000 => invalid (overlong ) patterns are 1110 0000 100# ####                      // ED9F = 1110 1101 1001 1111 => invalid (surrogate) patterns are 1110 1101 101# ####                      // If using the bitmask ......................................... 0000 1111 0010 0000 (=0F20)'                      // Then invalid (overlong) patterns match the comparand ......... 0000 0000 0000 0000 (=0000)'                      // And invalid (surrogate) patterns match the comparand ......... 0000 1101 0010 0000 (=0D20).                        if (BitConverter.IsLittleEndian)                      {                          // The "overlong or surrogate" check can be implemented using a single jump' but there's                          // some overhead to moving the bits into the correct locations in order to perform the                          // correct comparison' and in practice the processor's branch prediction capability is                          // good enough that we shouldn't bother. So we'll use two jumps instead.                            // Can't extract this check into its own helper method because JITter produces suboptimal                          // assembly' even with aggressive inlining.                            uint comparand = thisDWord & 0x0000200FU;                          if ((comparand == 0U) || (comparand == 0x0000200DU)) { goto Error; }                      }                      else                      {                          uint comparand = thisDWord & 0x0F200000U;                          if ((comparand == 0U) || (comparand == 0x0D200000U)) { goto Error; }                      }                        ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks:                        inputBufferCurrentOffset += 3;                      inputBufferRemainingBytes -= 3;                      tempScalarCount -= 2; // 3 bytes -> 1 scalar                        // Occasionally one-off ASCII characters like spaces' periods' or newlines will make their way                      // in to the text. If this happens strip it off now before seeing if the next character                      // consists of three code units.                        if (DWordFourthByteIsAscii(thisDWord))                      {                          inputBufferCurrentOffset += 1;                          inputBufferRemainingBytes--;                      }                        SuccessfullyProcessedThreeByteSequence:                        // Optimization: A three-byte character could indicate CJK text' which makes it likely                      // that the character following this one is also CJK. We'll try to process several                      // three-byte sequences at a time.                        if (IntPtr.Size >= 8 && BitConverter.IsLittleEndian && inputBufferRemainingBytes >= (sizeof(ulong) + 1))                      {                          ulong thisQWord = Unsafe.ReadUnaligned<ulong>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Is this three 3-byte sequences in a row?                          // thisQWord = [ 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ] [ 10xxxxxx ]                          //               ---- CHAR 3  ----   --------- CHAR 2 ---------   --------- CHAR 1 ---------     -CHAR 3-                          if ((thisQWord & 0xC0F0C0C0F0C0C0F0UL) == 0x80E08080E08080E0UL && IsUtf8ContinuationByte(Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + sizeof(ulong))))                          {                              // Saw a proper bitmask for three incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                // Check the third character (we already checked that it's followed by a continuation byte).                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 48) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 9;                              inputBufferRemainingBytes -= 9;                              tempScalarCount -= 6; // 9 bytes -> 3 scalars                              goto SuccessfullyProcessedThreeByteSequence;                          }                            // Is this two 3-byte sequences in a row?                          // thisQWord = [ ######## ######## | 10xxxxxx 10yyyyyy 1110zzzz | 10xxxxxx 10yyyyyy 1110zzzz ]                          //                                   --------- CHAR 2 ---------   --------- CHAR 1 ---------                          if ((thisQWord & 0xC0C0F0C0C0F0UL) == 0x8080E08080E0UL)                          {                              // Saw a proper bitmask for two incoming 3-byte sequences' perform the                              // overlong and surrogate sequence checking now.                                // Check the first character.                              // If the first character is overlong or a surrogate' fail immediately.                                uint comparand = (uint)thisQWord & 0x200FU;                              if ((comparand == 0UL) || (comparand == 0x200DU))                              {                                  goto Error;                              }                                // Check the second character.                              // If this character is overlong or a surrogate' process the first character (which we                              // know to be good because the first check passed) before reporting an error.                                comparand = (uint)(thisQWord >> 24) & 0x200FU;                              if ((comparand == 0U) || (comparand == 0x200DU))                              {                                  thisDWord = (uint)thisQWord;                                  goto ProcessSingleThreeByteSequenceSkipOverlongAndSurrogateChecks;                              }                                inputBufferCurrentOffset += 6;                              inputBufferRemainingBytes -= 6;                              tempScalarCount -= 4; // 6 bytes -> 2 scalars                                // The next char in the sequence didn't have a 3-byte marker' so it's probably                              // an ASCII character. Jump back to the beginning of loop processing.                              continue;                          }                            thisDWord = (uint)thisQWord;                          if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              // A single three-byte sequence.                              goto ProcessThreeByteSequenceWithCheck;                          }                          else                          {                              // Not a three-byte sequence; perhaps ASCII?                              goto AfterReadDWord;                          }                      }                        if (inputBufferRemainingBytes >= sizeof(uint))                      {                          thisDWord = Unsafe.ReadUnaligned<uint>(ref Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset));                            // Optimization: A three-byte character could indicate CJK text' which makes it likely                          // that the character following this one is also CJK. We'll check for a three-byte sequence                          // marker now and jump directly to three-byte sequence processing if we see one' skipping                          // all of the logic at the beginning of the loop.                            if (DWordBeginsWithUtf8ThreeByteMask(thisDWord))                          {                              goto ProcessThreeByteSequenceWithCheck; // Found another [not yet validated] three-byte sequence; process                          }                          else                          {                              goto AfterReadDWord; // Probably ASCII punctuation or whitespace; go back to start of loop                          }                      }                      else                      {                          goto ProcessRemainingBytesSlow; // Running out of data                      }                  }                    // Assume the 4-byte case' but we need to validate.                    {                      // We need to check for overlong or invalid (over U+10FFFF) four-byte sequences.                      //                      // Per Table 3-7' valid sequences are:                      // [   F0   ] [ 90..BF ] [ 80..BF ] [ 80..BF ]                      // [ F1..F3 ] [ 80..BF ] [ 80..BF ] [ 80..BF ]                      // [   F4   ] [ 80..8F ] [ 80..BF ] [ 80..BF ]                        if (!DWordBeginsWithUtf8FourByteMask(thisDWord)) { goto Error; }                        // Now check for overlong / out-of-range sequences.                        if (BitConverter.IsLittleEndian)                      {                          // The DWORD we read is [ 10xxxxxx 10yyyyyy 10zzzzzz 11110www ].                          // We want to get the 'w' byte in front of the 'z' byte so that we can perform                          // a single range comparison. We'll take advantage of the fact that the JITter                          // can detect a ROR / ROL operation' then we'll just zero out the bytes that                          // aren't involved in the range check.                            uint toCheck = (ushort)thisDWord;                            // At this point' toCheck = [ 00000000 00000000 10zzzzzz 11110www ].                            toCheck = (toCheck << 24) | (toCheck >> 8); // ROR 8 / ROL 24                            // At this point' toCheck = [ 11110www 00000000 00000000 10zzzzzz ].                            if (!IsInRangeInclusive(toCheck' 0xF0000090U' 0xF400008FU)) { goto Error; }                      }                      else                      {                          if (!IsInRangeInclusive(thisDWord' 0xF0900000U' 0xF48FFFFFU)) { goto Error; }                      }                        // Validation complete.                        inputBufferCurrentOffset += 4;                      inputBufferRemainingBytes -= 4;                      tempScalarCount -= 3; // 4 bytes -> 1 scalar                      tempSurrogatePairCount++; // 4 bytes implies UTF16 surrogate pair                        continue; // go back to beginning of loop for processing                  }              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: ProcessRemainingBytesSlow:                Debug.Assert(inputBufferRemainingBytes < 4);
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes > 0)              {                  uint firstByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                    if (firstByte < 0x80U)                  {                      // 1-byte (ASCII) case                      inputBufferCurrentOffset += 1;                      inputBufferRemainingBytes -= 1;                      continue;                  }                  else if (inputBufferRemainingBytes >= 2)                  {                      uint secondByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 1);                      if (firstByte < 0xE0U)                      {                          // 2-byte case                          if (firstByte >= 0xC2U && IsUtf8ContinuationByte(secondByte))                          {                              inputBufferCurrentOffset += 2;                              inputBufferRemainingBytes -= 2;                              tempScalarCount--; // 2 bytes -> 1 scalar                              continue;                          }                      }                      else if (inputBufferRemainingBytes >= 3)                      {                          uint thirdByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 2);                          if (firstByte <= 0xF0U)                          {                              if (firstByte == 0xE0U)                              {                                  if (!IsInRangeInclusive(secondByte' 0xA0U' 0xBFU)) { goto Error; }                              }                              else if (firstByte == 0xEDU)                              {                                  if (!IsInRangeInclusive(secondByte' 0x80U' 0x9FU)) { goto Error; }                              }                              else                              {                                  if (!IsUtf8ContinuationByte(secondByte)) { goto Error; }                              }                                if (IsUtf8ContinuationByte(thirdByte))                              {                                  inputBufferCurrentOffset += 3;                                  inputBufferRemainingBytes -= 3;                                  tempScalarCount -= 2; // 3 bytes -> 1 scalar                                  continue;                              }                          }                      }                  }                    // Error - no match.                    goto Error;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes > 0)              {                  uint firstByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                    if (firstByte < 0x80U)                  {                      // 1-byte (ASCII) case                      inputBufferCurrentOffset += 1;                      inputBufferRemainingBytes -= 1;                      continue;                  }                  else if (inputBufferRemainingBytes >= 2)                  {                      uint secondByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 1);                      if (firstByte < 0xE0U)                      {                          // 2-byte case                          if (firstByte >= 0xC2U && IsUtf8ContinuationByte(secondByte))                          {                              inputBufferCurrentOffset += 2;                              inputBufferRemainingBytes -= 2;                              tempScalarCount--; // 2 bytes -> 1 scalar                              continue;                          }                      }                      else if (inputBufferRemainingBytes >= 3)                      {                          uint thirdByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 2);                          if (firstByte <= 0xF0U)                          {                              if (firstByte == 0xE0U)                              {                                  if (!IsInRangeInclusive(secondByte' 0xA0U' 0xBFU)) { goto Error; }                              }                              else if (firstByte == 0xEDU)                              {                                  if (!IsInRangeInclusive(secondByte' 0x80U' 0x9FU)) { goto Error; }                              }                              else                              {                                  if (!IsUtf8ContinuationByte(secondByte)) { goto Error; }                              }                                if (IsUtf8ContinuationByte(thirdByte))                              {                                  inputBufferCurrentOffset += 3;                                  inputBufferRemainingBytes -= 3;                                  tempScalarCount -= 2; // 3 bytes -> 1 scalar                                  continue;                              }                          }                      }                  }                    // Error - no match.                    goto Error;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes > 0)              {                  uint firstByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                    if (firstByte < 0x80U)                  {                      // 1-byte (ASCII) case                      inputBufferCurrentOffset += 1;                      inputBufferRemainingBytes -= 1;                      continue;                  }                  else if (inputBufferRemainingBytes >= 2)                  {                      uint secondByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 1);                      if (firstByte < 0xE0U)                      {                          // 2-byte case                          if (firstByte >= 0xC2U && IsUtf8ContinuationByte(secondByte))                          {                              inputBufferCurrentOffset += 2;                              inputBufferRemainingBytes -= 2;                              tempScalarCount--; // 2 bytes -> 1 scalar                              continue;                          }                      }                      else if (inputBufferRemainingBytes >= 3)                      {                          uint thirdByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 2);                          if (firstByte <= 0xF0U)                          {                              if (firstByte == 0xE0U)                              {                                  if (!IsInRangeInclusive(secondByte' 0xA0U' 0xBFU)) { goto Error; }                              }                              else if (firstByte == 0xEDU)                              {                                  if (!IsInRangeInclusive(secondByte' 0x80U' 0x9FU)) { goto Error; }                              }                              else                              {                                  if (!IsUtf8ContinuationByte(secondByte)) { goto Error; }                              }                                if (IsUtf8ContinuationByte(thirdByte))                              {                                  inputBufferCurrentOffset += 3;                                  inputBufferRemainingBytes -= 3;                                  tempScalarCount -= 2; // 3 bytes -> 1 scalar                                  continue;                              }                          }                      }                  }                    // Error - no match.                    goto Error;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes > 0)              {                  uint firstByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                    if (firstByte < 0x80U)                  {                      // 1-byte (ASCII) case                      inputBufferCurrentOffset += 1;                      inputBufferRemainingBytes -= 1;                      continue;                  }                  else if (inputBufferRemainingBytes >= 2)                  {                      uint secondByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 1);                      if (firstByte < 0xE0U)                      {                          // 2-byte case                          if (firstByte >= 0xC2U && IsUtf8ContinuationByte(secondByte))                          {                              inputBufferCurrentOffset += 2;                              inputBufferRemainingBytes -= 2;                              tempScalarCount--; // 2 bytes -> 1 scalar                              continue;                          }                      }                      else if (inputBufferRemainingBytes >= 3)                      {                          uint thirdByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 2);                          if (firstByte <= 0xF0U)                          {                              if (firstByte == 0xE0U)                              {                                  if (!IsInRangeInclusive(secondByte' 0xA0U' 0xBFU)) { goto Error; }                              }                              else if (firstByte == 0xEDU)                              {                                  if (!IsInRangeInclusive(secondByte' 0x80U' 0x9FU)) { goto Error; }                              }                              else                              {                                  if (!IsUtf8ContinuationByte(secondByte)) { goto Error; }                              }                                if (IsUtf8ContinuationByte(thirdByte))                              {                                  inputBufferCurrentOffset += 3;                                  inputBufferRemainingBytes -= 3;                                  tempScalarCount -= 2; // 3 bytes -> 1 scalar                                  continue;                              }                          }                      }                  }                    // Error - no match.                    goto Error;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes > 0)              {                  uint firstByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                    if (firstByte < 0x80U)                  {                      // 1-byte (ASCII) case                      inputBufferCurrentOffset += 1;                      inputBufferRemainingBytes -= 1;                      continue;                  }                  else if (inputBufferRemainingBytes >= 2)                  {                      uint secondByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 1);                      if (firstByte < 0xE0U)                      {                          // 2-byte case                          if (firstByte >= 0xC2U && IsUtf8ContinuationByte(secondByte))                          {                              inputBufferCurrentOffset += 2;                              inputBufferRemainingBytes -= 2;                              tempScalarCount--; // 2 bytes -> 1 scalar                              continue;                          }                      }                      else if (inputBufferRemainingBytes >= 3)                      {                          uint thirdByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 2);                          if (firstByte <= 0xF0U)                          {                              if (firstByte == 0xE0U)                              {                                  if (!IsInRangeInclusive(secondByte' 0xA0U' 0xBFU)) { goto Error; }                              }                              else if (firstByte == 0xEDU)                              {                                  if (!IsInRangeInclusive(secondByte' 0x80U' 0x9FU)) { goto Error; }                              }                              else                              {                                  if (!IsUtf8ContinuationByte(secondByte)) { goto Error; }                              }                                if (IsUtf8ContinuationByte(thirdByte))                              {                                  inputBufferCurrentOffset += 3;                                  inputBufferRemainingBytes -= 3;                                  tempScalarCount -= 2; // 3 bytes -> 1 scalar                                  continue;                              }                          }                      }                  }                    // Error - no match.                    goto Error;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes > 0)              {                  uint firstByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                    if (firstByte < 0x80U)                  {                      // 1-byte (ASCII) case                      inputBufferCurrentOffset += 1;                      inputBufferRemainingBytes -= 1;                      continue;                  }                  else if (inputBufferRemainingBytes >= 2)                  {                      uint secondByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 1);                      if (firstByte < 0xE0U)                      {                          // 2-byte case                          if (firstByte >= 0xC2U && IsUtf8ContinuationByte(secondByte))                          {                              inputBufferCurrentOffset += 2;                              inputBufferRemainingBytes -= 2;                              tempScalarCount--; // 2 bytes -> 1 scalar                              continue;                          }                      }                      else if (inputBufferRemainingBytes >= 3)                      {                          uint thirdByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 2);                          if (firstByte <= 0xF0U)                          {                              if (firstByte == 0xE0U)                              {                                  if (!IsInRangeInclusive(secondByte' 0xA0U' 0xBFU)) { goto Error; }                              }                              else if (firstByte == 0xEDU)                              {                                  if (!IsInRangeInclusive(secondByte' 0x80U' 0x9FU)) { goto Error; }                              }                              else                              {                                  if (!IsUtf8ContinuationByte(secondByte)) { goto Error; }                              }                                if (IsUtf8ContinuationByte(thirdByte))                              {                                  inputBufferCurrentOffset += 3;                                  inputBufferRemainingBytes -= 3;                                  tempScalarCount -= 2; // 3 bytes -> 1 scalar                                  continue;                              }                          }                      }                  }                    // Error - no match.                    goto Error;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes > 0)              {                  uint firstByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                    if (firstByte < 0x80U)                  {                      // 1-byte (ASCII) case                      inputBufferCurrentOffset += 1;                      inputBufferRemainingBytes -= 1;                      continue;                  }                  else if (inputBufferRemainingBytes >= 2)                  {                      uint secondByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 1);                      if (firstByte < 0xE0U)                      {                          // 2-byte case                          if (firstByte >= 0xC2U && IsUtf8ContinuationByte(secondByte))                          {                              inputBufferCurrentOffset += 2;                              inputBufferRemainingBytes -= 2;                              tempScalarCount--; // 2 bytes -> 1 scalar                              continue;                          }                      }                      else if (inputBufferRemainingBytes >= 3)                      {                          uint thirdByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 2);                          if (firstByte <= 0xF0U)                          {                              if (firstByte == 0xE0U)                              {                                  if (!IsInRangeInclusive(secondByte' 0xA0U' 0xBFU)) { goto Error; }                              }                              else if (firstByte == 0xEDU)                              {                                  if (!IsInRangeInclusive(secondByte' 0x80U' 0x9FU)) { goto Error; }                              }                              else                              {                                  if (!IsUtf8ContinuationByte(secondByte)) { goto Error; }                              }                                if (IsUtf8ContinuationByte(thirdByte))                              {                                  inputBufferCurrentOffset += 3;                                  inputBufferRemainingBytes -= 3;                                  tempScalarCount -= 2; // 3 bytes -> 1 scalar                                  continue;                              }                          }                      }                  }                    // Error - no match.                    goto Error;              }
Magic Number,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The following statement contains a magic number: while (inputBufferRemainingBytes > 0)              {                  uint firstByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset);                    if (firstByte < 0x80U)                  {                      // 1-byte (ASCII) case                      inputBufferCurrentOffset += 1;                      inputBufferRemainingBytes -= 1;                      continue;                  }                  else if (inputBufferRemainingBytes >= 2)                  {                      uint secondByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 1);                      if (firstByte < 0xE0U)                      {                          // 2-byte case                          if (firstByte >= 0xC2U && IsUtf8ContinuationByte(secondByte))                          {                              inputBufferCurrentOffset += 2;                              inputBufferRemainingBytes -= 2;                              tempScalarCount--; // 2 bytes -> 1 scalar                              continue;                          }                      }                      else if (inputBufferRemainingBytes >= 3)                      {                          uint thirdByte = Unsafe.Add(ref inputBuffer' inputBufferCurrentOffset + 2);                          if (firstByte <= 0xF0U)                          {                              if (firstByte == 0xE0U)                              {                                  if (!IsInRangeInclusive(secondByte' 0xA0U' 0xBFU)) { goto Error; }                              }                              else if (firstByte == 0xEDU)                              {                                  if (!IsInRangeInclusive(secondByte' 0x80U' 0x9FU)) { goto Error; }                              }                              else                              {                                  if (!IsUtf8ContinuationByte(secondByte)) { goto Error; }                              }                                if (IsUtf8ContinuationByte(thirdByte))                              {                                  inputBufferCurrentOffset += 3;                                  inputBufferRemainingBytes -= 3;                                  tempScalarCount -= 2; // 3 bytes -> 1 scalar                                  continue;                              }                          }                      }                  }                    // Error - no match.                    goto Error;              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,GetExpectedNumberOfContinuationBytes,The following statement contains a magic number: if (firstByte < (byte)0xC2)              {                  // ASII (one-byte sequence)' or                  // continuation byte (invalid as first byte' hence no expected followers)' or                  // [ C0..C1 ] (always invalid UTF-8 byte' hence no expected followers)                  return 0;              }              else if (firstByte < (byte)0xE0)              {                  // [ C2..DF ] can start a two-byte sequence                  return 1;              }              else if (firstByte < (byte)0xF0)              {                  // [ E0..EF ] can start a three-byte sequence                  return 2;              }              else if (firstByte <= (byte)0xF4)              {                  // [ F0..F4 ] can start a four-byte sequence                  return 3;              }              else              {                  // [ F5 .. FF ] (always invalid UTF-8 byte' hence no expected followers)                  return 0;              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,GetExpectedNumberOfContinuationBytes,The following statement contains a magic number: if (firstByte < (byte)0xC2)              {                  // ASII (one-byte sequence)' or                  // continuation byte (invalid as first byte' hence no expected followers)' or                  // [ C0..C1 ] (always invalid UTF-8 byte' hence no expected followers)                  return 0;              }              else if (firstByte < (byte)0xE0)              {                  // [ C2..DF ] can start a two-byte sequence                  return 1;              }              else if (firstByte < (byte)0xF0)              {                  // [ E0..EF ] can start a three-byte sequence                  return 2;              }              else if (firstByte <= (byte)0xF4)              {                  // [ F0..F4 ] can start a four-byte sequence                  return 3;              }              else              {                  // [ F5 .. FF ] (always invalid UTF-8 byte' hence no expected followers)                  return 0;              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: if (data.Length < 2)              {                  // One byte of an incomplete multi-byte sequence.                  goto OneByteOfIncompleteMultiByteSequence;              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: if (firstByte < (byte)0xE0U)              {                  // Well-formed two-byte sequence.                  scalarValue = UnicodeScalar.CreateWithoutValidation((((uint)firstByte & 0x1FU) << 6) | ((uint)secondByte & 0x3FU));                  numBytesConsumed = 2;                  return SequenceValidity.WellFormed;              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: if (firstByte < (byte)0xE0U)              {                  // Well-formed two-byte sequence.                  scalarValue = UnicodeScalar.CreateWithoutValidation((((uint)firstByte & 0x1FU) << 6) | ((uint)secondByte & 0x3FU));                  numBytesConsumed = 2;                  return SequenceValidity.WellFormed;              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: if (firstByte < (byte)0xF0U)              {                  // Start of a three-byte sequence.                  // Need to check for overlong or surrogate sequences.                    uint scalar = (((uint)firstByte & 0x0FU) << 12) | (((uint)secondByte & 0x3FU) << 6);                  if (scalar < 0x800U || Utf8Util.IsLowWordSurrogate(scalar)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a three-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete three-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Well-formed three-byte sequence.                          scalar |= (uint)thirdByte & 0x3FU;                          scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                          numBytesConsumed = 3;                          return SequenceValidity.WellFormed;                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: if (firstByte < (byte)0xF0U)              {                  // Start of a three-byte sequence.                  // Need to check for overlong or surrogate sequences.                    uint scalar = (((uint)firstByte & 0x0FU) << 12) | (((uint)secondByte & 0x3FU) << 6);                  if (scalar < 0x800U || Utf8Util.IsLowWordSurrogate(scalar)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a three-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete three-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Well-formed three-byte sequence.                          scalar |= (uint)thirdByte & 0x3FU;                          scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                          numBytesConsumed = 3;                          return SequenceValidity.WellFormed;                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: if (firstByte < (byte)0xF0U)              {                  // Start of a three-byte sequence.                  // Need to check for overlong or surrogate sequences.                    uint scalar = (((uint)firstByte & 0x0FU) << 12) | (((uint)secondByte & 0x3FU) << 6);                  if (scalar < 0x800U || Utf8Util.IsLowWordSurrogate(scalar)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a three-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete three-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Well-formed three-byte sequence.                          scalar |= (uint)thirdByte & 0x3FU;                          scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                          numBytesConsumed = 3;                          return SequenceValidity.WellFormed;                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: if (firstByte < (byte)0xF0U)              {                  // Start of a three-byte sequence.                  // Need to check for overlong or surrogate sequences.                    uint scalar = (((uint)firstByte & 0x0FU) << 12) | (((uint)secondByte & 0x3FU) << 6);                  if (scalar < 0x800U || Utf8Util.IsLowWordSurrogate(scalar)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a three-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete three-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Well-formed three-byte sequence.                          scalar |= (uint)thirdByte & 0x3FU;                          scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                          numBytesConsumed = 3;                          return SequenceValidity.WellFormed;                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: if (firstByte < (byte)0xF0U)              {                  // Start of a three-byte sequence.                  // Need to check for overlong or surrogate sequences.                    uint scalar = (((uint)firstByte & 0x0FU) << 12) | (((uint)secondByte & 0x3FU) << 6);                  if (scalar < 0x800U || Utf8Util.IsLowWordSurrogate(scalar)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a three-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete three-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Well-formed three-byte sequence.                          scalar |= (uint)thirdByte & 0x3FU;                          scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                          numBytesConsumed = 3;                          return SequenceValidity.WellFormed;                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: {                  // Start of four-byte sequence.                  // Need to check for overlong or out-of-range sequences.                    uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);                  if (!Utf8Util.IsInRangeInclusive(scalar' 0x10000U' 0x10FFFFU)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a four-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete four-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Valid three-byte start of a four-byte sequence.                            if (data.Length < 4)                          {                              // Three bytes of an incomplete four-byte sequence.                              goto ThreeBytesOfIncompleteMultiByteSequence;                          }                          else                          {                              byte fourthByte = data[3];                              if (IsUtf8ContinuationByte(fourthByte))                              {                                  // Well-formed four-byte sequence.                                  scalar |= (((uint)thirdByte & 0x3FU) << 6) | ((uint)fourthByte & 0x3FU);                                  scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                                  numBytesConsumed = 4;                                  return SequenceValidity.WellFormed;                              }                              else                              {                                  // Three bytes of an improperly terminated multi-byte sequence.                                  goto InvalidThreeByteSequence;                              }                          }                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: {                  // Start of four-byte sequence.                  // Need to check for overlong or out-of-range sequences.                    uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);                  if (!Utf8Util.IsInRangeInclusive(scalar' 0x10000U' 0x10FFFFU)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a four-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete four-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Valid three-byte start of a four-byte sequence.                            if (data.Length < 4)                          {                              // Three bytes of an incomplete four-byte sequence.                              goto ThreeBytesOfIncompleteMultiByteSequence;                          }                          else                          {                              byte fourthByte = data[3];                              if (IsUtf8ContinuationByte(fourthByte))                              {                                  // Well-formed four-byte sequence.                                  scalar |= (((uint)thirdByte & 0x3FU) << 6) | ((uint)fourthByte & 0x3FU);                                  scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                                  numBytesConsumed = 4;                                  return SequenceValidity.WellFormed;                              }                              else                              {                                  // Three bytes of an improperly terminated multi-byte sequence.                                  goto InvalidThreeByteSequence;                              }                          }                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: {                  // Start of four-byte sequence.                  // Need to check for overlong or out-of-range sequences.                    uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);                  if (!Utf8Util.IsInRangeInclusive(scalar' 0x10000U' 0x10FFFFU)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a four-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete four-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Valid three-byte start of a four-byte sequence.                            if (data.Length < 4)                          {                              // Three bytes of an incomplete four-byte sequence.                              goto ThreeBytesOfIncompleteMultiByteSequence;                          }                          else                          {                              byte fourthByte = data[3];                              if (IsUtf8ContinuationByte(fourthByte))                              {                                  // Well-formed four-byte sequence.                                  scalar |= (((uint)thirdByte & 0x3FU) << 6) | ((uint)fourthByte & 0x3FU);                                  scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                                  numBytesConsumed = 4;                                  return SequenceValidity.WellFormed;                              }                              else                              {                                  // Three bytes of an improperly terminated multi-byte sequence.                                  goto InvalidThreeByteSequence;                              }                          }                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: {                  // Start of four-byte sequence.                  // Need to check for overlong or out-of-range sequences.                    uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);                  if (!Utf8Util.IsInRangeInclusive(scalar' 0x10000U' 0x10FFFFU)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a four-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete four-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Valid three-byte start of a four-byte sequence.                            if (data.Length < 4)                          {                              // Three bytes of an incomplete four-byte sequence.                              goto ThreeBytesOfIncompleteMultiByteSequence;                          }                          else                          {                              byte fourthByte = data[3];                              if (IsUtf8ContinuationByte(fourthByte))                              {                                  // Well-formed four-byte sequence.                                  scalar |= (((uint)thirdByte & 0x3FU) << 6) | ((uint)fourthByte & 0x3FU);                                  scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                                  numBytesConsumed = 4;                                  return SequenceValidity.WellFormed;                              }                              else                              {                                  // Three bytes of an improperly terminated multi-byte sequence.                                  goto InvalidThreeByteSequence;                              }                          }                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: {                  // Start of four-byte sequence.                  // Need to check for overlong or out-of-range sequences.                    uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);                  if (!Utf8Util.IsInRangeInclusive(scalar' 0x10000U' 0x10FFFFU)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a four-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete four-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Valid three-byte start of a four-byte sequence.                            if (data.Length < 4)                          {                              // Three bytes of an incomplete four-byte sequence.                              goto ThreeBytesOfIncompleteMultiByteSequence;                          }                          else                          {                              byte fourthByte = data[3];                              if (IsUtf8ContinuationByte(fourthByte))                              {                                  // Well-formed four-byte sequence.                                  scalar |= (((uint)thirdByte & 0x3FU) << 6) | ((uint)fourthByte & 0x3FU);                                  scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                                  numBytesConsumed = 4;                                  return SequenceValidity.WellFormed;                              }                              else                              {                                  // Three bytes of an improperly terminated multi-byte sequence.                                  goto InvalidThreeByteSequence;                              }                          }                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: {                  // Start of four-byte sequence.                  // Need to check for overlong or out-of-range sequences.                    uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);                  if (!Utf8Util.IsInRangeInclusive(scalar' 0x10000U' 0x10FFFFU)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a four-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete four-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Valid three-byte start of a four-byte sequence.                            if (data.Length < 4)                          {                              // Three bytes of an incomplete four-byte sequence.                              goto ThreeBytesOfIncompleteMultiByteSequence;                          }                          else                          {                              byte fourthByte = data[3];                              if (IsUtf8ContinuationByte(fourthByte))                              {                                  // Well-formed four-byte sequence.                                  scalar |= (((uint)thirdByte & 0x3FU) << 6) | ((uint)fourthByte & 0x3FU);                                  scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                                  numBytesConsumed = 4;                                  return SequenceValidity.WellFormed;                              }                              else                              {                                  // Three bytes of an improperly terminated multi-byte sequence.                                  goto InvalidThreeByteSequence;                              }                          }                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: {                  // Start of four-byte sequence.                  // Need to check for overlong or out-of-range sequences.                    uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);                  if (!Utf8Util.IsInRangeInclusive(scalar' 0x10000U' 0x10FFFFU)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a four-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete four-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Valid three-byte start of a four-byte sequence.                            if (data.Length < 4)                          {                              // Three bytes of an incomplete four-byte sequence.                              goto ThreeBytesOfIncompleteMultiByteSequence;                          }                          else                          {                              byte fourthByte = data[3];                              if (IsUtf8ContinuationByte(fourthByte))                              {                                  // Well-formed four-byte sequence.                                  scalar |= (((uint)thirdByte & 0x3FU) << 6) | ((uint)fourthByte & 0x3FU);                                  scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                                  numBytesConsumed = 4;                                  return SequenceValidity.WellFormed;                              }                              else                              {                                  // Three bytes of an improperly terminated multi-byte sequence.                                  goto InvalidThreeByteSequence;                              }                          }                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: {                  // Start of four-byte sequence.                  // Need to check for overlong or out-of-range sequences.                    uint scalar = (((uint)firstByte & 0x07U) << 18) | (((uint)secondByte & 0x3FU) << 12);                  if (!Utf8Util.IsInRangeInclusive(scalar' 0x10000U' 0x10FFFFU)) { goto OverlongOutOfRangeOrSurrogateSequence; }                    // At this point' we have a valid two-byte start of a four-byte sequence.                    if (data.Length < 3)                  {                      // Two bytes of an incomplete four-byte sequence.                      goto TwoBytesOfIncompleteMultiByteSequence;                  }                  else                  {                      byte thirdByte = data[2];                      if (IsUtf8ContinuationByte(thirdByte))                      {                          // Valid three-byte start of a four-byte sequence.                            if (data.Length < 4)                          {                              // Three bytes of an incomplete four-byte sequence.                              goto ThreeBytesOfIncompleteMultiByteSequence;                          }                          else                          {                              byte fourthByte = data[3];                              if (IsUtf8ContinuationByte(fourthByte))                              {                                  // Well-formed four-byte sequence.                                  scalar |= (((uint)thirdByte & 0x3FU) << 6) | ((uint)fourthByte & 0x3FU);                                  scalarValue = UnicodeScalar.CreateWithoutValidation(scalar);                                  numBytesConsumed = 4;                                  return SequenceValidity.WellFormed;                              }                              else                              {                                  // Three bytes of an improperly terminated multi-byte sequence.                                  goto InvalidThreeByteSequence;                              }                          }                      }                      else                      {                          // Two bytes of improperly terminated multi-byte sequence.                          goto InvalidTwoByteSequence;                      }                  }              }
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: InvalidTwoByteSequence:              OverlongOutOfRangeOrSurrogateSequence:              numBytesConsumed = 2;
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: InvalidThreeByteSequence:              numBytesConsumed = 3;
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: TwoBytesOfIncompleteMultiByteSequence:              numBytesConsumed = 2;
Magic Number,System.Buffers.Text,Utf8Utility,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Utility.cs,PeekFirstSequence,The following statement contains a magic number: ThreeBytesOfIncompleteMultiByteSequence:              numBytesConsumed = 3;
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,The following statement contains a magic number: var bytesCount = digitsCount * 2;
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimalInvariantCultureUtf16,The following statement contains a magic number: if ((symbol == 'D') && format.HasPrecision)              {                  var leadingZerosCount = format.Precision - digitsCount;                  if (leadingZerosCount > 0)                  {                      bytesCount += leadingZerosCount * 2;                  }                    if (bytesCount > buffer.Length)                  {                      bytesWritten = 0;                      return false;                  }                    while (leadingZerosCount-- > 0)                  {                      buffer[index++] = (byte)'0';                      buffer[index++] = 0;                  }              }              else if (bytesCount > buffer.Length)              {                  bytesWritten = 0;                  return false;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: firstHexCharOffset -= 10;
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: if (valueToCount > 0xFFFFFFFF)              {                  hexDigitsCount += 8;                  valueToCount >>= 0x20;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: if (valueToCount > 0xFFFF)              {                  hexDigitsCount += 4;                  valueToCount >>= 0x10;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: if (valueToCount > 0xFF)              {                  hexDigitsCount += 2;                  valueToCount >>= 0x8;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: var bytesCount = hexDigitsCount * 2;
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: bytesCount += leadingZerosCount > 0 ? leadingZerosCount * 2 : 0;
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf16,The following statement contains a magic number: while (hexDigitsCount-- > 0)              {                  byte digit = (byte)(value & 0xF);                  value >>= 0x4;                  digit += digit < 10 ? firstDigitOffset : firstHexCharOffset;                    buffer[--index] = 0;                  buffer[--index] = digit;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: firstHexCharOffset -= 10;
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: if (valueToCount > 0xFFFFFFFF)              {                  hexDigitsCount += 8;                  valueToCount >>= 0x20;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: if (valueToCount > 0xFFFF)              {                  hexDigitsCount += 4;                  valueToCount >>= 0x10;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: if (valueToCount > 0xFF)              {                  hexDigitsCount += 2;                  valueToCount >>= 0x8;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatHexadecimalInvariantCultureUtf8,The following statement contains a magic number: while (hexDigitsCount-- > 0)              {                  byte digit = (byte)(value & 0xF);                  value >>= 0x4;                  digit += digit < 10 ? firstDigitOffset : firstHexCharOffset;                  buffer[--index] = digit;              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: while (value >= 10)              {                  var digit = value % 10UL;                  value = value / 10UL;                    if (reversedValueExceptFirst == 0 && digit == 0)                  {                      trailingZerosCount++;                  }                  else                  {                      reversedValueExceptFirst = reversedValueExceptFirst * 10UL + digit;                      digitsCount++;                  }              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: if (symbol == 'N')              {                  const int GroupSize = 3;                    // Count amount of digits before first group separator. It will be reset to groupSize every time digitsLeftInGroup == zero                  var digitsLeftInGroup = (digitsCount + trailingZerosCount) % GroupSize;                  if (digitsLeftInGroup == 0)                  {                      if (digitsCount + trailingZerosCount > 0)                      {                          // There is a new group immediately after the first digit                          if (!symbolTable.TryEncode(SymbolTable.Symbol.GroupSeparator' buffer.Slice(bytesWritten)' out digitBytes))                          {                              bytesWritten = 0;                              return false;                          }                          bytesWritten += digitBytes;                      }                      digitsLeftInGroup = GroupSize;                  }                    // Append digits                  while (reversedValueExceptFirst > 0)                  {                      if (digitsLeftInGroup == 0)                      {                          if (!symbolTable.TryEncode(SymbolTable.Symbol.GroupSeparator' buffer.Slice(bytesWritten)' out digitBytes))                          {                              bytesWritten = 0;                              return false;                          }                          bytesWritten += digitBytes;                          digitsLeftInGroup = GroupSize;                      }                        var nextDigit = reversedValueExceptFirst % 10UL;                      reversedValueExceptFirst = reversedValueExceptFirst / 10UL;                        if (!symbolTable.TryEncode((SymbolTable.Symbol)nextDigit' buffer.Slice(bytesWritten)' out digitBytes))                      {                          bytesWritten = 0;                          return false;                      }                      bytesWritten += digitBytes;                      digitsLeftInGroup--;                  }                    // Append trailing zeros if any                  while (trailingZerosCount-- > 0)                  {                      if (digitsLeftInGroup == 0)                      {                          if (!symbolTable.TryEncode(SymbolTable.Symbol.GroupSeparator' buffer.Slice(bytesWritten)' out digitBytes))                          {                              bytesWritten = 0;                              return false;                          }                          bytesWritten += digitBytes;                          digitsLeftInGroup = GroupSize;                      }                        if (!symbolTable.TryEncode(SymbolTable.Symbol.D0' buffer.Slice(bytesWritten)' out digitBytes))                      {                          bytesWritten = 0;                          return false;                      }                      bytesWritten += digitBytes;                      digitsLeftInGroup--;                  }              }              else              {                  while (reversedValueExceptFirst > 0)                  {                      var bufferSlice = buffer.Slice(bytesWritten);                      var nextDigit = reversedValueExceptFirst % 10UL;                      reversedValueExceptFirst = reversedValueExceptFirst / 10UL;                      if (!symbolTable.TryEncode((SymbolTable.Symbol)nextDigit' bufferSlice' out digitBytes))                      {                          bytesWritten = 0;                          return false;                      }                      bytesWritten += digitBytes;                  }                    // Append trailing zeros if any                  while (trailingZerosCount-- > 0)                  {                      if (!symbolTable.TryEncode(SymbolTable.Symbol.D0' buffer.Slice(bytesWritten)' out digitBytes))                      {                          bytesWritten = 0;                          return false;                      }                      bytesWritten += digitBytes;                  }              }
Magic Number,System.Buffers.Text,CustomFormatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Formatter.cs,TryFormatDecimal,The following statement contains a magic number: if (symbol == 'N')              {                  int trailingZerosAfterDecimalCount = format.HasPrecision ? format.Precision : 2;                    if (trailingZerosAfterDecimalCount > 0)                  {                      if (!symbolTable.TryEncode(SymbolTable.Symbol.DecimalSeparator' buffer.Slice(bytesWritten)' out digitBytes))                      {                          bytesWritten = 0;                          return false;                      }                      bytesWritten += digitBytes;                        while (trailingZerosAfterDecimalCount-- > 0)                      {                          if (!symbolTable.TryEncode(SymbolTable.Symbol.D0' buffer.Slice(bytesWritten)' out digitBytes))                          {                              bytesWritten = 0;                              return false;                          }                          bytesWritten += digitBytes;                      }                  }              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,WriteHexByte,The following statement contains a magic number: Unsafe.Add(ref buffer' index) = HexTable[value >> 4];
Magic Number,System.Buffers.Text,FormattingHelpers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,WriteFractionDigits,The following statement contains a magic number: for (var i = FractionDigits; i > digitCount; i--)                  value /= 10;
Magic Number,System.Buffers.Text,FormattingHelpers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: for (var i = digitCount - 1; i >= 0; i--)              {                  left = DivMod(left' 10' out long num);                  Unsafe.Add(ref buffer' index + i) = (char)('0' + num);              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,WriteDigits,The following statement contains a magic number: for (var i = digitCount - 1; i >= 0; i--)              {                  left = DivMod(left' 10' out ulong num);                  Unsafe.Add(ref buffer' index + i) = (char)('0' + num);              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: while (n != 0)              {                  n /= 10;                  digits++;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,CountDigits,The following statement contains a magic number: while (n != 0)              {                  n /= 10;                  digits++;              }
Magic Number,System.Buffers.Text,FormattingHelpers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\FormattingHelpers.cs,CountFractionDigits,The following statement contains a magic number: while (left > 0 && m == 0 && count > 0)              {                  left = DivMod(left' 10' out m);                  count--;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: if (text.AsReadOnlySpan().AsBytes().TryCopyTo(buffer))              {                  bytesWritten = text.Length * 2;                  return true;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: if (value)              {                  if (buffer.Length < 8) // 4 chars for "true" = 8 bytes                  {                      bytesWritten = 0;                      return false;                  }                    if (format.IsDefault || format.Symbol == 'G')                  {                      s_True.CopyTo(buffer);                      bytesWritten = s_True.Length;                      return true;                  }                  else if (format.Symbol == 'l')                  {                      s_true.CopyTo(buffer);                      bytesWritten = s_true.Length;                      return true;                  }                  else                  {                      throw new FormatException();                  }              }              else              {                  if (buffer.Length < 10) // 5 chars for "false" = 10 bytes                  {                      bytesWritten = 0;                      return false;                  }                    if (format.IsDefault || format.Symbol == 'G')                  {                      s_False.CopyTo(buffer);                      bytesWritten = s_False.Length;                      return true;                  }                  else if (format.Symbol == 'l')                  {                      s_false.CopyTo(buffer);                      bytesWritten = s_false.Length;                      return true;                  }                  else                  {                      throw new FormatException();                  }              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: if (value)              {                  if (buffer.Length < 8) // 4 chars for "true" = 8 bytes                  {                      bytesWritten = 0;                      return false;                  }                    if (format.IsDefault || format.Symbol == 'G')                  {                      s_True.CopyTo(buffer);                      bytesWritten = s_True.Length;                      return true;                  }                  else if (format.Symbol == 'l')                  {                      s_true.CopyTo(buffer);                      bytesWritten = s_true.Length;                      return true;                  }                  else                  {                      throw new FormatException();                  }              }              else              {                  if (buffer.Length < 10) // 5 chars for "false" = 10 bytes                  {                      bytesWritten = 0;                      return false;                  }                    if (format.IsDefault || format.Symbol == 'G')                  {                      s_False.CopyTo(buffer);                      bytesWritten = s_False.Length;                      return true;                  }                  else if (format.Symbol == 'l')                  {                      s_false.CopyTo(buffer);                      bytesWritten = s_false.Length;                      return true;                  }                  else                  {                      throw new FormatException();                  }              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: bytesWritten = (GuidChars + (dash ? 4 : 0) + (bookEnds ? 2 : 0)) * sizeof(char);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: bytesWritten = (GuidChars + (dash ? 4 : 0) + (bookEnds ? 2 : 0)) * sizeof(char);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[3]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[2]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[2]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[1]' ref utf16Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[0]' ref utf16Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 8;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[5]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[4]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[4]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[7]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[6]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[6]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[8]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[9]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[9]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 4;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[10]' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[11]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[11]' ref utf16Bytes' idx + 2);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[12]' ref utf16Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[12]' ref utf16Bytes' idx + 4);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[13]' ref utf16Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[13]' ref utf16Bytes' idx + 6);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[14]' ref utf16Bytes' idx + 8);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[14]' ref utf16Bytes' idx + 8);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[15]' ref utf16Bytes' idx + 10);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: FormattingHelpers.WriteHexByte(bytes[15]' ref utf16Bytes' idx + 10);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormat,The following statement contains a magic number: idx += 12;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatDecimalInt64,The following statement contains a magic number: int charsNeeded = digitCount + (int)((value >> 63) & 1);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatDecimalInt64,The following statement contains a magic number: if (value < 0)              {                  Unsafe.Add(ref utf16Bytes' idx++) = Minus;                    // Abs(long.MinValue) == long.MaxValue + 1' so we need to re-route to unsigned to handle value                  if (value == long.MinValue)                  {                      if (!TryFormatDecimalUInt64((ulong)long.MaxValue + 1' precision' buffer.Slice(2)' out bytesWritten))                          return false;                        bytesWritten += sizeof(char); // Add the minus sign                      return true;                  }                    value = -value;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatDecimalUInt64,The following statement contains a magic number: value = FormattingHelpers.DivMod(value' 10' out ulong lastDigit);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: if (firstGroup == 0)              {                  firstGroup = 3;                  groupSeperators--;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: int trailingZeros = (precision == StandardFormat.NoPrecision) ? 2 : precision;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: int charsNeeded = (int)((value >> 63) & 1) + digitCount + groupSeperators;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: if (v < 0)              {                  Unsafe.Add(ref utf16Bytes' 0) = Minus;                    // Abs(long.MinValue) == long.MaxValue + 1' so we need to re-route to unsigned to handle value                  if (v == long.MinValue)                  {                      if (!TryFormatNumericUInt64((ulong)long.MaxValue + 1' precision' buffer.Slice(2)' out bytesWritten))                          return false;                        bytesWritten += sizeof(char); // Add the minus sign                      return true;                  }                    v = -v;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: while (digitCount > 3)              {                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf16Bytes' idx);                  Unsafe.Add(ref utf16Bytes' --idx) = Seperator;                  digitCount -= 3;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: while (digitCount > 3)              {                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf16Bytes' idx);                  Unsafe.Add(ref utf16Bytes' --idx) = Seperator;                  digitCount -= 3;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: while (digitCount > 3)              {                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf16Bytes' idx);                  Unsafe.Add(ref utf16Bytes' --idx) = Seperator;                  digitCount -= 3;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: while (digitCount > 3)              {                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf16Bytes' idx);                  Unsafe.Add(ref utf16Bytes' --idx) = Seperator;                  digitCount -= 3;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericInt64,The following statement contains a magic number: while (digitCount > 3)              {                  idx -= 3;                  v = FormattingHelpers.DivMod(v' 1000' out long groupValue);                  FormattingHelpers.WriteDigits(groupValue' 3' ref utf16Bytes' idx);                  Unsafe.Add(ref utf16Bytes' --idx) = Seperator;                  digitCount -= 3;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericUInt64,The following statement contains a magic number: value = FormattingHelpers.DivMod(value' 1000' out ulong lastGroup);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericUInt64,The following statement contains a magic number: if (precision == StandardFormat.NoPrecision)                  precision = 2;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericUInt64,The following statement contains a magic number: int extraChars = 4;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatNumericUInt64,The following statement contains a magic number: idx += FormattingHelpers.WriteDigits(lastGroup' 3' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The following statement contains a magic number: if (v > 0xFFFFFFFF)              {                  digits += 8;                  v >>= 0x20;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The following statement contains a magic number: if (v > 0xFFFF)              {                  digits += 4;                  v >>= 0x10;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The following statement contains a magic number: if (v > 0xFF)              {                  digits += 2;                  v >>= 0x8;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatHexUInt64,The following statement contains a magic number: for (v = value; digits-- > 0; v >>= 4)                  Unsafe.Add(ref utf16Bytes' --idx) = hexTable[(int)(v & 0xF)];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: const int MinimumCharsNeeded = 19;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  charsNeeded += 7; // Space['+'|'-']hh:ss              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf16Bytes' 0);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = Slash;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 3);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 3);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 5) = Slash;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 6);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 6);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 11);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 11);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 13) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 14);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 14);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 16) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  Unsafe.Add(ref utf16Bytes' 19) = Space;                    long ticks = value.Ticks;                  if (ticks < 0)                  {                      Unsafe.Add(ref utf16Bytes' 20) = Minus;                      ticks = -ticks;                  }                  else                  {                      Unsafe.Add(ref utf16Bytes' 20) = Plus;                  }                    FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);                  Unsafe.Add(ref utf16Bytes' 23) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  Unsafe.Add(ref utf16Bytes' 19) = Space;                    long ticks = value.Ticks;                  if (ticks < 0)                  {                      Unsafe.Add(ref utf16Bytes' 20) = Minus;                      ticks = -ticks;                  }                  else                  {                      Unsafe.Add(ref utf16Bytes' 20) = Plus;                  }                    FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);                  Unsafe.Add(ref utf16Bytes' 23) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  Unsafe.Add(ref utf16Bytes' 19) = Space;                    long ticks = value.Ticks;                  if (ticks < 0)                  {                      Unsafe.Add(ref utf16Bytes' 20) = Minus;                      ticks = -ticks;                  }                  else                  {                      Unsafe.Add(ref utf16Bytes' 20) = Plus;                  }                    FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);                  Unsafe.Add(ref utf16Bytes' 23) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  Unsafe.Add(ref utf16Bytes' 19) = Space;                    long ticks = value.Ticks;                  if (ticks < 0)                  {                      Unsafe.Add(ref utf16Bytes' 20) = Minus;                      ticks = -ticks;                  }                  else                  {                      Unsafe.Add(ref utf16Bytes' 20) = Plus;                  }                    FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);                  Unsafe.Add(ref utf16Bytes' 23) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  Unsafe.Add(ref utf16Bytes' 19) = Space;                    long ticks = value.Ticks;                  if (ticks < 0)                  {                      Unsafe.Add(ref utf16Bytes' 20) = Minus;                      ticks = -ticks;                  }                  else                  {                      Unsafe.Add(ref utf16Bytes' 20) = Plus;                  }                    FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);                  Unsafe.Add(ref utf16Bytes' 23) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  Unsafe.Add(ref utf16Bytes' 19) = Space;                    long ticks = value.Ticks;                  if (ticks < 0)                  {                      Unsafe.Add(ref utf16Bytes' 20) = Minus;                      ticks = -ticks;                  }                  else                  {                      Unsafe.Add(ref utf16Bytes' 20) = Plus;                  }                    FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);                  Unsafe.Add(ref utf16Bytes' 23) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  Unsafe.Add(ref utf16Bytes' 19) = Space;                    long ticks = value.Ticks;                  if (ticks < 0)                  {                      Unsafe.Add(ref utf16Bytes' 20) = Minus;                      ticks = -ticks;                  }                  else                  {                      Unsafe.Add(ref utf16Bytes' 20) = Plus;                  }                    FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);                  Unsafe.Add(ref utf16Bytes' 23) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatG,The following statement contains a magic number: if (offset != NullOffset)              {                  Unsafe.Add(ref utf16Bytes' 19) = Space;                    long ticks = value.Ticks;                  if (ticks < 0)                  {                      Unsafe.Add(ref utf16Bytes' 20) = Minus;                      ticks = -ticks;                  }                  else                  {                      Unsafe.Add(ref utf16Bytes' 20) = Plus;                  }                    FormattingHelpers.WriteDigits(offset.Hours' 2' ref utf16Bytes' 21);                  Unsafe.Add(ref utf16Bytes' 23) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 24);              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: const int MinimumCharsNeeded = 27;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (offset == NullOffset)              {                  kind = value.Kind;                  if (kind == DateTimeKind.Local)                  {                      offset = TimeZoneInfo.Local.GetUtcOffset(value);                      charsNeeded += 6;                  }                  else if (kind == DateTimeKind.Utc)                  {                      charsNeeded += 1;                  }              }              else              {                  charsNeeded += 6;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (offset == NullOffset)              {                  kind = value.Kind;                  if (kind == DateTimeKind.Local)                  {                      offset = TimeZoneInfo.Local.GetUtcOffset(value);                      charsNeeded += 6;                  }                  else if (kind == DateTimeKind.Utc)                  {                      charsNeeded += 1;                  }              }              else              {                  charsNeeded += 6;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 0);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 4) = Minus;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Month' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 7) = Minus;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 8);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 8);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = TimeMarker;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 11);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 11);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 13) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 14);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 14);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 16) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 19) = Period;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: FormattingHelpers.WriteFractionDigits(fraction' DefaultFractionDigits' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  char sign = Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Minus;                  }                    Unsafe.Add(ref utf16Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf16Bytes' 28);                  Unsafe.Add(ref utf16Bytes' 30) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf16Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  char sign = Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Minus;                  }                    Unsafe.Add(ref utf16Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf16Bytes' 28);                  Unsafe.Add(ref utf16Bytes' 30) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf16Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  char sign = Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Minus;                  }                    Unsafe.Add(ref utf16Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf16Bytes' 28);                  Unsafe.Add(ref utf16Bytes' 30) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf16Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  char sign = Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Minus;                  }                    Unsafe.Add(ref utf16Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf16Bytes' 28);                  Unsafe.Add(ref utf16Bytes' 30) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf16Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  char sign = Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Minus;                  }                    Unsafe.Add(ref utf16Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf16Bytes' 28);                  Unsafe.Add(ref utf16Bytes' 30) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf16Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  char sign = Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Minus;                  }                    Unsafe.Add(ref utf16Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf16Bytes' 28);                  Unsafe.Add(ref utf16Bytes' 30) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf16Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatO,The following statement contains a magic number: if (kind == DateTimeKind.Local)              {                  int hours = offset.Hours;                  char sign = Plus;                    if (offset.Hours < 0)                  {                      hours = -offset.Hours;                      sign = Minus;                  }                    Unsafe.Add(ref utf16Bytes' 27) = sign;                  FormattingHelpers.WriteDigits(hours' 2' ref utf16Bytes' 28);                  Unsafe.Add(ref utf16Bytes' 30) = Colon;                  FormattingHelpers.WriteDigits(offset.Minutes' 2' ref utf16Bytes' 31);              }              else if (kind == DateTimeKind.Utc)              {                  Unsafe.Add(ref utf16Bytes' 27) = UtcMarker;              }
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: const int CharsNeeded = 29;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 3) = Comma;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 4) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 7) = ' ';
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 8) = monthAbbrev[0];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 9) = monthAbbrev[1];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 11) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 12);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 12);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 16) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 19) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 22) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 23);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 23);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 25) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 26) = GMT1;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 27) = GMT2;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 28) = GMT3;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: const int CharsNeeded = 29;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 2) = dayAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 3) = Comma;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 4) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Day' 2' ref utf16Bytes' 5);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 7) = ' ';
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 8) = monthAbbrev[0];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 9) = monthAbbrev[1];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 10) = monthAbbrev[2];
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 11) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 12);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Year' 4' ref utf16Bytes' 12);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 16) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Hour' 2' ref utf16Bytes' 17);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 19) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Minute' 2' ref utf16Bytes' 20);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 22) = Colon;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 23);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: FormattingHelpers.WriteDigits(value.Second' 2' ref utf16Bytes' 23);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 25) = Space;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 26) = GMT1Lowercase;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 27) = GMT2Lowercase;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatRfc1123Lowercase,The following statement contains a magic number: Unsafe.Add(ref utf16Bytes' 28) = GMT3Lowercase;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: int hourDigits = (constant || longForm || hours > 9) ? 2 : 1;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: bytesWritten = hourDigits + 6;
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: idx += FormattingHelpers.WriteDigits(minutes' 2' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,Utf16Formatter,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Formatters\Utf16Formatter.cs,TryFormatTimeSpan,The following statement contains a magic number: idx += FormattingHelpers.WriteDigits(seconds' 2' ref utf16Bytes' idx);
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (sbyte)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > sbyte.MaxValue / 10 || (parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (int)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (sbyte)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > sbyte.MaxValue / 10 || (parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (int)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseSByte,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (sbyte)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > sbyte.MaxValue / 10 || (parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (int)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (short)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > short.MaxValue / 10 || (parsedValue == short.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (int)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (short)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > short.MaxValue / 10 || (parsedValue == short.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (int)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt16,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (short)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > short.MaxValue / 10 || (parsedValue == short.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (int)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The following statement contains a magic number: if (Parsers.IsValid(symbol))              {                  int numBytes = consumed;                  if (symbol == SymbolTable.Symbol.D0)                  {                      do                      {                          index += consumed;                          if (index >= textLength) goto Done;                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (symbol == SymbolTable.Symbol.D0);                      if (!Parsers.IsValid(symbol)) goto Done;                  }                    int firstNonZeroDigitIndex = index;                  if (textLength - firstNonZeroDigitIndex < Parsers.Int32OverflowLength * numBytes)                  {                      do                      {                          answer = answer * 10 + (int)symbol;                          index += consumed;                          if (index >= textLength) goto Done;                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (Parsers.IsValid(symbol));                  }                  else                  {                      do                      {                          answer = answer * 10 + (int)symbol;                          index += consumed;                          if (index - firstNonZeroDigitIndex == (Parsers.Int32OverflowLength - 1) * numBytes)                          {                              if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                              if (Parsers.IsValid(symbol))                              {                                  if (Parsers.WillOverFlow(answer' (int)symbol' sign)) goto FalseExit;                                  answer = answer * 10 + (int)symbol;                                  index += consumed;                              }                              goto Done;                          }                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (Parsers.IsValid(symbol));                  }                  goto Done;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The following statement contains a magic number: if (Parsers.IsValid(symbol))              {                  int numBytes = consumed;                  if (symbol == SymbolTable.Symbol.D0)                  {                      do                      {                          index += consumed;                          if (index >= textLength) goto Done;                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (symbol == SymbolTable.Symbol.D0);                      if (!Parsers.IsValid(symbol)) goto Done;                  }                    int firstNonZeroDigitIndex = index;                  if (textLength - firstNonZeroDigitIndex < Parsers.Int32OverflowLength * numBytes)                  {                      do                      {                          answer = answer * 10 + (int)symbol;                          index += consumed;                          if (index >= textLength) goto Done;                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (Parsers.IsValid(symbol));                  }                  else                  {                      do                      {                          answer = answer * 10 + (int)symbol;                          index += consumed;                          if (index - firstNonZeroDigitIndex == (Parsers.Int32OverflowLength - 1) * numBytes)                          {                              if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                              if (Parsers.IsValid(symbol))                              {                                  if (Parsers.WillOverFlow(answer' (int)symbol' sign)) goto FalseExit;                                  answer = answer * 10 + (int)symbol;                                  index += consumed;                              }                              goto Done;                          }                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (Parsers.IsValid(symbol));                  }                  goto Done;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt32,The following statement contains a magic number: if (Parsers.IsValid(symbol))              {                  int numBytes = consumed;                  if (symbol == SymbolTable.Symbol.D0)                  {                      do                      {                          index += consumed;                          if (index >= textLength) goto Done;                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (symbol == SymbolTable.Symbol.D0);                      if (!Parsers.IsValid(symbol)) goto Done;                  }                    int firstNonZeroDigitIndex = index;                  if (textLength - firstNonZeroDigitIndex < Parsers.Int32OverflowLength * numBytes)                  {                      do                      {                          answer = answer * 10 + (int)symbol;                          index += consumed;                          if (index >= textLength) goto Done;                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (Parsers.IsValid(symbol));                  }                  else                  {                      do                      {                          answer = answer * 10 + (int)symbol;                          index += consumed;                          if (index - firstNonZeroDigitIndex == (Parsers.Int32OverflowLength - 1) * numBytes)                          {                              if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                              if (Parsers.IsValid(symbol))                              {                                  if (Parsers.WillOverFlow(answer' (int)symbol' sign)) goto FalseExit;                                  answer = answer * 10 + (int)symbol;                                  index += consumed;                              }                              goto Done;                          }                          if (!symbolTable.TryParse(text.Slice(index)' out symbol' out consumed)) goto Done;                      } while (Parsers.IsValid(symbol));                  }                  goto Done;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (long)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > long.MaxValue / 10 || (parsedValue == long.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (long)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (long)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > long.MaxValue / 10 || (parsedValue == long.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (long)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseInt64,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (long)(parsedValue * sign);                      return true;                  }                    // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                  bool positive = sign > 0;                  bool nextDigitTooLarge = nextSymbol > SymbolTable.Symbol.D8 || (positive && nextSymbol > SymbolTable.Symbol.D7);                  if (parsedValue > long.MaxValue / 10 || (parsedValue == long.MaxValue / 10 && nextDigitTooLarge))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (long)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (byte)parsedValue;                      return true;                  }                    // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (byte)parsedValue;                      return true;                  }                    // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseByte,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (byte)parsedValue;                      return true;                  }                    // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (ushort)parsedValue;                      return true;                  }                    // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (ushort)parsedValue;                      return true;                  }                    // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt16,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (ushort)parsedValue;                      return true;                  }                    // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (uint)parsedValue;                      return true;                  }                    // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (uint)parsedValue;                      return true;                  }                    // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt32,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (uint)parsedValue;                      return true;                  }                    // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (ulong)parsedValue;                      return true;                  }                    // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (ulong)parsedValue;                      return true;                  }                    // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,CustomParser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_bool.cs,TryParseUInt64,The following statement contains a magic number: while (index < text.Length)              {                  bool success = symbolTable.TryParse(text.Slice(index)' out nextSymbol' out thisSymbolConsumed);                  if (!success || nextSymbol > SymbolTable.Symbol.D9)                  {                      bytesConsumed = index;                      value = (ulong)parsedValue;                      return true;                  }                    // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                  // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                  if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextSymbol > SymbolTable.Symbol.D5))                  {                      bytesConsumed = 0;                      value = default;                      return false;                  }                    index += thisSymbolConsumed;                  parsedValue = parsedValue * 10 + (uint)nextSymbol;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (text.Length < 32) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt32(text.Slice(0' 8)' out uint i1' out int justConsumed) || justConsumed != 8) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt32(text.Slice(0' 8)' out uint i1' out int justConsumed) || justConsumed != 8) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(8' 4)' out ushort i2' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(12' 4)' out ushort i3' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt16(text.Slice(16' 4)' out ushort i4' out justConsumed) || justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt64(text.Slice(20)' out ulong i5' out justConsumed) || justConsumed != 12) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: if (!Hex.TryParseUInt64(text.Slice(20)' out ulong i5' out justConsumed) || justConsumed != 12) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: charactersConsumed = 32;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidN,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: var expectedCodingUnits = 36 + (ends ? 2 : 0);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: var expectedCodingUnits = 36 + (ends ? 2 : 0);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 8) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(9);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 4) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: text = text.Slice(5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: if (justConsumed != 12) return false;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseGuidCore,The following statement contains a magic number: value = new Guid((int)i1' (short)i2' (short)i3' (byte)(i4 >> 8)' (byte)i4'                  (byte)(i5 >> 40)' (byte)(i5 >> 32)' (byte)(i5 >> 24)' (byte)(i5 >> 16)' (byte)(i5 >> 8)' (byte)i5);
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      // No need to set consumed                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          // No need to set consumed                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseBoolean,The following statement contains a magic number: if (text.Length >= 4)              {                  if ((text[0] == 'T' || text[0] == 't') &&                      (text[1] == 'R' || text[1] == 'r') &&                      (text[2] == 'U' || text[2] == 'u') &&                      (text[3] == 'E' || text[3] == 'e'))                  {                      charactersConsumed = 4;                      value = true;                      return true;                  }                  if (text.Length >= 5)                  {                      if ((text[0] == 'F' || text[0] == 'f') &&                          (text[1] == 'A' || text[1] == 'a') &&                          (text[2] == 'L' || text[2] == 'l') &&                          (text[3] == 'S' || text[3] == 's') &&                          (text[4] == 'E' || text[4] == 'e'))                      {                          charactersConsumed = 5;                          value = false;                          return true;                      }                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseSByte,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than SParsers.ByteOverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than SParsers.ByteOverflowLength; overflow is only possible after SParsers.ByteOverflowLength                  // digits. There may be no overflow after SParsers.ByteOverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (sbyte)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (sbyte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (sbyte.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > sbyte.MaxValue / 10 || parsedValue == sbyte.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt16,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = (short)(parsedValue * sign);                          return true;                      }                      // If parsedValue > (short.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (short.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > short.MaxValue / 10 || parsedValue == short.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: int firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt32,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      int nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (int.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (int.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > int.MaxValue / 10 || parsedValue == int.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: long firstDigit = text[indexOfFirstDigit] - 48;
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (firstDigit < 0 || firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseInt64,The following statement contains a magic number: if (text.Length < overflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = indexOfFirstDigit + 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = indexOfFirstDigit + 1; index < overflowLength - 1; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = overflowLength - 1; index < text.Length; index++)                  {                      long nextDigit = text[index] - 48; // '0'                      if (nextDigit < 0 || nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue * sign;                          return true;                      }                      // If parsedValue > (long.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (long.MaxValue / 10)' any nextDigit greater than 7 or 8 (depending on sign) implies overflow.                      bool positive = sign > 0;                      bool nextDigitTooLarge = nextDigit > 8 || (positive && nextDigit > 7);                      if (parsedValue > long.MaxValue / 10 || parsedValue == long.MaxValue / 10 && nextDigitTooLarge)                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseByte,The following statement contains a magic number: if (text.Length < Parsers.ByteOverflowLength)              {                  // Length is less than Parsers.ByteOverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.ByteOverflowLength; overflow is only possible after Parsers.ByteOverflowLength                  // digits. There may be no overflow after Parsers.ByteOverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.ByteOverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.ByteOverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (byte)(parsedValue);                          return true;                      }                      // If parsedValue > (byte.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (byte.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > byte.MaxValue / 10 || (parsedValue == byte.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length < Parsers.Int16OverflowLength)              {                  // Length is less than Parsers.Int16OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int16OverflowLength; overflow is only possible after Parsers.Int16OverflowLength                  // digits. There may be no overflow after Parsers.Int16OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int16OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int16OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = (ushort)(parsedValue);                          return true;                      }                      // If parsedValue > (ushort.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ushort.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ushort.MaxValue / 10 || (parsedValue == ushort.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length < Parsers.Int32OverflowLength)              {                  // Length is less than Parsers.Int32OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int32OverflowLength; overflow is only possible after Parsers.Int32OverflowLength                  // digits. There may be no overflow after Parsers.Int32OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int32OverflowLength - 1; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int32OverflowLength - 1; index < text.Length; index++)                  {                      uint nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (uint.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (uint.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > uint.MaxValue / 10 || (parsedValue == uint.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (firstDigit > 9)              {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (firstDigit > 9)              {                  charactersConsumed = 0;                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length < Parsers.Int64OverflowLength)              {                  // Length is less than Parsers.Int64OverflowLength; overflow is not possible                  for (int index = 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }              else              {                  // Length is greater than Parsers.Int64OverflowLength; overflow is only possible after Parsers.Int64OverflowLength                  // digits. There may be no overflow after Parsers.Int64OverflowLength if there are leading zeroes.                  for (int index = 1; index < Parsers.Int64OverflowLength - 1; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }                  for (int index = Parsers.Int64OverflowLength - 1; index < text.Length; index++)                  {                      ulong nextDigit = text[index] - 48u; // '0'                      if (nextDigit > 9)                      {                          charactersConsumed = index;                          value = parsedValue;                          return true;                      }                      // If parsedValue > (ulong.MaxValue / 10)' any more appended digits will cause overflow.                      // if parsedValue == (ulong.MaxValue / 10)' any nextDigit greater than 5 implies overflow.                      if (parsedValue > ulong.MaxValue / 10 || (parsedValue == ulong.MaxValue / 10 && nextDigit > 5))                      {                          charactersConsumed = 0;                          value = default;                          return false;                      }                      parsedValue = parsedValue * 10 + nextDigit;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The following statement contains a magic number: for (int charIndex = indexOfFirstDigit; charIndex < text.Length; charIndex++)              {                  char nextChar = text[charIndex];                  char nextCharVal = (char)(nextChar - '0');                    if (nextCharVal > 9)                  {                      if (!decimalPlace && nextChar == '.')                      {                          charactersConsumed++;                          decimalPlace = true;                          decimalString += nextChar;                      }                      else if ((decimalPlace && signed && charactersConsumed == 2) || ((signed || decimalPlace) && charactersConsumed == 1))                      {                          value = 0;                          charactersConsumed = 0;                          return false;                      }                      else                      {                          if (decimal.TryParse(decimalString' out value))                          {                              return true;                          }                          else                          {                              charactersConsumed = 0;                              return false;                          }                      }                  }                  else                  {                      charactersConsumed++;                      decimalString += nextChar;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The following statement contains a magic number: for (int charIndex = indexOfFirstDigit; charIndex < text.Length; charIndex++)              {                  char nextChar = text[charIndex];                  char nextCharVal = (char)(nextChar - '0');                    if (nextCharVal > 9)                  {                      if (!decimalPlace && nextChar == '.')                      {                          charactersConsumed++;                          decimalPlace = true;                          decimalString += nextChar;                      }                      else if ((decimalPlace && signed && charactersConsumed == 2) || ((signed || decimalPlace) && charactersConsumed == 1))                      {                          value = 0;                          charactersConsumed = 0;                          return false;                      }                      else                      {                          if (decimal.TryParse(decimalString' out value))                          {                              return true;                          }                          else                          {                              charactersConsumed = 0;                              return false;                          }                      }                  }                  else                  {                      charactersConsumed++;                      decimalString += nextChar;                  }              }
Magic Number,System.Buffers.Text,Utf16Parser,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Parser_guid.cs,TryParseDecimal,The following statement contains a magic number: if ((decimalPlace && signed && charactersConsumed == 2) || ((signed || decimalPlace) && charactersConsumed == 1))              {                  value = 0;                  charactersConsumed = 0;                  return false;              }              else              {                  if (decimal.TryParse(decimalString' out value))                  {                      return true;                  }                  else                  {                      charactersConsumed = 0;                      return false;                  }              }
Magic Number,System.Buffers.Text,Parsers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\ParsingHelpers.cs,WillOverFlow,The following statement contains a magic number: bool nextDigitTooLarge = nextDigit > 8 || (sign > 0 && nextDigit > 7);
Magic Number,System.Buffers.Text,Parsers,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\ParsingHelpers.cs,WillOverFlow,The following statement contains a magic number: bool nextDigitTooLarge = nextDigit > 8 || (sign > 0 && nextDigit > 7);
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseSByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (sbyte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(sbyte.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(sbyte.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (short)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(short.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(short.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (int)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(int.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(int.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (long)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than -(long.MinValue / 0x08)' there will be overflow                          if (parsedValue >= -(long.MinValue / 0x08))                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseByte,The following statement contains a magic number: if (text.Length <= Parsers.ByteOverflowLengthHex)                  {                      // Length is less than or equal to Parsers.ByteOverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.ByteOverflowLengthHex; overflow is only possible after Parsers.ByteOverflowLengthHex                      // digits. There may be no overflow after Parsers.ByteOverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.ByteOverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.ByteOverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (byte)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than byte.MaxValue / 0x10' there will be overflow                          if (parsedValue > byte.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt16,The following statement contains a magic number: if (text.Length <= Parsers.Int16OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int16OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int16OverflowLengthHex; overflow is only possible after Parsers.Int16OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int16OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int16OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int16OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = (ushort)(parsedValue);                              return true;                          }                          // If we try to append a digit to anything larger than ushort.MaxValue / 0x10' there will be overflow                          if (parsedValue > ushort.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt32,The following statement contains a magic number: if (text.Length <= Parsers.Int32OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int32OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int32OverflowLengthHex; overflow is only possible after Parsers.Int32OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int32OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int32OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int32OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than uint.MaxValue / 0x10' there will be overflow                          if (parsedValue > uint.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                  {                      charactersConsumed = 0;                      value = default;                      return false;                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,Hex,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Parsers\Utf16Parser_signed_hex.cs,TryParseUInt64,The following statement contains a magic number: if (text.Length <= Parsers.Int64OverflowLengthHex)                  {                      // Length is less than or equal to Parsers.Int64OverflowLengthHex; overflow is not possible                      for (int index = 1; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }                  else                  {                      // Length is greater than Parsers.Int64OverflowLengthHex; overflow is only possible after Parsers.Int64OverflowLengthHex                      // digits. There may be no overflow after Parsers.Int64OverflowLengthHex if there are leading zeroes.                      for (int index = 1; index < Parsers.Int64OverflowLengthHex; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                      for (int index = Parsers.Int64OverflowLengthHex; index < text.Length; index++)                      {                          nextCharacter = text[index];                          nextDigit = hexLookup[(byte)nextCharacter];                          if (nextDigit == 0xFF || (nextCharacter >> 8) != 0)                          {                              charactersConsumed = index;                              value = parsedValue;                              return true;                          }                          // If we try to append a digit to anything larger than ulong.MaxValue / 0x10' there will be overflow                          if (parsedValue > ulong.MaxValue / 0x10)                          {                              charactersConsumed = 0;                              value = default;                              return false;                          }                          parsedValue = (parsedValue << 4) + nextDigit;                      }                  }
Magic Number,System.Buffers.Text,ParsingTrie,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateParsingTrieNodeAndChildren,The following statement contains a magic number: if (longestSequence.Length > 5)              {                  parentNode.IndexOrSymbol = longestSequence.CreateSequenceMap();              }              else              {                  parentNode.IndexOrSymbol = 0;              }
Magic Number,System.Buffers.Text,ParsingTrie,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,Create,The following statement contains a magic number: List<Node> parsingTrieList = new List<Node>(100);
Magic Number,System.Buffers.Text,SuffixClump,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,SuffixClump,The following statement contains a magic number: Suffixes = new List<Suffix>(20);
Magic Number,System.Buffers.Text,Sequence,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateSequenceMap,The following statement contains a magic number: sequenceMap += BeginningValue << 24;
Magic Number,System.Buffers.Text,Sequence,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateSequenceMap,The following statement contains a magic number: sequenceMap += (BeginningIndex + 1) << 16;
Magic Number,System.Buffers.Text,Sequence,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\ParsingTrie.cs,CreateSequenceMap,The following statement contains a magic number: sequenceMap += EndValue << 8;
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryEncode,The following statement contains a magic number: if (bytesWritten == 2)              {                  destination[0] = bytes[0];                  destination[1] = bytes[1];                  return true;              }
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,TryEncode,The following statement contains a magic number: const int BufferSize = 256;
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: if (maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24)              {                  // See the comments on the struct above for more information about this format                  return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));              }
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: if (maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24)              {                  // See the comments on the struct above for more information about this format                  return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));              }
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: if (maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24)              {                  // See the comments on the struct above for more information about this format                  return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));              }
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: if (maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24)              {                  // See the comments on the struct above for more information about this format                  return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));              }
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: if (maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24)              {                  // See the comments on the struct above for more information about this format                  return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));              }
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: if (maxMinLimits != 0 && value > (uint)maxMinLimits >> 24 && value < (uint)(maxMinLimits << 16) >> 24)              {                  // See the comments on the struct above for more information about this format                  return (int)(nodeIndex + ((uint)(maxMinLimits << 8) >> 24) + value - ((uint)maxMinLimits >> 24));              }
Magic Number,System.Buffers.Text,SymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable.cs,BinarySearch,The following statement contains a magic number: while (true)              {                  if (leftBound > rightBound)  // if the search failed                  {                      // this loop is necessary because binary search takes the floor                      // of the middle' which means it can give incorrect indices for insertion.                      // we should never iterate up more than two indices.                      while (midIndex < nodeIndex + _parsingTrie[nodeIndex].ValueOrNumChildren                          && _parsingTrie[midIndex].ValueOrNumChildren < value)                      {                          midIndex++;                      }                      return -midIndex;                  }                    midIndex = (leftBound + rightBound) / 2; // find the middle value                    byte mValue = _parsingTrie[midIndex].ValueOrNumChildren;                    if (mValue < value)                      leftBound = midIndex + 1;                  else if (mValue > value)                      rightBound = midIndex - 1;                  else                      return midIndex;              }
Magic Number,System.Buffers.Text,Utf16InvariantSymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable_utf16.cs,TryEncode,The following statement contains a magic number: if (destination.Length < 2)                      goto ExitFailed;
Magic Number,System.Buffers.Text,Utf16InvariantSymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable_utf16.cs,TryEncode,The following statement contains a magic number: bytesWritten = 2;
Magic Number,System.Buffers.Text,Utf16InvariantSymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable_utf16.cs,TryParse,The following statement contains a magic number: if (source.Length < 2)                      goto ExitFailed;
Magic Number,System.Buffers.Text,Utf16InvariantSymbolTable,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\SymbolTable\SymbolTable_utf16.cs,TryParse,The following statement contains a magic number: bytesConsumed = 2;
Duplicate Code,System.Buffers.Text,Utf8Util,C:\repos\dotnet_corefxlab\src\System.Text.Primitives\System\Text\Encoders\Utf8Util.Helpers.cs,GetIndexOfFirstInvalidUtf8Sequence,The method contains a code clone-set at the following line numbers (starting from the method definition): ((361' 382)' (406' 427))
