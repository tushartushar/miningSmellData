Implementation smell,Namespace,Class,File,Method,Description
Long Statement,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The length of the statement  "                (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload " is 138.
Long Statement,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The length of the statement  "                (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload " is 154.
Long Statement,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The length of the statement  "                (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload " is 147.
Long Statement,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The length of the statement  "                (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload " is 164.
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,CompareTo_ThrowsArgumentException_TestData,The following statement contains a magic number: yield return new object[] { 234.0 };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,Equals_TestData,The following statement contains a magic number: yield return new object[] { Half.MaxValue' 789.0f' false };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt64_TestData,The following statement contains a magic number: (long Original' Half Expected)[] data =              {                  (65504L' Half.MaxValue)' // Half.MaxValue                  (-65504L' Half.MinValue)' // Half.MinValue                  (1L' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1L' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0L' UInt16BitsToHalf(0))' // 0                  (long.MaxValue' Half.PositiveInfinity)' // Overflow                  (long.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504L + 16' Half.PositiveInfinity)' // Overflow                  (-(65504L + 16)' Half.NegativeInfinity)' // Overflow                  (65504L + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504L + 16 - 1)' Half.MinValue)' // MinValue                  (65504L + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504L + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt64_TestData,The following statement contains a magic number: (ulong Original' Half Expected)[] data =                  unchecked                  (                      new (ulong' Half)[]                      {                          (65504UL' Half.MaxValue)' // Half.MaxValue                          ((ulong)-65504L' Half.PositiveInfinity)' // Overflow                          (1UL' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((ulong)-1L' Half.PositiveInfinity)' // Overflow                          (0UL' UInt16BitsToHalf(0))' // 0                          (long.MaxValue' Half.PositiveInfinity)' // Overflow                          ((ulong)long.MinValue' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16' Half.PositiveInfinity)' // Overflow                          ((ulong)-(65504L + 16)' Half.PositiveInfinity)' // Overflow                          (65504UL + 16 - 1' Half.MaxValue)' // MaxValue                          ((ulong)-(65504L + 16 - 1)' Half.PositiveInfinity)' // OverFlow                          (65504UL + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                          ((ulong)-(65504L + 16 + 1)' Half.PositiveInfinity)' // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromInt32_TestData,The following statement contains a magic number: (int Original' Half Expected)[] data =              {                  (65504' Half.MaxValue)' // Half.MaxValue                  (-65504' Half.MinValue)' // Half.MinValue                  (1' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0' UInt16BitsToHalf(0))' // 0                  (int.MaxValue' Half.PositiveInfinity)' // Overflow                  (int.MinValue' Half.NegativeInfinity)' // OverFlow                  (65504 + 16' Half.PositiveInfinity)' // Overflow                  (-(65504 + 16)' Half.NegativeInfinity)' // Overflow                  (65504 + 16 - 1' Half.MaxValue)' // MaxValue                  (-(65504 + 16 - 1)' Half.MinValue)' // MinValue                  (65504 + 16 + 1' Half.PositiveInfinity)' // MaxValue + half the increment unit + 1' should overflow                  (-(65504 + 16 + 1)' Half.NegativeInfinity) // MinValue - half the increment unit - 1' should overflow              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_FromUInt32_TestData,The following statement contains a magic number: (uint Original' Half Expected)[] data =                  unchecked                  (                      new []                      {                          (65504U' Half.MaxValue)' // Half.MaxValue                          ((uint)-65504' Half.PositiveInfinity)' // Overflow                          (1U' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                          ((uint)-1' Half.PositiveInfinity)' // Overflow                           (0U' UInt16BitsToHalf(0))' // 0                          ((uint)int.MaxValue' Half.PositiveInfinity)' // Overflow                          ((uint)int.MinValue' Half.PositiveInfinity)' // OverFlow                          (uint.MaxValue' Half.PositiveInfinity)'                          (65504U + 16' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 - 1' Half.MaxValue)' // MaxValue                          ((uint)-(65504 + 16 - 1)' Half.PositiveInfinity)' // Overflow                          (65504U + 16 + 1' Half.PositiveInfinity)' // Overflow                          ((uint)-(65504 + 16 + 1)' Half.PositiveInfinity) // Overflow                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromSingle_TestData,The following statement contains a magic number: (float' Half)[] data =               {                  (MathF.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (MathF.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-MathF.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-MathF.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (float.MaxValue' Half.PositiveInfinity)' // Overflow                  (float.MinValue' Half.NegativeInfinity)' // Overflow                  (float.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FC00000)' UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int32BitsToSingle(unchecked((int)0xFFD55555))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FD55555)' UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (float.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-float.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1f' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1f' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0f' UInt16BitsToHalf(0))' // 0                  (-0f' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42f' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42f' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1f' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1f' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5f' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5f' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625f' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625f' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromSingle_TestData,The following statement contains a magic number: (float' Half)[] data =               {                  (MathF.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (MathF.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-MathF.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-MathF.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (float.MaxValue' Half.PositiveInfinity)' // Overflow                  (float.MinValue' Half.NegativeInfinity)' // Overflow                  (float.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FC00000)' UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int32BitsToSingle(unchecked((int)0xFFD55555))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FD55555)' UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (float.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-float.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1f' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1f' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0f' UInt16BitsToHalf(0))' // 0                  (-0f' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42f' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42f' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1f' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1f' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5f' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5f' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625f' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625f' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromSingle_TestData,The following statement contains a magic number: (float' Half)[] data =               {                  (MathF.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (MathF.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-MathF.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-MathF.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (float.MaxValue' Half.PositiveInfinity)' // Overflow                  (float.MinValue' Half.NegativeInfinity)' // Overflow                  (float.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FC00000)' UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int32BitsToSingle(unchecked((int)0xFFD55555))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FD55555)' UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (float.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-float.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1f' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1f' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0f' UInt16BitsToHalf(0))' // 0                  (-0f' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42f' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42f' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1f' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1f' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5f' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5f' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625f' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625f' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromSingle_TestData,The following statement contains a magic number: (float' Half)[] data =               {                  (MathF.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (MathF.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-MathF.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-MathF.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (float.MaxValue' Half.PositiveInfinity)' // Overflow                  (float.MinValue' Half.NegativeInfinity)' // Overflow                  (float.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FC00000)' UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int32BitsToSingle(unchecked((int)0xFFD55555))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FD55555)' UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (float.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-float.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1f' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1f' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0f' UInt16BitsToHalf(0))' // 0                  (-0f' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42f' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42f' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1f' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1f' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5f' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5f' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625f' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625f' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromSingle_TestData,The following statement contains a magic number: (float' Half)[] data =               {                  (MathF.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (MathF.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-MathF.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-MathF.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (float.MaxValue' Half.PositiveInfinity)' // Overflow                  (float.MinValue' Half.NegativeInfinity)' // Overflow                  (float.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FC00000)' UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int32BitsToSingle(unchecked((int)0xFFD55555))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FD55555)' UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (float.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-float.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1f' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1f' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0f' UInt16BitsToHalf(0))' // 0                  (-0f' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42f' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42f' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1f' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1f' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5f' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5f' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625f' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625f' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromSingle_TestData,The following statement contains a magic number: (float' Half)[] data =               {                  (MathF.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (MathF.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-MathF.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-MathF.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (float.MaxValue' Half.PositiveInfinity)' // Overflow                  (float.MinValue' Half.NegativeInfinity)' // Overflow                  (float.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FC00000)' UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int32BitsToSingle(unchecked((int)0xFFD55555))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FD55555)' UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (float.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-float.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1f' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1f' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0f' UInt16BitsToHalf(0))' // 0                  (-0f' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42f' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42f' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1f' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1f' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5f' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5f' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625f' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625f' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromSingle_TestData,The following statement contains a magic number: (float' Half)[] data =               {                  (MathF.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (MathF.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-MathF.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-MathF.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (float.MaxValue' Half.PositiveInfinity)' // Overflow                  (float.MinValue' Half.NegativeInfinity)' // Overflow                  (float.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FC00000)' UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int32BitsToSingle(unchecked((int)0xFFD55555))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FD55555)' UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (float.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-float.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1f' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1f' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0f' UInt16BitsToHalf(0))' // 0                  (-0f' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42f' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42f' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1f' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1f' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5f' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5f' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625f' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625f' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromSingle_TestData,The following statement contains a magic number: (float' Half)[] data =               {                  (MathF.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (MathF.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-MathF.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-MathF.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (float.MaxValue' Half.PositiveInfinity)' // Overflow                  (float.MinValue' Half.NegativeInfinity)' // Overflow                  (float.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FC00000)' UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int32BitsToSingle(unchecked((int)0xFFD55555))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int32BitsToSingle(0x7FD55555)' UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (float.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-float.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1f' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1f' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0f' UInt16BitsToHalf(0))' // 0                  (-0f' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42f' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42f' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1f' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1f' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5f' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5f' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625f' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625f' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromDouble_TestData,The following statement contains a magic number: (double' Half)[] data =              {                  (Math.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (Math.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-Math.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-Math.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (double.MaxValue' Half.PositiveInfinity)' // Overflow                  (double.MinValue' Half.NegativeInfinity)' // Overflow                  (double.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FF80000_00000000)'                      UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAAAAA_AAAAAAAA))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FFAAAAA_AAAAAAAA)'                      UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (double.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-double.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1d' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1d' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0d' UInt16BitsToHalf(0))' // 0                  (-0d' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42d' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42d' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1d' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1d' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5d' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5d' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625d' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625d' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromDouble_TestData,The following statement contains a magic number: (double' Half)[] data =              {                  (Math.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (Math.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-Math.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-Math.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (double.MaxValue' Half.PositiveInfinity)' // Overflow                  (double.MinValue' Half.NegativeInfinity)' // Overflow                  (double.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FF80000_00000000)'                      UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAAAAA_AAAAAAAA))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FFAAAAA_AAAAAAAA)'                      UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (double.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-double.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1d' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1d' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0d' UInt16BitsToHalf(0))' // 0                  (-0d' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42d' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42d' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1d' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1d' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5d' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5d' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625d' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625d' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromDouble_TestData,The following statement contains a magic number: (double' Half)[] data =              {                  (Math.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (Math.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-Math.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-Math.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (double.MaxValue' Half.PositiveInfinity)' // Overflow                  (double.MinValue' Half.NegativeInfinity)' // Overflow                  (double.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FF80000_00000000)'                      UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAAAAA_AAAAAAAA))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FFAAAAA_AAAAAAAA)'                      UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (double.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-double.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1d' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1d' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0d' UInt16BitsToHalf(0))' // 0                  (-0d' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42d' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42d' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1d' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1d' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5d' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5d' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625d' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625d' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromDouble_TestData,The following statement contains a magic number: (double' Half)[] data =              {                  (Math.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (Math.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-Math.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-Math.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (double.MaxValue' Half.PositiveInfinity)' // Overflow                  (double.MinValue' Half.NegativeInfinity)' // Overflow                  (double.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FF80000_00000000)'                      UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAAAAA_AAAAAAAA))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FFAAAAA_AAAAAAAA)'                      UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (double.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-double.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1d' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1d' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0d' UInt16BitsToHalf(0))' // 0                  (-0d' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42d' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42d' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1d' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1d' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5d' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5d' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625d' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625d' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromDouble_TestData,The following statement contains a magic number: (double' Half)[] data =              {                  (Math.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (Math.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-Math.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-Math.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (double.MaxValue' Half.PositiveInfinity)' // Overflow                  (double.MinValue' Half.NegativeInfinity)' // Overflow                  (double.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FF80000_00000000)'                      UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAAAAA_AAAAAAAA))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FFAAAAA_AAAAAAAA)'                      UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (double.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-double.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1d' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1d' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0d' UInt16BitsToHalf(0))' // 0                  (-0d' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42d' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42d' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1d' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1d' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5d' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5d' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625d' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625d' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromDouble_TestData,The following statement contains a magic number: (double' Half)[] data =              {                  (Math.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (Math.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-Math.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-Math.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (double.MaxValue' Half.PositiveInfinity)' // Overflow                  (double.MinValue' Half.NegativeInfinity)' // Overflow                  (double.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FF80000_00000000)'                      UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAAAAA_AAAAAAAA))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FFAAAAA_AAAAAAAA)'                      UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (double.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-double.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1d' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1d' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0d' UInt16BitsToHalf(0))' // 0                  (-0d' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42d' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42d' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1d' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1d' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5d' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5d' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625d' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625d' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromDouble_TestData,The following statement contains a magic number: (double' Half)[] data =              {                  (Math.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (Math.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-Math.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-Math.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (double.MaxValue' Half.PositiveInfinity)' // Overflow                  (double.MinValue' Half.NegativeInfinity)' // Overflow                  (double.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FF80000_00000000)'                      UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAAAAA_AAAAAAAA))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FFAAAAA_AAAAAAAA)'                      UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (double.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-double.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1d' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1d' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0d' UInt16BitsToHalf(0))' // 0                  (-0d' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42d' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42d' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1d' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1d' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5d' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5d' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625d' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625d' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_FromDouble_TestData,The following statement contains a magic number: (double' Half)[] data =              {                  (Math.PI' UInt16BitsToHalf(0b0_10000_1001001000))' // 3.140625                  (Math.E' UInt16BitsToHalf(0b0_10000_0101110000))' // 2.71875                  (-Math.PI' UInt16BitsToHalf(0b1_10000_1001001000))' // -3.140625                  (-Math.E' UInt16BitsToHalf(0b1_10000_0101110000))' // -2.71875                  (double.MaxValue' Half.PositiveInfinity)' // Overflow                  (double.MinValue' Half.NegativeInfinity)' // Overflow                  (double.NaN' Half.NaN)' // Quiet Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FF80000_00000000)'                      UInt16BitsToHalf(0b0_11111_1000000000))' // Quiet Positive NaN                  (BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAAAAA_AAAAAAAA))'                      UInt16BitsToHalf(0b1_11111_1010101010))' // Signalling Negative NaN                  (BitConverter.Int64BitsToDouble(0x7FFAAAAA_AAAAAAAA)'                      UInt16BitsToHalf(0b0_11111_1010101010))' // Signalling Positive NaN                  (double.Epsilon' UInt16BitsToHalf(0))' // Underflow                  (-double.Epsilon' UInt16BitsToHalf(0b1_00000_0000000000))' // Underflow                  (1d' UInt16BitsToHalf(0b0_01111_0000000000))' // 1                  (-1d' UInt16BitsToHalf(0b1_01111_0000000000))' // -1                  (0d' UInt16BitsToHalf(0))' // 0                  (-0d' UInt16BitsToHalf(0b1_00000_0000000000))' // -0                  (42d' UInt16BitsToHalf(0b0_10100_0101000000))' // 42                  (-42d' UInt16BitsToHalf(0b1_10100_0101000000))' // -42                  (0.1d' UInt16BitsToHalf(0b0_01011_1001100110))' // 0.0999755859375                  (-0.1d' UInt16BitsToHalf(0b1_01011_1001100110))' // -0.0999755859375                  (1.5d' UInt16BitsToHalf(0b0_01111_1000000000))' // 1.5                  (-1.5d' UInt16BitsToHalf(0b1_01111_1000000000))' // -1.5                  (1.5009765625d' UInt16BitsToHalf(0b0_01111_1000000001))' // 1.5009765625                  (-1.5009765625d' UInt16BitsToHalf(0b1_01111_1000000001))' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt64_TestData,The following statement contains a magic number: (Half Original' long Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1L)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1L)' // -1                  (Half.MaxValue' 65504L)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504L)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0L)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0L)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42L)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42L)' // -42                  (Half.PositiveInfinity' IllegalValueToInt64)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt64)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt64)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt64)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt64)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt64)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0L)' // PosEpsilon -> 0                  (-Half.Epsilon' 0L)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0L)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0L)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3L)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3L)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2L)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2L)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1L)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1L)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1L)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1L)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt64_TestData,The following statement contains a magic number: (Half Original' long Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1L)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1L)' // -1                  (Half.MaxValue' 65504L)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504L)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0L)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0L)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42L)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42L)' // -42                  (Half.PositiveInfinity' IllegalValueToInt64)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt64)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt64)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt64)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt64)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt64)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0L)' // PosEpsilon -> 0                  (-Half.Epsilon' 0L)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0L)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0L)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3L)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3L)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2L)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2L)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1L)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1L)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1L)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1L)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt64_TestData,The following statement contains a magic number: (Half Original' long Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1L)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1L)' // -1                  (Half.MaxValue' 65504L)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504L)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0L)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0L)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42L)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42L)' // -42                  (Half.PositiveInfinity' IllegalValueToInt64)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt64)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt64)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt64)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt64)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt64)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0L)' // PosEpsilon -> 0                  (-Half.Epsilon' 0L)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0L)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0L)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3L)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3L)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2L)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2L)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1L)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1L)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1L)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1L)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt64_TestData,The following statement contains a magic number: (Half Original' long Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1L)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1L)' // -1                  (Half.MaxValue' 65504L)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504L)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0L)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0L)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42L)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42L)' // -42                  (Half.PositiveInfinity' IllegalValueToInt64)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt64)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt64)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt64)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt64)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt64)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0L)' // PosEpsilon -> 0                  (-Half.Epsilon' 0L)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0L)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0L)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3L)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3L)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2L)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2L)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1L)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1L)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1L)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1L)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt64_TestData,The following statement contains a magic number: (Half Original' long Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1L)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1L)' // -1                  (Half.MaxValue' 65504L)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504L)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0L)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0L)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42L)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42L)' // -42                  (Half.PositiveInfinity' IllegalValueToInt64)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt64)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt64)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt64)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt64)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt64)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0L)' // PosEpsilon -> 0                  (-Half.Epsilon' 0L)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0L)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0L)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3L)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3L)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2L)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2L)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1L)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1L)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1L)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1L)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt64_TestData,The following statement contains a magic number: (Half Original' long Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1L)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1L)' // -1                  (Half.MaxValue' 65504L)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504L)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0L)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0L)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42L)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42L)' // -42                  (Half.PositiveInfinity' IllegalValueToInt64)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt64)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt64)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt64)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt64)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt64)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0L)' // PosEpsilon -> 0                  (-Half.Epsilon' 0L)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0L)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0L)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3L)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3L)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2L)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2L)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1L)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1L)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1L)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1L)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt64_TestData,The following statement contains a magic number: (Half Original' long Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1L)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1L)' // -1                  (Half.MaxValue' 65504L)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504L)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0L)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0L)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42L)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42L)' // -42                  (Half.PositiveInfinity' IllegalValueToInt64)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt64)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt64)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt64)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt64)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt64)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0L)' // PosEpsilon -> 0                  (-Half.Epsilon' 0L)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0L)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0L)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3L)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3L)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2L)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2L)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1L)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1L)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1L)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1L)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt64_TestData,The following statement contains a magic number: (Half Original' long Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1L)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1L)' // -1                  (Half.MaxValue' 65504L)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504L)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0L)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0L)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42L)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42L)' // -42                  (Half.PositiveInfinity' IllegalValueToInt64)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt64)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt64)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt64)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt64)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt64)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0L)' // PosEpsilon -> 0                  (-Half.Epsilon' 0L)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0L)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0L)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3L)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3L)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2L)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2L)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1L)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1L)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1L)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1L)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt64_TestData,The following statement contains a magic number: (Half Original' ulong Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' 1UL)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ulong)-1L)' // -1 -> -1 in two's complement                          (Half.MaxValue' 65504UL)' // Half.MaxValue -> 65504                          (Half.MinValue' (ulong)-65504L)' // Half.MinValue -> -65504                          (UInt16BitsToHalf(0b0_01011_1001100110)' 0UL)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' 0UL)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' 42UL)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ulong)-42L)' // -42                          (Half.PositiveInfinity' IllegalValueToUInt64)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt64)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt64)' // Positive Quiet NaN -> Minvalue                          (Half.NaN'                              IllegalValueToUInt64)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt64)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt64)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' 0UL)' // PosEpsilon -> 0                          (-Half.Epsilon' 0UL)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' 0UL)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' 0UL)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' 3UL)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ulong)-3L)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' 2UL)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ulong)-2L)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' 1UL)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ulong)-1L)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' 1UL)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ulong)-1L)' // -1.5009765625 -> -1 in two's complement                      });
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt64_TestData,The following statement contains a magic number: (Half Original' ulong Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' 1UL)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ulong)-1L)' // -1 -> -1 in two's complement                          (Half.MaxValue' 65504UL)' // Half.MaxValue -> 65504                          (Half.MinValue' (ulong)-65504L)' // Half.MinValue -> -65504                          (UInt16BitsToHalf(0b0_01011_1001100110)' 0UL)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' 0UL)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' 42UL)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ulong)-42L)' // -42                          (Half.PositiveInfinity' IllegalValueToUInt64)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt64)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt64)' // Positive Quiet NaN -> Minvalue                          (Half.NaN'                              IllegalValueToUInt64)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt64)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt64)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' 0UL)' // PosEpsilon -> 0                          (-Half.Epsilon' 0UL)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' 0UL)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' 0UL)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' 3UL)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ulong)-3L)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' 2UL)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ulong)-2L)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' 1UL)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ulong)-1L)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' 1UL)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ulong)-1L)' // -1.5009765625 -> -1 in two's complement                      });
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt64_TestData,The following statement contains a magic number: (Half Original' ulong Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' 1UL)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ulong)-1L)' // -1 -> -1 in two's complement                          (Half.MaxValue' 65504UL)' // Half.MaxValue -> 65504                          (Half.MinValue' (ulong)-65504L)' // Half.MinValue -> -65504                          (UInt16BitsToHalf(0b0_01011_1001100110)' 0UL)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' 0UL)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' 42UL)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ulong)-42L)' // -42                          (Half.PositiveInfinity' IllegalValueToUInt64)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt64)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt64)' // Positive Quiet NaN -> Minvalue                          (Half.NaN'                              IllegalValueToUInt64)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt64)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt64)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' 0UL)' // PosEpsilon -> 0                          (-Half.Epsilon' 0UL)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' 0UL)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' 0UL)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' 3UL)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ulong)-3L)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' 2UL)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ulong)-2L)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' 1UL)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ulong)-1L)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' 1UL)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ulong)-1L)' // -1.5009765625 -> -1 in two's complement                      });
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt64_TestData,The following statement contains a magic number: (Half Original' ulong Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' 1UL)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ulong)-1L)' // -1 -> -1 in two's complement                          (Half.MaxValue' 65504UL)' // Half.MaxValue -> 65504                          (Half.MinValue' (ulong)-65504L)' // Half.MinValue -> -65504                          (UInt16BitsToHalf(0b0_01011_1001100110)' 0UL)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' 0UL)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' 42UL)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ulong)-42L)' // -42                          (Half.PositiveInfinity' IllegalValueToUInt64)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt64)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt64)' // Positive Quiet NaN -> Minvalue                          (Half.NaN'                              IllegalValueToUInt64)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt64)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt64)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' 0UL)' // PosEpsilon -> 0                          (-Half.Epsilon' 0UL)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' 0UL)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' 0UL)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' 3UL)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ulong)-3L)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' 2UL)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ulong)-2L)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' 1UL)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ulong)-1L)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' 1UL)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ulong)-1L)' // -1.5009765625 -> -1 in two's complement                      });
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt64_TestData,The following statement contains a magic number: (Half Original' ulong Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' 1UL)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ulong)-1L)' // -1 -> -1 in two's complement                          (Half.MaxValue' 65504UL)' // Half.MaxValue -> 65504                          (Half.MinValue' (ulong)-65504L)' // Half.MinValue -> -65504                          (UInt16BitsToHalf(0b0_01011_1001100110)' 0UL)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' 0UL)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' 42UL)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ulong)-42L)' // -42                          (Half.PositiveInfinity' IllegalValueToUInt64)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt64)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt64)' // Positive Quiet NaN -> Minvalue                          (Half.NaN'                              IllegalValueToUInt64)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt64)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt64)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' 0UL)' // PosEpsilon -> 0                          (-Half.Epsilon' 0UL)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' 0UL)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' 0UL)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' 3UL)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ulong)-3L)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' 2UL)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ulong)-2L)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' 1UL)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ulong)-1L)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' 1UL)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ulong)-1L)' // -1.5009765625 -> -1 in two's complement                      });
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt64_TestData,The following statement contains a magic number: (Half Original' ulong Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' 1UL)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ulong)-1L)' // -1 -> -1 in two's complement                          (Half.MaxValue' 65504UL)' // Half.MaxValue -> 65504                          (Half.MinValue' (ulong)-65504L)' // Half.MinValue -> -65504                          (UInt16BitsToHalf(0b0_01011_1001100110)' 0UL)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' 0UL)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' 42UL)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ulong)-42L)' // -42                          (Half.PositiveInfinity' IllegalValueToUInt64)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt64)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt64)' // Positive Quiet NaN -> Minvalue                          (Half.NaN'                              IllegalValueToUInt64)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt64)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt64)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' 0UL)' // PosEpsilon -> 0                          (-Half.Epsilon' 0UL)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' 0UL)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' 0UL)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' 3UL)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ulong)-3L)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' 2UL)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ulong)-2L)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' 1UL)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ulong)-1L)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' 1UL)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ulong)-1L)' // -1.5009765625 -> -1 in two's complement                      });
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt64_TestData,The following statement contains a magic number: (Half Original' ulong Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' 1UL)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ulong)-1L)' // -1 -> -1 in two's complement                          (Half.MaxValue' 65504UL)' // Half.MaxValue -> 65504                          (Half.MinValue' (ulong)-65504L)' // Half.MinValue -> -65504                          (UInt16BitsToHalf(0b0_01011_1001100110)' 0UL)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' 0UL)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' 42UL)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ulong)-42L)' // -42                          (Half.PositiveInfinity' IllegalValueToUInt64)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt64)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt64)' // Positive Quiet NaN -> Minvalue                          (Half.NaN'                              IllegalValueToUInt64)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt64)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt64)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' 0UL)' // PosEpsilon -> 0                          (-Half.Epsilon' 0UL)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' 0UL)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' 0UL)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' 3UL)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ulong)-3L)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' 2UL)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ulong)-2L)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' 1UL)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ulong)-1L)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' 1UL)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ulong)-1L)' // -1.5009765625 -> -1 in two's complement                      });
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt64_TestData,The following statement contains a magic number: (Half Original' ulong Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' 1UL)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ulong)-1L)' // -1 -> -1 in two's complement                          (Half.MaxValue' 65504UL)' // Half.MaxValue -> 65504                          (Half.MinValue' (ulong)-65504L)' // Half.MinValue -> -65504                          (UInt16BitsToHalf(0b0_01011_1001100110)' 0UL)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' 0UL)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' 42UL)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ulong)-42L)' // -42                          (Half.PositiveInfinity' IllegalValueToUInt64)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt64)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt64)' // Positive Quiet NaN -> Minvalue                          (Half.NaN'                              IllegalValueToUInt64)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt64)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt64)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' 0UL)' // PosEpsilon -> 0                          (-Half.Epsilon' 0UL)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' 0UL)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' 0UL)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' 3UL)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ulong)-3L)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' 2UL)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ulong)-2L)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' 1UL)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ulong)-1L)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' 1UL)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ulong)-1L)' // -1.5009765625 -> -1 in two's complement                      });
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt32_TestData,The following statement contains a magic number: (Half Original' int Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' 65504)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt32)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt32)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt32)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt32)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)'                      IllegalValueToInt32)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)'                      IllegalValueToInt32)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt32_TestData,The following statement contains a magic number: (Half Original' int Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' 65504)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt32)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt32)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt32)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt32)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)'                      IllegalValueToInt32)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)'                      IllegalValueToInt32)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt32_TestData,The following statement contains a magic number: (Half Original' int Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' 65504)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt32)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt32)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt32)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt32)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)'                      IllegalValueToInt32)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)'                      IllegalValueToInt32)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt32_TestData,The following statement contains a magic number: (Half Original' int Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' 65504)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt32)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt32)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt32)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt32)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)'                      IllegalValueToInt32)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)'                      IllegalValueToInt32)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt32_TestData,The following statement contains a magic number: (Half Original' int Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' 65504)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt32)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt32)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt32)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt32)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)'                      IllegalValueToInt32)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)'                      IllegalValueToInt32)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt32_TestData,The following statement contains a magic number: (Half Original' int Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' 65504)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt32)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt32)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt32)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt32)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)'                      IllegalValueToInt32)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)'                      IllegalValueToInt32)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt32_TestData,The following statement contains a magic number: (Half Original' int Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' 65504)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt32)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt32)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt32)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt32)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)'                      IllegalValueToInt32)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)'                      IllegalValueToInt32)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt32_TestData,The following statement contains a magic number: (Half Original' int Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' 65504)' // Half.MaxValue -> 65504                  (Half.MinValue' -65504)' // Half.MinValue -> -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt32)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt32)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt32)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt32)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)'                      IllegalValueToInt32)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)'                      IllegalValueToInt32)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt32_TestData,The following statement contains a magic number: (Half Original' uint Expected)[] data =              unchecked              (                  new []                   {                      (UInt16BitsToHalf(0b0_01111_0000000000)' 1U)' // 1                      (UInt16BitsToHalf(0b1_01111_0000000000)' (uint)-1)' // -1 in two's complement                      (Half.MaxValue' 65504U)' // Half.MaxValue -> 65504                      (Half.MinValue' (uint)-65504)' // Half.MinValue -> -65504 in two's complement                      (UInt16BitsToHalf(0b0_01011_1001100110)' 0U)' // 0.1 -> 0                       (UInt16BitsToHalf(0b1_01011_1001100110)' 0U)' // -0.1 -> 0                      (UInt16BitsToHalf(0b0_10100_0101000000)' 42U)' // 42                      (UInt16BitsToHalf(0b1_10100_0101000000)' (uint)-42)' // -42 in two's complement                      (Half.PositiveInfinity' IllegalValueToUInt32)' // PosInfinity -> MinValue                      (Half.NegativeInfinity' IllegalValueToUInt32)' // NegInfinity -> MinValue                      (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToUInt32)' // Positive Quiet NaN -> Minvalue                      (Half.NaN' IllegalValueToUInt32)' // Negative Quiet NaN -> Minvalue                      (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToUInt32)' // Positive Signalling NaN -> MinValue                      (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToUInt32)' // Negative Signalling NaN -> MinValue                      (Half.Epsilon' 0U)' // PosEpsilon -> 0                      (-Half.Epsilon' 0U)' // NegEpsilon -> 0                      (UInt16BitsToHalf(0)' 0U)' // 0                      (UInt16BitsToHalf(0b1_00000_0000000000)' 0U)' // -0 -> 0                       (UInt16BitsToHalf(0b0_10000_1001001000)' 3U)' // Pi -> 3                      (UInt16BitsToHalf(0b1_10000_1001001000)' (uint)-3)' // -Pi -> -3 in two's complement                      (UInt16BitsToHalf(0b0_10000_0101110000)' 2U)' // E -> 2                      (UInt16BitsToHalf(0b1_10000_0101110000)' (uint)-2)' // -E -> -2 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000000)' 1U)' // 1.5 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000000)' (uint)-1)' // -1.5 -> -1 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000001)' 1U)' // 1.5009765625 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000001)' (uint)-1)' // -1.5009765625 -> -1 in two's complement                  }              );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt32_TestData,The following statement contains a magic number: (Half Original' uint Expected)[] data =              unchecked              (                  new []                   {                      (UInt16BitsToHalf(0b0_01111_0000000000)' 1U)' // 1                      (UInt16BitsToHalf(0b1_01111_0000000000)' (uint)-1)' // -1 in two's complement                      (Half.MaxValue' 65504U)' // Half.MaxValue -> 65504                      (Half.MinValue' (uint)-65504)' // Half.MinValue -> -65504 in two's complement                      (UInt16BitsToHalf(0b0_01011_1001100110)' 0U)' // 0.1 -> 0                       (UInt16BitsToHalf(0b1_01011_1001100110)' 0U)' // -0.1 -> 0                      (UInt16BitsToHalf(0b0_10100_0101000000)' 42U)' // 42                      (UInt16BitsToHalf(0b1_10100_0101000000)' (uint)-42)' // -42 in two's complement                      (Half.PositiveInfinity' IllegalValueToUInt32)' // PosInfinity -> MinValue                      (Half.NegativeInfinity' IllegalValueToUInt32)' // NegInfinity -> MinValue                      (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToUInt32)' // Positive Quiet NaN -> Minvalue                      (Half.NaN' IllegalValueToUInt32)' // Negative Quiet NaN -> Minvalue                      (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToUInt32)' // Positive Signalling NaN -> MinValue                      (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToUInt32)' // Negative Signalling NaN -> MinValue                      (Half.Epsilon' 0U)' // PosEpsilon -> 0                      (-Half.Epsilon' 0U)' // NegEpsilon -> 0                      (UInt16BitsToHalf(0)' 0U)' // 0                      (UInt16BitsToHalf(0b1_00000_0000000000)' 0U)' // -0 -> 0                       (UInt16BitsToHalf(0b0_10000_1001001000)' 3U)' // Pi -> 3                      (UInt16BitsToHalf(0b1_10000_1001001000)' (uint)-3)' // -Pi -> -3 in two's complement                      (UInt16BitsToHalf(0b0_10000_0101110000)' 2U)' // E -> 2                      (UInt16BitsToHalf(0b1_10000_0101110000)' (uint)-2)' // -E -> -2 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000000)' 1U)' // 1.5 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000000)' (uint)-1)' // -1.5 -> -1 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000001)' 1U)' // 1.5009765625 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000001)' (uint)-1)' // -1.5009765625 -> -1 in two's complement                  }              );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt32_TestData,The following statement contains a magic number: (Half Original' uint Expected)[] data =              unchecked              (                  new []                   {                      (UInt16BitsToHalf(0b0_01111_0000000000)' 1U)' // 1                      (UInt16BitsToHalf(0b1_01111_0000000000)' (uint)-1)' // -1 in two's complement                      (Half.MaxValue' 65504U)' // Half.MaxValue -> 65504                      (Half.MinValue' (uint)-65504)' // Half.MinValue -> -65504 in two's complement                      (UInt16BitsToHalf(0b0_01011_1001100110)' 0U)' // 0.1 -> 0                       (UInt16BitsToHalf(0b1_01011_1001100110)' 0U)' // -0.1 -> 0                      (UInt16BitsToHalf(0b0_10100_0101000000)' 42U)' // 42                      (UInt16BitsToHalf(0b1_10100_0101000000)' (uint)-42)' // -42 in two's complement                      (Half.PositiveInfinity' IllegalValueToUInt32)' // PosInfinity -> MinValue                      (Half.NegativeInfinity' IllegalValueToUInt32)' // NegInfinity -> MinValue                      (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToUInt32)' // Positive Quiet NaN -> Minvalue                      (Half.NaN' IllegalValueToUInt32)' // Negative Quiet NaN -> Minvalue                      (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToUInt32)' // Positive Signalling NaN -> MinValue                      (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToUInt32)' // Negative Signalling NaN -> MinValue                      (Half.Epsilon' 0U)' // PosEpsilon -> 0                      (-Half.Epsilon' 0U)' // NegEpsilon -> 0                      (UInt16BitsToHalf(0)' 0U)' // 0                      (UInt16BitsToHalf(0b1_00000_0000000000)' 0U)' // -0 -> 0                       (UInt16BitsToHalf(0b0_10000_1001001000)' 3U)' // Pi -> 3                      (UInt16BitsToHalf(0b1_10000_1001001000)' (uint)-3)' // -Pi -> -3 in two's complement                      (UInt16BitsToHalf(0b0_10000_0101110000)' 2U)' // E -> 2                      (UInt16BitsToHalf(0b1_10000_0101110000)' (uint)-2)' // -E -> -2 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000000)' 1U)' // 1.5 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000000)' (uint)-1)' // -1.5 -> -1 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000001)' 1U)' // 1.5009765625 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000001)' (uint)-1)' // -1.5009765625 -> -1 in two's complement                  }              );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt32_TestData,The following statement contains a magic number: (Half Original' uint Expected)[] data =              unchecked              (                  new []                   {                      (UInt16BitsToHalf(0b0_01111_0000000000)' 1U)' // 1                      (UInt16BitsToHalf(0b1_01111_0000000000)' (uint)-1)' // -1 in two's complement                      (Half.MaxValue' 65504U)' // Half.MaxValue -> 65504                      (Half.MinValue' (uint)-65504)' // Half.MinValue -> -65504 in two's complement                      (UInt16BitsToHalf(0b0_01011_1001100110)' 0U)' // 0.1 -> 0                       (UInt16BitsToHalf(0b1_01011_1001100110)' 0U)' // -0.1 -> 0                      (UInt16BitsToHalf(0b0_10100_0101000000)' 42U)' // 42                      (UInt16BitsToHalf(0b1_10100_0101000000)' (uint)-42)' // -42 in two's complement                      (Half.PositiveInfinity' IllegalValueToUInt32)' // PosInfinity -> MinValue                      (Half.NegativeInfinity' IllegalValueToUInt32)' // NegInfinity -> MinValue                      (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToUInt32)' // Positive Quiet NaN -> Minvalue                      (Half.NaN' IllegalValueToUInt32)' // Negative Quiet NaN -> Minvalue                      (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToUInt32)' // Positive Signalling NaN -> MinValue                      (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToUInt32)' // Negative Signalling NaN -> MinValue                      (Half.Epsilon' 0U)' // PosEpsilon -> 0                      (-Half.Epsilon' 0U)' // NegEpsilon -> 0                      (UInt16BitsToHalf(0)' 0U)' // 0                      (UInt16BitsToHalf(0b1_00000_0000000000)' 0U)' // -0 -> 0                       (UInt16BitsToHalf(0b0_10000_1001001000)' 3U)' // Pi -> 3                      (UInt16BitsToHalf(0b1_10000_1001001000)' (uint)-3)' // -Pi -> -3 in two's complement                      (UInt16BitsToHalf(0b0_10000_0101110000)' 2U)' // E -> 2                      (UInt16BitsToHalf(0b1_10000_0101110000)' (uint)-2)' // -E -> -2 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000000)' 1U)' // 1.5 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000000)' (uint)-1)' // -1.5 -> -1 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000001)' 1U)' // 1.5009765625 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000001)' (uint)-1)' // -1.5009765625 -> -1 in two's complement                  }              );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt32_TestData,The following statement contains a magic number: (Half Original' uint Expected)[] data =              unchecked              (                  new []                   {                      (UInt16BitsToHalf(0b0_01111_0000000000)' 1U)' // 1                      (UInt16BitsToHalf(0b1_01111_0000000000)' (uint)-1)' // -1 in two's complement                      (Half.MaxValue' 65504U)' // Half.MaxValue -> 65504                      (Half.MinValue' (uint)-65504)' // Half.MinValue -> -65504 in two's complement                      (UInt16BitsToHalf(0b0_01011_1001100110)' 0U)' // 0.1 -> 0                       (UInt16BitsToHalf(0b1_01011_1001100110)' 0U)' // -0.1 -> 0                      (UInt16BitsToHalf(0b0_10100_0101000000)' 42U)' // 42                      (UInt16BitsToHalf(0b1_10100_0101000000)' (uint)-42)' // -42 in two's complement                      (Half.PositiveInfinity' IllegalValueToUInt32)' // PosInfinity -> MinValue                      (Half.NegativeInfinity' IllegalValueToUInt32)' // NegInfinity -> MinValue                      (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToUInt32)' // Positive Quiet NaN -> Minvalue                      (Half.NaN' IllegalValueToUInt32)' // Negative Quiet NaN -> Minvalue                      (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToUInt32)' // Positive Signalling NaN -> MinValue                      (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToUInt32)' // Negative Signalling NaN -> MinValue                      (Half.Epsilon' 0U)' // PosEpsilon -> 0                      (-Half.Epsilon' 0U)' // NegEpsilon -> 0                      (UInt16BitsToHalf(0)' 0U)' // 0                      (UInt16BitsToHalf(0b1_00000_0000000000)' 0U)' // -0 -> 0                       (UInt16BitsToHalf(0b0_10000_1001001000)' 3U)' // Pi -> 3                      (UInt16BitsToHalf(0b1_10000_1001001000)' (uint)-3)' // -Pi -> -3 in two's complement                      (UInt16BitsToHalf(0b0_10000_0101110000)' 2U)' // E -> 2                      (UInt16BitsToHalf(0b1_10000_0101110000)' (uint)-2)' // -E -> -2 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000000)' 1U)' // 1.5 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000000)' (uint)-1)' // -1.5 -> -1 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000001)' 1U)' // 1.5009765625 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000001)' (uint)-1)' // -1.5009765625 -> -1 in two's complement                  }              );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt32_TestData,The following statement contains a magic number: (Half Original' uint Expected)[] data =              unchecked              (                  new []                   {                      (UInt16BitsToHalf(0b0_01111_0000000000)' 1U)' // 1                      (UInt16BitsToHalf(0b1_01111_0000000000)' (uint)-1)' // -1 in two's complement                      (Half.MaxValue' 65504U)' // Half.MaxValue -> 65504                      (Half.MinValue' (uint)-65504)' // Half.MinValue -> -65504 in two's complement                      (UInt16BitsToHalf(0b0_01011_1001100110)' 0U)' // 0.1 -> 0                       (UInt16BitsToHalf(0b1_01011_1001100110)' 0U)' // -0.1 -> 0                      (UInt16BitsToHalf(0b0_10100_0101000000)' 42U)' // 42                      (UInt16BitsToHalf(0b1_10100_0101000000)' (uint)-42)' // -42 in two's complement                      (Half.PositiveInfinity' IllegalValueToUInt32)' // PosInfinity -> MinValue                      (Half.NegativeInfinity' IllegalValueToUInt32)' // NegInfinity -> MinValue                      (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToUInt32)' // Positive Quiet NaN -> Minvalue                      (Half.NaN' IllegalValueToUInt32)' // Negative Quiet NaN -> Minvalue                      (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToUInt32)' // Positive Signalling NaN -> MinValue                      (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToUInt32)' // Negative Signalling NaN -> MinValue                      (Half.Epsilon' 0U)' // PosEpsilon -> 0                      (-Half.Epsilon' 0U)' // NegEpsilon -> 0                      (UInt16BitsToHalf(0)' 0U)' // 0                      (UInt16BitsToHalf(0b1_00000_0000000000)' 0U)' // -0 -> 0                       (UInt16BitsToHalf(0b0_10000_1001001000)' 3U)' // Pi -> 3                      (UInt16BitsToHalf(0b1_10000_1001001000)' (uint)-3)' // -Pi -> -3 in two's complement                      (UInt16BitsToHalf(0b0_10000_0101110000)' 2U)' // E -> 2                      (UInt16BitsToHalf(0b1_10000_0101110000)' (uint)-2)' // -E -> -2 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000000)' 1U)' // 1.5 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000000)' (uint)-1)' // -1.5 -> -1 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000001)' 1U)' // 1.5009765625 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000001)' (uint)-1)' // -1.5009765625 -> -1 in two's complement                  }              );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt32_TestData,The following statement contains a magic number: (Half Original' uint Expected)[] data =              unchecked              (                  new []                   {                      (UInt16BitsToHalf(0b0_01111_0000000000)' 1U)' // 1                      (UInt16BitsToHalf(0b1_01111_0000000000)' (uint)-1)' // -1 in two's complement                      (Half.MaxValue' 65504U)' // Half.MaxValue -> 65504                      (Half.MinValue' (uint)-65504)' // Half.MinValue -> -65504 in two's complement                      (UInt16BitsToHalf(0b0_01011_1001100110)' 0U)' // 0.1 -> 0                       (UInt16BitsToHalf(0b1_01011_1001100110)' 0U)' // -0.1 -> 0                      (UInt16BitsToHalf(0b0_10100_0101000000)' 42U)' // 42                      (UInt16BitsToHalf(0b1_10100_0101000000)' (uint)-42)' // -42 in two's complement                      (Half.PositiveInfinity' IllegalValueToUInt32)' // PosInfinity -> MinValue                      (Half.NegativeInfinity' IllegalValueToUInt32)' // NegInfinity -> MinValue                      (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToUInt32)' // Positive Quiet NaN -> Minvalue                      (Half.NaN' IllegalValueToUInt32)' // Negative Quiet NaN -> Minvalue                      (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToUInt32)' // Positive Signalling NaN -> MinValue                      (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToUInt32)' // Negative Signalling NaN -> MinValue                      (Half.Epsilon' 0U)' // PosEpsilon -> 0                      (-Half.Epsilon' 0U)' // NegEpsilon -> 0                      (UInt16BitsToHalf(0)' 0U)' // 0                      (UInt16BitsToHalf(0b1_00000_0000000000)' 0U)' // -0 -> 0                       (UInt16BitsToHalf(0b0_10000_1001001000)' 3U)' // Pi -> 3                      (UInt16BitsToHalf(0b1_10000_1001001000)' (uint)-3)' // -Pi -> -3 in two's complement                      (UInt16BitsToHalf(0b0_10000_0101110000)' 2U)' // E -> 2                      (UInt16BitsToHalf(0b1_10000_0101110000)' (uint)-2)' // -E -> -2 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000000)' 1U)' // 1.5 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000000)' (uint)-1)' // -1.5 -> -1 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000001)' 1U)' // 1.5009765625 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000001)' (uint)-1)' // -1.5009765625 -> -1 in two's complement                  }              );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt32_TestData,The following statement contains a magic number: (Half Original' uint Expected)[] data =              unchecked              (                  new []                   {                      (UInt16BitsToHalf(0b0_01111_0000000000)' 1U)' // 1                      (UInt16BitsToHalf(0b1_01111_0000000000)' (uint)-1)' // -1 in two's complement                      (Half.MaxValue' 65504U)' // Half.MaxValue -> 65504                      (Half.MinValue' (uint)-65504)' // Half.MinValue -> -65504 in two's complement                      (UInt16BitsToHalf(0b0_01011_1001100110)' 0U)' // 0.1 -> 0                       (UInt16BitsToHalf(0b1_01011_1001100110)' 0U)' // -0.1 -> 0                      (UInt16BitsToHalf(0b0_10100_0101000000)' 42U)' // 42                      (UInt16BitsToHalf(0b1_10100_0101000000)' (uint)-42)' // -42 in two's complement                      (Half.PositiveInfinity' IllegalValueToUInt32)' // PosInfinity -> MinValue                      (Half.NegativeInfinity' IllegalValueToUInt32)' // NegInfinity -> MinValue                      (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToUInt32)' // Positive Quiet NaN -> Minvalue                      (Half.NaN' IllegalValueToUInt32)' // Negative Quiet NaN -> Minvalue                      (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToUInt32)' // Positive Signalling NaN -> MinValue                      (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToUInt32)' // Negative Signalling NaN -> MinValue                      (Half.Epsilon' 0U)' // PosEpsilon -> 0                      (-Half.Epsilon' 0U)' // NegEpsilon -> 0                      (UInt16BitsToHalf(0)' 0U)' // 0                      (UInt16BitsToHalf(0b1_00000_0000000000)' 0U)' // -0 -> 0                       (UInt16BitsToHalf(0b0_10000_1001001000)' 3U)' // Pi -> 3                      (UInt16BitsToHalf(0b1_10000_1001001000)' (uint)-3)' // -Pi -> -3 in two's complement                      (UInt16BitsToHalf(0b0_10000_0101110000)' 2U)' // E -> 2                      (UInt16BitsToHalf(0b1_10000_0101110000)' (uint)-2)' // -E -> -2 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000000)' 1U)' // 1.5 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000000)' (uint)-1)' // -1.5 -> -1 in two's complement                      (UInt16BitsToHalf(0b0_01111_1000000001)' 1U)' // 1.5009765625 -> 1                      (UInt16BitsToHalf(0b1_01111_1000000001)' (uint)-1)' // -1.5009765625 -> -1 in two's complement                  }              );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt16_TestData,The following statement contains a magic number: (Half Original' short Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((short)(65504 & 0xFFFF)))' // Half.MaxValue -> -32' 65504 bitmasked                  (Half.MinValue' -65504 & 0xFFFF)' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt16)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt16)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt16)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt16)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt16)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt16)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1) // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt16_TestData,The following statement contains a magic number: (Half Original' short Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((short)(65504 & 0xFFFF)))' // Half.MaxValue -> -32' 65504 bitmasked                  (Half.MinValue' -65504 & 0xFFFF)' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt16)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt16)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt16)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt16)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt16)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt16)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1) // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt16_TestData,The following statement contains a magic number: (Half Original' short Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((short)(65504 & 0xFFFF)))' // Half.MaxValue -> -32' 65504 bitmasked                  (Half.MinValue' -65504 & 0xFFFF)' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt16)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt16)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt16)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt16)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt16)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt16)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1) // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt16_TestData,The following statement contains a magic number: (Half Original' short Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((short)(65504 & 0xFFFF)))' // Half.MaxValue -> -32' 65504 bitmasked                  (Half.MinValue' -65504 & 0xFFFF)' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt16)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt16)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt16)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt16)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt16)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt16)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1) // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt16_TestData,The following statement contains a magic number: (Half Original' short Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((short)(65504 & 0xFFFF)))' // Half.MaxValue -> -32' 65504 bitmasked                  (Half.MinValue' -65504 & 0xFFFF)' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt16)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt16)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt16)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt16)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt16)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt16)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1) // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt16_TestData,The following statement contains a magic number: (Half Original' short Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((short)(65504 & 0xFFFF)))' // Half.MaxValue -> -32' 65504 bitmasked                  (Half.MinValue' -65504 & 0xFFFF)' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt16)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt16)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt16)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt16)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt16)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt16)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1) // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt16_TestData,The following statement contains a magic number: (Half Original' short Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((short)(65504 & 0xFFFF)))' // Half.MaxValue -> -32' 65504 bitmasked                  (Half.MinValue' -65504 & 0xFFFF)' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt16)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt16)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt16)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt16)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt16)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt16)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1) // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToInt16_TestData,The following statement contains a magic number: (Half Original' short Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((short)(65504 & 0xFFFF)))' // Half.MaxValue -> -32' 65504 bitmasked                  (Half.MinValue' -65504 & 0xFFFF)' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToInt16)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToInt16)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToInt16)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToInt16)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToInt16)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToInt16)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1) // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt16_TestData,The following statement contains a magic number: (Half Original' ushort Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (ushort)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ushort)-1)' // -1 in two's complement                          (Half.MaxValue' (ushort)65504)' // Half.MaxValue -> 65504                          (Half.MinValue' (ushort)(-65504 & 0xFFFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (ushort)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (ushort)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (ushort)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ushort)-42)' // -42 in two's complement                          (Half.PositiveInfinity' IllegalValueToUInt16)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt16)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt16)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToUInt16)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt16)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt16)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (ushort)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (ushort)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (ushort)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (ushort)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (ushort)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ushort)-3)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' (ushort)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ushort)-2)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' (ushort)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ushort)-1)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' (ushort)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ushort)-1)' // -1.5009765625 -> -1 in two's complement                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt16_TestData,The following statement contains a magic number: (Half Original' ushort Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (ushort)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ushort)-1)' // -1 in two's complement                          (Half.MaxValue' (ushort)65504)' // Half.MaxValue -> 65504                          (Half.MinValue' (ushort)(-65504 & 0xFFFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (ushort)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (ushort)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (ushort)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ushort)-42)' // -42 in two's complement                          (Half.PositiveInfinity' IllegalValueToUInt16)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt16)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt16)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToUInt16)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt16)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt16)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (ushort)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (ushort)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (ushort)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (ushort)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (ushort)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ushort)-3)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' (ushort)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ushort)-2)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' (ushort)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ushort)-1)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' (ushort)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ushort)-1)' // -1.5009765625 -> -1 in two's complement                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt16_TestData,The following statement contains a magic number: (Half Original' ushort Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (ushort)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ushort)-1)' // -1 in two's complement                          (Half.MaxValue' (ushort)65504)' // Half.MaxValue -> 65504                          (Half.MinValue' (ushort)(-65504 & 0xFFFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (ushort)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (ushort)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (ushort)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ushort)-42)' // -42 in two's complement                          (Half.PositiveInfinity' IllegalValueToUInt16)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt16)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt16)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToUInt16)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt16)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt16)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (ushort)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (ushort)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (ushort)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (ushort)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (ushort)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ushort)-3)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' (ushort)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ushort)-2)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' (ushort)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ushort)-1)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' (ushort)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ushort)-1)' // -1.5009765625 -> -1 in two's complement                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt16_TestData,The following statement contains a magic number: (Half Original' ushort Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (ushort)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ushort)-1)' // -1 in two's complement                          (Half.MaxValue' (ushort)65504)' // Half.MaxValue -> 65504                          (Half.MinValue' (ushort)(-65504 & 0xFFFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (ushort)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (ushort)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (ushort)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ushort)-42)' // -42 in two's complement                          (Half.PositiveInfinity' IllegalValueToUInt16)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt16)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt16)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToUInt16)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt16)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt16)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (ushort)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (ushort)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (ushort)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (ushort)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (ushort)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ushort)-3)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' (ushort)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ushort)-2)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' (ushort)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ushort)-1)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' (ushort)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ushort)-1)' // -1.5009765625 -> -1 in two's complement                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt16_TestData,The following statement contains a magic number: (Half Original' ushort Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (ushort)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ushort)-1)' // -1 in two's complement                          (Half.MaxValue' (ushort)65504)' // Half.MaxValue -> 65504                          (Half.MinValue' (ushort)(-65504 & 0xFFFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (ushort)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (ushort)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (ushort)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ushort)-42)' // -42 in two's complement                          (Half.PositiveInfinity' IllegalValueToUInt16)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt16)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt16)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToUInt16)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt16)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt16)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (ushort)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (ushort)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (ushort)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (ushort)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (ushort)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ushort)-3)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' (ushort)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ushort)-2)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' (ushort)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ushort)-1)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' (ushort)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ushort)-1)' // -1.5009765625 -> -1 in two's complement                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt16_TestData,The following statement contains a magic number: (Half Original' ushort Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (ushort)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ushort)-1)' // -1 in two's complement                          (Half.MaxValue' (ushort)65504)' // Half.MaxValue -> 65504                          (Half.MinValue' (ushort)(-65504 & 0xFFFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (ushort)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (ushort)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (ushort)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ushort)-42)' // -42 in two's complement                          (Half.PositiveInfinity' IllegalValueToUInt16)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt16)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt16)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToUInt16)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt16)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt16)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (ushort)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (ushort)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (ushort)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (ushort)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (ushort)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ushort)-3)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' (ushort)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ushort)-2)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' (ushort)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ushort)-1)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' (ushort)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ushort)-1)' // -1.5009765625 -> -1 in two's complement                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt16_TestData,The following statement contains a magic number: (Half Original' ushort Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (ushort)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ushort)-1)' // -1 in two's complement                          (Half.MaxValue' (ushort)65504)' // Half.MaxValue -> 65504                          (Half.MinValue' (ushort)(-65504 & 0xFFFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (ushort)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (ushort)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (ushort)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ushort)-42)' // -42 in two's complement                          (Half.PositiveInfinity' IllegalValueToUInt16)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt16)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt16)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToUInt16)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt16)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt16)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (ushort)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (ushort)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (ushort)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (ushort)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (ushort)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ushort)-3)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' (ushort)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ushort)-2)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' (ushort)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ushort)-1)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' (ushort)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ushort)-1)' // -1.5009765625 -> -1 in two's complement                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToUInt16_TestData,The following statement contains a magic number: (Half Original' ushort Expected)[] data =                  unchecked                  (                      new []                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (ushort)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (ushort)-1)' // -1 in two's complement                          (Half.MaxValue' (ushort)65504)' // Half.MaxValue -> 65504                          (Half.MinValue' (ushort)(-65504 & 0xFFFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (ushort)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (ushort)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (ushort)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (ushort)-42)' // -42 in two's complement                          (Half.PositiveInfinity' IllegalValueToUInt16)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToUInt16)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)'                              IllegalValueToUInt16)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToUInt16)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToUInt16)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToUInt16)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (ushort)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (ushort)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (ushort)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (ushort)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (ushort)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (ushort)-3)' // -Pi -> -3 in two's complement                          (UInt16BitsToHalf(0b0_10000_0101110000)' (ushort)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (ushort)-2)' // -E -> -2 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000000)' (ushort)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (ushort)-1)' // -1.5 -> -1 in two's complement                          (UInt16BitsToHalf(0b0_01111_1000000001)' (ushort)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (ushort)-1)' // -1.5009765625 -> -1 in two's complement                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToByte_TestData,The following statement contains a magic number: (Half Original' byte Expected)[] data =                  unchecked                  (                      new[]                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (byte)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (byte)-1)' // -1                          (Half.MaxValue' (byte)(65504 & 0xFF))' // Half.MaxValue -> 224' 65504 bitmasked                          (Half.MinValue' (byte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (byte)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (byte)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (byte)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (byte)-42)' // -42                          (Half.PositiveInfinity' IllegalValueToByte)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToByte)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToByte)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToByte)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToByte)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToByte)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (byte)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (byte)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (byte)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (byte)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (byte)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (byte)-3)' // -Pi -> -3                          (UInt16BitsToHalf(0b0_10000_0101110000)' (byte)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (byte)-2)' // -E -> -2                          (UInt16BitsToHalf(0b0_01111_1000000000)' (byte)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (byte)-1)' // -1.5 -> -1                          (UInt16BitsToHalf(0b0_01111_1000000001)' (byte)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (byte)-1)' // -1.5009765625 -> -1                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToByte_TestData,The following statement contains a magic number: (Half Original' byte Expected)[] data =                  unchecked                  (                      new[]                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (byte)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (byte)-1)' // -1                          (Half.MaxValue' (byte)(65504 & 0xFF))' // Half.MaxValue -> 224' 65504 bitmasked                          (Half.MinValue' (byte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (byte)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (byte)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (byte)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (byte)-42)' // -42                          (Half.PositiveInfinity' IllegalValueToByte)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToByte)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToByte)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToByte)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToByte)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToByte)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (byte)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (byte)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (byte)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (byte)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (byte)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (byte)-3)' // -Pi -> -3                          (UInt16BitsToHalf(0b0_10000_0101110000)' (byte)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (byte)-2)' // -E -> -2                          (UInt16BitsToHalf(0b0_01111_1000000000)' (byte)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (byte)-1)' // -1.5 -> -1                          (UInt16BitsToHalf(0b0_01111_1000000001)' (byte)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (byte)-1)' // -1.5009765625 -> -1                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToByte_TestData,The following statement contains a magic number: (Half Original' byte Expected)[] data =                  unchecked                  (                      new[]                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (byte)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (byte)-1)' // -1                          (Half.MaxValue' (byte)(65504 & 0xFF))' // Half.MaxValue -> 224' 65504 bitmasked                          (Half.MinValue' (byte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (byte)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (byte)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (byte)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (byte)-42)' // -42                          (Half.PositiveInfinity' IllegalValueToByte)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToByte)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToByte)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToByte)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToByte)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToByte)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (byte)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (byte)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (byte)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (byte)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (byte)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (byte)-3)' // -Pi -> -3                          (UInt16BitsToHalf(0b0_10000_0101110000)' (byte)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (byte)-2)' // -E -> -2                          (UInt16BitsToHalf(0b0_01111_1000000000)' (byte)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (byte)-1)' // -1.5 -> -1                          (UInt16BitsToHalf(0b0_01111_1000000001)' (byte)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (byte)-1)' // -1.5009765625 -> -1                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToByte_TestData,The following statement contains a magic number: (Half Original' byte Expected)[] data =                  unchecked                  (                      new[]                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (byte)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (byte)-1)' // -1                          (Half.MaxValue' (byte)(65504 & 0xFF))' // Half.MaxValue -> 224' 65504 bitmasked                          (Half.MinValue' (byte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (byte)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (byte)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (byte)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (byte)-42)' // -42                          (Half.PositiveInfinity' IllegalValueToByte)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToByte)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToByte)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToByte)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToByte)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToByte)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (byte)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (byte)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (byte)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (byte)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (byte)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (byte)-3)' // -Pi -> -3                          (UInt16BitsToHalf(0b0_10000_0101110000)' (byte)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (byte)-2)' // -E -> -2                          (UInt16BitsToHalf(0b0_01111_1000000000)' (byte)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (byte)-1)' // -1.5 -> -1                          (UInt16BitsToHalf(0b0_01111_1000000001)' (byte)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (byte)-1)' // -1.5009765625 -> -1                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToByte_TestData,The following statement contains a magic number: (Half Original' byte Expected)[] data =                  unchecked                  (                      new[]                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (byte)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (byte)-1)' // -1                          (Half.MaxValue' (byte)(65504 & 0xFF))' // Half.MaxValue -> 224' 65504 bitmasked                          (Half.MinValue' (byte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (byte)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (byte)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (byte)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (byte)-42)' // -42                          (Half.PositiveInfinity' IllegalValueToByte)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToByte)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToByte)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToByte)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToByte)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToByte)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (byte)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (byte)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (byte)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (byte)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (byte)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (byte)-3)' // -Pi -> -3                          (UInt16BitsToHalf(0b0_10000_0101110000)' (byte)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (byte)-2)' // -E -> -2                          (UInt16BitsToHalf(0b0_01111_1000000000)' (byte)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (byte)-1)' // -1.5 -> -1                          (UInt16BitsToHalf(0b0_01111_1000000001)' (byte)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (byte)-1)' // -1.5009765625 -> -1                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToByte_TestData,The following statement contains a magic number: (Half Original' byte Expected)[] data =                  unchecked                  (                      new[]                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (byte)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (byte)-1)' // -1                          (Half.MaxValue' (byte)(65504 & 0xFF))' // Half.MaxValue -> 224' 65504 bitmasked                          (Half.MinValue' (byte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (byte)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (byte)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (byte)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (byte)-42)' // -42                          (Half.PositiveInfinity' IllegalValueToByte)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToByte)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToByte)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToByte)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToByte)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToByte)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (byte)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (byte)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (byte)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (byte)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (byte)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (byte)-3)' // -Pi -> -3                          (UInt16BitsToHalf(0b0_10000_0101110000)' (byte)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (byte)-2)' // -E -> -2                          (UInt16BitsToHalf(0b0_01111_1000000000)' (byte)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (byte)-1)' // -1.5 -> -1                          (UInt16BitsToHalf(0b0_01111_1000000001)' (byte)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (byte)-1)' // -1.5009765625 -> -1                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToByte_TestData,The following statement contains a magic number: (Half Original' byte Expected)[] data =                  unchecked                  (                      new[]                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (byte)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (byte)-1)' // -1                          (Half.MaxValue' (byte)(65504 & 0xFF))' // Half.MaxValue -> 224' 65504 bitmasked                          (Half.MinValue' (byte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (byte)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (byte)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (byte)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (byte)-42)' // -42                          (Half.PositiveInfinity' IllegalValueToByte)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToByte)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToByte)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToByte)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToByte)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToByte)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (byte)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (byte)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (byte)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (byte)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (byte)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (byte)-3)' // -Pi -> -3                          (UInt16BitsToHalf(0b0_10000_0101110000)' (byte)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (byte)-2)' // -E -> -2                          (UInt16BitsToHalf(0b0_01111_1000000000)' (byte)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (byte)-1)' // -1.5 -> -1                          (UInt16BitsToHalf(0b0_01111_1000000001)' (byte)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (byte)-1)' // -1.5009765625 -> -1                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToByte_TestData,The following statement contains a magic number: (Half Original' byte Expected)[] data =                  unchecked                  (                      new[]                      {                          (UInt16BitsToHalf(0b0_01111_0000000000)' (byte)1)' // 1                          (UInt16BitsToHalf(0b1_01111_0000000000)' (byte)-1)' // -1                          (Half.MaxValue' (byte)(65504 & 0xFF))' // Half.MaxValue -> 224' 65504 bitmasked                          (Half.MinValue' (byte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                          (UInt16BitsToHalf(0b0_01011_1001100110)' (byte)0)' // 0.1 -> 0                           (UInt16BitsToHalf(0b1_01011_1001100110)' (byte)0)' // -0.1 -> 0                          (UInt16BitsToHalf(0b0_10100_0101000000)' (byte)42)' // 42                          (UInt16BitsToHalf(0b1_10100_0101000000)' (byte)-42)' // -42                          (Half.PositiveInfinity' IllegalValueToByte)' // PosInfinity -> MinValue                          (Half.NegativeInfinity' IllegalValueToByte)' // NegInfinity -> MinValue                          (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToByte)' // Positive Quiet NaN -> Minvalue                          (Half.NaN' IllegalValueToByte)' // Negative Quiet NaN -> Minvalue                          (UInt16BitsToHalf(0b0_11111_1010101010)'                              IllegalValueToByte)' // Positive Signalling NaN -> MinValue                          (UInt16BitsToHalf(0b1_11111_1010101010)'                              IllegalValueToByte)' // Negative Signalling NaN -> MinValue                          (Half.Epsilon' (byte)0)' // PosEpsilon -> 0                          (-Half.Epsilon' (byte)0)' // NegEpsilon -> 0                          (UInt16BitsToHalf(0)' (byte)0)' // 0                          (UInt16BitsToHalf(0b1_00000_0000000000)' (byte)0)' // -0 -> 0                           (UInt16BitsToHalf(0b0_10000_1001001000)' (byte)3)' // Pi -> 3                          (UInt16BitsToHalf(0b1_10000_1001001000)' (byte)-3)' // -Pi -> -3                          (UInt16BitsToHalf(0b0_10000_0101110000)' (byte)2)' // E -> 2                          (UInt16BitsToHalf(0b1_10000_0101110000)' (byte)-2)' // -E -> -2                          (UInt16BitsToHalf(0b0_01111_1000000000)' (byte)1)' // 1.5 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000000)' (byte)-1)' // -1.5 -> -1                          (UInt16BitsToHalf(0b0_01111_1000000001)' (byte)1)' // 1.5009765625 -> 1                          (UInt16BitsToHalf(0b1_01111_1000000001)' (byte)-1)' // -1.5009765625 -> -1                      }                  );
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToSByte_TestData,The following statement contains a magic number: (Half Original' sbyte Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((sbyte)(65504 & 0xFF)))' // Half.MaxValue -> -32' -65504 bitmasked                  (Half.MinValue' (sbyte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToSByte)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToSByte)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToSByte)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToSByte)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToSByte)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToSByte)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToSByte_TestData,The following statement contains a magic number: (Half Original' sbyte Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((sbyte)(65504 & 0xFF)))' // Half.MaxValue -> -32' -65504 bitmasked                  (Half.MinValue' (sbyte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToSByte)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToSByte)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToSByte)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToSByte)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToSByte)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToSByte)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToSByte_TestData,The following statement contains a magic number: (Half Original' sbyte Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((sbyte)(65504 & 0xFF)))' // Half.MaxValue -> -32' -65504 bitmasked                  (Half.MinValue' (sbyte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToSByte)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToSByte)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToSByte)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToSByte)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToSByte)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToSByte)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToSByte_TestData,The following statement contains a magic number: (Half Original' sbyte Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((sbyte)(65504 & 0xFF)))' // Half.MaxValue -> -32' -65504 bitmasked                  (Half.MinValue' (sbyte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToSByte)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToSByte)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToSByte)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToSByte)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToSByte)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToSByte)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToSByte_TestData,The following statement contains a magic number: (Half Original' sbyte Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((sbyte)(65504 & 0xFF)))' // Half.MaxValue -> -32' -65504 bitmasked                  (Half.MinValue' (sbyte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToSByte)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToSByte)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToSByte)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToSByte)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToSByte)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToSByte)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToSByte_TestData,The following statement contains a magic number: (Half Original' sbyte Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((sbyte)(65504 & 0xFF)))' // Half.MaxValue -> -32' -65504 bitmasked                  (Half.MinValue' (sbyte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToSByte)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToSByte)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToSByte)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToSByte)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToSByte)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToSByte)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToSByte_TestData,The following statement contains a magic number: (Half Original' sbyte Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((sbyte)(65504 & 0xFF)))' // Half.MaxValue -> -32' -65504 bitmasked                  (Half.MinValue' (sbyte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToSByte)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToSByte)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToSByte)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToSByte)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToSByte)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToSByte)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ExplicitConversion_ToSByte_TestData,The following statement contains a magic number: (Half Original' sbyte Expected)[] data =              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1)' // -1                  (Half.MaxValue' unchecked((sbyte)(65504 & 0xFF)))' // Half.MaxValue -> -32' -65504 bitmasked                  (Half.MinValue' (sbyte)(-65504 & 0xFF))' // Half.MinValue -> 32' -65504 bitmasked                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0)' // 0.1 -> 0                   (UInt16BitsToHalf(0b1_01011_1001100110)' 0)' // -0.1 -> 0                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42)' // -42                  (Half.PositiveInfinity' IllegalValueToSByte)' // PosInfinity -> MinValue                  (Half.NegativeInfinity' IllegalValueToSByte)' // NegInfinity -> MinValue                  (UInt16BitsToHalf(0b0_11111_1000000000)' IllegalValueToSByte)' // Positive Quiet NaN -> Minvalue                  (Half.NaN' IllegalValueToSByte)' // Negative Quiet NaN -> Minvalue                  (UInt16BitsToHalf(0b0_11111_1010101010)' IllegalValueToSByte)' // Positive Signalling NaN -> MinValue                  (UInt16BitsToHalf(0b1_11111_1010101010)' IllegalValueToSByte)' // Negative Signalling NaN -> MinValue                  (Half.Epsilon' 0)' // PosEpsilon -> 0                  (-Half.Epsilon' 0)' // NegEpsilon -> 0                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' 0)' // -0 -> 0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3)' // Pi -> 3                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3)' // -Pi -> -3                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2)' // E -> 2                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2)' // -E -> -2                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1)' // 1.5 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1)' // -1.5 -> -1                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1)' // 1.5009765625 -> 1                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1)' // -1.5009765625 -> -1              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToSingle_TestData,The following statement contains a magic number: (Half Original' float Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1f)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1f)' // -1                  (Half.MaxValue' 65504f)' // 65504                  (Half.MinValue' -65504f)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375f)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375f)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42f)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42f)' // -42                  (Half.PositiveInfinity' float.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' float.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int32BitsToSingle(0x7FC00000))' // Positive Quiet NaN                  (Half.NaN' float.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int32BitsToSingle(0x7FD54000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int32BitsToSingle(unchecked((int)0xFFD54000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216f)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216f)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0f)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625f)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625f)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875f)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875f)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5f)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5f)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625f)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625f)' // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
Magic Number,System.Numerics.Experimental.Tests,HalfTests,D:\research\architectureSmells\repos\dotnet_corefxlab\tests\System.Numerics.Experimental.Tests\HalfTests.cs,ImplicitConversion_ToDouble_TestData,The following statement contains a magic number: (Half Original' double Expected)[] data = // Fraction is shifted left by 42' Exponent is -15 then +127 = +112              {                  (UInt16BitsToHalf(0b0_01111_0000000000)' 1d)' // 1                  (UInt16BitsToHalf(0b1_01111_0000000000)' -1d)' // -1                  (Half.MaxValue' 65504d)' // 65504                  (Half.MinValue' -65504d)' // -65504                  (UInt16BitsToHalf(0b0_01011_1001100110)' 0.0999755859375d)' // 0.1ish                  (UInt16BitsToHalf(0b1_01011_1001100110)' -0.0999755859375d)' // -0.1ish                  (UInt16BitsToHalf(0b0_10100_0101000000)' 42d)' // 42                  (UInt16BitsToHalf(0b1_10100_0101000000)' -42d)' // -42                  (Half.PositiveInfinity' double.PositiveInfinity)' // PosInfinity                  (Half.NegativeInfinity' double.NegativeInfinity)' // NegInfinity                  (UInt16BitsToHalf(0b0_11111_1000000000)' BitConverter.Int64BitsToDouble(0x7FF80000_00000000))' // Positive Quiet NaN                  (Half.NaN' double.NaN)' // Negative Quiet NaN                  (UInt16BitsToHalf(0b0_11111_1010101010)' BitConverter.Int64BitsToDouble(0x7FFAA800_00000000))' // Positive Signalling NaN - Should preserve payload                  (UInt16BitsToHalf(0b1_11111_1010101010)' BitConverter.Int64BitsToDouble(unchecked((long)0xFFFAA800_00000000)))' // Negative Signalling NaN - Should preserve payload                  (Half.Epsilon' 1/16777216d)' // PosEpsilon = 0.000000059605...                  (-Half.Epsilon' -1/16777216d)' // NegEpsilon = 0.000000059605...                  (UInt16BitsToHalf(0)' 0d)' // 0                  (UInt16BitsToHalf(0b1_00000_0000000000)' -0d)' // -0                   (UInt16BitsToHalf(0b0_10000_1001001000)' 3.140625d)' // 3.140625                  (UInt16BitsToHalf(0b1_10000_1001001000)' -3.140625d)' // -3.140625                  (UInt16BitsToHalf(0b0_10000_0101110000)' 2.71875d)' // 2.71875                  (UInt16BitsToHalf(0b1_10000_0101110000)' -2.71875d)' // -2.71875                  (UInt16BitsToHalf(0b0_01111_1000000000)' 1.5d)' // 1.5                  (UInt16BitsToHalf(0b1_01111_1000000000)' -1.5d)' // -1.5                  (UInt16BitsToHalf(0b0_01111_1000000001)' 1.5009765625d)' // 1.5009765625                  (UInt16BitsToHalf(0b1_01111_1000000001)' -1.5009765625d) // -1.5009765625              };
