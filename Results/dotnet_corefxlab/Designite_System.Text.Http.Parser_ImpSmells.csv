Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseRequestLine,The method has 100 lines of code.
Long Method,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseHeaders,The method has 114 lines of code.
Long Method,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseHeaders,The method has 100 lines of code.
Complex Method,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseRequestLine,Cyclomatic complexity of the method is 12
Complex Method,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,TakeSingleHeader,Cyclomatic complexity of the method is 8
Long Parameter List,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseHeaders,The method has 5 parameters. Parameters: handler' buffer' consumed' examined' consumedBytes
Long Parameter List,System.Text.Http.Parser,IHttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\IHttpParser.cs,ParseHeaders,The method has 5 parameters. Parameters: handler' buffer' consumed' examined' consumedBytes
Long Parameter List,System.Text.Http.Parser,IHttpRequestLineHandler,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\IHttpRequestLineHandler.cs,OnStartLine,The method has 7 parameters. Parameters: method' version' target' path' query' customMethod' pathEncoded
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status413RequestEntityTooLarge is 30.
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status416RequestedRangeNotSatisfiable is 37.
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status419AuthenticationTimeout is 30.
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status431RequestHeaderFieldsTooLarge is 36.
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status451UnavailableForLegalReasons is 35.
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status505HttpVersionNotsupported is 32.
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status506VariantAlsoNegotiates is 30.
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status407ProxyAuthenticationRequired is 36.
Long Identifier,System.Text.Http.Parser,StatusCodes,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,,The length of the parameter Status511NetworkAuthenticationRequired is 38.
Long Statement,System.Text.Http.Parser,BadHttpRequestException,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,GetException,The length of the statement  "                    ex = new BadHttpRequestException("Invalid request headers: missing final CRLF in header fields."' StatusCodes.Status400BadRequest); " is 131.
Long Statement,System.Text.Http.Parser,BadHttpRequestException,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,GetException,The length of the statement  "                    ex = new BadHttpRequestException("Request contains too many headers."' StatusCodes.Status431RequestHeaderFieldsTooLarge); " is 121.
Long Statement,System.Text.Http.Parser,BadHttpRequestException,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,GetException,The length of the statement  "                    ex = new BadHttpRequestException($"Unrecognized HTTP version: '{detail}'"' StatusCodes.Status505HttpVersionNotsupported); " is 121.
Long Statement,System.Text.Http.Parser,BadHttpRequestException,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,GetException,The length of the statement  "                    ex = new BadHttpRequestException($"Final transfer coding is not \"chunked\": \"{detail}\""' StatusCodes.Status400BadRequest); " is 125.
Long Statement,System.Text.Http.Parser,BadHttpRequestException,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,GetException,The length of the statement  "                    ex = new BadHttpRequestException($"{detail} request contains no Content-Length or Transfer-Encoding header"' StatusCodes.Status411LengthRequired); " is 146.
Long Statement,System.Text.Http.Parser,BadHttpRequestException,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\BadHttpRequestException.cs,GetException,The length of the statement  "                    ex = new BadHttpRequestException($"{detail} request contains no Content-Length header"' StatusCodes.Status400BadRequest); " is 121.
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: while (i < count - 11)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0 && *(signedInput + 6) > 0 &&                      *(signedInput + 7) > 0 && *(signedInput + 8) > 0 && *(signedInput + 9) > 0 && *(signedInput + 10) > 0 &&                      *(signedInput + 11) > 0;                    i += 12;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  *(output + 6) = (char)*(signedInput + 6);                  *(output + 7) = (char)*(signedInput + 7);                  *(output + 8) = (char)*(signedInput + 8);                  *(output + 9) = (char)*(signedInput + 9);                  *(output + 10) = (char)*(signedInput + 10);                  *(output + 11) = (char)*(signedInput + 11);                  output += 12;                  signedInput += 12;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 5)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0 && *(signedInput + 4) > 0 && *(signedInput + 5) > 0;                    i += 6;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  *(output + 4) = (char)*(signedInput + 4);                  *(output + 5) = (char)*(signedInput + 5);                  output += 6;                  signedInput += 6;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,AsciiUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\AsciiUtilities.cs,TryGetAsciiString,The following statement contains a magic number: if (i < count - 3)              {                  isValid = isValid && *signedInput > 0 && *(signedInput + 1) > 0 && *(signedInput + 2) > 0 &&                      *(signedInput + 3) > 0;                    i += 4;                  *(output) = (char)*(signedInput);                  *(output + 1) = (char)*(signedInput + 1);                  *(output + 2) = (char)*(signedInput + 2);                  *(output + 3) = (char)*(signedInput + 3);                  output += 4;                  signedInput += 4;              }
Magic Number,System.Text.Http.Parser.Internal,HttpUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpUtilities.cs,CreateMethodNames,The following statement contains a magic number: var methodNames = new string[9];
Magic Number,System.Text.Http.Parser.Internal,HttpUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpUtilities.cs,GetAsciiStringAsLong,The following statement contains a magic number: Debug.Assert(str.Length == 8' "String must be exactly 8 (ASCII) characters long.");
Magic Number,System.Text.Http.Parser.Internal,HttpUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpUtilities.cs,GetAsciiStringAsLong,The following statement contains a magic number: Span<byte> span = stackalloc byte[8];
Magic Number,System.Text.Http.Parser.Internal,HttpUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpUtilities.cs,GetAsciiStringAsInt,The following statement contains a magic number: Debug.Assert(str.Length == 4' "String must be exactly 4 (ASCII) characters long.");
Magic Number,System.Text.Http.Parser.Internal,HttpUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpUtilities.cs,GetAsciiStringAsInt,The following statement contains a magic number: Span<byte> span = stackalloc byte[4];
Magic Number,System.Text.Http.Parser.Internal,HttpUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpUtilities.cs,GetMaskAsLong,The following statement contains a magic number: Debug.Assert(bytes.Length == 8' "Mask must be exactly 8 bytes long.");
Magic Number,System.Text.Http.Parser.Internal,HttpUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpUtilities.cs,GetKnownMethod,The following statement contains a magic number: if (length < sizeof(uint))              {                  return Http.Method.Custom;              }              else if (*(uint*)data == _httpGetMethodInt)              {                  methodLength = 3;                  return Http.Method.Get;              }              else if (length < sizeof(ulong))              {                  return Http.Method.Custom;              }              else              {                  var value = *(ulong*)data;                  foreach (var x in _knownMethods)                  {                      if ((value & x.Item1) == x.Item2)                      {                          methodLength = x.Item4;                          return x.Item3;                      }                  }              }
Magic Number,System.Text.Http.Parser.Internal,HttpUtilities,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpUtilities.cs,MethodToString,The following statement contains a magic number: if (methodIndex >= 0 && methodIndex <= 8)              {                  return _methodNames[methodIndex];              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseRequestLine,The following statement contains a magic number: if (httpVersion == Http.Version.Unknown)              {                  if (data[offset] == ByteCR || data[length - 2] != ByteCR)                  {                      // If missing delimiter or CR before LF' reject and log entire line                      RejectRequestLine(data' length);                  }                  else                  {                      // else inform HTTP version is unsupported.                      RejectUnknownVersion(data + offset' length - offset - 2);                  }              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseRequestLine,The following statement contains a magic number: if (httpVersion == Http.Version.Unknown)              {                  if (data[offset] == ByteCR || data[length - 2] != ByteCR)                  {                      // If missing delimiter or CR before LF' reject and log entire line                      RejectRequestLine(data' length);                  }                  else                  {                      // else inform HTTP version is unsupported.                      RejectUnknownVersion(data + offset' length - offset - 2);                  }              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseRequestLine,The following statement contains a magic number: if (data[offset + 8 + 1] != ByteLF)              {                  RejectRequestLine(data' length);              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseHeaders,The following statement contains a magic number: try              {                  while (!reader.End)                  {                      var span = reader.Span;                      var remaining = span.Length - reader.Index;                        fixed (byte* pBuffer = &span.DangerousGetPinnableReference())                      {                          while (remaining > 0)                          {                              var index = reader.Index;                              int ch1;                              int ch2;                                // Fast path' we're still looking at the same span                              if (remaining >= 2)                              {                                  ch1 = pBuffer[index];                                  ch2 = pBuffer[index + 1];                              }                              else                              {                                  // Store the reader before we look ahead 2 bytes (probably straddling                                  // spans)                                  start = reader;                                    // Possibly split across spans                                  ch1 = reader.Take();                                  ch2 = reader.Take();                              }                                if (ch1 == ByteCR)                              {                                  // Check for final CRLF.                                  if (ch2 == -1)                                  {                                      // Reset the reader so we don't consume anything                                      reader = start;                                      return false;                                  }                                  else if (ch2 == ByteLF)                                  {                                      // If we got 2 bytes from the span directly so skip ahead 2 so that                                      // the reader's state matches what we expect                                      if (index == reader.Index)                                      {                                          reader.Skip(2);                                      }                                        done = true;                                      return true;                                  }                                    // Headers don't end in CRLF line.                                  RejectRequest(RequestRejectionReason.InvalidRequestHeadersNoCRLF);                              }                                // We moved the reader so look ahead 2 bytes so reset both the reader                              // and the index                              if (index != reader.Index)                              {                                  reader = start;                                  index = reader.Index;                              }                                var endIndex = new ReadOnlySpan<byte>(pBuffer + index' remaining).IndexOf(ByteLF);                              var length = 0;                                if (endIndex != -1)                              {                                  length = endIndex + 1;                                  var pHeader = pBuffer + index;                                    TakeSingleHeader(pHeader' length' ref handler);                              }                              else                              {                                  var current = reader.Cursor;                                    // Split buffers                                  if (ReadCursorOperations.Seek(current' bufferEnd' out var lineEnd' ByteLF) == -1)                                  {                                      // Not there                                      return false;                                  }                                    // Make sure LF is included in lineEnd                                  lineEnd = buffer.Move(lineEnd' 1);                                  var headerSpan = buffer.Slice(current' lineEnd).ToSpan();                                  length = headerSpan.Length;                                    fixed (byte* pHeader = &headerSpan.DangerousGetPinnableReference())                                  {                                      TakeSingleHeader(pHeader' length' ref handler);                                  }                                    // We're going to the next span after this since we know we crossed spans here                                  // so mark the remaining as equal to the headerSpan so that we end up at 0                                  // on the next iteration                                  remaining = length;                              }                                // Skip the reader forward past the header line                              reader.Skip(length);                              remaining -= length;                          }                      }                  }                    return false;              }              finally              {                  consumed = reader.Cursor;                  consumedBytes = reader.ConsumedBytes;                    if (done)                  {                      examined = consumed;                  }              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseHeaders,The following statement contains a magic number: try              {                  while (!reader.End)                  {                      var span = reader.Span;                      var remaining = span.Length - reader.Index;                        fixed (byte* pBuffer = &span.DangerousGetPinnableReference())                      {                          while (remaining > 0)                          {                              var index = reader.Index;                              int ch1;                              int ch2;                                // Fast path' we're still looking at the same span                              if (remaining >= 2)                              {                                  ch1 = pBuffer[index];                                  ch2 = pBuffer[index + 1];                              }                              else                              {                                  // Store the reader before we look ahead 2 bytes (probably straddling                                  // spans)                                  start = reader;                                    // Possibly split across spans                                  ch1 = reader.Take();                                  ch2 = reader.Take();                              }                                if (ch1 == ByteCR)                              {                                  // Check for final CRLF.                                  if (ch2 == -1)                                  {                                      // Reset the reader so we don't consume anything                                      reader = start;                                      return false;                                  }                                  else if (ch2 == ByteLF)                                  {                                      // If we got 2 bytes from the span directly so skip ahead 2 so that                                      // the reader's state matches what we expect                                      if (index == reader.Index)                                      {                                          reader.Skip(2);                                      }                                        done = true;                                      return true;                                  }                                    // Headers don't end in CRLF line.                                  RejectRequest(RequestRejectionReason.InvalidRequestHeadersNoCRLF);                              }                                // We moved the reader so look ahead 2 bytes so reset both the reader                              // and the index                              if (index != reader.Index)                              {                                  reader = start;                                  index = reader.Index;                              }                                var endIndex = new ReadOnlySpan<byte>(pBuffer + index' remaining).IndexOf(ByteLF);                              var length = 0;                                if (endIndex != -1)                              {                                  length = endIndex + 1;                                  var pHeader = pBuffer + index;                                    TakeSingleHeader(pHeader' length' ref handler);                              }                              else                              {                                  var current = reader.Cursor;                                    // Split buffers                                  if (ReadCursorOperations.Seek(current' bufferEnd' out var lineEnd' ByteLF) == -1)                                  {                                      // Not there                                      return false;                                  }                                    // Make sure LF is included in lineEnd                                  lineEnd = buffer.Move(lineEnd' 1);                                  var headerSpan = buffer.Slice(current' lineEnd).ToSpan();                                  length = headerSpan.Length;                                    fixed (byte* pHeader = &headerSpan.DangerousGetPinnableReference())                                  {                                      TakeSingleHeader(pHeader' length' ref handler);                                  }                                    // We're going to the next span after this since we know we crossed spans here                                  // so mark the remaining as equal to the headerSpan so that we end up at 0                                  // on the next iteration                                  remaining = length;                              }                                // Skip the reader forward past the header line                              reader.Skip(length);                              remaining -= length;                          }                      }                  }                    return false;              }              finally              {                  consumed = reader.Cursor;                  consumedBytes = reader.ConsumedBytes;                    if (done)                  {                      examined = consumed;                  }              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseHeaders,The following statement contains a magic number: while (true)              {                  fixed (byte* pBuffer = &currentSpan.DangerousGetPinnableReference())                  {                      while (remaining > 0)                      {                          int ch1;                          int ch2;                            // Fast path' we're still looking at the same span                          if (remaining >= 2)                          {                              ch1 = pBuffer[index];                              ch2 = pBuffer[index + 1];                          }                          // Slow Path                          else                          {                              ReadTwoChars(buffer' consumedBytes' out ch1' out ch2);                              // I think the above is fast enough. If we don't like it' we can do the code below after some modifications                              // to ensure that one next.Span is enough                              //if(hasNext) ReadNextTwoChars(pBuffer' remaining' index' out ch1' out ch2' next.Span);                              //else                              //{                              //    return false;                              //}                          }                            if (ch1 == ByteCR)                          {                              if (ch2 == ByteLF)                              {                                  consumedBytes += 2;                                  return true;                              }                                if (ch2 == -1)                              {                                  consumedBytes = 0;                                  return false;                              }                                // Headers don't end in CRLF line.                              RejectRequest(RequestRejectionReason.InvalidRequestHeadersNoCRLF);                          }                            var endIndex = new ReadOnlySpan<byte>(pBuffer + index' remaining).IndexOf(ByteLF);                          var length = 0;                            if (endIndex != -1)                          {                              length = endIndex + 1;                              var pHeader = pBuffer + index;                                TakeSingleHeader(pHeader' length' ref handler);                          }                          else                          {                              // Split buffers                              var end = Sequence.IndexOf(buffer.Slice(index)' ByteLF);                              if (end == -1)                              {                                  // Not there                                  consumedBytes = 0;                                  return false;                              }                                var headerSpan = buffer.Slice(index' end - index + 1).ToSpan();                              length = headerSpan.Length;                                fixed (byte* pHeader = &headerSpan.DangerousGetPinnableReference())                              {                                  TakeSingleHeader(pHeader' length' ref handler);                              }                          }                            // Skip the reader forward past the header line                          index += length;                          consumedBytes += length;                          remaining -= length;                      }                  }                    // This is just to get the position to be at the second segment                  if (position == default)                  {                      if (!buffer.TryGet(ref position' out ReadOnlyMemory<byte> current))                      {                          consumedBytes = 0;                          return false;                      }                  }                    if (buffer.TryGet(ref position' out var nextSegment))                  {                      currentSpan = nextSegment.Span;                      remaining = currentSpan.Length + remaining;                      index = currentSpan.Length - remaining;                  }                  else                  {                      consumedBytes = 0;                      return false;                  }              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ParseHeaders,The following statement contains a magic number: while (true)              {                  fixed (byte* pBuffer = &currentSpan.DangerousGetPinnableReference())                  {                      while (remaining > 0)                      {                          int ch1;                          int ch2;                            // Fast path' we're still looking at the same span                          if (remaining >= 2)                          {                              ch1 = pBuffer[index];                              ch2 = pBuffer[index + 1];                          }                          // Slow Path                          else                          {                              ReadTwoChars(buffer' consumedBytes' out ch1' out ch2);                              // I think the above is fast enough. If we don't like it' we can do the code below after some modifications                              // to ensure that one next.Span is enough                              //if(hasNext) ReadNextTwoChars(pBuffer' remaining' index' out ch1' out ch2' next.Span);                              //else                              //{                              //    return false;                              //}                          }                            if (ch1 == ByteCR)                          {                              if (ch2 == ByteLF)                              {                                  consumedBytes += 2;                                  return true;                              }                                if (ch2 == -1)                              {                                  consumedBytes = 0;                                  return false;                              }                                // Headers don't end in CRLF line.                              RejectRequest(RequestRejectionReason.InvalidRequestHeadersNoCRLF);                          }                            var endIndex = new ReadOnlySpan<byte>(pBuffer + index' remaining).IndexOf(ByteLF);                          var length = 0;                            if (endIndex != -1)                          {                              length = endIndex + 1;                              var pHeader = pBuffer + index;                                TakeSingleHeader(pHeader' length' ref handler);                          }                          else                          {                              // Split buffers                              var end = Sequence.IndexOf(buffer.Slice(index)' ByteLF);                              if (end == -1)                              {                                  // Not there                                  consumedBytes = 0;                                  return false;                              }                                var headerSpan = buffer.Slice(index' end - index + 1).ToSpan();                              length = headerSpan.Length;                                fixed (byte* pHeader = &headerSpan.DangerousGetPinnableReference())                              {                                  TakeSingleHeader(pHeader' length' ref handler);                              }                          }                            // Skip the reader forward past the header line                          index += length;                          consumedBytes += length;                          remaining -= length;                      }                  }                    // This is just to get the position to be at the second segment                  if (position == default)                  {                      if (!buffer.TryGet(ref position' out ReadOnlyMemory<byte> current))                      {                          consumedBytes = 0;                          return false;                      }                  }                    if (buffer.TryGet(ref position' out var nextSegment))                  {                      currentSpan = nextSegment.Span;                      remaining = currentSpan.Length + remaining;                      index = currentSpan.Length - remaining;                  }                  else                  {                      consumedBytes = 0;                      return false;                  }              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ReadTwoChars,The following statement contains a magic number: Span<byte> temp = stackalloc byte[2];
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,ReadTwoChars,The following statement contains a magic number: if (buffer.Slice(consumedBytes).CopyTo(temp) < 2)              {                  ch1 = -1;                  ch2 = -1;              }              else              {                  ch1 = temp[0];                  ch2 = temp[1];              }
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,TakeSingleHeader,The following statement contains a magic number: var valueEnd = length - 3;
Magic Number,System.Text.Http.Parser,HttpParser,C:\repos\dotnet_corefxlab\src\System.Text.Http.Parser\HttpParser.cs,TakeSingleHeader,The following statement contains a magic number: if (headerLine[valueEnd + 2] != ByteLF)              {                  RejectRequestHeader(headerLine' length);              }
