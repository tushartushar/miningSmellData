Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The method has 122 lines of code.
Complex Method,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,Cyclomatic complexity of the method is 17
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: if ((byte1 & 0xE0) == 0xC0)              {                  // 110x xxxx' expect one more byte                  currentDecodeBits = byte1 & 0x1F;                  byteCount = 2;                  expectValueMin = 0x80;              }              else if ((byte1 & 0xF0) == 0xE0)              {                  // 1110 xxxx' expect two more bytes                  currentDecodeBits = byte1 & 0x0F;                  byteCount = 3;                  expectValueMin = 0x800;              }              else if ((byte1 & 0xF8) == 0xF0)              {                  // 1111 0xxx' expect three more bytes                  currentDecodeBits = byte1 & 0x07;                  byteCount = 4;                  expectValueMin = 0x10000;              }              else              {                  // invalid first byte                  return false;              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: if ((byte1 & 0xE0) == 0xC0)              {                  // 110x xxxx' expect one more byte                  currentDecodeBits = byte1 & 0x1F;                  byteCount = 2;                  expectValueMin = 0x80;              }              else if ((byte1 & 0xF0) == 0xE0)              {                  // 1110 xxxx' expect two more bytes                  currentDecodeBits = byte1 & 0x0F;                  byteCount = 3;                  expectValueMin = 0x800;              }              else if ((byte1 & 0xF8) == 0xF0)              {                  // 1111 0xxx' expect three more bytes                  currentDecodeBits = byte1 & 0x07;                  byteCount = 4;                  expectValueMin = 0x10000;              }              else              {                  // invalid first byte                  return false;              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: if ((byte1 & 0xE0) == 0xC0)              {                  // 110x xxxx' expect one more byte                  currentDecodeBits = byte1 & 0x1F;                  byteCount = 2;                  expectValueMin = 0x80;              }              else if ((byte1 & 0xF0) == 0xE0)              {                  // 1110 xxxx' expect two more bytes                  currentDecodeBits = byte1 & 0x0F;                  byteCount = 3;                  expectValueMin = 0x800;              }              else if ((byte1 & 0xF8) == 0xF0)              {                  // 1111 0xxx' expect three more bytes                  currentDecodeBits = byte1 & 0x07;                  byteCount = 4;                  expectValueMin = 0x10000;              }              else              {                  // invalid first byte                  return false;              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: while (remainingBytes > 0)              {                  // read following three chars                  if (sourceIndex == buffer.Length)                  {                      return false;                  }                    var nextSourceIndex = sourceIndex;                  var nextByte = UnescapePercentEncoding(ref nextSourceIndex' buffer);                  if (nextByte == -1)                  {                      return false;                  }                    if ((nextByte & 0xC0) != 0x80)                  {                      // the follow up byte is not in form of 10xx xxxx                      return false;                  }                    currentDecodeBits = (currentDecodeBits << 6) | (nextByte & 0x3F);                  remainingBytes--;                    if (remainingBytes == 1 && currentDecodeBits >= 0x360 && currentDecodeBits <= 0x37F)                  {                      // this is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that                      // are not allowed in UTF-8;                      return false;                  }                    if (remainingBytes == 2 && currentDecodeBits >= 0x110)                  {                      // this is going to be out of the upper Unicode bound 0x10FFFF.                      return false;                  }                    sourceIndex = nextSourceIndex;                  if (byteCount - remainingBytes == 2)                  {                      byte2 = nextByte;                  }                  else if (byteCount - remainingBytes == 3)                  {                      byte3 = nextByte;                  }                  else if (byteCount - remainingBytes == 4)                  {                      byte4 = nextByte;                  }              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: while (remainingBytes > 0)              {                  // read following three chars                  if (sourceIndex == buffer.Length)                  {                      return false;                  }                    var nextSourceIndex = sourceIndex;                  var nextByte = UnescapePercentEncoding(ref nextSourceIndex' buffer);                  if (nextByte == -1)                  {                      return false;                  }                    if ((nextByte & 0xC0) != 0x80)                  {                      // the follow up byte is not in form of 10xx xxxx                      return false;                  }                    currentDecodeBits = (currentDecodeBits << 6) | (nextByte & 0x3F);                  remainingBytes--;                    if (remainingBytes == 1 && currentDecodeBits >= 0x360 && currentDecodeBits <= 0x37F)                  {                      // this is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that                      // are not allowed in UTF-8;                      return false;                  }                    if (remainingBytes == 2 && currentDecodeBits >= 0x110)                  {                      // this is going to be out of the upper Unicode bound 0x10FFFF.                      return false;                  }                    sourceIndex = nextSourceIndex;                  if (byteCount - remainingBytes == 2)                  {                      byte2 = nextByte;                  }                  else if (byteCount - remainingBytes == 3)                  {                      byte3 = nextByte;                  }                  else if (byteCount - remainingBytes == 4)                  {                      byte4 = nextByte;                  }              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: while (remainingBytes > 0)              {                  // read following three chars                  if (sourceIndex == buffer.Length)                  {                      return false;                  }                    var nextSourceIndex = sourceIndex;                  var nextByte = UnescapePercentEncoding(ref nextSourceIndex' buffer);                  if (nextByte == -1)                  {                      return false;                  }                    if ((nextByte & 0xC0) != 0x80)                  {                      // the follow up byte is not in form of 10xx xxxx                      return false;                  }                    currentDecodeBits = (currentDecodeBits << 6) | (nextByte & 0x3F);                  remainingBytes--;                    if (remainingBytes == 1 && currentDecodeBits >= 0x360 && currentDecodeBits <= 0x37F)                  {                      // this is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that                      // are not allowed in UTF-8;                      return false;                  }                    if (remainingBytes == 2 && currentDecodeBits >= 0x110)                  {                      // this is going to be out of the upper Unicode bound 0x10FFFF.                      return false;                  }                    sourceIndex = nextSourceIndex;                  if (byteCount - remainingBytes == 2)                  {                      byte2 = nextByte;                  }                  else if (byteCount - remainingBytes == 3)                  {                      byte3 = nextByte;                  }                  else if (byteCount - remainingBytes == 4)                  {                      byte4 = nextByte;                  }              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: while (remainingBytes > 0)              {                  // read following three chars                  if (sourceIndex == buffer.Length)                  {                      return false;                  }                    var nextSourceIndex = sourceIndex;                  var nextByte = UnescapePercentEncoding(ref nextSourceIndex' buffer);                  if (nextByte == -1)                  {                      return false;                  }                    if ((nextByte & 0xC0) != 0x80)                  {                      // the follow up byte is not in form of 10xx xxxx                      return false;                  }                    currentDecodeBits = (currentDecodeBits << 6) | (nextByte & 0x3F);                  remainingBytes--;                    if (remainingBytes == 1 && currentDecodeBits >= 0x360 && currentDecodeBits <= 0x37F)                  {                      // this is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that                      // are not allowed in UTF-8;                      return false;                  }                    if (remainingBytes == 2 && currentDecodeBits >= 0x110)                  {                      // this is going to be out of the upper Unicode bound 0x10FFFF.                      return false;                  }                    sourceIndex = nextSourceIndex;                  if (byteCount - remainingBytes == 2)                  {                      byte2 = nextByte;                  }                  else if (byteCount - remainingBytes == 3)                  {                      byte3 = nextByte;                  }                  else if (byteCount - remainingBytes == 4)                  {                      byte4 = nextByte;                  }              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: while (remainingBytes > 0)              {                  // read following three chars                  if (sourceIndex == buffer.Length)                  {                      return false;                  }                    var nextSourceIndex = sourceIndex;                  var nextByte = UnescapePercentEncoding(ref nextSourceIndex' buffer);                  if (nextByte == -1)                  {                      return false;                  }                    if ((nextByte & 0xC0) != 0x80)                  {                      // the follow up byte is not in form of 10xx xxxx                      return false;                  }                    currentDecodeBits = (currentDecodeBits << 6) | (nextByte & 0x3F);                  remainingBytes--;                    if (remainingBytes == 1 && currentDecodeBits >= 0x360 && currentDecodeBits <= 0x37F)                  {                      // this is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that                      // are not allowed in UTF-8;                      return false;                  }                    if (remainingBytes == 2 && currentDecodeBits >= 0x110)                  {                      // this is going to be out of the upper Unicode bound 0x10FFFF.                      return false;                  }                    sourceIndex = nextSourceIndex;                  if (byteCount - remainingBytes == 2)                  {                      byte2 = nextByte;                  }                  else if (byteCount - remainingBytes == 3)                  {                      byte3 = nextByte;                  }                  else if (byteCount - remainingBytes == 4)                  {                      byte4 = nextByte;                  }              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: if (byteCount > 2)              {                  buffer[destinationIndex++] = (byte)byte3;              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,DecodeCore,The following statement contains a magic number: if (byteCount > 3)              {                  buffer[destinationIndex++] = (byte)byte4;              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,UnescapePercentEncoding,The following statement contains a magic number: return (value1 << 4) + value2;
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,ReadHex,The following statement contains a magic number: if (value <= '9')              {                  return value - '0';              }              else if (value <= 'F')              {                  return (value - 'A') + 10;              }              else // a - f              {                  return (value - 'a') + 10;              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,ReadHex,The following statement contains a magic number: if (value <= '9')              {                  return value - '0';              }              else if (value <= 'F')              {                  return (value - 'A') + 10;              }              else // a - f              {                  return (value - 'a') + 10;              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,SkipUnescape,The following statement contains a magic number: if (value1 == 2 && value2 == 15)              {                  return true;              }
Magic Number,System.Text.Encodings.Web.Utf8,UrlEncoder,C:\repos\dotnet_corefxlab\src\System.Text.Encodings.Web.Utf8\UrlEncoder.cs,SkipUnescape,The following statement contains a magic number: if (value1 == 2 && value2 == 15)              {                  return true;              }
