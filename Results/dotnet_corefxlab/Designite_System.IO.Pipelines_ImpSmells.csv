Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,System.IO.Pipelines,BufferSegment,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\BufferSegment.cs,Clone,The method has 5 parameters. Parameters: start' startIndex' end' endIndex' lastSegment
Long Parameter List,System.IO.Pipelines,PipeOptions,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\PipeOptions.cs,PipeOptions,The method has 5 parameters. Parameters: pool' readerScheduler' writerScheduler' maximumSizeHigh' maximumSizeLow
Long Parameter List,System.IO.Pipelines,ReadCursor,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\ReadCursor.cs,TryGetBufferMultiBlock,The method has 5 parameters. Parameters: start' startIndex' end' endIndex' data
Long Parameter List,System.IO.Pipelines,ReadCursorOperations,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\ReadCursorOperations.cs,Seek,The method has 5 parameters. Parameters: begin' end' result' byte0' byte1
Long Parameter List,System.IO.Pipelines,ReadCursorOperations,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\ReadCursorOperations.cs,Seek,The method has 6 parameters. Parameters: begin' end' result' byte0' byte1' byte2
Long Identifier,System.IO.Pipelines,PipeAwaitable,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\PipeAwaitable.cs,,The length of the parameter _cancellationTokenRegistration is 30.
Long Statement,System.IO.Pipelines,Pipe,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\Pipe.cs,Append,The length of the statement  "            var clonedBegin = BufferSegment.Clone(buffer.Start.GetSegment()' buffer.Start.Index' buffer.End.GetSegment()' buffer.End.Index' out BufferSegment clonedEnd); " is 157.
Long Statement,System.IO.Pipelines,Pipe,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\Pipe.cs,Complete,The length of the statement  "                PipelinesThrowHelper.ThrowInvalidOperationException(ExceptionResource.CompleteWriterActiveWriter' _writingState.Location); " is 122.
Long Statement,System.IO.Pipelines,Pipe,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\Pipe.cs,Complete,The length of the statement  "                PipelinesThrowHelper.ThrowInvalidOperationException(ExceptionResource.CompleteReaderActiveReader' _readingState.Location); " is 122.
Long Statement,System.IO.Pipelines,ReadableBuffer,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\ReadableBuffer.cs,Clone,The length of the statement  "                var segmentHead = BufferSegment.Clone(bufferSegment' buffer.BufferStart.Index' buffer.BufferEnd.GetSegment()' buffer.BufferEnd.Index' out var segmentTail); " is 155.
Magic Number,System.IO.Pipelines,PipeCompletion,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\PipeCompletion.cs,AddCallback,The following statement contains a magic number: if (newIndex == _callbacks.Length)              {                  var newArray = CompletionCallbackPool.Rent(_callbacks.Length * 2);                  Array.Copy(_callbacks' newArray' _callbacks.Length);                  CompletionCallbackPool.Return(_callbacks' clearArray: true);                  _callbacks = newArray;              }
Magic Number,System.IO.Pipelines,ReadCursor,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\ReadCursor.cs,GetHashCode,The following statement contains a magic number: var shift5 = ((uint)h1 << 5) | ((uint)h1 >> 27);
Magic Number,System.IO.Pipelines,ReadCursor,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\ReadCursor.cs,GetHashCode,The following statement contains a magic number: var shift5 = ((uint)h1 << 5) | ((uint)h1 >> 27);
Missing Default,System.IO.Pipelines,PipelinesThrowHelper,C:\repos\dotnet_corefxlab\src\System.IO.Pipelines\System\IO\Pipelines\PipelinesThrowHelper.cs,GetResourceString,The following switch statement is missing a default case: switch (argument)              {                  case ExceptionResource.AlreadyWriting:                      resourceString = "Already writing.";                      break;                  case ExceptionResource.NotWritingNoAlloc:                      resourceString = "No writing operation. Make sure Alloc() was called.";                      break;                  case ExceptionResource.NoWriteToComplete:                      resourceString = "No writing operation to complete.";                      break;                  case ExceptionResource.AlreadyReading:                      resourceString = "Already reading.";                      break;                  case ExceptionResource.NoReadToComplete:                      resourceString = "No reading operation to complete.";                      break;                  case ExceptionResource.NoConcurrentOperation:                      resourceString = "Concurrent reads or writes are not supported.";                      break;                  case ExceptionResource.GetResultNotCompleted:                      resourceString = "Can't GetResult unless completed";                      break;                  case ExceptionResource.NoWritingAllowed:                      resourceString = "Writing is not allowed after writer was completed";                      break;                  case ExceptionResource.NoReadingAllowed:                      resourceString = "Reading is not allowed after reader was completed";                      break;                  case ExceptionResource.CompleteWriterActiveWriter:                      resourceString = "Can't complete writer while writing.";                      break;                  case ExceptionResource.CompleteReaderActiveReader:                      resourceString = "Can't complete reader while reading.";                      break;                  case ExceptionResource.AdvancingPastBufferSize:                      resourceString = "Can't advance past buffer size";                      break;                  case ExceptionResource.AdvancingWithNoBuffer:                      resourceString = "Can't advance without buffer allocated";                      break;                  case ExceptionResource.BackpressureDeadlock:                      resourceString = "Advancing examined to the end would cause pipe to deadlock because FlushAsync is waiting";                      break;                  case ExceptionResource.AdvanceToInvalidCursor:                      resourceString = "Pipe is already advanced past provided cursor";                      break;                  case ExceptionResource.ReferenceCountZero:                      resourceString = "Can't release when reference count is already zero";                      break;                  case ExceptionResource.BufferDoesNotBelongToPool:                      resourceString = "Can't return buffers that were not rented from this pool";                      break;              }
