Implementation smell,Namespace,Class,File,Method,Description
Long Method,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The method has 120 lines of code.
Complex Method,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,Cyclomatic complexity of the method is 26
Long Statement,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,ParseAndReply,The length of the statement  "                // Console.WriteLine("  ** REPLYING {0} bytes : {1}"' response.Length' response.Buffer.AsString(response.Length).Replace("\r\n"' "\r\n      ")); " is 144.
Long Statement,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The length of the statement  "            if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ') " is 147.
Long Statement,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The length of the statement  "                if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P' " is 146.
Long Statement,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The length of the statement  "                                   && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1') " is 128.
Complex Conditional,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The conditional expression  "end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' '"  is complex.
Complex Conditional,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The conditional expression  "end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1'"  is complex.
Magic Number,SimpleHttpServer,Program,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,Main,The following statement contains a magic number: var server = new Server(5000' UserCode);
Magic Number,SimpleHttpServer,Server,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,Run,The following statement contains a magic number: _listenSocket.Listen(1000);
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,ProcessRequests,The following statement contains a magic number: _readArgs.SetBuffer(new byte[4096]' 0' 4096);
Magic Number,SimpleHttpServer,Connection,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,ProcessRequests,The following statement contains a magic number: _readArgs.SetBuffer(new byte[4096]' 0' 4096);
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,Response,The following statement contains a magic number: _responseBuffer = new byte[4096];
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,FlushResponse,The following statement contains a magic number: do          {              _responseBuffer[--_contentLengthOffset] = (byte)(length % 10 + '0');              length = length / 10;          } while (0 < length);
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,FlushResponse,The following statement contains a magic number: do          {              _responseBuffer[--_contentLengthOffset] = (byte)(length % 10 + '0');              length = length / 10;          } while (0 < length);
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,AppendResponseHeader,The following statement contains a magic number: _contentLengthOffset = _responseLength - 2;
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,GrowBuffer,The following statement contains a magic number: int newLength = oldBuffer.Length * 2 < minLength ? minLength : oldBuffer.Length * 2;
Magic Number,SimpleHttpServer,Response,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\Program.cs,GrowBuffer,The following statement contains a magic number: int newLength = oldBuffer.Length * 2 < minLength ? minLength : oldBuffer.Length * 2;
Magic Number,SimpleHttpServer,ParseResult,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,GrowArray,The following statement contains a magic number: if (a == null)                  a = new int[5];
Magic Number,SimpleHttpServer,ParseResult,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,GrowArray,The following statement contains a magic number: if (a.Length <= length)              {                  int[] n = new int[length * 2];                  for (int i = 0; i < a.Length; i++)                  {                      n[i] = a[i];                  }                  a = n;              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
Magic Number,SimpleHttpServer,RequestParser,C:\repos\dotnet_corefxlab\samples\SimpleHttpWithTasks\RequestParser.cs,ParseRequest,The following statement contains a magic number: if (end - cur >= 4 && buffer[cur + 0] == (byte)'G' && buffer[cur + 1] == (byte)'E' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)' ')              {                  cur += 4;                    parseResult._method = HttpMethod.Get;                    parseResult._pathStart = cur;                    // parse the URI                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)' ')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)' ')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)' ')                                  continue;                          }                      }                        if (b == (byte)' ')                          break;                        return cur;                  }                  parseResult._pathEnd = cur-1;                      // check for "HTTP/1.1"                  if (end - cur >= 8 && buffer[cur + 0] == (byte)'H' && buffer[cur + 1] == (byte)'T' && buffer[cur + 2] == (byte)'T' && buffer[cur + 3] == (byte)'P'                                     && buffer[cur + 4] == (byte)'/' && buffer[cur + 5] == (byte)'1' && buffer[cur + 6] == (byte)'.' && buffer[cur + 7] == (byte)'1')                  {                      cur += 8;                  }                  else                  {                      return cur;                  }                    // check for \r\n                  if (end - cur >= 2 && buffer[cur + 0] == (byte)'\r' && buffer[cur + 1] == (byte)'\n')                      cur += 2;                  else                      return cur;                    // parse header lines                  int line = 0;                  int lineStart = cur;                  bool colonSeen = false;                  int valueStart = 0;                  while (cur < end)                  {                      // loop 3x unrolled to reduce number of taken branches                      byte b = buffer[cur++];                      if (b > (byte)':')                      {                          if (cur >= end)                              break;                          b = buffer[cur++];                          if (b > (byte)':')                          {                              if (cur >= end)                                  break;                              b = buffer[cur++];                              if (b > (byte)':')                                  continue;                          }                      }                      if (b == (byte)':')                      {                          if (lineStart < cur)                          {                              colonSeen = true;                              valueStart = cur;                          }                          else                          {                              Console.WriteLine("empty key");                              return cur;                          }                      }                      if (b < (byte)' ')                      {                          if (b == (byte)'\r')                          {                              if (lineStart == cur - 1 && cur < end && buffer[cur++] == (byte)'\n')                              {                                  if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                      parseResult.GrowHeaders();                                  parseResult._lineStart[parseResult._headerCount] = lineStart;                                  parseResult._parseOK = true;                                  return cur;                              }                                if (!colonSeen || valueStart == cur)                              {                                  Console.WriteLine("empty value {0} {1} {2} {3}"' lineStart' colonSeen' valueStart' cur);                                  return cur;                              }                              if (parseResult._lineStart == null || parseResult._lineStart.Length <= parseResult._headerCount)                                  parseResult.GrowHeaders();                              parseResult._lineStart[parseResult._headerCount] = lineStart;                              parseResult._valueStart[parseResult._headerCount] = valueStart;                              parseResult._headerCount++;                              colonSeen = false;                              if (cur < end && buffer[cur++] == (byte)'\n')                                  line++;                              else                                  break;                              lineStart = cur;                              continue;                          }                          break;                      }                  }              }
