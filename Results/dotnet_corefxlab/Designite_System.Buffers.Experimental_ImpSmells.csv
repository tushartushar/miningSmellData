Implementation smell,Namespace,Class,File,Method,Description
Complex Method,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,Cyclomatic complexity of the method is 9
Complex Method,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,IndexOfStraddling,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers,ReadOnlyBytes,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\ReadOnlyBytes.cs,TryGet,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers,ReadWriteBytes,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\ReadWriteBytes.cs,TryGet,Cyclomatic complexity of the method is 11
Long Parameter List,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,TryIndicesOf,The method has 5 parameters. Parameters: searchSpace' value' length' indices' numberOfIndices
Long Statement,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,The length of the statement  "                    OperationStatus status = transformation.Execute(spanToTransform' outputSpan' out int bytesConsumed' out int bytesWritten); " is 122.
Long Statement,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,The length of the statement  "                OperationStatus result = transformation.Execute(sourceSpan.Slice(afterMergeSlice)' outputSpan' out int consumed' out int written); " is 130.
Long Statement,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,IndexOfStraddling,The length of the statement  "            // we only need to search the end of the first buffer. More precisely' only up to value.Length - 1 bytes in the first buffer " is 124.
Long Statement,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,IndexOfStraddling,The length of the statement  "            // this check is a small optimization: if the first byte from the value does not exist in the bytesToSearchAgain' there is no reason to combine " is 143.
Long Statement,System.Buffers,Sequence,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\SequenceExtensions.cs,TryParse,The length of the statement  "                Span<byte> temp = stackalloc byte[11]; // TODO: it would be good to have APIs to return constants related to sizes of needed buffers " is 132.
Long Statement,System.Buffers.Text,SpanWriter,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Text\SpanWriter.cs,TryApplyTransformation,The length of the statement  "            if (status == OperationStatus.InvalidData || status == OperationStatus.NeedMoreData) throw new Exception("invalid value or transformation"); " is 140.
Long Statement,System.Buffers.Text,SpanWriter,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Text\SpanWriter.cs,WriteCore,The length of the statement  "                    var status = Buffers.Text.Encodings.Utf16.ToUtf8(text.AsReadOnlySpan().AsBytes()' Free' out var consumed' out var encoded); " is 123.
Magic Number,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,The following statement contains a magic number: while (source.TryGet(ref poisition' out var sourceBuffer))              {                  Span<byte> outputSpan = destination.Buffer;                  ReadOnlySpan<byte> sourceSpan = sourceBuffer.Span;                    if (!remainder.IsEmpty)                  {                      int leftOverBytes = remainder.Length;                      remainder.CopyTo(stackSpan);                      int amountToCopy = Math.Min(sourceSpan.Length' stackSpan.Length - leftOverBytes);                      sourceSpan.Slice(0' amountToCopy).CopyTo(stackSpan.Slice(leftOverBytes));                      int amountOfData = leftOverBytes + amountToCopy;                        Span<byte> spanToTransform = stackSpan.Slice(0' amountOfData);                        TryTransformWithRemainder:                      OperationStatus status = transformation.Execute(spanToTransform' outputSpan' out int bytesConsumed' out int bytesWritten);                      if (status != OperationStatus.Done)                      {                          destination.Advance(bytesWritten);                          spanToTransform = spanToTransform.Slice(bytesConsumed);                            if (status == OperationStatus.DestinationTooSmall)                          {                              destination.Enlarge();  // output buffer is too small                              outputSpan = destination.Buffer;                                if (outputSpan.Length - bytesWritten < 3)                              {                                  return; // no more output space' user decides what to do.                              }                              goto TryTransformWithRemainder;                          }                          else                          {                              if (status == OperationStatus.InvalidData)                              {                                  continue; // source buffer contains invalid bytes' user decides what to do for fallback                              }                                // at this point' status = TransformationStatus.NeedMoreSourceData                              // left over bytes in stack span                              remainder = spanToTransform;                          }                          continue;                      }                      else    // success                      {                          afterMergeSlice = bytesConsumed - remainder.Length;                          remainder = Span<byte>.Empty;                          destination.Advance(bytesWritten);                          outputSpan = destination.Buffer;                      }                  }                    TryTransform:                  OperationStatus result = transformation.Execute(sourceSpan.Slice(afterMergeSlice)' outputSpan' out int consumed' out int written);                  afterMergeSlice = 0;                  destination.Advance(written);                  sourceSpan = sourceSpan.Slice(consumed);                    if (result == OperationStatus.Done) continue;                    // Not successful                  if (result == OperationStatus.DestinationTooSmall)                  {                      destination.Enlarge();  // output buffer is too small                      outputSpan = destination.Buffer;                      if (outputSpan.Length - written < 3)                      {                          return; // no more output space' user decides what to do.                      }                      goto TryTransform;                  }                  else                  {                      if (result == OperationStatus.InvalidData)                      {                          continue; // source buffer contains invalid bytes' user decides what to do for fallback                      }                        // at this point' result = TransformationStatus.NeedMoreSourceData                      // left over bytes in source span                      remainder = sourceSpan;                  }              }
Magic Number,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,The following statement contains a magic number: while (source.TryGet(ref poisition' out var sourceBuffer))              {                  Span<byte> outputSpan = destination.Buffer;                  ReadOnlySpan<byte> sourceSpan = sourceBuffer.Span;                    if (!remainder.IsEmpty)                  {                      int leftOverBytes = remainder.Length;                      remainder.CopyTo(stackSpan);                      int amountToCopy = Math.Min(sourceSpan.Length' stackSpan.Length - leftOverBytes);                      sourceSpan.Slice(0' amountToCopy).CopyTo(stackSpan.Slice(leftOverBytes));                      int amountOfData = leftOverBytes + amountToCopy;                        Span<byte> spanToTransform = stackSpan.Slice(0' amountOfData);                        TryTransformWithRemainder:                      OperationStatus status = transformation.Execute(spanToTransform' outputSpan' out int bytesConsumed' out int bytesWritten);                      if (status != OperationStatus.Done)                      {                          destination.Advance(bytesWritten);                          spanToTransform = spanToTransform.Slice(bytesConsumed);                            if (status == OperationStatus.DestinationTooSmall)                          {                              destination.Enlarge();  // output buffer is too small                              outputSpan = destination.Buffer;                                if (outputSpan.Length - bytesWritten < 3)                              {                                  return; // no more output space' user decides what to do.                              }                              goto TryTransformWithRemainder;                          }                          else                          {                              if (status == OperationStatus.InvalidData)                              {                                  continue; // source buffer contains invalid bytes' user decides what to do for fallback                              }                                // at this point' status = TransformationStatus.NeedMoreSourceData                              // left over bytes in stack span                              remainder = spanToTransform;                          }                          continue;                      }                      else    // success                      {                          afterMergeSlice = bytesConsumed - remainder.Length;                          remainder = Span<byte>.Empty;                          destination.Advance(bytesWritten);                          outputSpan = destination.Buffer;                      }                  }                    TryTransform:                  OperationStatus result = transformation.Execute(sourceSpan.Slice(afterMergeSlice)' outputSpan' out int consumed' out int written);                  afterMergeSlice = 0;                  destination.Advance(written);                  sourceSpan = sourceSpan.Slice(consumed);                    if (result == OperationStatus.Done) continue;                    // Not successful                  if (result == OperationStatus.DestinationTooSmall)                  {                      destination.Enlarge();  // output buffer is too small                      outputSpan = destination.Buffer;                      if (outputSpan.Length - written < 3)                      {                          return; // no more output space' user decides what to do.                      }                      goto TryTransform;                  }                  else                  {                      if (result == OperationStatus.InvalidData)                      {                          continue; // source buffer contains invalid bytes' user decides what to do for fallback                      }                        // at this point' result = TransformationStatus.NeedMoreSourceData                      // left over bytes in source span                      remainder = sourceSpan;                  }              }
Magic Number,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,IndexOfStraddling,The following statement contains a magic number: if (bytesToSearchAgain.IndexOf(value[0]) != -1)              {                  var combinedBufferLength = value.Length << 1;                  var combined = combinedBufferLength < 128 ?                                          stackalloc byte[combinedBufferLength] :                                          // TODO (pri 3): I think this could be eliminated by chunking values                                          new byte[combinedBufferLength];                    bytesToSearchAgain.CopyTo(combined);                  int combinedLength = bytesToSearchAgain.Length + rest.CopyTo(combined.Slice(bytesToSearchAgain.Length));                  combined = combined.Slice(0' combinedLength);                    if (combined.Length < value.Length) return -1;                    index = combined.IndexOf(value);                  if (index != -1)                  {                      return index + bytesToSkipFromFirst;                  }              }
Magic Number,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,LocateFirstFoundByte,The following statement contains a magic number: return i * 8 + LocateFirstFoundByte(candidate);
Magic Number,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,LocateFirstFoundByte,The following statement contains a magic number: unchecked              {                  // Flag least significant power of two bit                  var powerOfTwoFlag = match ^ (match - 1);                  // Shift all powers of two into the high byte and extract                  return (int)((powerOfTwoFlag * xorPowerOfTwoToHighByte) >> 57);              }
Magic Number,System.Buffers,BufferExtensions,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,SetLowBitsForByteMatch,The following statement contains a magic number: unchecked              {                  var flaggedValue = potentialMatch ^ (byteBroadcastToUlong * search);                  return (                          (flaggedValue - byteBroadcastToUlong) &                          ~(flaggedValue) &                          filterByteHighBitsInUlong                         ) >> 7;              }
Magic Number,System.Buffers,MemoryList,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\MemoryList.cs,ToString,The following statement contains a magic number: for (int i = 0; i < Math.Min(5' _data.Length); i++)              {                  if (!first) { builder.Append("' "); }                  first = false;                  builder.Append(_data.Span[i]);                      }
Magic Number,System.Buffers,MemoryList,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\MemoryList.cs,ToString,The following statement contains a magic number: if(_data.Length > 5 || _next != null)              {                  builder.Append("' ...");              }
Magic Number,System.Buffers,Sequence,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\SequenceExtensions.cs,ToSpan,The following statement contains a magic number: ResizableArray<byte> array = new ResizableArray<byte>(1024);
Magic Number,System.Buffers,Sequence,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\SequenceExtensions.cs,TryParse,The following statement contains a magic number: if(sequence.TryGet(ref position' out ReadOnlyMemory<byte> memory))              {                  var span = memory.Span;                  if(Utf8Parser.TryParse(span' out value' out consumed) && consumed < span.Length)                  {                      return true;                  }                    Span<byte> temp = stackalloc byte[11]; // TODO: it would be good to have APIs to return constants related to sizes of needed buffers                  var copied = Copy(sequence' temp);                  // we need to slice temp' as we might stop zeroing stack allocated buffers                  if (Utf8Parser.TryParse(temp.Slice(0' copied)' out value' out consumed))                  {                      return true;                  }                    }
Magic Number,System.Buffers.Text,BytesReader,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Text\BytesReader.cs,TryParse,The following statement contains a magic number: Span<byte> tempSpan = stackalloc byte[5];
Magic Number,System.Buffers.Text,BytesReader,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Text\BytesReader.cs,TryParseStraddling,The following statement contains a magic number: Span<byte> tempSpan = stackalloc byte[15];
Magic Number,System.Buffers.Text,BytesReader,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Text\BytesReader.cs,TryParse,The following statement contains a magic number: Span<byte> tempSpan = stackalloc byte[30];
Magic Number,System.Buffers.Text,BytesReader,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Text\BytesReader.cs,TryRead,The following statement contains a magic number: Span<byte> span = stackalloc byte[4];
Magic Number,System.Buffers.Text,BytesReader,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Text\BytesReader.cs,TryRead,The following statement contains a magic number: if (copied < 4) {                  value = default;                  return false;              }
Magic Number,System.Buffers.Text,SpanWriter,C:\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Text\SpanWriter.cs,Write,The following statement contains a magic number: if (character > 127) throw new NotImplementedException();
