Implementation smell,Namespace,Class,File,Method,Description
Complex Method,System.Buffers,MemoryListExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,IndexOfStraddling,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,Cyclomatic complexity of the method is 11
Complex Method,System.Buffers,ReadWriteBytes,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\ReadWriteBytes.cs,Slice,Cyclomatic complexity of the method is 10
Complex Method,System.Buffers,ReadWriteBytes,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\ReadWriteBytes.cs,TryGet,Cyclomatic complexity of the method is 8
Complex Method,System.Buffers,Sequence,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\SequenceExtensions.cs,IndexOf,Cyclomatic complexity of the method is 8
Long Parameter List,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,TryIndicesOf,The method has 5 parameters. Parameters: searchSpace' value' length' indices' numberOfIndices
Long Statement,System.Buffers,MemoryListExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,IndexOfStraddling,The length of the statement  "            // we only need to search the end of the first buffer. More precisely' only up to value.Length - 1 bytes in the first buffer " is 124.
Long Statement,System.Buffers,MemoryListExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,IndexOfStraddling,The length of the statement  "            // this check is a small optimization: if the first byte from the value does not exist in the bytesToSearchAgain' there is no reason to combine " is 143.
Long Statement,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,The length of the statement  "                    OperationStatus status = transformation.Execute(spanToTransform' outputSpan' out int bytesConsumed' out int bytesWritten); " is 122.
Long Statement,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,The length of the statement  "                OperationStatus result = transformation.Execute(sourceSpan.Slice(afterMergeSlice)' outputSpan' out int consumed' out int written); " is 130.
Long Statement,System.Buffers,Sequence,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\SequenceExtensions.cs,TryParse,The length of the statement  "                Span<byte> temp = stackalloc byte[11]; // TODO: it would be good to have APIs to return constants related to sizes of needed buffers " is 132.
Long Statement,System.Buffers.Native,OwnedPinnedBuffer<T>,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Native\OwnedPinnedBuffer.cs,Pin,The length of the statement  "            if (elementIndex != 0 && (((uint)elementIndex) - 1) / Unsafe.SizeOf<T>() >= _array.Length) throw new ArgumentOutOfRangeException(nameof(elementIndex)); " is 151.
Magic Number,System.Buffers,MemoryListExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,IndexOfStraddling,The following statement contains a magic number: var combined = combinedBufferLength < 128 ?                                          stackalloc byte[combinedBufferLength] :                                          // TODO (pri 3): I think this could be eliminated by chunking values                                          new byte[combinedBufferLength];
Magic Number,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,The following statement contains a magic number: outputSpan.Length - bytesWritten < 3
Magic Number,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,Pipe,The following statement contains a magic number: outputSpan.Length - written < 3
Magic Number,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,LocateFirstFoundByte,The following statement contains a magic number: return i * 8 + LocateFirstFoundByte(candidate);
Magic Number,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,LocateFirstFoundByte,The following statement contains a magic number: return (int)((powerOfTwoFlag * xorPowerOfTwoToHighByte) >> 57);
Magic Number,System.Buffers,BufferExtensions,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\BufferExtensions.cs,SetLowBitsForByteMatch,The following statement contains a magic number: return (                          (flaggedValue - byteBroadcastToUlong) &                          ~(flaggedValue) &                          filterByteHighBitsInUlong                         ) >> 7;
Magic Number,System.Buffers,BufferList,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\BufferList.cs,ToString,The following statement contains a magic number: i < Math.Min(5' Memory.Length)
Magic Number,System.Buffers,BufferList,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\BufferList.cs,ToString,The following statement contains a magic number: Memory.Length > 5 || Next != null
Magic Number,System.Buffers,Sequence,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\SequenceExtensions.cs,ToSpan,The following statement contains a magic number: ResizableArray<byte> array = new ResizableArray<byte>(1024);
Magic Number,System.Buffers,Sequence,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\SequenceExtensions.cs,ToSpan,The following statement contains a magic number: ResizableArray<byte> array = new ResizableArray<byte>(1024);
Magic Number,System.Buffers,Sequence,D:\research\architectureSmells\repos\dotnet_corefxlab\src\System.Buffers.Experimental\System\Buffers\Sequences\SequenceExtensions.cs,TryParse,The following statement contains a magic number: Span<byte> temp = stackalloc byte[11];
