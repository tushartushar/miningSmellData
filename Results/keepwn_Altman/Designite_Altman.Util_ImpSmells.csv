Implementation smell,Namespace,Class,File,Method,Description
Long Method,Altman.Util.Logic,SettingXmlHandle,C:\repos\keepwn_Altman\Source\Altman.Util\Logic\SettingXmlHandle.cs,WriteXml,The method has 122 lines of code.
Long Method,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,DoHttpProcessing,The method has 178 lines of code.
Complex Method,Altman.Util.Share,IniValue,C:\repos\keepwn_Altman\Source\Altman.Util\Share\IniElement.cs,IniValue,Cyclomatic complexity of the method is 10
Complex Method,Altman.Util.Web,Http,C:\repos\keepwn_Altman\Source\Altman.Util\Web\Http.cs,CopyHeadersTo,Cyclomatic complexity of the method is 9
Complex Method,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,DoHttpProcessing,Cyclomatic complexity of the method is 13
Long Parameter List,Altman.Util.Controls,EditSubItemEventArgs,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\ListViewPlus.cs,EditSubItemEventArgs,The method has 6 parameters. Parameters: oldLabel' label' itemRowIndex' itemColumnIndex' userSate' isRemoveIfCancel
Long Parameter List,Altman.Util.Setting,Setting,C:\repos\keepwn_Altman\Source\Altman.Util\Setting\Setting.cs,Setting,The method has 5 parameters. Parameters: basic' userAgent' httpHeader' policy' proxy
Long Identifier,Altman.Util.Web,HttpClient,C:\repos\keepwn_Altman\Source\Altman.Util\Web\HttpClient.cs,SubmitCommandByPost,The length of the parameter isBindUploadProgressChangedEvent is 32.
Long Identifier,Altman.Util.Web,HttpClient,C:\repos\keepwn_Altman\Source\Altman.Util\Web\HttpClient.cs,SubmitCommandByPost,The length of the parameter isBindDownloadProgressChangedEvent is 34.
Long Statement,Altman.Util.Common.AltData,ResultMatch,C:\repos\keepwn_Altman\Source\Altman.Util\Common\AltData\ResultMatch.cs,MatchResultToFile,The length of the statement  "                    throw new ResponseCustomException(ExceptionTitle.MatchTheErrorInfoSucceeded.ToString()' encode.GetString(errBytes)' result); " is 124.
Long Statement,Altman.Util.Controls,ListViewPlus,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\ListViewPlus.cs,CreateOneTextBox,The length of the statement  "            _tmpTextBox.Bounds = new Rectangle(subItem.Bounds.Location' new Size(this.Columns[columnIndex].Width' subItem.Bounds.Height)); " is 126.
Long Statement,Altman.Util.Controls,ListViewPlus,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\ListViewPlus.cs,tmpTextBox_Leave,The length of the statement  "            EditSubItemEventArgs editSubItemArgs = new EditSubItemEventArgs(oldLabel' label' itemRowIndex' itemColumnIndex' userSate' isRemoveIfCancel); " is 140.
Long Statement,Altman.Util.Share,IniReader,C:\repos\keepwn_Altman\Source\Altman.Util\Share\Ini.cs,ReadSection,The length of the statement  "				throw new InvalidOperationException("The current position of the reader must be at IniSectionStart. Use GotoSection method"); " is 125.
Long Statement,Altman.Util.Share,IniSection,C:\repos\keepwn_Altman\Source\Altman.Util\Share\Ini.cs,SetComment,The length of the statement  "				throw new NotSupportedException("Comments are currently disabled. Setup ConfigFileSettings.CommentChars property to enable them."); " is 131.
Long Statement,Altman.Util.Web,Http,C:\repos\keepwn_Altman\Source\Altman.Util\Web\Http.cs,ProgressChanged,The length of the statement  "                    DownloadProgressChanged(null' new AltDownloadProgressChangedEventArgs(progress.BytesReceived' progress.TotalBytesToReceive)); " is 125.
Long Statement,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,DoHttpProcessing,The length of the statement  "                    //Console.WriteLine("{0} {1} HTTP/{2}"' webRequest.Method' webRequest.RequestUri.AbsoluteUri' webRequest.ProtocolVersion); " is 122.
Complex Conditional,Altman.Util.Logic,SettingXmlHandle,C:\repos\keepwn_Altman\Source\Altman.Util\Logic\SettingXmlHandle.cs,ReadProxyNode,The conditional expression  "c.Attributes["address"] == null                          ||c.Attributes["port"] == null                          ||c.Attributes["user"] == null                          ||c.Attributes["password"] == null                          ||c.Attributes["domain"] == null"  is complex.
Complex Conditional,Altman.Util.Share,IniReader,C:\repos\keepwn_Altman\Source\Altman.Util\Share\Ini.cs,GotoSection,The conditional expression  "sect != null &&  						(sect.SectionName == sectionName ||  						(!IniSettings.CaseSensitive && sect.SectionName.ToLowerInvariant() == sectionName))"  is complex.
Complex Conditional,Altman.Util.Share,IniReader,C:\repos\keepwn_Altman\Source\Altman.Util\Share\Ini.cs,GotoValue,The conditional expression  "val != null &&  						(val.Key == key || (!IniSettings.CaseSensitive && val.Key.ToLowerInvariant() == key.ToLowerInvariant()))"  is complex.
Complex Conditional,Altman.Util.Share,IniWriter,C:\repos\keepwn_Altman\Source\Altman.Util\Share\Ini.cs,OutputString,The conditional expression  "!( // 1) element is a blank line AND blank lines are not allowed  					(element is IniBlankLine && !IniSettings.AllowBlankLines)  					// 2) element is an empty value AND empty values are not allowed  					|| (!IniSettings.AllowEmptyValues && element is IniValue && ((IniValue)element).Value == ""))"  is complex.
Complex Conditional,Altman.Util.Share,IniWriter,C:\repos\keepwn_Altman\Source\Altman.Util\Share\Ini.cs,WriteElement,The conditional expression  "!( // 1) element is a blank line AND blank lines are not allowed  				(element is IniBlankLine && !IniSettings.AllowBlankLines)  				// 2) element is an empty value AND empty values are not allowed  				|| (!IniSettings.AllowEmptyValues && element is IniValue && ((IniValue)element).Value == ""))"  is complex.
Empty Catch Block,Altman.Util.Data,AccessHelper,C:\repos\keepwn_Altman\Source\Altman.Util\Data\AccessHelper.cs,GetDataReader,The method has an empty catch block.
Empty Catch Block,Altman.Util.Data,AccessHelper,C:\repos\keepwn_Altman\Source\Altman.Util\Data\AccessHelper.cs,GetDataReader,The method has an empty catch block.
Empty Catch Block,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,Listen,The method has an empty catch block.
Empty Catch Block,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,Listen,The method has an empty catch block.
Magic Number,Altman.Util.Common.AltData,DataConvert,C:\repos\keepwn_Altman\Source\Altman.Util\Common\AltData\DataConvert.cs,BytesToHexStr,The following statement contains a magic number: StringBuilder returnStr = new StringBuilder(1024);
Magic Number,Altman.Util.Common.AltData,DataConvert,C:\repos\keepwn_Altman\Source\Altman.Util\Common\AltData\DataConvert.cs,HexStrToBytes,The following statement contains a magic number: if ((hexString.Length % 2) != 0)                  hexString += " ";
Magic Number,Altman.Util.Common.AltData,DataConvert,C:\repos\keepwn_Altman\Source\Altman.Util\Common\AltData\DataConvert.cs,HexStrToBytes,The following statement contains a magic number: byte[] returnBytes = new byte[hexString.Length / 2];
Magic Number,Altman.Util.Common.AltData,DataConvert,C:\repos\keepwn_Altman\Source\Altman.Util\Common\AltData\DataConvert.cs,HexStrToBytes,The following statement contains a magic number: for (int i = 0; i < returnBytes.Length; i++)                  returnBytes[i] = Convert.ToByte(hexString.Substring(i * 2' 2)' 16);
Magic Number,Altman.Util.Common.AltData,DataConvert,C:\repos\keepwn_Altman\Source\Altman.Util\Common\AltData\DataConvert.cs,HexStrToBytes,The following statement contains a magic number: for (int i = 0; i < returnBytes.Length; i++)                  returnBytes[i] = Convert.ToByte(hexString.Substring(i * 2' 2)' 16);
Magic Number,Altman.Util.Common.AltData,DataConvert,C:\repos\keepwn_Altman\Source\Altman.Util\Common\AltData\DataConvert.cs,HexStrToBytes,The following statement contains a magic number: for (int i = 0; i < returnBytes.Length; i++)                  returnBytes[i] = Convert.ToByte(hexString.Substring(i * 2' 2)' 16);
Magic Number,Altman.Util.Common.AltData,DataConvert,C:\repos\keepwn_Altman\Source\Altman.Util\Common\AltData\DataConvert.cs,GetParma,The following statement contains a magic number: foreach (string str in tmp)              {                  string[] nameValue = str.Split('=');                  if (nameValue.Length == 2)                  {                      items.Add(nameValue[0]' nameValue[1]);                  }                  else                  {                      throw new Exception("Split data to nameValueCollection failed");                  }              }
Magic Number,Altman.Util.Controls,ListViewPlus,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\ListViewPlus.cs,tmpTextBox_Leave,The following statement contains a magic number: string userSate = tmpIndex[2];
Magic Number,Altman.Util.Controls,ListViewPlus,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\ListViewPlus.cs,tmpTextBox_Leave,The following statement contains a magic number: bool isRemoveIfCancel = bool.Parse(tmpIndex[3]);
Magic Number,Altman.Util.Controls,ListViewPlus,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\ListViewPlus.cs,tmpTextBox_KeyDown,The following statement contains a magic number: if ((int)e.KeyCode == 13)              {                  e.SuppressKeyPress = true;              }
Magic Number,Altman.Util.Controls,TextBoxShell,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\TextBoxShell.cs,ShellTextBox_KeyPress,The following statement contains a magic number: if (e.KeyChar == (char)8 && IsCaretJustBeforePrompt())              {                  e.Handled = true;                  return;              }
Magic Number,Altman.Util.Controls,TextBoxShell,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\TextBoxShell.cs,IsTerminatorKey,The following statement contains a magic number: return ((int)keyChar) == 13;
Magic Number,Altman.Util.Controls,TextBoxShell,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\TextBoxShell.cs,PrintCommandResult,The following statement contains a magic number: if (this.InvokeRequired)              {                  PrintCommandResultClient c = new PrintCommandResultClient(PrintCommandResult);                  this.Invoke(c' new object[1] { result });//通过代理调用刷新方法              }              else              {                  PrintLine(1);                  AddResultText(result ?? "");                  PrintLine(2);                  PrintPrompt();              }
Magic Number,Altman.Util.Controls,TextBoxShell,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\TextBoxShell.cs,ClearContext,The following statement contains a magic number: if (this.InvokeRequired)              {                  ClearContextClient c = new ClearContextClient(ClearContext);                  this.Invoke(c);//通过代理调用刷新方法              }              else              {                  string[] sLines = this.Lines;                    string[] sNewLines = new string[2];                        Array.Copy(sLines'0'sNewLines'0'sNewLines.Length);                  this.Lines = sNewLines;                  PrintLine(2);                  PrintPrompt();              }
Magic Number,Altman.Util.Controls,TextBoxShell,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\TextBoxShell.cs,ClearContext,The following statement contains a magic number: if (this.InvokeRequired)              {                  ClearContextClient c = new ClearContextClient(ClearContext);                  this.Invoke(c);//通过代理调用刷新方法              }              else              {                  string[] sLines = this.Lines;                    string[] sNewLines = new string[2];                        Array.Copy(sLines'0'sNewLines'0'sNewLines.Length);                  this.Lines = sNewLines;                  PrintLine(2);                  PrintPrompt();              }
Magic Number,Altman.Util.Controls,TextBoxShell,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\TextBoxShell.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(400' 176);
Magic Number,Altman.Util.Controls,TextBoxShell,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\TextBoxShell.cs,InitializeComponent,The following statement contains a magic number: this.Size = new System.Drawing.Size(400' 176);
Magic Number,Altman.Util.Logic,SettingXmlHandle,C:\repos\keepwn_Altman\Source\Altman.Util\Logic\SettingXmlHandle.cs,ReadProxyNode,The following statement contains a magic number: foreach (XmlNode c in child.ChildNodes)              {                  if (c.Name == "type")                  {                      int tmp;                      string type = c.InnerText;                      switch (type)                      {                          case "1":                              tmp = 1;                              break;                          case "2":                              tmp = 2;                              break;                          default:                              tmp = 0;                              break;                      }                      proxy.IsNoOrIeOrCustomProxy = tmp;                  }                  else if (c.Name == "customProxy")                  {                      //判断属性是否存在                      if (c.Attributes["address"] == null                          ||c.Attributes["port"] == null                          ||c.Attributes["user"] == null                          ||c.Attributes["password"] == null                          ||c.Attributes["domain"] == null) continue;                        string address = c.Attributes["address"].Value;                      string port = c.Attributes["port"].Value;                      string user = c.Attributes["user"].Value;                      string password = c.Attributes["password"].Value;                      string domain = c.Attributes["domain"].Value;                        proxy.ProxyAddr = address;                      proxy.ProxyPort = port;                      proxy.ProxyUser = user;                      proxy.ProxyPassword = password;                      proxy.ProxyDomain = domain;                  }              }
Magic Number,Altman.Util.Share,IniValue,C:\repos\keepwn_Altman\Source\Altman.Util\Share\IniElement.cs,IniValue,The following statement contains a magic number: string[] split = Content.Split(new[] {IniSettings.EqualsString}' 2' StringSplitOptions.None);
Magic Number,Altman.Util.Share,IniValue,C:\repos\keepwn_Altman\Source\Altman.Util\Share\IniElement.cs,IniValue,The following statement contains a magic number: if (split0.Length > 0)  			{  				if (IniSettings.AllowInlineComments)  				{  					IniSettings.IndexOfAnyResult result = IniSettings.IndexOfAny(split1' IniSettings.CommentChars);  					if (result.index != -1)  					{  						_inlineComment = split1.Substring(result.index + result.any.Length);  						split1 = split1.Substring(0' result.index).TrimEnd();  						_inlineCommentChar = result.any;  					}  				}  				if (IniSettings.QuoteChar != null && split1.Length >= 2)  				{  					var quoteChar = (char) IniSettings.QuoteChar;  					if (split1[0] == quoteChar)  					{  						int lastQuotePos;  						if (IniSettings.AllowTextOnTheRight)  						{  							lastQuotePos = split1.LastIndexOf(quoteChar);  							if (lastQuotePos != split1.Length - 1)  								_textOnTheRight = split1.Substring(lastQuotePos + 1);  						}  						else  							lastQuotePos = split1.Length - 1;  						if (lastQuotePos > 0)  						{  							if (split1.Length == 2)  								split1 = "";  							else  								split1 = split1.Substring(1' lastQuotePos - 1);  						}  					}  				}  				_key = split0;  				_value = split1;  			}
Magic Number,Altman.Util.Share,IniValue,C:\repos\keepwn_Altman\Source\Altman.Util\Share\IniElement.cs,IniValue,The following statement contains a magic number: if (split0.Length > 0)  			{  				if (IniSettings.AllowInlineComments)  				{  					IniSettings.IndexOfAnyResult result = IniSettings.IndexOfAny(split1' IniSettings.CommentChars);  					if (result.index != -1)  					{  						_inlineComment = split1.Substring(result.index + result.any.Length);  						split1 = split1.Substring(0' result.index).TrimEnd();  						_inlineCommentChar = result.any;  					}  				}  				if (IniSettings.QuoteChar != null && split1.Length >= 2)  				{  					var quoteChar = (char) IniSettings.QuoteChar;  					if (split1[0] == quoteChar)  					{  						int lastQuotePos;  						if (IniSettings.AllowTextOnTheRight)  						{  							lastQuotePos = split1.LastIndexOf(quoteChar);  							if (lastQuotePos != split1.Length - 1)  								_textOnTheRight = split1.Substring(lastQuotePos + 1);  						}  						else  							lastQuotePos = split1.Length - 1;  						if (lastQuotePos > 0)  						{  							if (split1.Length == 2)  								split1 = "";  							else  								split1 = split1.Substring(1' lastQuotePos - 1);  						}  					}  				}  				_key = split0;  				_value = split1;  			}
Magic Number,Altman.Util.Web,Http,C:\repos\keepwn_Altman\Source\Altman.Util\Web\Http.cs,Http,The following statement contains a magic number: ServicePointManager.DefaultConnectionLimit = 512;
Magic Number,Altman.Util.Web,Http,C:\repos\keepwn_Altman\Source\Altman.Util\Web\Http.cs,WriteBytesToStream,The following statement contains a magic number: const int chunkSize = 1024;
Magic Number,Altman.Util.Web,Http,C:\repos\keepwn_Altman\Source\Altman.Util\Web\Http.cs,ReadBytesFromStream,The following statement contains a magic number: const int bufferLen = 4096;
Magic Number,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,DoHttpProcessing,The following statement contains a magic number: try              {                  //读取第一行（http cmd）                  String httpCmd = clientStreamReader.ReadLine();                  if (String.IsNullOrEmpty(httpCmd))                  {                      clientStreamReader.Close();                      return;                  }                  //分割为3段                  String[] splitBuffer = httpCmd.Split(spaceSplit' 3);                    String method = splitBuffer[0];                  String remoteUri = splitBuffer[1];                  Version version = new Version(1' 0);                    HttpWebRequest webRequest;                  HttpWebResponse webResponse = null;                    /**                   * http包发往代理服务器时，方法包括（get'post'connect）                   * 当方法为connect时，表示ssl连接                   */                  if (splitBuffer[0].ToUpper() == "CONNECT")                  {                      //                      remoteUri = "https://" + splitBuffer[1];                      while (!String.IsNullOrEmpty(clientStreamReader.ReadLine())) { }                      StreamWriter connectStreamWriter = new StreamWriter(clientStream);                      connectStreamWriter.WriteLine("HTTP/1.0 200 Connection established");                      connectStreamWriter.WriteLine("Timestamp: {0}"' DateTime.Now.ToString());                      connectStreamWriter.WriteLine("Proxy-agent: altman-agent");                      connectStreamWriter.WriteLine();                      connectStreamWriter.Flush();                        sslStream = new SslStream(clientStream' false);                      try                      {                          //进行身份验证                          sslStream.AuthenticateAsServer(_certificate' false' SslProtocols.Tls | SslProtocols.Ssl3 | SslProtocols.Ssl2' true);                      }                      catch (Exception)                      {                          sslStream.Close();                          clientStreamReader.Close();                          connectStreamWriter.Close();                          clientStream.Close();                          return;                      }                        //创建https，加密client的通信                      clientStream = sslStream;                      clientStreamReader = new StreamReader(sslStream);                      outStream = sslStream;                      //读取新的http cmd                      httpCmd = clientStreamReader.ReadLine();                      if (String.IsNullOrEmpty(httpCmd))                      {                          clientStreamReader.Close();                          clientStream.Close();                          sslStream.Close();                          return;                      }                      splitBuffer = httpCmd.Split(spaceSplit' 3);                      method = splitBuffer[0];                      remoteUri = remoteUri + splitBuffer[1];                  }                    //重新组合客户端请求的第一行                  webRequest = (HttpWebRequest)HttpWebRequest.Create(remoteUri);                  webRequest.Method = method;                  webRequest.ProtocolVersion = version;                    //读取客户端请求的headers，并复制                  int contentLen = ReadRequestHeaders(clientStreamReader' webRequest);                    webRequest.Proxy = null;                  webRequest.KeepAlive = false;                  webRequest.AllowAutoRedirect = false;                  webRequest.AutomaticDecompression = DecompressionMethods.None;                    //打印headers                  if (Server.DumpHeaders)                  {                      //Console.WriteLine("{0} {1} HTTP/{2}"' webRequest.Method' webRequest.RequestUri.AbsoluteUri' webRequest.ProtocolVersion);                      DumpHeaderCollectionToConsole(webRequest.Headers);                  }                    if (method.ToUpper() == "GET")                  {                      //                  }                  else if (method.ToUpper() == "POST")                  {                      char[] postBuffer = new char[contentLen];                      int bytesRead;                      int totalBytesRead = 0;                      StreamWriter sw = new StreamWriter(webRequest.GetRequestStream());                      while (totalBytesRead < contentLen &&                             (bytesRead = clientStreamReader.ReadBlock(postBuffer' 0' contentLen)) > 0)                      {                          totalBytesRead += bytesRead;                          sw.Write(postBuffer' 0' bytesRead);                          if (Server.DumpPostData)                          {                              if (ProxyReceiveToDo != null)                                  ProxyReceiveToDo(null' new ProxyReceiveEventArgs(new string(postBuffer)));                          }                      }                        sw.Close();                  }                    webRequest.Timeout = 15000;                    try                  {                      webResponse = (HttpWebResponse)webRequest.GetResponse();                  }                  catch (WebException webEx)                  {                      webResponse = webEx.Response as HttpWebResponse;                  }                  if (webResponse != null)                  {                      List<Tuple<String' String>> responseHeaders = ProcessResponse(webResponse);                      StreamWriter myResponseWriter = new StreamWriter(outStream);                      Stream responseStream = webResponse.GetResponseStream();                      try                      {                          //发送response状态码和headers                          WriteResponseStatus(webResponse.StatusCode' webResponse.StatusDescription' myResponseWriter);                          WriteResponseHeaders(myResponseWriter' responseHeaders);                            Byte[] buffer;                          if (webResponse.ContentLength > 0)                              buffer = new Byte[webResponse.ContentLength];                          else                              buffer = new Byte[BUFFER_SIZE];                            int bytesRead;                            while ((bytesRead = responseStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              outStream.Write(buffer' 0' bytesRead);                              if (Server.DumpResponseData)                              {                                  if (ProxyReceiveToDo != null)                                      ProxyReceiveToDo(null' new ProxyReceiveEventArgs(Encoding.Default.GetString(buffer' 0' bytesRead)));                              }                          }                            responseStream.Close();                          outStream.Flush();                      }                      catch (Exception ex)                      {                          Console.WriteLine(ex.Message);                      }                      finally                      {                          responseStream.Close();                          webResponse.Close();                          myResponseWriter.Close();                      }                  }              }              catch (Exception ex)              {                  Console.WriteLine(ex.Message);              }              finally              {                  if (Server.DumpHeaders || Server.DumpPostData || Server.DumpResponseData)                  {                      //release the lock                      Monitor.Exit(_outputLockObj);                  }                    clientStreamReader.Close();                  clientStream.Close();                  if (sslStream != null)                      sslStream.Close();                  outStream.Close();              }
Magic Number,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,DoHttpProcessing,The following statement contains a magic number: try              {                  //读取第一行（http cmd）                  String httpCmd = clientStreamReader.ReadLine();                  if (String.IsNullOrEmpty(httpCmd))                  {                      clientStreamReader.Close();                      return;                  }                  //分割为3段                  String[] splitBuffer = httpCmd.Split(spaceSplit' 3);                    String method = splitBuffer[0];                  String remoteUri = splitBuffer[1];                  Version version = new Version(1' 0);                    HttpWebRequest webRequest;                  HttpWebResponse webResponse = null;                    /**                   * http包发往代理服务器时，方法包括（get'post'connect）                   * 当方法为connect时，表示ssl连接                   */                  if (splitBuffer[0].ToUpper() == "CONNECT")                  {                      //                      remoteUri = "https://" + splitBuffer[1];                      while (!String.IsNullOrEmpty(clientStreamReader.ReadLine())) { }                      StreamWriter connectStreamWriter = new StreamWriter(clientStream);                      connectStreamWriter.WriteLine("HTTP/1.0 200 Connection established");                      connectStreamWriter.WriteLine("Timestamp: {0}"' DateTime.Now.ToString());                      connectStreamWriter.WriteLine("Proxy-agent: altman-agent");                      connectStreamWriter.WriteLine();                      connectStreamWriter.Flush();                        sslStream = new SslStream(clientStream' false);                      try                      {                          //进行身份验证                          sslStream.AuthenticateAsServer(_certificate' false' SslProtocols.Tls | SslProtocols.Ssl3 | SslProtocols.Ssl2' true);                      }                      catch (Exception)                      {                          sslStream.Close();                          clientStreamReader.Close();                          connectStreamWriter.Close();                          clientStream.Close();                          return;                      }                        //创建https，加密client的通信                      clientStream = sslStream;                      clientStreamReader = new StreamReader(sslStream);                      outStream = sslStream;                      //读取新的http cmd                      httpCmd = clientStreamReader.ReadLine();                      if (String.IsNullOrEmpty(httpCmd))                      {                          clientStreamReader.Close();                          clientStream.Close();                          sslStream.Close();                          return;                      }                      splitBuffer = httpCmd.Split(spaceSplit' 3);                      method = splitBuffer[0];                      remoteUri = remoteUri + splitBuffer[1];                  }                    //重新组合客户端请求的第一行                  webRequest = (HttpWebRequest)HttpWebRequest.Create(remoteUri);                  webRequest.Method = method;                  webRequest.ProtocolVersion = version;                    //读取客户端请求的headers，并复制                  int contentLen = ReadRequestHeaders(clientStreamReader' webRequest);                    webRequest.Proxy = null;                  webRequest.KeepAlive = false;                  webRequest.AllowAutoRedirect = false;                  webRequest.AutomaticDecompression = DecompressionMethods.None;                    //打印headers                  if (Server.DumpHeaders)                  {                      //Console.WriteLine("{0} {1} HTTP/{2}"' webRequest.Method' webRequest.RequestUri.AbsoluteUri' webRequest.ProtocolVersion);                      DumpHeaderCollectionToConsole(webRequest.Headers);                  }                    if (method.ToUpper() == "GET")                  {                      //                  }                  else if (method.ToUpper() == "POST")                  {                      char[] postBuffer = new char[contentLen];                      int bytesRead;                      int totalBytesRead = 0;                      StreamWriter sw = new StreamWriter(webRequest.GetRequestStream());                      while (totalBytesRead < contentLen &&                             (bytesRead = clientStreamReader.ReadBlock(postBuffer' 0' contentLen)) > 0)                      {                          totalBytesRead += bytesRead;                          sw.Write(postBuffer' 0' bytesRead);                          if (Server.DumpPostData)                          {                              if (ProxyReceiveToDo != null)                                  ProxyReceiveToDo(null' new ProxyReceiveEventArgs(new string(postBuffer)));                          }                      }                        sw.Close();                  }                    webRequest.Timeout = 15000;                    try                  {                      webResponse = (HttpWebResponse)webRequest.GetResponse();                  }                  catch (WebException webEx)                  {                      webResponse = webEx.Response as HttpWebResponse;                  }                  if (webResponse != null)                  {                      List<Tuple<String' String>> responseHeaders = ProcessResponse(webResponse);                      StreamWriter myResponseWriter = new StreamWriter(outStream);                      Stream responseStream = webResponse.GetResponseStream();                      try                      {                          //发送response状态码和headers                          WriteResponseStatus(webResponse.StatusCode' webResponse.StatusDescription' myResponseWriter);                          WriteResponseHeaders(myResponseWriter' responseHeaders);                            Byte[] buffer;                          if (webResponse.ContentLength > 0)                              buffer = new Byte[webResponse.ContentLength];                          else                              buffer = new Byte[BUFFER_SIZE];                            int bytesRead;                            while ((bytesRead = responseStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              outStream.Write(buffer' 0' bytesRead);                              if (Server.DumpResponseData)                              {                                  if (ProxyReceiveToDo != null)                                      ProxyReceiveToDo(null' new ProxyReceiveEventArgs(Encoding.Default.GetString(buffer' 0' bytesRead)));                              }                          }                            responseStream.Close();                          outStream.Flush();                      }                      catch (Exception ex)                      {                          Console.WriteLine(ex.Message);                      }                      finally                      {                          responseStream.Close();                          webResponse.Close();                          myResponseWriter.Close();                      }                  }              }              catch (Exception ex)              {                  Console.WriteLine(ex.Message);              }              finally              {                  if (Server.DumpHeaders || Server.DumpPostData || Server.DumpResponseData)                  {                      //release the lock                      Monitor.Exit(_outputLockObj);                  }                    clientStreamReader.Close();                  clientStream.Close();                  if (sslStream != null)                      sslStream.Close();                  outStream.Close();              }
Magic Number,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,DoHttpProcessing,The following statement contains a magic number: try              {                  //读取第一行（http cmd）                  String httpCmd = clientStreamReader.ReadLine();                  if (String.IsNullOrEmpty(httpCmd))                  {                      clientStreamReader.Close();                      return;                  }                  //分割为3段                  String[] splitBuffer = httpCmd.Split(spaceSplit' 3);                    String method = splitBuffer[0];                  String remoteUri = splitBuffer[1];                  Version version = new Version(1' 0);                    HttpWebRequest webRequest;                  HttpWebResponse webResponse = null;                    /**                   * http包发往代理服务器时，方法包括（get'post'connect）                   * 当方法为connect时，表示ssl连接                   */                  if (splitBuffer[0].ToUpper() == "CONNECT")                  {                      //                      remoteUri = "https://" + splitBuffer[1];                      while (!String.IsNullOrEmpty(clientStreamReader.ReadLine())) { }                      StreamWriter connectStreamWriter = new StreamWriter(clientStream);                      connectStreamWriter.WriteLine("HTTP/1.0 200 Connection established");                      connectStreamWriter.WriteLine("Timestamp: {0}"' DateTime.Now.ToString());                      connectStreamWriter.WriteLine("Proxy-agent: altman-agent");                      connectStreamWriter.WriteLine();                      connectStreamWriter.Flush();                        sslStream = new SslStream(clientStream' false);                      try                      {                          //进行身份验证                          sslStream.AuthenticateAsServer(_certificate' false' SslProtocols.Tls | SslProtocols.Ssl3 | SslProtocols.Ssl2' true);                      }                      catch (Exception)                      {                          sslStream.Close();                          clientStreamReader.Close();                          connectStreamWriter.Close();                          clientStream.Close();                          return;                      }                        //创建https，加密client的通信                      clientStream = sslStream;                      clientStreamReader = new StreamReader(sslStream);                      outStream = sslStream;                      //读取新的http cmd                      httpCmd = clientStreamReader.ReadLine();                      if (String.IsNullOrEmpty(httpCmd))                      {                          clientStreamReader.Close();                          clientStream.Close();                          sslStream.Close();                          return;                      }                      splitBuffer = httpCmd.Split(spaceSplit' 3);                      method = splitBuffer[0];                      remoteUri = remoteUri + splitBuffer[1];                  }                    //重新组合客户端请求的第一行                  webRequest = (HttpWebRequest)HttpWebRequest.Create(remoteUri);                  webRequest.Method = method;                  webRequest.ProtocolVersion = version;                    //读取客户端请求的headers，并复制                  int contentLen = ReadRequestHeaders(clientStreamReader' webRequest);                    webRequest.Proxy = null;                  webRequest.KeepAlive = false;                  webRequest.AllowAutoRedirect = false;                  webRequest.AutomaticDecompression = DecompressionMethods.None;                    //打印headers                  if (Server.DumpHeaders)                  {                      //Console.WriteLine("{0} {1} HTTP/{2}"' webRequest.Method' webRequest.RequestUri.AbsoluteUri' webRequest.ProtocolVersion);                      DumpHeaderCollectionToConsole(webRequest.Headers);                  }                    if (method.ToUpper() == "GET")                  {                      //                  }                  else if (method.ToUpper() == "POST")                  {                      char[] postBuffer = new char[contentLen];                      int bytesRead;                      int totalBytesRead = 0;                      StreamWriter sw = new StreamWriter(webRequest.GetRequestStream());                      while (totalBytesRead < contentLen &&                             (bytesRead = clientStreamReader.ReadBlock(postBuffer' 0' contentLen)) > 0)                      {                          totalBytesRead += bytesRead;                          sw.Write(postBuffer' 0' bytesRead);                          if (Server.DumpPostData)                          {                              if (ProxyReceiveToDo != null)                                  ProxyReceiveToDo(null' new ProxyReceiveEventArgs(new string(postBuffer)));                          }                      }                        sw.Close();                  }                    webRequest.Timeout = 15000;                    try                  {                      webResponse = (HttpWebResponse)webRequest.GetResponse();                  }                  catch (WebException webEx)                  {                      webResponse = webEx.Response as HttpWebResponse;                  }                  if (webResponse != null)                  {                      List<Tuple<String' String>> responseHeaders = ProcessResponse(webResponse);                      StreamWriter myResponseWriter = new StreamWriter(outStream);                      Stream responseStream = webResponse.GetResponseStream();                      try                      {                          //发送response状态码和headers                          WriteResponseStatus(webResponse.StatusCode' webResponse.StatusDescription' myResponseWriter);                          WriteResponseHeaders(myResponseWriter' responseHeaders);                            Byte[] buffer;                          if (webResponse.ContentLength > 0)                              buffer = new Byte[webResponse.ContentLength];                          else                              buffer = new Byte[BUFFER_SIZE];                            int bytesRead;                            while ((bytesRead = responseStream.Read(buffer' 0' buffer.Length)) > 0)                          {                              outStream.Write(buffer' 0' bytesRead);                              if (Server.DumpResponseData)                              {                                  if (ProxyReceiveToDo != null)                                      ProxyReceiveToDo(null' new ProxyReceiveEventArgs(Encoding.Default.GetString(buffer' 0' bytesRead)));                              }                          }                            responseStream.Close();                          outStream.Flush();                      }                      catch (Exception ex)                      {                          Console.WriteLine(ex.Message);                      }                      finally                      {                          responseStream.Close();                          webResponse.Close();                          myResponseWriter.Close();                      }                  }              }              catch (Exception ex)              {                  Console.WriteLine(ex.Message);              }              finally              {                  if (Server.DumpHeaders || Server.DumpPostData || Server.DumpResponseData)                  {                      //release the lock                      Monitor.Exit(_outputLockObj);                  }                    clientStreamReader.Close();                  clientStream.Close();                  if (sslStream != null)                      sslStream.Close();                  outStream.Close();              }
Magic Number,Altman.Util.Web,ProxyServer,C:\repos\keepwn_Altman\Source\Altman.Util\Web\ProxyServer.cs,ReadRequestHeaders,The following statement contains a magic number: do              {                  httpCmd = sr.ReadLine();                  if (String.IsNullOrEmpty(httpCmd))                      return contentLength;                  String[] header = httpCmd.Split(colonSpaceSplit' 2' StringSplitOptions.None);                  switch (header[0].ToLower())                  {                      case "host":                          webRequest.Host = header[1];                          break;                      case "user-agent":                          webRequest.UserAgent = header[1];                          break;                      case "accept":                          webRequest.Accept = header[1];                          break;                      case "referer":                          webRequest.Referer = header[1];                          break;                      case "cookie":                          webRequest.Headers["Cookie"] = header[1];                          break;                      case "proxy-connection":                      case "connection":                      case "keep-alive":                          //ignore these                          break;                      case "content-length":                          int.TryParse(header[1]' out contentLength);                          break;                      case "content-type":                          webRequest.ContentType = header[1];                          break;                      //case "expect":                      //    webRequest.Expect = header[1];                      //    break;                      case "if-modified-since":                          String[] sb = header[1].Trim().Split(semicolonSplit);                          DateTime d;                          if (DateTime.TryParse(sb[0]' out d))                              webRequest.IfModifiedSince = d;                          break;                      default:                          try                          {                              webRequest.Headers.Add(header[0]' header[1]);                          }                          catch (Exception ex)                          {                              Console.WriteLine("Could not add header {0}.  Exception message:{1}"' header[0]' ex.Message);                          }                          break;                  }              } while (!String.IsNullOrWhiteSpace(httpCmd));
Missing Default,Altman.Util.Controls,TextBoxShell,C:\repos\keepwn_Altman\Source\Altman.Util\Controls\TextBoxShell.cs,WndProc,The following switch statement is missing a default case: switch (m.Msg)              {                  case 0x0302: //WM_PASTE                  case 0x0300: //WM_CUT                  case 0x000C: //WM_SETTEXT                      if (!IsCaretAtWritablePosition())                          MoveCaretToEndOfText();                      break;                  case 0x0303: //WM_CLEAR                      return;              }
