Implementation smell,Namespace,Class,File,Method,Description
Long Method,DbLinq.Data.Linq.Sugar.Expressions,SpecialExpression,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Expressions\SpecialExpression.cs,Execute,The method has 117 lines of code.
Long Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionQualifier,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionQualifier.cs,GetPrecedence,The method has 137 lines of code.
Long Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Database,The method has 102 lines of code.
Long Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Column,The method has 101 lines of code.
Complex Method,DbLinq.Firebird,FirebirdVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Firebird\FirebirdVendor.cs,ExecuteMethodCall,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Ingres,IngresVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Ingres\IngresVendor.cs,ExecuteMethodCall,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.MySql,MySqlVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.MySql\MySqlVendor.cs,BulkInsert,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.MySql,MySqlVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.MySql\MySqlVendor.cs,ExecuteMethodCall,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.PostgreSql,PostgreSqlVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.PostgreSql\PgsqlVendor.cs,ExecuteMethodCall,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Sqlite.Schema,DataCommand,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Sqlite\Schema\DataCommand.cs,Find,Cyclomatic complexity of the method is 11
Complex Method,DbLinq.Sqlite,SqliteVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Sqlite\SqliteVendor.cs,ExecuteMethodCall,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SubmitChangesImpl,Cyclomatic complexity of the method is 20
Complex Method,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,FillReferencedObjects,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntityRefQueries,Cyclomatic complexity of the method is 11
Complex Method,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntitySetsQueries,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,GetChangeSet,Cyclomatic complexity of the method is 13
Complex Method,DbLinq.Data.Linq.Database.Implementation,DatabaseConnection,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Database\Implementation\DatabaseConnection.cs,DatabaseConnection,Cyclomatic complexity of the method is 9
Complex Method,DbLinq.Data.Linq.Implementation,EntityTracker,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Implementation\EntityTracker.cs,RegisterToInsert,Cyclomatic complexity of the method is 11
Complex Method,DbLinq.Data.Linq.Implementation,EntityTracker,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Implementation\EntityTracker.cs,RegisterToWatch,Cyclomatic complexity of the method is 12
Complex Method,DbLinq.Data.Linq.Implementation,EntityTracker,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Implementation\EntityTracker.cs,RegisterToDelete,Cyclomatic complexity of the method is 13
Complex Method,DbLinq.Data.Linq.Implementation,EntityTracker,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Implementation\EntityTracker.cs,RegisterDeleted,Cyclomatic complexity of the method is 9
Complex Method,DbLinq.Data.Linq.Mapping,LambdaMetaAccessor,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Mapping\LambdaMetaAccessor.cs,Create,Cyclomatic complexity of the method is 11
Complex Method,DbLinq.Data.Linq.Sql,SqlStatementBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sql\SqlStatementBuilder.cs,AppendFormat,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Data.Linq.Sugar.ExpressionMutator.Implementation,BinaryExpressionMutator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionMutator\Implementation\BinaryExpressionMutator.cs,Mutate,Cyclomatic complexity of the method is 47
Complex Method,DbLinq.Data.Linq.Sugar.ExpressionMutator.Implementation,UnaryExpressionMutator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionMutator\Implementation\UnaryExpressionMutator.cs,Mutate,Cyclomatic complexity of the method is 15
Complex Method,DbLinq.Data.Linq.Sugar.Expressions,SpecialExpression,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Expressions\SpecialExpression.cs,GetSpecialExpressionTypeType,Cyclomatic complexity of the method is 44
Complex Method,DbLinq.Data.Linq.Sugar.Expressions,SpecialExpression,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Expressions\SpecialExpression.cs,Execute,Cyclomatic complexity of the method is 58
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,Cyclomatic complexity of the method is 21
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,Analyze,Cyclomatic complexity of the method is 38
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeQueryableCall,Cyclomatic complexity of the method is 34
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeStringCall,Cyclomatic complexity of the method is 17
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeMathCall,Cyclomatic complexity of the method is 11
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeProjectionQuery,Cyclomatic complexity of the method is 11
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeMember,Cyclomatic complexity of the method is 14
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,Cyclomatic complexity of the method is 33
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeDateTimeMemberAccess,Cyclomatic complexity of the method is 11
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,FindTable,Cyclomatic complexity of the method is 10
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeAny,Cyclomatic complexity of the method is 11
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ParameterBinder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Registrar.cs,Visit,Cyclomatic complexity of the method is 12
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionOptimizer,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionOptimizer.cs,AnalyzeNot,Cyclomatic complexity of the method is 10
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionQualifier,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionQualifier.cs,GetPrecedence,Cyclomatic complexity of the method is 89
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,ExpressionQualifier,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionQualifier.cs,GetTier,Cyclomatic complexity of the method is 60
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetUpsertParameters,Cyclomatic complexity of the method is 9
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,QueryRunner,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryRunner.cs,Select,Cyclomatic complexity of the method is 10
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,QueryRunner,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryRunner.cs,Upsert,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,SpecialExpressionTranslator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SpecialExpressionTranslator.cs,Translate,Cyclomatic complexity of the method is 25
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,SqlBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SqlBuilder.cs,BuildExpression,Cyclomatic complexity of the method is 13
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,SqlBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SqlBuilder.cs,BuildJoin,Cyclomatic complexity of the method is 15
Complex Method,DbLinq.Data.Linq.Sugar.Implementation,SqlBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SqlBuilder.cs,BuildSelect,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Database,Cyclomatic complexity of the method is 23
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Table,Cyclomatic complexity of the method is 17
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Function,Cyclomatic complexity of the method is 19
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Connection,Cyclomatic complexity of the method is 14
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunction,Cyclomatic complexity of the method is 13
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Type,Cyclomatic complexity of the method is 19
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Return,Cyclomatic complexity of the method is 11
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Parameter,Cyclomatic complexity of the method is 14
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunctionReturn,Cyclomatic complexity of the method is 10
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunctionParameter,Cyclomatic complexity of the method is 12
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Column,Cyclomatic complexity of the method is 26
Complex Method,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Association,Cyclomatic complexity of the method is 21
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Database,Cyclomatic complexity of the method is 15
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Connection,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Table,Cyclomatic complexity of the method is 9
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Function,Cyclomatic complexity of the method is 18
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Type,Cyclomatic complexity of the method is 17
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_TableFunction,Cyclomatic complexity of the method is 10
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Parameter,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Column,Cyclomatic complexity of the method is 18
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Association,Cyclomatic complexity of the method is 12
Complex Method,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_TableFunctionParameter,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Util,DataCommand,C:\repos\lytico_dblinq2007\src\DbLinq\Util\DataCommand.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Util,Output,C:\repos\lytico_dblinq2007\src\DbLinq\Util\Output.cs,WriteConsoleLine,Cyclomatic complexity of the method is 19
Complex Method,DbLinq.Util,StringExtensions,C:\repos\lytico_dblinq2007\src\DbLinq\Util\StringExtensions.cs,IsIdentifier,Cyclomatic complexity of the method is 8
Complex Method,DbLinq.Language.Implementation,AbstractWords,C:\repos\lytico_dblinq2007\src\DbLinq\Language\Implementation\AbstractWords.cs,Load,Cyclomatic complexity of the method is 10
Complex Method,DbLinq.Schema.Implementation,NameFormatter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Implementation\NameFormatter.cs,AdjustPart,Cyclomatic complexity of the method is 16
Complex Method,DbLinq.Vendor.Implementation,SchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SchemaLoader.Name.cs,GenerateStorageAndMemberFields,Cyclomatic complexity of the method is 9
Complex Method,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,Cyclomatic complexity of the method is 31
Complex Method,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,Cyclomatic complexity of the method is 44
Long Parameter List,DbLinq.Firebird,FirebirdSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Firebird\FirebirdSqlProvider.cs,GetInsertIds,The method has 7 parameters.
Long Parameter List,DbLinq.Ingres,IngresSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Ingres\IngresSqlProvider.cs,GetInsertIds,The method has 7 parameters.
Long Parameter List,DbLinq.Oracle,OracleSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleSqlProvider.cs,GetInsertIds,The method has 7 parameters.
Long Parameter List,DbLinq.Oracle,OracleSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleSqlProvider.cs,GetLiteralLimit,The method has 5 parameters.
Long Parameter List,DbLinq.PostgreSql,PgsqlSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.PostgreSql\PgsqlSqlProvider.cs,GetInsertIds,The method has 7 parameters.
Long Parameter List,DbLinq.Sqlite,SqliteSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Sqlite\SqliteSqlProvider.cs,GetInsertIds,The method has 7 parameters.
Long Parameter List,DbLinq.Data.Linq.Sugar,IDataMapper,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\IDataMapper.cs,GetAssociation,The method has 7 parameters.
Long Parameter List,DbLinq.Data.Linq.Sugar,SelectQuery,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\SelectQuery.cs,SelectQuery,The method has 5 parameters.
Long Parameter List,DbLinq.Data.Linq.Sugar,UpsertQuery,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\UpsertQuery.cs,UpsertQuery,The method has 6 parameters.
Long Parameter List,DbLinq.Data.Linq.Sugar.Expressions,EntitySetExpression,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Expressions\EntitySetExpression.cs,EntitySetExpression,The method has 5 parameters.
Long Parameter List,DbLinq.Data.Linq.Sugar.Implementation,DataMapper,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataMapper.cs,GetAssociation,The method has 7 parameters.
Long Parameter List,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The method has 64 parameters.
Long Parameter List,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeLike,The method has 5 parameters.
Long Parameter List,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetUpsertParameters,The method has 9 parameters.
Long Parameter List,DbLinq.Schema,INameFormatter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\INameFormatter.cs,GetAssociationName,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Database,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_AccessModifier,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_ClassModifier,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_SerializationMode,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Connection,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Table,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Function,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_ConnectionMode,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_MemberModifier,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Type,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_TableFunction,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Parameter,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Return,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Column,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Association,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_TableFunctionParameter,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_TableFunctionReturn,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_ParameterDirection,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_UpdateCheck,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_AutoSync,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Cardinality,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Version,The method has 6 parameters.
Long Parameter List,DbLinq.Schema.Dbml,DbmlSerializer,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DbmlSerializer.cs,OpenXml,The method has 5 parameters.
Long Parameter List,DbLinq.Util,DataCommand,C:\repos\lytico_dblinq2007\src\DbLinq\Util\DataCommand.cs,Find,The method has 5 parameters.
Long Parameter List,DbLinq.Schema.Implementation,NameFormatter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Implementation\NameFormatter.cs,AdjustPart,The method has 5 parameters.
Long Parameter List,DbLinq.Schema.Implementation,NameFormatter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Implementation\NameFormatter.cs,GetAssociationName,The method has 6 parameters.
Long Parameter List,DbLinq.Vendor,DbSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\DbSchemaLoader.cs,LoadConstraints,The method has 6 parameters.
Long Parameter List,DbLinq.Vendor,ISchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\ISchemaLoader.cs,Load,The method has 6 parameters.
Long Parameter List,DbLinq.Vendor,ISqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\ISqlProvider.cs,GetLiteralLimit,The method has 5 parameters.
Long Parameter List,DbLinq.Vendor,ISqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\ISqlProvider.cs,GetInsertIds,The method has 7 parameters.
Long Parameter List,DbLinq.Vendor,ISqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\ISqlProvider.cs,GetUpdate,The method has 7 parameters.
Long Parameter List,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetInsertIds,The method has 7 parameters.
Long Parameter List,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetUpdate,The method has 7 parameters.
Long Parameter List,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteralLimit,The method has 5 parameters.
Long Identifier,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSelectMany,The length of the parameter metaTableDefinitionBuilderContext is 33.
Long Identifier,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeJoin,The length of the parameter metaTableDefinitionBuilderContext is 33.
Long Statement,DbLinq.Firebird,FirebirdExpressionTranslator,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Firebird\FirebirdExpressionTranslator.cs,OuterExpression,The length of the statement  "	if (e.Operands.Select (o => o as SpecialExpression).Where (o => o != null).Where (s => s.SpecialNodeType == SpecialExpressionType.Count).Any ()) { " is 146.
Long Statement,DbLinq.Firebird,FirebirdSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Firebird\FirebirdSqlProvider.cs,GetLiteralLimit,The length of the statement  "	string stmt = limit.Count == 2 ? string.Format ("SELECT FIRST {0}' LAST {1}"' limit [0].Sql' limit [1].Sql) : string.Format ("SELECT FIRST {0}"' limit [0].Sql); " is 160.
Long Statement,DbLinq.Firebird,FirebirdSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Firebird\FirebirdSqlProvider.cs,GetLiteralLimit,The length of the statement  "	string stmt = (limit.Count == 2 ? string.Format ("SELECT FIRST {0}' LAST {1} SKIP {2}"' limit [0].Sql' limit [1].Sql' offset) : string.Format ("SELECT FIRST {0} SKIP {1}"' limit [0].Sql' offset)); " is 196.
Long Statement,DbLinq.Firebird,FirebirdSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Firebird\FirebirdSqlProvider.cs,GetInsertIds,The length of the statement  "	return SqlStatement.Format ("SELECT {0} INTO {1} FROM DUAL"' SqlStatement.Join ("' "' (from outputExpression in outputExpressions " is 129.
Long Statement,DbLinq.Firebird,FirebirdSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Firebird\FirebirdSqlProvider.cs,GetInsertIds,The length of the statement  "	select outputExpression.Replace (".NextVal"' ".CurrVal"' true)).ToArray ())' SqlStatement.Join ("' "' outputParameters.ToArray ())); " is 132.
Long Statement,DbLinq.Oracle,OracleSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleSqlProvider.cs,GetInsertIds,The length of the statement  "	return SqlStatement.Format ("SELECT {0} INTO {1} FROM DUAL"' SqlStatement.Join ("' "' (from outputExpression in outputExpressions " is 129.
Long Statement,DbLinq.Oracle,OracleSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleSqlProvider.cs,GetInsertIds,The length of the statement  "	select outputExpression.Replace (".NextVal"' ".CurrVal"' true)).ToArray ())' SqlStatement.Join ("' "' outputParameters.ToArray ())); " is 132.
Long Statement,DbLinq.Oracle,OracleSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleSqlProvider.cs,GetLiteralLimit,The length of the statement  "	return SqlStatement.Format (@"SELECT {2}.*' rownum {3} FROM ({4}{0}{4}) {2} WHERE rownum <= {1}"' select' limit' LimitedTableName' LimitedRownum' NewLine); " is 155.
Long Statement,DbLinq.Oracle,OracleSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleSqlProvider.cs,GetLiteralLimit,The length of the statement  "	return SqlStatement.Format (@"SELECT {4} FROM ({3}{0}{3}) WHERE {2} > {1}"' GetLiteralLimit (select' offsetAndLimit)' offset' LimitedRownum' NewLine' limitFields); " is 163.
Long Statement,DbLinq.Oracle,OracleVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleVendor.cs,BuildConnectionString,The length of the statement  "	connectionStringBuilder.AppendFormat ("Data Source = (DESCRIPTION = (ADDRESS_LIST = (ADDRESS = (PROTOCOL = TCP)(HOST = {0})(PORT = 1521)))(CONNECT_DATA = (SERVER = DEDICATED)))"' host); " is 185.
Long Statement,DbLinq.PostgreSql,PgsqlSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.PostgreSql\PgsqlSqlProvider.cs,GetLiteralDateDiff,The length of the statement  "	return string.Format ("(EXTRACT(EPOCH FROM ({0})::timestamp)-EXTRACT(EPOCH FROM ({1})::timestamp))*1000"' dateA' dateB); " is 120.
Long Statement,DbLinq.SqlServer,SqlServerExpressionTranslator,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.SqlServer\SqlServerExpressionTranslator.cs,OuterExpression,The length of the statement  "	if (e.Operands.Select (o => o as SpecialExpression).Where (o => o != null).Where (s => s.SpecialNodeType == SpecialExpressionType.Count).Any ()) { " is 146.
Long Statement,DbLinq.SqlServer,SqlServerSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.SqlServer\SqlServerSqlProvider.cs,GetLiteralLimit,The length of the statement  "	return SqlStatement.Format ("SELECT *{0}" + "FROM ({0}" + "    {1}'{0}" + "    ROW_NUMBER() OVER({2}) AS [__ROW_NUMBER]{0}" + "    {3}" + "    ) AS [t0]{0}" + "WHERE [__ROW_NUMBER] BETWEEN {4}+1 AND {4}+{5}{0}" + "ORDER BY [__ROW_NUMBER]"' NewLine' selectFieldsClause' orderByClause' sourceClause' offset' limit); " is 313.
Long Statement,DbLinq.SqlServer,SqlServerSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.SqlServer\SqlServerSqlProvider.cs,GetLiteralDateDiff,The length of the statement  "	return SqlStatement.Format ("(CONVERT(BigInt'DATEDIFF(DAY' {0}' {1}))) * 86400000 +" //diffierence in milliseconds regards days " is 127.
Long Statement,DbLinq.SqlServer,SqlServerSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.SqlServer\SqlServerSqlProvider.cs,GetLiteralDateDiff,The length of the statement  "	//this trick is needed in sqlserver since DATEDIFF(MILLISECONDS'{0}'{1}) usually crhases in the database engine due an overflow: " is 128.
Long Statement,DbLinq.SqlServer,SqlServerSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.SqlServer\SqlServerSqlProvider.cs,GetLiteralStringConcat,The length of the statement  "	return SqlStatement.Format ("{0} + {1}"' a.Replace ("sql_variant"' "varchar"' false)' b.Replace ("sql_variant"' "varchar"' false)); " is 131.
Long Statement,DbLinq.SqlServer,SqlServerSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.SqlServer\SqlServerSqlProvider.cs,GetLiteralStringIndexOf,The length of the statement  "	return GetLiteralSubtract (SqlStatement.Format ("CHARINDEX({0}'{1}'{2})"' searchString' GetLiteralSubString (baseString' "1"' GetLiteralStringConcat (count' startIndex))' startIndex)' "1"); " is 189.
Long Statement,System.Data.Linq,ChangeSet,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\ChangeSet.cs,ToString,The length of the statement  "	return string.Format ("Total changes: {{Added: {0}' Removed: {1}' Modified: {2}}}"' Inserts.Count' Deletes.Count' Updates.Count); " is 129.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,GetVendor,The length of the statement  "	where type.Name.ToLowerInvariant () == vendorClassToLoad.ToLowerInvariant () && type.GetInterfaces ().Contains (typeof(IVendor)) && type.GetConstructor (Type.EmptyTypes) != null " is 177.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,GetVendor,The length of the statement  "		throw new ArgumentException (string.Format ("Found no IVendor class in assembly `{0}' named `{1}' having a default constructor."' assy.GetName ().Name' vendorClassToLoad)); " is 172.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,GetVendor,The length of the statement  "		throw new ArgumentException (string.Format ("Found too many IVendor classes in assembly `{0}' named `{1}' having a default constructor."' assy.GetName ().Name' vendorClassToLoad)); " is 180.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,GetVendorInfo,The length of the statement  "	System.Text.RegularExpressions.Regex reProvider = new System.Text.RegularExpressions.Regex (@"DbLinqProvider=([\w\.]+);?"); " is 123.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,GetVendorInfo,The length of the statement  "		throw new ArgumentException (string.Format ("Unable to load the `{0}' DbLinq vendor within assembly '{1}.dll'."' assemblyName' vendor)' "connectionString"' e); " is 159.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,Init,The length of the statement  "	Vendor = vendor ?? (connectionString != null ? GetVendor (ref connectionString) : null) ?? _VendorProvider.FindVendorByProviderType (typeof(SqlClient.Sql2005Provider)); " is 168.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,GetTable,The length of the statement  "	var tableNew = Activator.CreateInstance (typeof(Table<>).MakeGenericType (type)' BindingFlags.NonPublic | BindingFlags.Instance' null' new object[] { " is 149.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SubmitChangesImpl,The length of the statement  "	foreach (var entityTrack in CurrentTransactionEntities.EnumerateAll ().Concat (AllTrackedEntities.EnumerateAll ()).ToList ()) { " is 127.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,FillReferencedObjects,The length of the statement  "		IEnumerable<MetaAssociation> associationList = Mapping.GetMetaType (value.GetType ()).Associations.Where (a => !a.IsForeignKey); " is 128.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,UpdateReferencedObjects,The length of the statement  "		//This is not correct - AutoSyncing applies to auto-updating columns' such as a TimeStamp' not to foreign key associations' which is always automatically synched " is 161.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,UpdateReferencedObjects,The length of the statement  "			throw new InvalidOperationException (string.Format ("Count of primary keys ({0}) doesn't match count of other keys ({1})."' pks.Count' oks.Count)); " is 147.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,_GetRegisteredEntity,The length of the statement  "	var registeredEntityTrack = CurrentTransactionEntities.FindByIdentity (identityKey) ?? AllTrackedEntities.FindByIdentity (identityKey); " is 135.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,_GetOrRegisterEntity,The length of the statement  "	var registeredEntityTrack = CurrentTransactionEntities.FindByIdentity (identityKey) ?? AllTrackedEntities.FindByIdentity (identityKey); " is 135.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntityRefQueries,The length of the statement  "	IEnumerable<MetaAssociation> associationList = Mapping.GetMetaType (entity.GetType ()).Associations.Where (a => a.IsForeignKey); " is 128.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntityRefQueries,The length of the statement  "					keyPredicate = Expression.Equal (Expression.MakeMemberAccess (p' otherPKEnumerator.Current.Member)' Expression.Constant (thisForeignKeyValue)); " is 143.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntityRefQueries,The length of the statement  "					keyPredicate = Expression.Equal (Expression.MakeMemberAccess (p' otherPKEnumerator.Current.Member)' Expression.Constant (ValueProperty.GetValue (thisForeignKeyValue' null))); " is 174.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntityRefQueries,The length of the statement  "			throw new InvalidOperationException (String.Format ("Member {0}.{1} is not a field nor a writable property"' storage.DeclaringType' storage.Name)); " is 147.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntitySetsQueries,The length of the statement  "	IEnumerable<MetaAssociation> associationList = Mapping.GetMetaType (entity.GetType ()).Associations.Where (a => !a.IsForeignKey); " is 129.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntitySetsQueries,The length of the statement  "					keyPredicate = Expression.Equal (Expression.MakeMemberAccess (p' otherTableMember)' Expression.Constant (thisKeyEnumerator.Current.Member.GetMemberValue (entity))); " is 164.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,SetEntitySetsQueries,The length of the statement  "					keyPredicate = Expression.Equal (Expression.MakeMemberAccess (Expression.MakeMemberAccess (p' otherTableMember)' ValueProperty)' Expression.Constant (thisKeyEnumerator.Current.Member.GetMemberValue (entity))); " is 209.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,GetOtherTableQuery,The length of the statement  "	Expression call = Expression.Call (_WhereMethod.MakeGenericMethod (otherTableType)' otherTable.Expression' lambdaPredicate); " is 124.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,WriteLog,The length of the statement  "		Log.WriteLine ("-- {0}: {1} {2} (Size = {3}; Prec = {4}; Scale = {5}) [{6}]"' parameter.ParameterName' parameter.Direction' parameter.DbType' parameter.Size' parameter.Precision' parameter.Scale' parameter.Value); " is 213.
Long Statement,System.Data.Linq,DataContext,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataContext.cs,CreateDefaultQuery,The length of the statement  "	var identityBody = Expression.Lambda (typeof(Func<' >).MakeGenericType (query.ElementType' query.ElementType)' identityParameter' new[] { " is 137.
Long Statement,System.Data.Linq,DataLoadOptions,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataLoadOptions.cs,AssociateWith,The length of the statement  "		throw new InvalidOperationException ("The argument expression must be a property access or a field access where the target object is the parameter"); " is 149.
Long Statement,System.Data.Linq,DataLoadOptions,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataLoadOptions.cs,LoadWith,The length of the statement  "		throw new InvalidOperationException ("The argument expression must be a property access or a field access where the target object is the parameter"); " is 149.
Long Statement,System.Data.Linq,DataLoadOptions,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\DataLoadOptions.cs,VerifyMemberAccessCycles,The length of the statement  "			throw new InvalidOperationException ("Illegal cycles are detected in the argument expression among other eager-loading expressions"); " is 133.
Long Statement,System.Data.Linq,EntitySet,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\EntitySet.cs,Add,The length of the statement  "		comp = Expression.Equal (Expression.Constant (value)' Expression.MakeMemberAccess (Expression.MakeMemberAccess (nestedQueryParam' member)' valueProp)); " is 151.
Long Statement,System.Data.Linq,EntitySet,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\EntitySet.cs,GetList,The length of the statement  "	//It seems that Microsoft is doing a similar thing in L2SQL' matter of fact' after doing a GetList().Add(new TEntity())' HasAssignedValues continues to be false " is 160.
Long Statement,DbLinq.Data.Linq.Implementation,MemberModificationHandler,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Implementation\MemberModificationHandler.cs,RegisterNotification,The length of the statement  "			if (entityOriginalState == null || IsPropertyModified (memberInfo.GetMemberValue (entity)' memberInfo.GetMemberValue (entityOriginalState))) { " is 142.
Long Statement,DbLinq.Data.Linq.Implementation,MemberModificationHandler,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Implementation\MemberModificationHandler.cs,IsNotifyingModified,The length of the statement  "	return ReferenceEquals (propertyChangingSentinal' modifiedProperties [entity]) || modifiedProperties [entity].Count > 0; " is 120.
Long Statement,DbLinq.Data.Linq.Implementation,MemberModificationHandler,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Implementation\MemberModificationHandler.cs,GetNotifyingModifiedProperties,The length of the statement  "	if (!modifiedProperties.TryGetValue (entity' out properties) || ReferenceEquals (propertyChangingSentinal' modifiedProperties [entity])) " is 136.
Long Statement,DbLinq.Data.Linq.Mapping,AttributedMetaAssociation,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Mapping\AttributedMetaAssociation.cs,GetKeys,The length of the statement  "				string errorMessage = string.Format ("Could not find key member '{0}' of key '{1}' on type '{2}'. The key may be wrong or the field or property on '{2}' has changed names."' keyName' keyListString' parentType.Type.Name); " is 220.
Long Statement,DbLinq.Data.Linq.Mapping,AttributedMetaModel,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Mapping\AttributedMetaModel.cs,GetTables,The length of the statement  "	const BindingFlags scope = BindingFlags.GetField | BindingFlags.GetProperty | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public; " is 169.
Long Statement,DbLinq.Data.Linq.Mapping,AttributedMetaType,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Mapping\AttributedMetaType.cs,GetAssociations,The length of the statement  "			throw new InvalidOperationException (string.Format ("Error on Association {0} {1} {2}"' data.Member.Name' data.Association.Name' data.DataMember.Name)' ex); " is 156.
Long Statement,DbLinq.Data.Linq.Mapping,LambdaMetaAccessor,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Mapping\LambdaMetaAccessor.cs,MakeSetter,The length of the statement  "		member = declaringType.GetField (ca.Storage' BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static); " is 137.
Long Statement,DbLinq.Data.Linq.Sugar,AbstractQuery,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\AbstractQuery.cs,GetCommand,The length of the statement  "	return new DbLinq.Data.Linq.Database.Implementation.TransactionalCommand (Sql.ToString ()' createTransaction' DataContext); " is 123.
Long Statement,DbLinq.Data.Linq.Sugar.ExpressionMutator.Implementation,BinaryExpressionMutator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionMutator\Implementation\BinaryExpressionMutator.cs,Mutate,The length of the statement  "			return Expression.GreaterThanOrEqual (operands [0]' operands [1]' BinaryExpression.IsLiftedToNull' BinaryExpression.Method); " is 124.
Long Statement,DbLinq.Data.Linq.Sugar.ExpressionMutator.Implementation,BinaryExpressionMutator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionMutator\Implementation\BinaryExpressionMutator.cs,Mutate,The length of the statement  "			return Expression.LessThanOrEqual (operands [0]' operands [1]' BinaryExpression.IsLiftedToNull' BinaryExpression.Method); " is 121.
Long Statement,DbLinq.Data.Linq.Sugar.Expressions,SpecialExpression,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Expressions\SpecialExpression.cs,EvaluateMathCallInvoke,The length of the statement  "	return typeof(Math).GetMethod (SpecialNodeType.ToString ()' operands.Skip (1).Select (op => op.Type).ToArray ()).Invoke (null' operands.Skip (1).Select (op => op.Evaluate ()).ToArray ()); " is 187.
Long Statement,DbLinq.Data.Linq.Sugar.Expressions,SpecialExpression,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Expressions\SpecialExpression.cs,EvaluateStandardCallInvoke,The length of the statement  "	return operands [0].Type.GetMethod (methodName' operands.Skip (1).Select (op => op.Type).ToArray ()).Invoke (operands [0].Evaluate ()' operands.Skip (1).Select (op => op.Evaluate ()).ToArray ()); " is 195.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataMapper,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataMapper.cs,GetEntitySetAssociations,The length of the statement  "	return type.GetProperties ().Where (p => p.PropertyType.IsGenericType && (p.PropertyType.GetGenericTypeDefinition () == typeof(System.Data.Linq.EntitySet<>) " is 156.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataMapper,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataMapper.cs,GetEntityRefAssociations,The length of the statement  "		AssociationAttribute associationAttribute = p.GetCustomAttributes (typeof(AssociationAttribute)' true).FirstOrDefault () as AssociationAttribute; " is 145.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' string>>)((dataRecord' mappingContext' valueIndex) => GetAsString (dataRecord' valueIndex' mappingContext)); " is 166.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' bool?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableBool (valueIndex)); " is 154.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' char?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableChar (valueIndex)); " is 154.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' byte?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<byte> (valueIndex)); " is 163.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' sbyte?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<sbyte> (valueIndex)); " is 165.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' short?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<short> (valueIndex)); " is 165.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' ushort?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<ushort> (valueIndex)); " is 167.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' int?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<int> (valueIndex)); " is 161.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' uint?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<uint> (valueIndex)); " is 163.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' long?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<long> (valueIndex)); " is 163.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' ulong?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<ulong> (valueIndex)); " is 165.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' float?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<float> (valueIndex)); " is 165.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' double?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<double> (valueIndex)); " is 167.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' decimal?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<decimal> (valueIndex)); " is 169.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' DateTime?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableDateTime (valueIndex)); " is 162.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' Guid?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableGuid (valueIndex)); " is 154.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' byte[]>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsBytes (valueIndex)); " is 148.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' int?>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsNullableNumeric<int> (valueIndex)); " is 161.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' System.Data.Linq.Binary>>)((dataRecord' mappingContext' valueIndex) => dataRecord.GetAsBinary (valueIndex)); " is 166.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "		return (Expression<Func<IDataRecord' MappingContext' int' object>>)((dataRecord' mappingContext' valueIndex) => GetAsObject (dataRecord' valueIndex' mappingContext)); " is 166.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,DataRecordReader,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\DataRecordReader.cs,GetNullablePropertyReader,The length of the statement  "	return (Expression<Func<IDataRecord' MappingContext' int' object>>)((dataRecord' mappingContext' valueIndex) => GetAsObject (dataRecord' valueIndex' mappingContext)); " is 166.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeCall,The length of the statement  "	return AnalyzeQueryableCall (expression.Method' newParameters' builderContext) ?? AnalyzeStringCall (expression.Method' newParameters' builderContext) ?? AnalyzeMathCall (expression.Method' newParameters' builderContext) ?? AnalyzeUnknownCall (expression' newParameters' builderContext); " is 287.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeMathCall,The length of the statement  "		return popCallStack (AnalyzeGenericSpecialExpressionType ((SpecialExpressionType)Enum.Parse (typeof(SpecialExpressionType)' method.Name)' parameters' builderContext)); " is 167.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeStringInsert,The length of the statement  "	var startIndexExpression = new StartIndexOffsetExpression (builderContext.QueryContext.DataContext.Vendor.SqlProvider.StringIndexStartsAtOne' parameters.ElementAt (1)); " is 168.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeLog,The length of the statement  "		return new SpecialExpression (SpecialExpressionType.Ln' parameters.Select (p => Analyze (p' builderContext)).ToList ()); " is 120.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeLog,The length of the statement  "		return new SpecialExpression (SpecialExpressionType.Log' parameters.Select (p => Analyze (p' builderContext)).ToList ()); " is 121.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeParse,The length of the statement  "				parsed = RegisterParameter (System.Linq.Expressions.Expression.Call (method' inputParameterToParse.Expression)' inputParameterToParse.Alias' builderContext); " is 157.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeParse,The length of the statement  "			//pibgeus: I would like to call to the expression optimizer since the exception must be thrown if the expression cannot be executed " is 131.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeParse,The length of the statement  "			// ie: from e in db.Employees where DateTime.Parse(e.BirthDate).Year==1999 select e  <--- a NotSupportedException must be throwed (this is the behaviour of linq2sql) " is 165.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeParse,The length of the statement  "			//        throw new NotSupportedException("Method 'System.DateTime Parse(System.String)' has no supported translation to SQL"); " is 127.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeToString,The length of the statement  "		parameterToHandle = RegisterParameter (System.Linq.Expressions.Expression.Call (inputParameter.Expression' method)' inputParameter.Alias' builderContext); " is 154.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AddLimit,The length of the statement  "		builderContext.CurrentSelect.Limit = Expression.Condition (Expression.LessThan (previousLimit' limit)' previousLimit' limit); " is 125.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeProjectionQuery,The length of the statement  "		if (builderContext.CurrentSelect.NextSelectExpression != null || builderContext.CurrentSelect.Operands.Count () > 0 || builderContext.CurrentSelect.Group.Count > 0) { " is 166.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeProjectionQuery,The length of the statement  "		projectionQueryBuilderContext.CurrentSelect = projectionQueryBuilderContext.CurrentSelect.ChangeOperands (new SpecialExpression (specialExpressionType' tableExpression)); " is 170.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSelect,The length of the statement  "	if (ex.NodeType == ExpressionType.MemberInit && builderContext.QueryContext.DataContext.Mapping.GetMetaType (ex.Type) != null) " is 126.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSelect,The length of the statement  "		throw new NotSupportedException (string.Format ("Explicit construction of entity type '{0}' in query is not allowed."' ex.Type.FullName)); " is 138.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,IsEntitySet,The length of the statement  "            if (memberType.IsGenericType && typeof(System.Data.Linq.EntitySet<>).IsAssignableFrom(memberType.GetGenericTypeDefinition()))" is 125.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeMember,The length of the statement  "			Type storageType = queryColumnExpression.StorageInfo != null ? queryColumnExpression.StorageInfo.GetMemberType () : null; " is 121.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeMember,The length of the statement  "				return Expression.Convert (queryColumnExpression' queryColumnExpression.Type' typeof(Convert).GetMethod ("To" + queryColumnExpression.Type.Name' new Type[] { " is 157.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "	//A timespan expression can be only generated in a c# query as a DateTime difference' as a function call return or as a paramter " is 128.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "		currentExpression = Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double)); " is 169.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "		currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (1000.0)); " is 219.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "		currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (60000.0)); " is 220.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "		currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (3600000.0)); " is 222.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "		currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (86400000.0)); " is 223.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "		throw new NotSupportedException (string.Format ("The operation {0} over the TimeSpan isn't currently supported"' memberInfo.Name)); " is 131.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "			currentExpression = Expression.Convert (Expression.Modulo (Expression.Convert (currentExpression' typeof(long))' Expression.Constant (1000L))' typeof(int)); " is 156.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "			currentExpression = Expression.Convert (Expression.Modulo (Expression.Convert (currentExpression' typeof(long))' Expression.Constant (60L))' typeof(int)); " is 154.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "			currentExpression = Expression.Convert (Expression.Modulo (Expression.Convert (currentExpression' typeof(long))' Expression.Constant (60L))' typeof(int)); " is 154.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The length of the statement  "			currentExpression = Expression.Convert (Expression.Modulo (Expression.Convert (currentExpression' typeof(long))' Expression.Constant (24L))' typeof(int)); " is 154.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeExternalParameterMember,The length of the statement  "	return RegisterParameter (Expression.MakeMemberAccess (expression.Expression' memberInfo)' memberInfo.Name' builderContext); " is 124.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeOperator,The length of the statement  "	if (expression.NodeType == ExpressionType.Convert && u.Method == null && (parameterName = GetParameterName (u.Operand)) != null) { " is 130.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSelectMany,The length of the statement  "	throw Error.BadArgument ("S0358: Don't know how to handle this SelectMany() overload ({0} parameters)"' parameters.Count); " is 122.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeJoin,The length of the statement  "			throw Error.BadArgument ("S0702: Unable to join Table {0} with {1}; there is already a Join with {2}"' rightTable.Name' leftTable.Name' rightTable.JoinedTable.Name); " is 165.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeJoin,The length of the statement  "		rightTable.Join (joinType' leftTable' Expression.Equal (leftJoin' rightJoin)' string.Format ("join{0}"' builderContext.EnumerateAllTables ().Count ())); " is 152.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeGroupBy,The length of the statement  "		throw Error.BadArgument ("S0629: Don't know how to handle Expression to group by with {0} parameters"' parameters.Count); " is 121.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeAll,The length of the statement  "	allBuilderContext.CurrentSelect = allBuilderContext.CurrentSelect.ChangeOperands (new SpecialExpression (SpecialExpressionType.Count' tableExpression)); " is 152.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeAny,The length of the statement  "		return Expression.GreaterThan (new SpecialExpression (SpecialExpressionType.Count' projectionOperand)' Expression.Constant (0)); " is 128.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeAny,The length of the statement  "		anyBuilderContext.CurrentSelect = anyBuilderContext.CurrentSelect.ChangeOperands (new SpecialExpression (SpecialExpressionType.Count' tableExpression)); " is 152.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSubString,The length of the statement  "	var startExpression = new StartIndexOffsetExpression (builderContext.QueryContext.DataContext.Vendor.SqlProvider.StringIndexStartsAtOne' Analyze (parameters [1]' builderContext)); " is 179.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeConstant,The length of the statement  "			//return new TableExpression(queriedType' DataMapper.GetTableName(queriedType' builderContext.QueryContext.DataContext)); " is 121.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeQueryProvider,The length of the statement  "	// TODO: check if the QueryProvider queryProvider belong to DataContext present in builderContext.QueryContext.DataContext " is 122.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeInvoke,The length of the statement  "		//    localBuilderContext.Parameters[parameter.Name] = Analyze(invocationExpression.Arguments[parameterIndex]' builderContext); " is 127.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionLanguageParser,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionLanguageParser.cs,AnalyzeCompareString,The length of the statement  "		if (methodExpression != null && methodExpression.Method.DeclaringType.FullName == "Microsoft.VisualBasic.CompilerServices.Operators" && methodExpression.Method.Name == "CompareString") { " is 186.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,ExpressionLanguageParser,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionLanguageParser.cs,AnalyzeLikeString,The length of the statement  "	if (methodExpression != null && methodExpression.Method.DeclaringType.FullName == "Microsoft.VisualBasic.CompilerServices.LikeOperator" && methodExpression.Method.Name == "LikeString") { " is 186.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetInsertQuery,The length of the statement  "	var insertSql = sqlProvider.GetInsert (sqlProvider.GetTable (upsertParameters.Table.TableName)' upsertParameters.InputColumns' upsertParameters.InputValues); " is 157.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetInsertQuery,The length of the statement  "	var insertIdSql = sqlProvider.GetInsertIds (sqlProvider.GetTable (upsertParameters.Table.TableName)' upsertParameters.AutoPKColumns' upsertParameters.PKColumns' upsertParameters.PKValues' upsertParameters.OutputColumns' upsertParameters.OutputValues' upsertParameters.OutputExpressions); " is 287.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetInsertQuery,The length of the statement  "	return new UpsertQuery (queryContext.DataContext' insertSql' insertIdSql' upsertParameters.InputParameters' upsertParameters.OutputParameters' upsertParameters.PKParameters); " is 174.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetUpsertParameters,The length of the statement  "		ParameterType type = GetParameterType (objectToUpsert' dataMember' update' update ? AutoSync.OnUpdate : AutoSync.OnInsert); " is 123.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetUpdateQuery,The length of the statement  "	var updateSql = sqlProvider.GetUpdate (sqlProvider.GetTable (upsertParameters.Table.TableName)' upsertParameters.InputColumns' upsertParameters.InputValues' upsertParameters.OutputValues' upsertParameters.OutputExpressions' upsertParameters.InputPKColumns' upsertParameters.InputPKValues); " is 289.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetUpdateQuery,The length of the statement  "	var insertIdSql = (upsertParameters.OutputValues.Count == 0) ? "" : sqlProvider.GetInsertIds (sqlProvider.GetTable (upsertParameters.Table.TableName)' upsertParameters.AutoPKColumns' upsertParameters.PKColumns' upsertParameters.PKValues' upsertParameters.OutputColumns' upsertParameters.OutputValues' upsertParameters.OutputExpressions); " is 337.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryBuilder.Upsert.cs,GetUpdateQuery,The length of the statement  "	return new UpsertQuery (queryContext.DataContext' updateSql' insertIdSql' upsertParameters.InputParameters' upsertParameters.OutputParameters' upsertParameters.PKParameters); " is 174.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,PrequelAnalyzer,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\PrequelAnalyzer.cs,AnalyzeExpression,The length of the statement  "	if (expression.NodeType == ExpressionType.Add && binaryExpression != null && typeof(string).IsAssignableFrom (binaryExpression.Left.Type)) { " is 140.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryRunner,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryRunner.cs,Select,The length of the statement  "					if (row != null && selectQuery.DataContext.ObjectTrackingEnabled && selectQuery.DataContext.Mapping.GetTable (row.GetType ()) != null) { " is 136.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryRunner,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryRunner.cs,Upsert,The length of the statement  "			var outputCommandTransaction = new ParameterizedQuery (dataContext' insertQuery.IdQuerySql' insertQuery.PrimaryKeyParameters); " is 126.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,QueryRunner,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryRunner.cs,Upsert,The length of the statement  "				for (IEnumerator<ObjectOutputParameterExpression> output = insertQuery.OutputParameters.GetEnumerator (); output.MoveNext (); ++outputParameterIndex) { " is 151.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,SpecialExpressionTranslator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SpecialExpressionTranslator.cs,GetCallDateDiffInMilliseconds,The length of the statement  "	return Expression.MakeMemberAccess (Expression.Subtract (operands.First ()' operands.ElementAt (1))' typeof(TimeSpan).GetProperty ("TotalMilliseconds")); " is 153.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,SpecialExpressionTranslator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SpecialExpressionTranslator.cs,GetStandardCallInvoke,The length of the statement  "	return Expression.Call (operands [0]' operands [0].Type.GetMethod (methodName' parametersExpressions.Select (op => op.Type).ToArray ())' parametersExpressions); " is 160.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,SqlBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SqlBuilder.cs,Build,The length of the statement  "		select = queryContext.DataContext.Vendor.SqlProvider.GetLiteral (selectExpression.NextSelectExpressionOperator' select' nextLiteralSelect); " is 139.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,SqlBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SqlBuilder.cs,BuildExpression,The length of the statement  "				inputParameters.Add (new SqlStatement (new SqlParameterPart (sqlProvider.GetParameterName (inputParameterExpression.Alias + i.ToString ())' inputParameterExpression.Alias + i.ToString ()))); " is 190.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,SqlBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SqlBuilder.cs,BuildExpression,The length of the statement  "		return new SqlStatement (new SqlParameterPart (sqlProvider.GetParameterName (inputParameterExpression.Alias)' inputParameterExpression.Alias)); " is 143.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,SqlBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SqlBuilder.cs,BuildOrderBy,The length of the statement  "		orderByClauses.Add (sqlProvider.GetOrderByColumn (BuildExpression (clause.ColumnExpression' queryContext)' clause.Descending)); " is 127.
Long Statement,DbLinq.Data.Linq.Sugar.Implementation,SqlBuilder,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\SqlBuilder.cs,BuildLimit,The length of the statement  "			var limitFields = SqlStatement.Join ("'"' select.Operands.OfType<ColumnExpression> ().Select (c => new SqlStatement (sqlProvider.GetColumn (c.Name))).ToList ()); " is 161.
Long Statement,DbLinq.Schema.Dbml.Adapter,EnumType,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\Adapter\EnumType.cs,Extract,The length of the statement  "			// a value may indicate its numeric equivalent' or not (in this case' we work the same way as C# enums' with an implicit counter) " is 129.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Database,The length of the statement  "			else if (Reader.LocalName == "Function" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b2) { " is 126.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Database,The length of the statement  "			else if (Reader.LocalName == "Connection" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b0) { " is 128.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Table,The length of the statement  "			if (Reader.LocalName == "UpdateFunction" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b9) { " is 127.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Table,The length of the statement  "			else if (Reader.LocalName == "Type" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b7) { " is 122.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Table,The length of the statement  "			else if (Reader.LocalName == "InsertFunction" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b8) { " is 132.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Table,The length of the statement  "			else if (Reader.LocalName == "DeleteFunction" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b10) { " is 133.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Function,The length of the statement  "			if (Reader.LocalName == "Return" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b12) { " is 120.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Function,The length of the statement  "			else if (Reader.LocalName == "ElementType" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b12) { " is 130.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Function,The length of the statement  "			else if (Reader.LocalName == "Parameter" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b11) { " is 128.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunction,The length of the statement  "			if (Reader.LocalName == "Return" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b18) { " is 120.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunction,The length of the statement  "			else if (Reader.LocalName == "Argument" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b17) { " is 127.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunction,The length of the statement  "				o20 = (DbLinq.Schema.Dbml.TableFunctionParameter[])EnsureArrayIndex (o20' n19' typeof(DbLinq.Schema.Dbml.TableFunctionParameter)); " is 130.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunction,The length of the statement  "	o20 = (DbLinq.Schema.Dbml.TableFunctionParameter[])ShrinkArray (o20' n19' typeof(DbLinq.Schema.Dbml.TableFunctionParameter)' true); " is 131.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Type,The length of the statement  "			if (Reader.LocalName == "Column" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b21) { " is 120.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Type,The length of the statement  "			else if (Reader.LocalName == "Association" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b21) { " is 130.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_Type,The length of the statement  "			else if (Reader.LocalName == "Type" && Reader.NamespaceURI == "http://schemas.microsoft.com/linqtosql/dbml/2007" && !b22) { " is 123.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunctionReturn,The length of the statement  "	ob = (DbLinq.Schema.Dbml.TableFunctionReturn)Activator.CreateInstance (typeof(DbLinq.Schema.Dbml.TableFunctionReturn)' true); " is 125.
Long Statement,DbLinq.Schema.Dbml,GeneratedReader,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,ReadObject_TableFunctionParameter,The length of the statement  "	ob = (DbLinq.Schema.Dbml.TableFunctionParameter)Activator.CreateInstance (typeof(DbLinq.Schema.Dbml.TableFunctionParameter)' true); " is 131.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Database,The length of the statement  "	WriteObject_Connection (ob.@Connection' "Connection"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 126.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Database,The length of the statement  "			WriteObject_Function (ob.@Function [n28]' "Function"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 126.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Table,The length of the statement  "	WriteObject_TableFunction (ob.@InsertFunction' "InsertFunction"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 137.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Table,The length of the statement  "	WriteObject_TableFunction (ob.@UpdateFunction' "UpdateFunction"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 137.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Table,The length of the statement  "	WriteObject_TableFunction (ob.@DeleteFunction' "DeleteFunction"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 137.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Function,The length of the statement  "			WriteObject_Parameter (ob.@Parameter [n29]' "Parameter"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 129.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Function,The length of the statement  "				WriteObject_Return (((DbLinq.Schema.Dbml.Return)ob.@Items [n30])' "Return"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 148.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Function,The length of the statement  "				WriteObject_Type (((DbLinq.Schema.Dbml.Type)ob.@Items [n30])' "ElementType"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 149.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Type,The length of the statement  "				WriteObject_Column (((DbLinq.Schema.Dbml.Column)ob.@Items [n31])' "Column"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 148.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_Type,The length of the statement  "				WriteObject_Association (((DbLinq.Schema.Dbml.Association)ob.@Items [n31])' "Association"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 163.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_TableFunction,The length of the statement  "			WriteObject_TableFunctionParameter (ob.@Argument [n33]' "Argument"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 140.
Long Statement,DbLinq.Schema.Dbml,GeneratedWriter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,WriteObject_TableFunction,The length of the statement  "	WriteObject_TableFunctionReturn (ob.@Return' "Return"' "http://schemas.microsoft.com/linqtosql/dbml/2007"' false' false' true); " is 127.
Long Statement,System.Data.Linq.SqlClient,SqlMethods,C:\repos\lytico_dblinq2007\src\DbLinq\System.Data.Linq\System.Data.Linq.SqlClient\SqlMethods.cs,NotSupported,The length of the statement  "	return new NotSupportedException ("The method in SqlMethods type cannot be used directly. It is only for Linq to SQL trsnslation"); " is 131.
Long Statement,DbLinq.Util,ReflectionUtility,C:\repos\lytico_dblinq2007\src\DbLinq\Util\ReflectionUtility.cs,GetMemberCallInfo,The length of the statement  "				memberExpression = (methodCallExpression.Object != null) ? methodCallExpression.Object : methodCallExpression.Arguments [0]; " is 124.
Long Statement,DbLinq.Util,ThreadSafeDictionary,C:\repos\lytico_dblinq2007\src\DbLinq\Util\ThreadSafeDictionary.cs,GetEnumerator,The length of the statement  "	throw new NotSupportedException ("Cannot enumerate a threadsafe dictionary.  Instead' enumerate the keys or values collection"); " is 128.
Long Statement,DbLinq.Util,ThreadSafeDictionary,C:\repos\lytico_dblinq2007\src\DbLinq\Util\ThreadSafeDictionary.cs,GetEnumerator,The length of the statement  "	throw new NotSupportedException ("Cannot enumerate a threadsafe dictionary.  Instead' enumerate the keys or values collection"); " is 128.
Long Statement,DbLinq.Util,TypeConvert,C:\repos\lytico_dblinq2007\src\DbLinq\Util\TypeConvert.cs,ToNumber,The length of the statement  "	throw new InvalidCastException (string.Format ("Can't convert type {0} in Convert.{1}()"' o.GetType ().Name' methodName)); " is 122.
Long Statement,DbLinq.Util,QuotesHelper,C:\repos\lytico_dblinq2007\src\DbLinq\Util\QuotesHelper.cs,AddQuotesToSequence,The length of the statement  "	if (idColName != idColName.ToLower () && !sequenceName.StartsWith ("\""))//toncho11: quotes are added due to issue http://code.google.com/p/dblinq2007/issues/detail?id=27} " is 171.
Long Statement,DbLinq.Util,TypeExtensions,C:\repos\lytico_dblinq2007\src\DbLinq\Util\TypeExtensions.cs,GetSingleMember,The length of the statement  "	return GetSingleMember (t' name' BindingFlags.Public | BindingFlags.Static | BindingFlags.Instance | BindingFlags.NonPublic); " is 125.
Long Statement,DbLinq.Util,TypeExtensions,C:\repos\lytico_dblinq2007\src\DbLinq\Util\TypeExtensions.cs,GetTableColumnMember,The length of the statement  "	where (member.GetCustomAttributes (true).OfType<ColumnAttribute> ().DefaultIfEmpty (new ColumnAttribute ()).Single ().Name == name) " is 131.
Long Statement,DbLinq.Schema.Implementation,NameFormatter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Implementation\NameFormatter.cs,GetTableName,The length of the statement  "		tableName.ClassName = Format (words' tableName.NameWords' nameFormat.Case' GetSingularization (Singularization.Singular' nameFormat)); " is 134.
Long Statement,DbLinq.Schema.Implementation,NameFormatter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Implementation\NameFormatter.cs,GetTableName,The length of the statement  "	tableName.MemberName = Format (words' tableName.NameWords' nameFormat.Case' GetSingularization (Singularization.Plural' nameFormat)); " is 133.
Long Statement,DbLinq.Schema.Implementation,NameFormatter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Implementation\NameFormatter.cs,GetAssociationName,The length of the statement  "	associationName.ManyToOneMemberName = Format (words' dbOneName' nameFormat.Case' GetSingularization (Singularization.Singular' nameFormat)); " is 140.
Long Statement,DbLinq.Schema.Implementation,NameFormatter,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Implementation\NameFormatter.cs,GetAssociationName,The length of the statement  "	associationName.OneToManyMemberName = Format (words' dbManyName' nameFormat.Case' GetSingularization (Singularization.Plural' nameFormat)); " is 139.
Long Statement,DbLinq.Vendor,DbSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\DbSchemaLoader.cs,LoadConstraints,The length of the statement  "	if (iConstName < 0 || iConstType < 0 || iFromColumn < 0 || iFromSchema < 0 || iFromTable < 0 || iToColumn < 0 || iToSchema < 0 || iToTable < 0) { " is 145.
Long Statement,DbLinq.Vendor,DbSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\DbSchemaLoader.cs,LoadConstraints,The length of the statement  "			LoadForeignKey (schema' table' fromColumn' fromTable' fromSchema' toColumn' toTable' toSchema' constraintName' nameFormat' names); " is 130.
Long Statement,DbLinq.Vendor,DbSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\DbSchemaLoader.cs,ReadColumns,The length of the statement  "			Console.Error.WriteLine ("Warning: The column '{0}.{1}.{2}' could not be imported because the column's DATA_TYPE is empty."' tableSchema' tableName' columnName); " is 161.
Long Statement,DbLinq.Vendor,DbSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\DbSchemaLoader.cs,FillDataTableColumnInformation,The length of the statement  "	if (column.PrimaryKey.HasValue && column.PrimaryKey.Value && (column.ManagedType == "System.Int32" || column.ManagedType == "System.Int64")) " is 140.
Long Statement,DbLinq.Vendor.Implementation,SchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SchemaLoader.Name.cs,CheckConstraintsName,The length of the statement  "	CheckConstraintsName (schema' association => association.ThisKey.Replace ('''' '_') + association.Member' association => association.Member + association.Type); " is 160.
Long Statement,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetInsertIds,The length of the statement  "	for (IEnumerator<SqlStatement> column = pkColumns.GetEnumerator ()' value = pkValues.GetEnumerator (); column.MoveNext () && value.MoveNext ();) { " is 146.
Long Statement,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetUpdate,The length of the statement  "	for (IEnumerator<SqlStatement> column = inputColumns.GetEnumerator ()' value = inputValues.GetEnumerator (); column.MoveNext () && value.MoveNext ();) { " is 152.
Long Statement,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetUpdate,The length of the statement  "	for (IEnumerator<SqlStatement> column = inputPKColumns.GetEnumerator ()' value = inputPKValues.GetEnumerator (); column.MoveNext () && value.MoveNext ();) { " is 156.
Long Statement,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetDelete,The length of the statement  "	for (IEnumerator<SqlStatement> column = inputPKColumns.GetEnumerator ()' value = inputPKValues.GetEnumerator (); column.MoveNext () && value.MoveNext ();) { " is 156.
Long Statement,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteralStringRemove,The length of the statement  "	return GetLiteralStringConcat (GetLiteralSubString (baseString' SqlStatement.Format (SpecificVendorStringIndexStart.ToString ())' startIndex)' GetLiteralSubString (baseString' GetLiteralAdd (startIndex' count).ToString ()' GetLiteralStringLength (baseString))); " is 261.
Long Statement,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteralStringInsert,The length of the statement  "	return this.GetLiteralStringConcat (this.GetLiteralStringConcat (GetLiteralSubString (stringExpression' "1"' position)' insertString)' this.GetLiteralSubString (stringExpression' GetLiteralAdd (position' "1"))); " is 211.
Complex Conditional,DbLinq.Vendor,DbSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\DbSchemaLoader.cs,LoadConstraints,The conditional expression  "iConstName < 0 || iConstType < 0 || iFromColumn < 0 || iFromSchema < 0 || iFromTable < 0 || iToColumn < 0 || iToSchema < 0 || iToTable < 0"  is complex.
Complex Conditional,DbLinq.Vendor,DbSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\DbSchemaLoader.cs,FillDataTableColumnInformation,The conditional expression  "column.PrimaryKey.HasValue && column.PrimaryKey.Value && (column.ManagedType == "System.Int32" || column.ManagedType == "System.Int64")"  is complex.
Empty Catch Block,DbLinq.Firebird,FirebirdVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Firebird\FirebirdVendor.cs,CopyOutParams,The method has an empty catch block.
Empty Catch Block,DbLinq.MySql,MySqlVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.MySql\MySqlVendor.cs,CopyOutParams,The method has an empty catch block.
Empty Catch Block,DbLinq.PostgreSql,PostgreSqlVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.PostgreSql\PgsqlVendor.cs,CopyOutParams,The method has an empty catch block.
Empty Catch Block,DbLinq.Sqlite,SqliteVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Sqlite\SqliteVendor.cs,CopyOutParams,The method has an empty catch block.
Empty Catch Block,DbLinq.Factory.Implementation,ReflectionObjectFactory,C:\repos\lytico_dblinq2007\src\DbLinq\Factory\Implementation\ReflectionObjectFactory.cs,Parse,The method has an empty catch block.
Empty Catch Block,DbLinq.Util,TextWriterExtension,C:\repos\lytico_dblinq2007\src\DbLinq\Util\TextWriterExtension.cs,WriteExpression,The method has an empty catch block.
Magic Number,DbLinq.MySql,MySqlVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.MySql\MySqlVendor.cs,BulkInsert,The following statement contains a magic number: if (pageSize == 0)  	pageSize = 99 / columns.Count;  
Magic Number,DbLinq.MySql,MySqlVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.MySql\MySqlVendor.cs,BulkInsert,The following statement contains a magic number: pageSize = 99 / columns.Count;  
Magic Number,DbLinq.Oracle,OracleVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleVendor.cs,Ping,The following statement contains a magic number: if (result is decimal)  	return (int)(decimal)result == 11;  else  	return (int)result == 11;  
Magic Number,DbLinq.Oracle,OracleVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleVendor.cs,Ping,The following statement contains a magic number: if (result is decimal)  	return (int)(decimal)result == 11;  else  	return (int)result == 11;  
Magic Number,DbLinq.Oracle,OracleVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleVendor.cs,Ping,The following statement contains a magic number: return (int)(decimal)result == 11;  
Magic Number,DbLinq.Oracle,OracleVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Oracle\OracleVendor.cs,Ping,The following statement contains a magic number: return (int)result == 11;  
Magic Number,DbLinq.Sqlite,SqliteSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Sqlite\SqliteSchemaLoader.Columns.cs,ReadColumn,The following statement contains a magic number: column.UnpackRawDbType (dataReader.GetString (2));  
Magic Number,DbLinq.Sqlite,SqliteSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Sqlite\SqliteSchemaLoader.Columns.cs,ReadColumn,The following statement contains a magic number: column.FullType = dataReader.GetString (2);  
Magic Number,DbLinq.Sqlite,SqliteSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Sqlite\SqliteSchemaLoader.Columns.cs,ReadColumn,The following statement contains a magic number: column.Nullable = dataReader.GetInt64 (3) == 0;  
Magic Number,DbLinq.Sqlite,SqliteSchemaLoader,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Sqlite\SqliteSchemaLoader.Columns.cs,ReadColumn,The following statement contains a magic number: column.PrimaryKey = dataReader.GetInt64 (5) == 1;  
Magic Number,DbLinq.SqlServer,SqlServerSqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.SqlServer\SqlServerSqlProvider.cs,GetLiteral,The following statement contains a magic number: return "'" + literal.ToString ("o").Substring (0' 23) + "'";  
Magic Number,DbLinq.Data.Linq.Sugar,ExpressionChain,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionChain.cs,GetHashCode,The following statement contains a magic number: foreach (var expression in Expressions) {  	hash <<= 10;  	hash ^= (int)expression.NodeType;  	hash ^= expression.Type.GetHashCode ();  }  
Magic Number,DbLinq.Data.Linq.Sugar,ExpressionChain,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionChain.cs,GetHashCode,The following statement contains a magic number: hash <<= 10;  
Magic Number,DbLinq.Data.Linq.Sugar.ExpressionMutator.Implementation,ConditionalExpressionMutator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionMutator\Implementation\ConditionalExpressionMutator.cs,Mutate,The following statement contains a magic number: return Expression.Condition (operands [0]' operands [1]' operands [2]);  
Magic Number,DbLinq.Data.Linq.Sugar.Expressions,ObjectOutputParameterExpression,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Expressions\ObjectOutputParameterExpression.cs,ObjectOutputParameterExpression,The following statement contains a magic number: if (lambda.Parameters.Count != 2)  	throw Error.BadArgument ("S0055: Lambda must have 2 arguments");  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeQueryableCall,The following statement contains a magic number: switch (methodName) {  case "All":  	return popCallStack (AnalyzeAll (parameters' builderContext));  case "Any":  	return popCallStack (AnalyzeAny (parameters' builderContext));  case "Average":  	return popCallStack (AnalyzeProjectionQuery (SpecialExpressionType.Average' parameters' builderContext));  case "Concat":  	return popCallStack (AnalyzeSelectOperation (SelectOperatorType.UnionAll' parameters' builderContext));  case "Contains":  	return popCallStack (AnalyzeContains (parameters' builderContext));  case "Count":  	return popCallStack (AnalyzeProjectionQuery (SpecialExpressionType.Count' parameters' builderContext));  case "DefaultIfEmpty":  	return popCallStack (AnalyzeOuterJoin (parameters' builderContext));  case "Distinct":  	return popCallStack (AnalyzeDistinct (parameters' builderContext));  case "Except":  	return popCallStack (AnalyzeSelectOperation (SelectOperatorType.Exception' parameters' builderContext));  case "First":  case "FirstOrDefault":  	return popCallStack (AnalyzeScalar (methodName' 1' parameters' builderContext));  case "GroupBy":  	return popCallStack (AnalyzeGroupBy (parameters' builderContext));  case "GroupJoin":  	return popCallStack (AnalyzeGroupJoin (parameters' builderContext));  case "Intersect":  	return popCallStack (AnalyzeSelectOperation (SelectOperatorType.Intersection' parameters' builderContext));  case "Join":  	return popCallStack (AnalyzeJoin (parameters' builderContext));  case "Last":  	return popCallStack (AnalyzeScalar (methodName' null' parameters' builderContext));  case "Max":  	return popCallStack (AnalyzeProjectionQuery (SpecialExpressionType.Max' parameters' builderContext));  case "Min":  	return popCallStack (AnalyzeProjectionQuery (SpecialExpressionType.Min' parameters' builderContext));  case "OrderBy":  case "ThenBy":  	return popCallStack (AnalyzeOrderBy (parameters' false' builderContext));  case "OrderByDescending":  case "ThenByDescending":  	return popCallStack (AnalyzeOrderBy (parameters' true' builderContext));  case "Select":  	return popCallStack (AnalyzeSelect (parameters' builderContext));  case "SelectMany":  	return popCallStack (AnalyzeSelectMany (parameters' builderContext));  case "Single":  case "SingleOrDefault":  	return popCallStack (AnalyzeScalar (methodName' 2' parameters' builderContext));  case "Skip":  	return popCallStack (AnalyzeSkip (parameters' builderContext));  case "Sum":  	return popCallStack (AnalyzeProjectionQuery (SpecialExpressionType.Sum' parameters' builderContext));  case "Take":  	return popCallStack (AnalyzeTake (parameters' builderContext));  case "Union":  	return popCallStack (AnalyzeSelectOperation (SelectOperatorType.Union' parameters' builderContext));  case "Where":  	return popCallStack (AnalyzeWhere (parameters' builderContext));  default:  	if (method.DeclaringType == typeof(Queryable))  		throw Error.BadArgument ("S0133: Implement QueryMethod Queryable.{0}."' methodName);  	return popCallStack (null);  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeQueryableCall,The following statement contains a magic number: return popCallStack (AnalyzeScalar (methodName' 2' parameters' builderContext));  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeLog,The following statement contains a magic number: if (parameters.Count == 1)  	return new SpecialExpression (SpecialExpressionType.Ln' parameters.Select (p => Analyze (p' builderContext)).ToList ());  else if (parameters.Count == 2)  	return new SpecialExpression (SpecialExpressionType.Log' parameters.Select (p => Analyze (p' builderContext)).ToList ());  else  	throw new NotSupportedException ();  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeLog,The following statement contains a magic number: if (parameters.Count == 2)  	return new SpecialExpression (SpecialExpressionType.Log' parameters.Select (p => Analyze (p' builderContext)).ToList ());  else  	throw new NotSupportedException ();  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following statement contains a magic number: switch (operationKey) {  case "Milliseconds":  	currentExpression = Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double));  	break;  case "Seconds":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (1000.0));  	break;  case "Minutes":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (60000.0));  	break;  case "Hours":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (3600000.0));  	break;  case "Days":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (86400000.0));  	break;  default:  	throw new NotSupportedException (string.Format ("The operation {0} over the TimeSpan isn't currently supported"' memberInfo.Name));  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following statement contains a magic number: switch (operationKey) {  case "Milliseconds":  	currentExpression = Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double));  	break;  case "Seconds":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (1000.0));  	break;  case "Minutes":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (60000.0));  	break;  case "Hours":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (3600000.0));  	break;  case "Days":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (86400000.0));  	break;  default:  	throw new NotSupportedException (string.Format ("The operation {0} over the TimeSpan isn't currently supported"' memberInfo.Name));  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following statement contains a magic number: switch (operationKey) {  case "Milliseconds":  	currentExpression = Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double));  	break;  case "Seconds":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (1000.0));  	break;  case "Minutes":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (60000.0));  	break;  case "Hours":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (3600000.0));  	break;  case "Days":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (86400000.0));  	break;  default:  	throw new NotSupportedException (string.Format ("The operation {0} over the TimeSpan isn't currently supported"' memberInfo.Name));  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following statement contains a magic number: switch (operationKey) {  case "Milliseconds":  	currentExpression = Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double));  	break;  case "Seconds":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (1000.0));  	break;  case "Minutes":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (60000.0));  	break;  case "Hours":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (3600000.0));  	break;  case "Days":  	currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (86400000.0));  	break;  default:  	throw new NotSupportedException (string.Format ("The operation {0} over the TimeSpan isn't currently supported"' memberInfo.Name));  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following statement contains a magic number: currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (1000.0));  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following statement contains a magic number: currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (60000.0));  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following statement contains a magic number: currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (3600000.0));  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following statement contains a magic number: currentExpression = Expression.Divide (Expression.Convert (new SpecialExpression (SpecialExpressionType.DateDiffInMilliseconds' operands.First ()' operands.ElementAt (1))' typeof(double))' Expression.Constant (86400000.0));  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,IsMetaTableDefinition,The following statement contains a magic number: if (aliases.Count != 2)  	return false;  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSelectMany,The following statement contains a magic number: if (parameters.Count == 3) {  	// ms-help://MS.VSCC.v90/MS.MSDNQTR.v90.en/fxref_system.core/html/3371348f-7811-b0bc-8c0a-2a595e08e086.htm  	var tableExpression = parameters [0];  	var projectionExpression = Analyze (parameters [1]' new[] {  		tableExpression  	}' builderContext);  	var metaTableDefinitionBuilderContext = builderContext.Clone ();  	metaTableDefinitionBuilderContext.ExpectMetaTableDefinition = true;  	var expression = Analyze (parameters [2]' new[] {  		tableExpression'  		projectionExpression  	}' metaTableDefinitionBuilderContext);  	if (false) {  		var newExpression = expression as NewExpression;  		if (newExpression != null) {  			Type metaTableType;  			var associations = GetTypeInitializers<MutableExpression> (newExpression' true' out metaTableType);  			return RegisterMetaTable (metaTableType' associations' builderContext);  		}  	}  	return expression;  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSelectMany,The following statement contains a magic number: if (parameters.Count == 3) {  	// ms-help://MS.VSCC.v90/MS.MSDNQTR.v90.en/fxref_system.core/html/3371348f-7811-b0bc-8c0a-2a595e08e086.htm  	var tableExpression = parameters [0];  	var projectionExpression = Analyze (parameters [1]' new[] {  		tableExpression  	}' builderContext);  	var metaTableDefinitionBuilderContext = builderContext.Clone ();  	metaTableDefinitionBuilderContext.ExpectMetaTableDefinition = true;  	var expression = Analyze (parameters [2]' new[] {  		tableExpression'  		projectionExpression  	}' metaTableDefinitionBuilderContext);  	if (false) {  		var newExpression = expression as NewExpression;  		if (newExpression != null) {  			Type metaTableType;  			var associations = GetTypeInitializers<MutableExpression> (newExpression' true' out metaTableType);  			return RegisterMetaTable (metaTableType' associations' builderContext);  		}  	}  	return expression;  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeJoin,The following statement contains a magic number: if (parameters.Count == 5) {  	var leftExpression = Analyze (parameters [0]' builderContext);  	var rightExpression = Analyze (parameters [1]' builderContext);  	var leftJoin = Analyze (parameters [2]' leftExpression' builderContext);  	var rightJoin = Analyze (parameters [3]' rightExpression' builderContext);  	var rightTable = rightExpression as TableExpression ?? FindTable (rightJoin);  	if (rightTable == null)  		throw Error.BadArgument ("S0536: No way to find right table for Join");  	var leftTable = // from here' we have two options to join:  	leftExpression as TableExpression ?? // 1. left and right are tables' we can use generic expressions (most common)  	FindTable (leftJoin);  	// 2. left is something else (a meta table)  	if (leftTable == null)  		throw Error.BadArgument ("S0701: No way to find left table for Join");  	if (rightTable.JoinedTable != null)  		throw Error.BadArgument ("S0702: Unable to join Table {0} with {1}; there is already a Join with {2}"' rightTable.Name' leftTable.Name' rightTable.JoinedTable.Name);  	rightTable.Join (joinType' leftTable' Expression.Equal (leftJoin' rightJoin)' string.Format ("join{0}"' builderContext.EnumerateAllTables ().Count ()));  	var metaTableDefinitionBuilderContext = builderContext.Clone ();  	metaTableDefinitionBuilderContext.ExpectMetaTableDefinition = true;  	var expression = Analyze (parameters [4]' new[] {  		leftExpression'  		rightExpression  	}' metaTableDefinitionBuilderContext);  	return expression;  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeJoin,The following statement contains a magic number: if (parameters.Count == 5) {  	var leftExpression = Analyze (parameters [0]' builderContext);  	var rightExpression = Analyze (parameters [1]' builderContext);  	var leftJoin = Analyze (parameters [2]' leftExpression' builderContext);  	var rightJoin = Analyze (parameters [3]' rightExpression' builderContext);  	var rightTable = rightExpression as TableExpression ?? FindTable (rightJoin);  	if (rightTable == null)  		throw Error.BadArgument ("S0536: No way to find right table for Join");  	var leftTable = // from here' we have two options to join:  	leftExpression as TableExpression ?? // 1. left and right are tables' we can use generic expressions (most common)  	FindTable (leftJoin);  	// 2. left is something else (a meta table)  	if (leftTable == null)  		throw Error.BadArgument ("S0701: No way to find left table for Join");  	if (rightTable.JoinedTable != null)  		throw Error.BadArgument ("S0702: Unable to join Table {0} with {1}; there is already a Join with {2}"' rightTable.Name' leftTable.Name' rightTable.JoinedTable.Name);  	rightTable.Join (joinType' leftTable' Expression.Equal (leftJoin' rightJoin)' string.Format ("join{0}"' builderContext.EnumerateAllTables ().Count ()));  	var metaTableDefinitionBuilderContext = builderContext.Clone ();  	metaTableDefinitionBuilderContext.ExpectMetaTableDefinition = true;  	var expression = Analyze (parameters [4]' new[] {  		leftExpression'  		rightExpression  	}' metaTableDefinitionBuilderContext);  	return expression;  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeJoin,The following statement contains a magic number: if (parameters.Count == 5) {  	var leftExpression = Analyze (parameters [0]' builderContext);  	var rightExpression = Analyze (parameters [1]' builderContext);  	var leftJoin = Analyze (parameters [2]' leftExpression' builderContext);  	var rightJoin = Analyze (parameters [3]' rightExpression' builderContext);  	var rightTable = rightExpression as TableExpression ?? FindTable (rightJoin);  	if (rightTable == null)  		throw Error.BadArgument ("S0536: No way to find right table for Join");  	var leftTable = // from here' we have two options to join:  	leftExpression as TableExpression ?? // 1. left and right are tables' we can use generic expressions (most common)  	FindTable (leftJoin);  	// 2. left is something else (a meta table)  	if (leftTable == null)  		throw Error.BadArgument ("S0701: No way to find left table for Join");  	if (rightTable.JoinedTable != null)  		throw Error.BadArgument ("S0702: Unable to join Table {0} with {1}; there is already a Join with {2}"' rightTable.Name' leftTable.Name' rightTable.JoinedTable.Name);  	rightTable.Join (joinType' leftTable' Expression.Equal (leftJoin' rightJoin)' string.Format ("join{0}"' builderContext.EnumerateAllTables ().Count ()));  	var metaTableDefinitionBuilderContext = builderContext.Clone ();  	metaTableDefinitionBuilderContext.ExpectMetaTableDefinition = true;  	var expression = Analyze (parameters [4]' new[] {  		leftExpression'  		rightExpression  	}' metaTableDefinitionBuilderContext);  	return expression;  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeJoin,The following statement contains a magic number: if (parameters.Count == 5) {  	var leftExpression = Analyze (parameters [0]' builderContext);  	var rightExpression = Analyze (parameters [1]' builderContext);  	var leftJoin = Analyze (parameters [2]' leftExpression' builderContext);  	var rightJoin = Analyze (parameters [3]' rightExpression' builderContext);  	var rightTable = rightExpression as TableExpression ?? FindTable (rightJoin);  	if (rightTable == null)  		throw Error.BadArgument ("S0536: No way to find right table for Join");  	var leftTable = // from here' we have two options to join:  	leftExpression as TableExpression ?? // 1. left and right are tables' we can use generic expressions (most common)  	FindTable (leftJoin);  	// 2. left is something else (a meta table)  	if (leftTable == null)  		throw Error.BadArgument ("S0701: No way to find left table for Join");  	if (rightTable.JoinedTable != null)  		throw Error.BadArgument ("S0702: Unable to join Table {0} with {1}; there is already a Join with {2}"' rightTable.Name' leftTable.Name' rightTable.JoinedTable.Name);  	rightTable.Join (joinType' leftTable' Expression.Equal (leftJoin' rightJoin)' string.Format ("join{0}"' builderContext.EnumerateAllTables ().Count ()));  	var metaTableDefinitionBuilderContext = builderContext.Clone ();  	metaTableDefinitionBuilderContext.ExpectMetaTableDefinition = true;  	var expression = Analyze (parameters [4]' new[] {  		leftExpression'  		rightExpression  	}' metaTableDefinitionBuilderContext);  	return expression;  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeGroupBy,The following statement contains a magic number: if (parameters.Count == 2)  	result = table;  // we return the whole table  else if (parameters.Count == 3)  	result = Analyze (parameters [2]' table' builderContext);  // 3 parameters for a projection expression  else  	throw Error.BadArgument ("S0629: Don't know how to handle Expression to group by with {0} parameters"' parameters.Count);  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeGroupBy,The following statement contains a magic number: if (parameters.Count == 2)  	result = table;  // we return the whole table  else if (parameters.Count == 3)  	result = Analyze (parameters [2]' table' builderContext);  // 3 parameters for a projection expression  else  	throw Error.BadArgument ("S0629: Don't know how to handle Expression to group by with {0} parameters"' parameters.Count);  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeGroupBy,The following statement contains a magic number: if (parameters.Count == 2)  	result = table;  // we return the whole table  else if (parameters.Count == 3)  	result = Analyze (parameters [2]' table' builderContext);  // 3 parameters for a projection expression  else  	throw Error.BadArgument ("S0629: Don't know how to handle Expression to group by with {0} parameters"' parameters.Count);  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeGroupBy,The following statement contains a magic number: if (parameters.Count == 3)  	result = Analyze (parameters [2]' table' builderContext);  // 3 parameters for a projection expression  else  	throw Error.BadArgument ("S0629: Don't know how to handle Expression to group by with {0} parameters"' parameters.Count);  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeGroupBy,The following statement contains a magic number: if (parameters.Count == 3)  	result = Analyze (parameters [2]' table' builderContext);  // 3 parameters for a projection expression  else  	throw Error.BadArgument ("S0629: Don't know how to handle Expression to group by with {0} parameters"' parameters.Count);  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeGroupBy,The following statement contains a magic number: result = Analyze (parameters [2]' table' builderContext);  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSubString,The following statement contains a magic number: if (parameters.Count > 2) {  	var lengthExpression = parameters [2];  	return new SpecialExpression (SpecialExpressionType.Substring' stringExpression' startExpression' lengthExpression);  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeSubString,The following statement contains a magic number: if (parameters.Count > 2) {  	var lengthExpression = parameters [2];  	return new SpecialExpression (SpecialExpressionType.Substring' stringExpression' startExpression' lengthExpression);  }  
Magic Number,DbLinq.Data.Linq.Sugar.Implementation,ExpressionOptimizer,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionOptimizer.cs,AnalyzeConstant,The following statement contains a magic number: if ((short)expression.NodeType > 999)  	return expression;  
Magic Number,DbLinq.Schema.Dbml.Adapter,EnumType,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\Adapter\EnumType.cs,Extract,The following statement contains a magic number: if (nameValues.Length == 2) {  	// extract the name  	string name = nameValues [0].Trim ();  	if (!name.IsIdentifier ())  		return false;  	// now extract the values  	IDictionary<string' int> readValues = new Dictionary<string' int> ();  	int currentValue = 1;  	var keyValues = nameValues [1].Split (''');  	foreach (var keyValue in keyValues) {  		// a value may indicate its numeric equivalent' or not (in this case' we work the same way as C# enums' with an implicit counter)  		var keyValueParts = keyValue.Split (new[] {  			'='  		}' 2);  		var key = keyValueParts [0].Trim ();  		if (!key.IsIdentifier ())  			return false;  		if (keyValueParts.Length > 1) {  			if (!int.TryParse (keyValueParts [1]' out currentValue))  				return false;  		}  		readValues [key] = currentValue++;  	}  	if (name == "enum")  		enumName = string.Empty;  	else  		enumName = name;  	values = readValues;  	return true;  }  
Magic Number,DbLinq.Schema.Dbml.Adapter,EnumType,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\Adapter\EnumType.cs,Extract,The following statement contains a magic number: if (nameValues.Length == 2) {  	// extract the name  	string name = nameValues [0].Trim ();  	if (!name.IsIdentifier ())  		return false;  	// now extract the values  	IDictionary<string' int> readValues = new Dictionary<string' int> ();  	int currentValue = 1;  	var keyValues = nameValues [1].Split (''');  	foreach (var keyValue in keyValues) {  		// a value may indicate its numeric equivalent' or not (in this case' we work the same way as C# enums' with an implicit counter)  		var keyValueParts = keyValue.Split (new[] {  			'='  		}' 2);  		var key = keyValueParts [0].Trim ();  		if (!key.IsIdentifier ())  			return false;  		if (keyValueParts.Length > 1) {  			if (!int.TryParse (keyValueParts [1]' out currentValue))  				return false;  		}  		readValues [key] = currentValue++;  	}  	if (name == "enum")  		enumName = string.Empty;  	else  		enumName = name;  	values = readValues;  	return true;  }  
Magic Number,DbLinq.Schema.Dbml.Adapter,EnumType,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\Adapter\EnumType.cs,Extract,The following statement contains a magic number: foreach (var keyValue in keyValues) {  	// a value may indicate its numeric equivalent' or not (in this case' we work the same way as C# enums' with an implicit counter)  	var keyValueParts = keyValue.Split (new[] {  		'='  	}' 2);  	var key = keyValueParts [0].Trim ();  	if (!key.IsIdentifier ())  		return false;  	if (keyValueParts.Length > 1) {  		if (!int.TryParse (keyValueParts [1]' out currentValue))  			return false;  	}  	readValues [key] = currentValue++;  }  
Magic Number,DbLinq.Util,TextWriterExtension,C:\repos\lytico_dblinq2007\src\DbLinq\Util\TextWriterExtension.cs,GetPrefix,The following statement contains a magic number: return string.Empty.PadRight (depth * 2' '.');  
Magic Number,DbLinq.Language.Implementation,AbstractEndPluralWords,C:\repos\lytico_dblinq2007\src\DbLinq\Language\Implementation\AbstractEndPluralWords.cs,ComputeSingular,The following statement contains a magic number: if (plural.Length < 2)  	return plural;  
Magic Number,DbLinq.Language.Implementation,AbstractEndPluralWords,C:\repos\lytico_dblinq2007\src\DbLinq\Language\Implementation\AbstractEndPluralWords.cs,ComputePlural,The following statement contains a magic number: if (singular.Length < 2)  	return singular;  
Magic Number,DbLinq.Language.Implementation,AbstractWords,C:\repos\lytico_dblinq2007\src\DbLinq\Language\Implementation\AbstractWords.cs,GetNote,The following statement contains a magic number: return averageWeight / words.Count * 1000;  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) {  case ExpressionType.Add:  	return GetLiteralAdd (p [0]' p [1]);  case ExpressionType.AddChecked:  	return GetLiteralAddChecked (p [0]' p [1]);  case ExpressionType.And:  	return GetLiteralAnd (p [0]' p [1]);  case ExpressionType.AndAlso:  	return GetLiteralAndAlso (p [0]' p [1]);  case ExpressionType.ArrayLength:  	return GetLiteralArrayLength (p [0]' p [1]);  case ExpressionType.ArrayIndex:  	return GetLiteralArrayIndex (p [0]' p [1]);  case ExpressionType.Call:  	return GetLiteralCall (p [0]);  case ExpressionType.Coalesce:  	return GetLiteralCoalesce (p [0]' p [1]);  case ExpressionType.Conditional:  	return GetLiteralConditional (p [0]' p [1]' p [2]);  //case ExpressionType.Constant:  //break;  case ExpressionType.Divide:  	return GetLiteralDivide (p [0]' p [1]);  case ExpressionType.Equal:  	return GetLiteralEqual (p [0]' p [1]);  case ExpressionType.ExclusiveOr:  	return GetLiteralExclusiveOr (p [0]' p [1]);  case ExpressionType.GreaterThan:  	return GetLiteralGreaterThan (p [0]' p [1]);  case ExpressionType.GreaterThanOrEqual:  	return GetLiteralGreaterThanOrEqual (p [0]' p [1]);  //case ExpressionType.Invoke:  //break;  //case ExpressionType.Lambda:  //break;  case ExpressionType.LeftShift:  	return GetLiteralLeftShift (p [0]' p [1]);  case ExpressionType.LessThan:  	return GetLiteralLessThan (p [0]' p [1]);  case ExpressionType.LessThanOrEqual:  	return GetLiteralLessThanOrEqual (p [0]' p [1]);  //case ExpressionType.ListInit:  //break;  //case ExpressionType.MemberAccess:  //    break;  //case ExpressionType.MemberInit:  //    break;  case ExpressionType.Modulo:  	return GetLiteralModulo (p [0]' p [1]);  case ExpressionType.Multiply:  	return GetLiteralMultiply (p [0]' p [1]);  case ExpressionType.MultiplyChecked:  	return GetLiteralMultiplyChecked (p [0]' p [1]);  case ExpressionType.Negate:  	return GetLiteralNegate (p [0]);  case ExpressionType.UnaryPlus:  	return GetLiteralUnaryPlus (p [0]);  case ExpressionType.NegateChecked:  	return GetLiteralNegateChecked (p [0]);  //case ExpressionType.New:  //    break;  //case ExpressionType.NewArrayInit:  //    break;  //case ExpressionType.NewArrayBounds:  //    break;  case ExpressionType.Not:  	return GetLiteralNot (p [0]);  case ExpressionType.NotEqual:  	return GetLiteralNotEqual (p [0]' p [1]);  case ExpressionType.Or:  	return GetLiteralOr (p [0]' p [1]);  case ExpressionType.OrElse:  	return GetLiteralOrElse (p [0]' p [1]);  //case ExpressionType.Parameter:  //    break;  case ExpressionType.Power:  	return GetLiteralPower (p [0]' p [1]);  //case ExpressionType.Quote:  //    break;  case ExpressionType.RightShift:  	return GetLiteralRightShift (p [0]' p [1]);  case ExpressionType.Subtract:  	return GetLiteralSubtract (p [0]' p [1]);  case ExpressionType.SubtractChecked:  	return GetLiteralSubtractChecked (p [0]' p [1]);  //case ExpressionType.TypeAs:  //    break;  //case ExpressionType.TypeIs:  //    break;  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: return GetLiteralConditional (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count > 2)  	return GetLiteralSubString (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count > 2)  	return GetLiteralSubString (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: return GetLiteralSubString (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: return GetLiteralStringInsert (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: return GetLiteralStringReplace (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count > 2)  	return GetLiteralStringRemove (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count > 2)  	return GetLiteralStringRemove (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: return GetLiteralStringRemove (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 2)  	return GetLiteralStringIndexOf (p [0]' p [1]);  else if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 2)  	return GetLiteralStringIndexOf (p [0]' p [1]);  else if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 2)  	return GetLiteralStringIndexOf (p [0]' p [1]);  else if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 2)  	return GetLiteralStringIndexOf (p [0]' p [1]);  else if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 2)  	return GetLiteralStringIndexOf (p [0]' p [1]);  else if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 2)  	return GetLiteralStringIndexOf (p [0]' p [1]);  else if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 3)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  else if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: if (p.Count == 4)  	return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following statement contains a magic number: return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  
Magic Number,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,IsMadeSafe,The following statement contains a magic number: if (l < 2)  	return false;  
Missing Default,DbLinq.Ingres,IngresVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Ingres\IngresVendor.cs,isReplaceable,The following switch statement is missing a default case: switch (param.DbType) {  case DbType.String:  case DbType.Int16:  case DbType.Int32:  case DbType.Int64:  case DbType.Double:  	return true;  }  
Missing Default,DbLinq.Ingres,IngresVendor,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.Ingres\IngresVendor.cs,getParamValueAsString,The following switch statement is missing a default case: switch (param.DbType) {  case DbType.String:  	return " '" + param.Value.ToString () + "' ";  case DbType.Int16:  case DbType.Int32:  case DbType.Int64:  case DbType.Double:  	return param.Value.ToString ();  }  
Missing Default,DbLinq.SqlServer,SqlServerTypeConversions,C:\repos\lytico_dblinq2007\src\DbLinq\..\DbLinq.SqlServer\SqlServerTypeConversions.cs,ParseType,The following switch statement is missing a default case: switch (typeStrL) {  case "tinyint":  	return SqlDbType.Int;  case "int":  	return SqlDbType.Int;  }  
Missing Default,DbLinq.Data.Linq.Sugar.ExpressionMutator.Implementation,BinaryExpressionMutator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionMutator\Implementation\BinaryExpressionMutator.cs,Mutate,The following switch statement is missing a default case: switch (BinaryExpression.NodeType) {  case ExpressionType.Add:  	if (BinaryExpression.Method != null)  		return Expression.Add (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.Add (operands [0]' operands [1]);  case ExpressionType.AddChecked:  	if (BinaryExpression.Method != null)  		return Expression.AddChecked (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.AddChecked (operands [0]' operands [1]);  case ExpressionType.Divide:  	if (BinaryExpression.Method != null)  		return Expression.Divide (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.Divide (operands [0]' operands [1]);  case ExpressionType.Modulo:  	if (BinaryExpression.Method != null)  		return Expression.Modulo (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.Modulo (operands [0]' operands [1]);  case ExpressionType.Multiply:  	if (BinaryExpression.Method != null)  		return Expression.Multiply (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.Multiply (operands [0]' operands [1]);  case ExpressionType.MultiplyChecked:  	if (BinaryExpression.Method != null)  		return Expression.MultiplyChecked (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.MultiplyChecked (operands [0]' operands [1]);  case ExpressionType.Power:  	if (BinaryExpression.Method != null)  		return Expression.Power (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.Power (operands [0]' operands [1]);  case ExpressionType.Subtract:  	if (BinaryExpression.Method != null)  		return Expression.Subtract (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.Subtract (operands [0]' operands [1]);  case ExpressionType.SubtractChecked:  	if (BinaryExpression.Method != null)  		return Expression.SubtractChecked (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.SubtractChecked (operands [0]' operands [1]);  case ExpressionType.And:  	if (BinaryExpression.Method != null)  		return Expression.And (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.And (operands [0]' operands [1]);  case ExpressionType.Or:  	if (BinaryExpression.Method != null)  		return Expression.Or (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.Or (operands [0]' operands [1]);  case ExpressionType.ExclusiveOr:  	if (BinaryExpression.Method != null)  		return Expression.ExclusiveOr (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.ExclusiveOr (operands [0]' operands [1]);  case ExpressionType.LeftShift:  	if (BinaryExpression.Method != null)  		return Expression.LeftShift (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.LeftShift (operands [0]' operands [1]);  case ExpressionType.RightShift:  	if (BinaryExpression.Method != null)  		return Expression.RightShift (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.RightShift (operands [0]' operands [1]);  case ExpressionType.AndAlso:  	if (BinaryExpression.Method != null)  		return Expression.AndAlso (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.AndAlso (operands [0]' operands [1]);  case ExpressionType.OrElse:  	if (BinaryExpression.Method != null)  		return Expression.OrElse (operands [0]' operands [1]' BinaryExpression.Method);  	return Expression.OrElse (operands [0]' operands [1]);  case ExpressionType.Equal:  	if (BinaryExpression.Method != null)  		return Expression.Equal (operands [0]' operands [1]' BinaryExpression.IsLiftedToNull' BinaryExpression.Method);  	return Expression.Equal (operands [0]' operands [1]);  case ExpressionType.NotEqual:  	if (BinaryExpression.Method != null)  		return Expression.NotEqual (operands [0]' operands [1]' BinaryExpression.IsLiftedToNull' BinaryExpression.Method);  	return Expression.NotEqual (operands [0]' operands [1]);  case ExpressionType.GreaterThanOrEqual:  	if (BinaryExpression.Method != null)  		return Expression.GreaterThanOrEqual (operands [0]' operands [1]' BinaryExpression.IsLiftedToNull' BinaryExpression.Method);  	return Expression.GreaterThanOrEqual (operands [0]' operands [1]);  case ExpressionType.GreaterThan:  	if (BinaryExpression.Method != null)  		return Expression.GreaterThan (operands [0]' operands [1]' BinaryExpression.IsLiftedToNull' BinaryExpression.Method);  	return Expression.GreaterThan (operands [0]' operands [1]);  case ExpressionType.LessThan:  	if (BinaryExpression.Method != null)  		return Expression.LessThan (operands [0]' operands [1]' BinaryExpression.IsLiftedToNull' BinaryExpression.Method);  	return Expression.LessThan (operands [0]' operands [1]);  case ExpressionType.LessThanOrEqual:  	if (BinaryExpression.Method != null)  		return Expression.LessThanOrEqual (operands [0]' operands [1]' BinaryExpression.IsLiftedToNull' BinaryExpression.Method);  	return Expression.LessThanOrEqual (operands [0]' operands [1]);  case ExpressionType.Coalesce:  	if (BinaryExpression.Conversion != null)  		return Expression.Coalesce (operands [0]' operands [1]' BinaryExpression.Conversion);  	return Expression.Coalesce (operands [0]' operands [1]);  case ExpressionType.ArrayIndex:  	return Expression.ArrayIndex (operands [0]' operands.Skip (1));  }  
Missing Default,DbLinq.Data.Linq.Sugar.ExpressionMutator.Implementation,NewArrayExpressionMutator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionMutator\Implementation\NewArrayExpressionMutator.cs,Mutate,The following switch statement is missing a default case: switch (NewArrayExpression.NodeType) {  case ExpressionType.NewArrayBounds:  	return Expression.NewArrayBounds (NewArrayExpression.Type' operands);  case ExpressionType.NewArrayInit:  	return Expression.NewArrayInit (NewArrayExpression.Type' operands);  }  
Missing Default,DbLinq.Data.Linq.Sugar.ExpressionMutator.Implementation,UnaryExpressionMutator,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\ExpressionMutator\Implementation\UnaryExpressionMutator.cs,Mutate,The following switch statement is missing a default case: switch (UnaryExpression.NodeType) {  case ExpressionType.ArrayLength:  	return Expression.ArrayLength (operands [0]);  case ExpressionType.Convert:  	if (UnaryExpression.Method != null)  		return Expression.Convert (operands [0]' UnaryExpression.Type' UnaryExpression.Method);  	return Expression.Convert (operands [0]' UnaryExpression.Type);  case ExpressionType.ConvertChecked:  	if (UnaryExpression.Method != null)  		return Expression.ConvertChecked (operands [0]' UnaryExpression.Type' UnaryExpression.Method);  	return Expression.ConvertChecked (operands [0]' UnaryExpression.Type);  case ExpressionType.Negate:  	if (UnaryExpression.Method != null)  		return Expression.Negate (operands [0]' UnaryExpression.Method);  	return Expression.Negate (operands [0]);  case ExpressionType.NegateChecked:  	if (UnaryExpression.Method != null)  		return Expression.NegateChecked (operands [0]' UnaryExpression.Method);  	return Expression.NegateChecked (operands [0]);  case ExpressionType.Not:  	if (UnaryExpression.Method != null)  		return Expression.Not (operands [0]' UnaryExpression.Method);  	return Expression.Not (operands [0]);  case ExpressionType.Quote:  	return Expression.Quote (operands [0]);  case ExpressionType.TypeAs:  	return Expression.TypeAs (operands [0]' UnaryExpression.Type);  case ExpressionType.UnaryPlus:  	if (UnaryExpression.Method != null)  		return Expression.UnaryPlus (operands [0]' UnaryExpression.Method);  	return Expression.UnaryPlus (operands [0]);  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,Analyze,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.Call:  	return AnalyzeCall ((MethodCallExpression)expression' parameters' builderContext);  case ExpressionType.Lambda:  	return AnalyzeLambda (expression' parameters' builderContext);  case ExpressionType.Parameter:  	return AnalyzeParameter (expression' builderContext);  case ExpressionType.Quote:  	return AnalyzeQuote (expression' parameters' builderContext);  case ExpressionType.MemberAccess:  	return AnalyzeMember (expression' builderContext);  #region case ExpressionType.<Common operators>:  case ExpressionType.Add:  case ExpressionType.AddChecked:  case ExpressionType.Divide:  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  case ExpressionType.Power:  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked:  case ExpressionType.And:  case ExpressionType.Or:  case ExpressionType.ExclusiveOr:  case ExpressionType.LeftShift:  case ExpressionType.RightShift:  case ExpressionType.AndAlso:  case ExpressionType.OrElse:  case ExpressionType.Equal:  case ExpressionType.NotEqual:  case ExpressionType.GreaterThanOrEqual:  case ExpressionType.GreaterThan:  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  case ExpressionType.Coalesce:  //case ExpressionType.ArrayIndex  //case ExpressionType.ArrayLength  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  case ExpressionType.Negate:  case ExpressionType.NegateChecked:  case ExpressionType.Not:  //case ExpressionType.TypeAs  case ExpressionType.UnaryPlus:  case ExpressionType.MemberInit:  	#endregion  	return AnalyzeOperator (expression' builderContext);  case ExpressionType.New:  	return AnalyzeNewOperator (expression' builderContext);  case ExpressionType.Constant:  	return AnalyzeConstant (expression' builderContext);  case ExpressionType.Invoke:  	return AnalyzeInvoke (expression' parameters' builderContext);  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeUnknownCall,The following switch statement is missing a default case: switch (method.Name) {  case "Parse":  	if (method.IsStatic && parameters.Count == 1)  		return AnalyzeParse (method' parameters' builderContext);  	break;  case "ToString":  	// Can we sanity check this type?  	return AnalyzeToString (method' parameters' builderContext);  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeTimeSpanMemberAccess,The following switch statement is missing a default case: switch (memberInfo.Name) {  case "Milliseconds":  	currentExpression = Expression.Convert (Expression.Modulo (Expression.Convert (currentExpression' typeof(long))' Expression.Constant (1000L))' typeof(int));  	break;  case "Seconds":  	currentExpression = Expression.Convert (Expression.Modulo (Expression.Convert (currentExpression' typeof(long))' Expression.Constant (60L))' typeof(int));  	break;  case "Minutes":  	currentExpression = Expression.Convert (Expression.Modulo (Expression.Convert (currentExpression' typeof(long))' Expression.Constant (60L))' typeof(int));  	break;  case "Hours":  	currentExpression = Expression.Convert (Expression.Modulo (Expression.Convert (currentExpression' typeof(long))' Expression.Constant (24L))' typeof(int));  	break;  case "Days":  	currentExpression = Expression.Convert (currentExpression' typeof(int));  	break;  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,ExpressionDispatcher,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionDispatcher.Analyzer.cs,AnalyzeCommonMember,The following switch statement is missing a default case: switch (memberInfo.Name) {  case "Length":  	return new SpecialExpression (SpecialExpressionType.StringLength' objectExpression);  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,ExpressionOptimizer,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionOptimizer.cs,AnalyzeBinaryBoolean,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.AndAlso:  	if (canOptimizeLeft)  		if ((bool)bin.Left.Evaluate ())  			return bin.Right;  		// (TRUE and X) == X   		else  			return bin.Left;  	// (FALSE and X) == FALSE   	if (canOptimizeRight)  		if ((bool)bin.Right.Evaluate ())  			return bin.Left;  		// (X and TRUE) == X   		else  			return bin.Right;  	// (X and FALSE) == FALSE  	break;  case ExpressionType.OrElse:  	if (canOptimizeLeft)  		if ((bool)bin.Left.Evaluate ())  			return bin.Left;  		// (TRUE or X) == TRUE   		else  			return bin.Right;  	// (FALSE or X) == X   	if (canOptimizeRight)  		if ((bool)bin.Right.Evaluate ())  			return bin.Right;  		// (X or TRUE) == TRUE   		else  			return bin.Left;  	// (X or FALSE) == X  	break;  case ExpressionType.Equal:  	// TODO: this optimization should work for Unary Expression Too  	// this actually produce errors becouse of string based Sql generation  	canOptimizeLeft = canOptimizeLeft && bin.Right is BinaryExpression;  	if (canOptimizeLeft)  		if ((bool)bin.Left.Evaluate ())  			return bin.Right;  		// (TRUE == X) == X   		else  			return Expression.Not (bin.Right);  	// (FALSE == X) == not X   	canOptimizeRight = canOptimizeRight && bin.Left is BinaryExpression;  	// TODO: this optimization should work for Unary Expression Too  	// this actually produce errors becouse of string based Sql generation  	if (canOptimizeRight)  		if ((bool)bin.Right.Evaluate ())  			return bin.Left;  		// (X == TRUE) == X   		else  			return Expression.Not (bin.Left);  	// (X == FALSE) == not X  	break;  case ExpressionType.NotEqual:  	canOptimizeLeft = canOptimizeLeft && bin.Right is BinaryExpression;  	// TODO: this optimization should work for Unary Expression Too  	// this actually produce errors becouse of string based Sql generation  	if (canOptimizeLeft)  		if ((bool)bin.Left.Evaluate ())  			return Expression.Not (bin.Right);  		// (TRUE != X) == not X   		else  			return bin.Right;  	// (FALSE != X) == X   	canOptimizeRight = canOptimizeRight && bin.Left is BinaryExpression;  	// TODO: this optimization should work for Unary Expression Too  	// this actually produce errors becouse of string based Sql generation  	if (canOptimizeRight)  		if ((bool)bin.Right.Evaluate ())  			return Expression.Not (bin.Left);  		// (X != TRUE) == not X   		else  			return bin.Left;  	// (X != FALSE) == X  	break;  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,ExpressionOptimizer,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionOptimizer.cs,AnalyzeNot,The following switch statement is missing a default case: switch (subExpression.NodeType) {  case ExpressionType.Equal:  	return Expression.NotEqual (subOperands [0]' subOperands [1]);  case ExpressionType.GreaterThan:  	return Expression.LessThanOrEqual (subOperands [0]' subOperands [1]);  case ExpressionType.GreaterThanOrEqual:  	return Expression.LessThan (subOperands [0]' subOperands [1]);  case ExpressionType.LessThan:  	return Expression.GreaterThanOrEqual (subOperands [0]' subOperands [1]);  case ExpressionType.LessThanOrEqual:  	return Expression.GreaterThan (subOperands [0]' subOperands [1]);  case ExpressionType.Not:  	return subOperands [0];  // not not x -> x :)  case ExpressionType.NotEqual:  	return Expression.Equal (subOperands [0]' subOperands [1]);  case (ExpressionType)SpecialExpressionType.IsNotNull:  	// is this dirty work?  	return new SpecialExpression (SpecialExpressionType.IsNull' subOperands);  case (ExpressionType)SpecialExpressionType.IsNull:  	return new SpecialExpression (SpecialExpressionType.IsNotNull' subOperands);  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,ExpressionOptimizer,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionOptimizer.cs,GetNullComparison,The following switch statement is missing a default case: switch (nodeType) {  case ExpressionType.Equal:  	return new SpecialExpression (SpecialExpressionType.IsNull' columnExpression);  case ExpressionType.NotEqual:  	return new SpecialExpression (SpecialExpressionType.IsNotNull' columnExpression);  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,ExpressionQualifier,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\ExpressionQualifier.cs,GetPrecedence,The following switch statement is missing a default case: switch (expression.NodeType) {  case ExpressionType.Add:  case ExpressionType.AddChecked:  	return ExpressionPrecedence.Additive;  case ExpressionType.And:  case ExpressionType.AndAlso:  	return ExpressionPrecedence.ConditionalAnd;  case ExpressionType.ArrayLength:  case ExpressionType.ArrayIndex:  case ExpressionType.Call:  	return ExpressionPrecedence.Primary;  case ExpressionType.Coalesce:  	return ExpressionPrecedence.NullCoalescing;  case ExpressionType.Conditional:  	return ExpressionPrecedence.Conditional;  case ExpressionType.Constant:  	return ExpressionPrecedence.Primary;  case ExpressionType.Convert:  case ExpressionType.ConvertChecked:  	return ExpressionPrecedence.Primary;  case ExpressionType.Divide:  	return ExpressionPrecedence.Multiplicative;  case ExpressionType.Equal:  	return ExpressionPrecedence.Equality;  case ExpressionType.ExclusiveOr:  	return ExpressionPrecedence.LogicalXor;  case ExpressionType.GreaterThan:  case ExpressionType.GreaterThanOrEqual:  	return ExpressionPrecedence.RelationalAndTypeTest;  case ExpressionType.Invoke:  	return ExpressionPrecedence.Primary;  case ExpressionType.Lambda:  	return ExpressionPrecedence.Primary;  case ExpressionType.LeftShift:  	return ExpressionPrecedence.Shift;  case ExpressionType.LessThan:  case ExpressionType.LessThanOrEqual:  	return ExpressionPrecedence.RelationalAndTypeTest;  case ExpressionType.ListInit:  case ExpressionType.MemberAccess:  case ExpressionType.MemberInit:  	return ExpressionPrecedence.Primary;  case ExpressionType.Modulo:  case ExpressionType.Multiply:  case ExpressionType.MultiplyChecked:  	return ExpressionPrecedence.Multiplicative;  case ExpressionType.Negate:  case ExpressionType.UnaryPlus:  case ExpressionType.NegateChecked:  	return ExpressionPrecedence.Unary;  case ExpressionType.New:  case ExpressionType.NewArrayInit:  case ExpressionType.NewArrayBounds:  	return ExpressionPrecedence.Primary;  case ExpressionType.Not:  	return ExpressionPrecedence.Unary;  case ExpressionType.NotEqual:  	return ExpressionPrecedence.Equality;  case ExpressionType.Or:  case ExpressionType.OrElse:  	return ExpressionPrecedence.ConditionalOr;  case ExpressionType.Parameter:  	return ExpressionPrecedence.Primary;  case ExpressionType.Power:  	return ExpressionPrecedence.Primary;  case ExpressionType.Quote:  	return ExpressionPrecedence.Primary;  case ExpressionType.RightShift:  	return ExpressionPrecedence.Shift;  case ExpressionType.Subtract:  case ExpressionType.SubtractChecked:  	return ExpressionPrecedence.Additive;  case ExpressionType.TypeAs:  case ExpressionType.TypeIs:  	return ExpressionPrecedence.RelationalAndTypeTest;  }  
Missing Default,DbLinq.Data.Linq.Sugar.Implementation,QueryRunner,C:\repos\lytico_dblinq2007\src\DbLinq\Data\Linq\Sugar\Implementation\QueryRunner.cs,SelectScalar,The following switch statement is missing a default case: switch (selectQuery.ExecuteMethodName) {  case null:  	// some calls' like Count() generate SQL and the resulting projection method name is null (never initialized)  	return SelectSingle<S> (selectQuery' false);  // Single() for safety' but First() should work  case "First":  	return SelectFirst<S> (selectQuery' false);  case "FirstOrDefault":  	return SelectFirst<S> (selectQuery' true);  case "Single":  	return SelectSingle<S> (selectQuery' false);  case "SingleOrDefault":  	return SelectSingle<S> (selectQuery' true);  case "Last":  	return SelectLast<S> (selectQuery' false);  }  
Missing Default,DbLinq.Schema.Dbml,XmlSerializerContract,C:\repos\lytico_dblinq2007\src\DbLinq\Schema\Dbml\DatabaseSerializer.cs,GetSerializer,The following switch statement is missing a default case: switch (type.FullName) {  case "DbLinq.Schema.Dbml.Database":  	return (XmlSerializer)TypedSerializers ["DbLinq.Schema.Dbml.Database"];  }  
Missing Default,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following switch statement is missing a default case: switch (operationType) {  case ExpressionType.Add:  	return GetLiteralAdd (p [0]' p [1]);  case ExpressionType.AddChecked:  	return GetLiteralAddChecked (p [0]' p [1]);  case ExpressionType.And:  	return GetLiteralAnd (p [0]' p [1]);  case ExpressionType.AndAlso:  	return GetLiteralAndAlso (p [0]' p [1]);  case ExpressionType.ArrayLength:  	return GetLiteralArrayLength (p [0]' p [1]);  case ExpressionType.ArrayIndex:  	return GetLiteralArrayIndex (p [0]' p [1]);  case ExpressionType.Call:  	return GetLiteralCall (p [0]);  case ExpressionType.Coalesce:  	return GetLiteralCoalesce (p [0]' p [1]);  case ExpressionType.Conditional:  	return GetLiteralConditional (p [0]' p [1]' p [2]);  //case ExpressionType.Constant:  //break;  case ExpressionType.Divide:  	return GetLiteralDivide (p [0]' p [1]);  case ExpressionType.Equal:  	return GetLiteralEqual (p [0]' p [1]);  case ExpressionType.ExclusiveOr:  	return GetLiteralExclusiveOr (p [0]' p [1]);  case ExpressionType.GreaterThan:  	return GetLiteralGreaterThan (p [0]' p [1]);  case ExpressionType.GreaterThanOrEqual:  	return GetLiteralGreaterThanOrEqual (p [0]' p [1]);  //case ExpressionType.Invoke:  //break;  //case ExpressionType.Lambda:  //break;  case ExpressionType.LeftShift:  	return GetLiteralLeftShift (p [0]' p [1]);  case ExpressionType.LessThan:  	return GetLiteralLessThan (p [0]' p [1]);  case ExpressionType.LessThanOrEqual:  	return GetLiteralLessThanOrEqual (p [0]' p [1]);  //case ExpressionType.ListInit:  //break;  //case ExpressionType.MemberAccess:  //    break;  //case ExpressionType.MemberInit:  //    break;  case ExpressionType.Modulo:  	return GetLiteralModulo (p [0]' p [1]);  case ExpressionType.Multiply:  	return GetLiteralMultiply (p [0]' p [1]);  case ExpressionType.MultiplyChecked:  	return GetLiteralMultiplyChecked (p [0]' p [1]);  case ExpressionType.Negate:  	return GetLiteralNegate (p [0]);  case ExpressionType.UnaryPlus:  	return GetLiteralUnaryPlus (p [0]);  case ExpressionType.NegateChecked:  	return GetLiteralNegateChecked (p [0]);  //case ExpressionType.New:  //    break;  //case ExpressionType.NewArrayInit:  //    break;  //case ExpressionType.NewArrayBounds:  //    break;  case ExpressionType.Not:  	return GetLiteralNot (p [0]);  case ExpressionType.NotEqual:  	return GetLiteralNotEqual (p [0]' p [1]);  case ExpressionType.Or:  	return GetLiteralOr (p [0]' p [1]);  case ExpressionType.OrElse:  	return GetLiteralOrElse (p [0]' p [1]);  //case ExpressionType.Parameter:  //    break;  case ExpressionType.Power:  	return GetLiteralPower (p [0]' p [1]);  //case ExpressionType.Quote:  //    break;  case ExpressionType.RightShift:  	return GetLiteralRightShift (p [0]' p [1]);  case ExpressionType.Subtract:  	return GetLiteralSubtract (p [0]' p [1]);  case ExpressionType.SubtractChecked:  	return GetLiteralSubtractChecked (p [0]' p [1]);  //case ExpressionType.TypeAs:  //    break;  //case ExpressionType.TypeIs:  //    break;  }  
Missing Default,DbLinq.Vendor.Implementation,SqlProvider,C:\repos\lytico_dblinq2007\src\DbLinq\Vendor\Implementation\SqlProvider.cs,GetLiteral,The following switch statement is missing a default case: switch (operationType) // SETuse  {  case SpecialExpressionType.IsNull:  	return GetLiteralIsNull (p [0]);  case SpecialExpressionType.IsNotNull:  	return GetLiteralIsNotNull (p [0]);  case SpecialExpressionType.Concat:  	return GetLiteralStringConcat (p [0]' p [1]);  case SpecialExpressionType.Count:  	return GetLiteralCount (p [0]);  case SpecialExpressionType.Exists:  	return GetLiteralExists (p [0]);  case SpecialExpressionType.Like:  	return GetLiteralLike (p [0]' p [1]);  case SpecialExpressionType.Min:  	return GetLiteralMin (p [0]);  case SpecialExpressionType.Max:  	return GetLiteralMax (p [0]);  case SpecialExpressionType.Sum:  	return GetLiteralSum (p [0]);  case SpecialExpressionType.Average:  	return GetLiteralAverage (p [0]);  case SpecialExpressionType.StringLength:  	return GetLiteralStringLength (p [0]);  case SpecialExpressionType.ToUpper:  	return GetLiteralStringToUpper (p [0]);  case SpecialExpressionType.ToLower:  	return GetLiteralStringToLower (p [0]);  case SpecialExpressionType.In:  	return GetLiteralIn (p [0]' p [1]);  case SpecialExpressionType.Substring:  	if (p.Count > 2)  		return GetLiteralSubString (p [0]' p [1]' p [2]);  	return GetLiteralSubString (p [0]' p [1]);  case SpecialExpressionType.Trim:  case SpecialExpressionType.LTrim:  case SpecialExpressionType.RTrim:  	return GetLiteralTrim (p [0]);  case SpecialExpressionType.StringInsert:  	return GetLiteralStringInsert (p [0]' p [1]' p [2]);  case SpecialExpressionType.Replace:  	return GetLiteralStringReplace (p [0]' p [1]' p [2]);  case SpecialExpressionType.Remove:  	if (p.Count > 2)  		return GetLiteralStringRemove (p [0]' p [1]' p [2]);  	return GetLiteralStringRemove (p [0]' p [1]);  case SpecialExpressionType.IndexOf:  	if (p.Count == 2)  		return GetLiteralStringIndexOf (p [0]' p [1]);  	else if (p.Count == 3)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]);  	else if (p.Count == 4)  		return GetLiteralStringIndexOf (p [0]' p [1]' p [2]' p [3]);  	break;  case SpecialExpressionType.Year:  case SpecialExpressionType.Month:  case SpecialExpressionType.Day:  case SpecialExpressionType.Hour:  case SpecialExpressionType.Minute:  case SpecialExpressionType.Second:  case SpecialExpressionType.Millisecond:  	return GetLiteralDateTimePart (p [0]' operationType);  case SpecialExpressionType.Date:  	return p [0];  case SpecialExpressionType.DateDiffInMilliseconds:  	return GetLiteralDateDiff (p [0]' p [1]);  case SpecialExpressionType.Abs:  	return GetLiteralMathAbs (p [0]);  case SpecialExpressionType.Exp:  	return GetLiteralMathExp (p [0]);  case SpecialExpressionType.Floor:  	return GetLiteralMathFloor (p [0]);  case SpecialExpressionType.Ln:  	return GetLiteralMathLn (p [0]);  case SpecialExpressionType.Log:  	if (p.Count == 1)  		return GetLiteralMathLog (p [0]);  	else  		return GetLiteralMathLog (p [0]' p [1]);  case SpecialExpressionType.Pow:  	return GetLiteralMathPow (p [0]' p [1]);  case SpecialExpressionType.Round:  	return GetLiteralMathRound (p [0]);  case SpecialExpressionType.Sign:  	return GetLiteralMathSign (p [0]);  case SpecialExpressionType.Sqrt:  	return GetLiteralMathSqrt (p [0]);  }  
