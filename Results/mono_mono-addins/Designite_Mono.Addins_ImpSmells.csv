Implementation smell,Namespace,Class,File,Method,Description
Long Method,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,SaveXml,The method has 119 lines of code.
Long Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The method has 125 lines of code.
Long Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,InternalScanFolders2,The method has 100 lines of code.
Long Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanFolder,The method has 113 lines of code.
Long Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanFile,The method has 148 lines of code.
Long Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanDescription,The method has 104 lines of code.
Long Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssemblyAddinHeaders,The method has 105 lines of code.
Long Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssemblyContents,The method has 144 lines of code.
Complex Method,Mono.Addins,ExtensionNode,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionNode.cs,ReadObject,Cyclomatic complexity of the method is 9
Complex Method,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,LoadExtensionElement,Cyclomatic complexity of the method is 19
Complex Method,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,InitializeNodeType,Cyclomatic complexity of the method is 14
Complex Method,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,GetMembersMap,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins,ExtensionContext,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionContext.cs,GetExtensionNodes,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins,ExtensionContext,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionContext.cs,ActivateAddinExtensions,Cyclomatic complexity of the method is 13
Complex Method,Mono.Addins,ExtensionContext,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionContext.cs,RemoveAddinExtensions,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins,ExtensionContext,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionContext.cs,LoadExtensions,Cyclomatic complexity of the method is 12
Complex Method,Mono.Addins,AddinEngine,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinEngine.cs,ResolveLoadDependencies,Cyclomatic complexity of the method is 11
Complex Method,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,FindExtensionNode,Cyclomatic complexity of the method is 12
Complex Method,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,TransferCoreProperties,Cyclomatic complexity of the method is 9
Complex Method,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,SaveXml,Cyclomatic complexity of the method is 20
Complex Method,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,ParseString,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,Verify,Cyclomatic complexity of the method is 15
Complex Method,Mono.Addins.Description,ModuleDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ModuleDescription.cs,SaveXml,Cyclomatic complexity of the method is 11
Complex Method,Mono.Addins.Description,ExtensionNodeSet,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeSet.cs,SaveXml,Cyclomatic complexity of the method is 10
Complex Method,Mono.Addins.Description,ExtensionNodeSet,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeSet.cs,GetAllowedNodeTypes,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins.Description,Extension,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\Extension.cs,GetExtendedObject,Cyclomatic complexity of the method is 9
Complex Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,FindNodeSet,Cyclomatic complexity of the method is 9
Complex Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,InternalGetInstalledAddins,Cyclomatic complexity of the method is 10
Complex Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,DisableAddin,Cyclomatic complexity of the method is 9
Complex Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,Cyclomatic complexity of the method is 24
Complex Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,EnsureInsertionsSorted,Cyclomatic complexity of the method is 11
Complex Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,Update,Cyclomatic complexity of the method is 15
Complex Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,RunPendingUninstalls,Cyclomatic complexity of the method is 11
Complex Method,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,InternalScanFolders2,Cyclomatic complexity of the method is 21
Complex Method,Mono.Addins.Database,AddinIndex,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,InsertSortedAddin,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins.Database,AddinScanFolderInfo,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanFolderInfo.cs,GetMissingAddins,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanFolder,Cyclomatic complexity of the method is 18
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,RegisterFileToScan,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanFile,Cyclomatic complexity of the method is 22
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAddinsFile,Cyclomatic complexity of the method is 11
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssembly,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanDescription,Cyclomatic complexity of the method is 17
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssemblyAddinHeaders,Cyclomatic complexity of the method is 25
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssemblyContents,Cyclomatic complexity of the method is 16
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanNodeType,Cyclomatic complexity of the method is 17
Complex Method,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,FindAddinType,Cyclomatic complexity of the method is 9
Complex Method,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,RegisterExtension,Cyclomatic complexity of the method is 8
Complex Method,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,IsAddinCompatible,Cyclomatic complexity of the method is 10
Long Parameter List,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,LoadExtensionElement,The method has 8 parameters. Parameters: tnode' addin' extension' module' curPos' parentCondition' inComplextCondition' addedNodes
Long Parameter List,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,ReadNode,The method has 5 parameters. Parameters: tnode' addin' ntype' elem' module
Long Parameter List,Mono.Addins,TreeNode,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\TreeNode.cs,FindExtensionPathByType,The method has 5 parameters. Parameters: monitor' type' nodeName' path' pathNodeName
Long Parameter List,Mono.Addins,ExtensionContext,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionContext.cs,FindExtensionPathByType,The method has 5 parameters. Parameters: monitor' type' nodeName' path' pathNodeName
Long Parameter List,Mono.Addins,AddinRegistry,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinRegistry.cs,AddinRegistry,The method has 5 parameters. Parameters: engine' registryPath' startupDirectory' addinsDir' databaseDir
Long Parameter List,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GetInstalledDomainAddin,The method has 5 parameters. Parameters: domain' id' exactVersionMatch' enabledOnly' dbLockCheck
Long Parameter List,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The method has 5 parameters. Parameters: monitor' domain' addinsToUpdate' addinsToUpdateRelations' removedAddins
Long Parameter List,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,AddChildExtensions,The method has 7 parameters. Parameters: conf' module' updateData' index' path' nodes' conditionChildren
Long Parameter List,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,ParseAddin,The method has 5 parameters. Parameters: progressStatus' domain' file' outFile' inProcess
Long Parameter List,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,UninstallAddin,The method has 5 parameters. Parameters: monitor' domain' addinId' addinFile' scanResult
Long Parameter List,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GetAddinDescription,The method has 5 parameters. Parameters: monitor' domain' addinId' addinFile' description
Long Parameter List,Mono.Addins.Database,AddinScanFolderInfo,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanFolderInfo.cs,SetLastScanTime,The method has 5 parameters. Parameters: file' addinId' isRoot' time' scanError
Long Parameter List,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanEmbeddedDescription,The method has 5 parameters. Parameters: monitor' filePath' reflector' asm' config
Long Parameter List,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanDescription,The method has 5 parameters. Parameters: monitor' reflector' config' rootAssembly' scanResult
Long Parameter List,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanSubmodule,The method has 7 parameters. Parameters: monitor' mod' reflector' config' scanResult' assemblyName' asm
Long Parameter List,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssemblyContents,The method has 5 parameters. Parameters: reflector' config' module' asm' scanResult
Long Parameter List,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanNodeSet,The method has 5 parameters. Parameters: reflector' config' nset' assemblies' internalNodeSets
Long Parameter List,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanNodeType,The method has 5 parameters. Parameters: reflector' config' nt' assemblies' internalNodeSets
Long Parameter List,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,RegisterTypeNode,The method has 5 parameters. Parameters: config' eatt' path' nodeName' typeFullName
Long Parameter List,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,ReadSharedObject,The method has 6 parameters. Parameters: directory' sharedFileName' extension' objectId' typeMap' fileName
Long Parameter List,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,ReadSharedObject,The method has 7 parameters. Parameters: directory' sharedFileName' extension' objectId' typeMap' checkOnly' fileName
Long Parameter List,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,OpenFileForPath,The method has 5 parameters. Parameters: f' objectId' typeMap' checkOnly' result
Long Parameter List,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,WriteSharedObject,The method has 7 parameters. Parameters: directory' sharedFileName' extension' objectId' readFileName' typeMap' obj
Long Parameter List,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,ExecuteCommand,The method has 8 parameters. Parameters: monitor' registryPath' startupDir' addinsDir' databaseDir' name' arg1' args
Long Parameter List,Mono.Addins.Database,RemoteSetupDomain,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupDomain.cs,Scan,The method has 7 parameters. Parameters: monitor' registryPath' startupDir' addinsDir' databaseDir' scanFolder' filesToIgnore
Long Parameter List,Mono.Addins.Database,RemoteSetupDomain,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupDomain.cs,GetAddinDescription,The method has 7 parameters. Parameters: monitor' registryPath' startupDir' addinsDir' databaseDir' file' outFile
Long Statement,Mono.Addins,ExtensionNode,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionNode.cs,GetChildObjectsInternal,The length of the statement  "					addinEngine.ReportError ("Error while getting object for node in path '" + Path + "'. Extension node is not a subclass of InstanceExtensionNode."' null' null' false); " is 166.
Long Statement,Mono.Addins,ExtensionNode,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionNode.cs,ReadObject,The length of the statement  "						throw new InvalidOperationException ("Property type not supported by [NodeAttribute]: " + f.Member.DeclaringType + "." + f.Member.Name); " is 136.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,LoadExtension,The length of the statement  "				addinEngine.ReportError ("Can't load extensions for path '" + extension.Path + "'. Extension point not defined."' addin' null' false); " is 134.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,LoadExtension,The length of the statement  "			LoadExtensionElement (tnode' addin' extension.ExtensionNodes' (ModuleDescription) extension.Parent' ref curPos' tnode.Condition' false' addedNodes); " is 148.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,LoadExtensionElement,The length of the statement  "					addinEngine.ReportError ("Node '" + elem.NodeName + "' not allowed in extension: " + tnode.GetPath ()' addin' null' false); " is 123.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,ReadComplexCondition,The length of the statement  "						addinEngine.ReportError ("Invalid complex condition element '" + elem.NodeName + "'. 'Not' condition can only have one parameter."' null' null' false); " is 151.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,ReadNode,The length of the statement  "					addinEngine.ReportError ("Extension node type '" + ntype.Type + "' must be a subclass of ExtensionNode"' addin' null' false); " is 125.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,ReadNode,The length of the statement  "				addinEngine.ReportError ("Could not read extension node of type '" + ntype.Type + "' from extension path '" + tnode.GetPath() + "'"' addin' ex' false); " is 151.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,InitializeNodeType,The length of the statement  "						addinEngine.ReportError ("Custom attribute type '" + ntype.ExtensionAttributeTypeName + "' not found."' ntype.AddinId' null' false); " is 132.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,InitializeNodeType,The length of the statement  "					throw new InvalidOperationException ("Incorrect custom attribute type declaration in " + ntype.Type + ". Expected '" + ntype.ExtensionAttributeTypeName + "' found '" + boundAttributeType.MemberType.FullName + "'"); " is 214.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,GetMembersMap,The length of the statement  "				foreach (FieldInfo field in type.GetFields (BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly)) { " is 144.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,GetMembersMap,The length of the statement  "					NodeAttributeAttribute at = (NodeAttributeAttribute) Attribute.GetCustomAttribute (field' typeof(NodeAttributeAttribute)' true); " is 128.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,GetMembersMap,The length of the statement  "				foreach (PropertyInfo prop in type.GetProperties (BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly)) { " is 150.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,GetMembersMap,The length of the statement  "					NodeAttributeAttribute at = (NodeAttributeAttribute) Attribute.GetCustomAttribute (prop' typeof(NodeAttributeAttribute)' true); " is 127.
Long Statement,Mono.Addins,ExtensionTree,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionTree.cs,CreateFieldData,The length of the statement  "					throw new InvalidOperationException ("Type '" + member.DeclaringType + "' has two members bound to a custom attribute. There can be only one."); " is 144.
Long Statement,Mono.Addins,RuntimeAddin,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\RuntimeAddin.cs,GetDepAddins,The length of the statement  "						addinEngine.ReportError ("Add-in dependency not loaded: " + pdep.FullAddinId' module.ParentAddinDescription.AddinId' null' false); " is 130.
Long Statement,Mono.Addins,ExtensionContext,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ExtensionContext.cs,GetExtensionNodes,The length of the statement  "						AddinEngine.ReportError ("Error while getting nodes for path '" + path + "'. Expected subclass of node type '" + expectedNodeType + "'. Found '" + cnode.GetType ()' null' null' false); " is 184.
Long Statement,Mono.Addins,InstanceExtensionNode,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\InstanceExtensionNode.cs,GetInstance,The length of the statement  "				throw new InvalidOperationException (string.Format ("Expected subclass of type '{0}'. Found '{1}'."' expectedType' ob.GetType ())); " is 131.
Long Statement,Mono.Addins,InstanceExtensionNode,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\InstanceExtensionNode.cs,CreateInstance,The length of the statement  "				throw new InvalidOperationException (string.Format ("Expected subclass of type '{0}'. Found '{1}'."' expectedType' ob.GetType ())); " is 131.
Long Statement,Mono.Addins,AddinEngine,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinEngine.cs,CurrentDomainAssemblyResolve,The length of the statement  "				// MS.NET is more strict than Mono when loading assemblies. Assemblies loaded in the "Load" context can't see assemblies loaded " is 127.
Long Statement,Mono.Addins,AddinEngine,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinEngine.cs,CurrentDomainAssemblyResolve,The length of the statement  "				return loadedAddins.Values.Where(a => a.AssembliesLoaded).SelectMany(a => a.Assemblies).FirstOrDefault(a => a.FullName.ToString () == args.Name); " is 145.
Long Statement,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,Verify,The length of the statement  "						errors.Add (string.Format ("Property {0} specified more than once"' prop.Name + (prop.Locale != null ? " (" + prop.Locale + ")" : ""))); " is 136.
Long Statement,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,Read,The length of the statement  "			conditionTypes = (ConditionTypeDescriptionCollection) reader.ReadValue ("ConditionTypes"' new ConditionTypeDescriptionCollection (this)); " is 137.
Long Statement,Mono.Addins.Description,ExtensionPoint,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionPoint.cs,Read,The length of the statement  "			conditions = (ConditionTypeDescriptionCollection) reader.ReadValue ("Conditions"' new ConditionTypeDescriptionCollection (this)); " is 129.
Long Statement,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,Read,The length of the statement  "			childNodes = (ExtensionNodeDescriptionCollection) reader.ReadValue ("ChildNodes"' new ExtensionNodeDescriptionCollection (this)); " is 129.
Long Statement,Mono.Addins.Serialization,BinaryXmlReader,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Serialization\BinaryXmlReader.cs,ReadObject,The length of the statement  "						throw new InvalidOperationException ("Target instance has an invalid type. Expected an IBinaryXmlElement implementation."); " is 123.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,CollectExtensionData,The length of the statement  "				string w = "The add-in '" + conf.AddinId + "' could not be updated because some of its dependencies are missing or not compatible:"; " is 132.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,CollectExtensionData,The length of the statement  "						string w = "An optional module of the add-in '" + conf.AddinId + "' could not be updated because some of its dependencies are missing or not compatible:"; " is 154.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,Repair,The length of the statement  "					monitor.ReportError ("The add-in registry could not be rebuilt. It may be due to lack of write permissions to the directory: " + AddinDbDir' ex); " is 145.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,Update,The length of the statement  "				monitor.ReportError ("The add-in database could not be updated. It may be due to file corruption. Try running the setup repair utility"' null); " is 143.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,RunScannerProcess,The length of the statement  "						monitor.ReportError ("Add-in scan operation failed. The runtime may have encountered an error while trying to load an assembly."' null); " is 136.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,InternalScanFolders2,The length of the statement  "					bool validForDomain = scanResult.Domain == null || folderInfo.Domain == GlobalDomain || folderInfo.Domain == scanResult.Domain; " is 127.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,InternalScanFolders2,The length of the statement  "				GenerateAddinExtensionMapsInternal (monitor' scanResult.Domain' scanResult.AddinsToUpdate' scanResult.AddinsToUpdateRelations' scanResult.RemovedAddins); " is 153.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,InternalScanFolders2,The length of the statement  "				monitor.ReportError ("The add-in database could not be updated. It may be due to file corruption. Try running the setup repair utility"' ex); " is 141.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GetAddinDescription,The length of the statement  "			// If the same add-in is installed in different folders (in the same domain) there will be several .maddin files for it' " is 120.
Long Statement,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GetAddinDescription,The length of the statement  "			// using the suffix "_X" where X is a number > 1 (for example: someAddin'1.0.maddin' someAddin'1.0.maddin_2' someAddin'1.0.maddin_3' ...) " is 137.
Long Statement,Mono.Addins.Database,AddinScanFolderInfo,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanFolderInfo.cs,Read,The length of the statement  "			AddinScanFolderInfo finfo = (AddinScanFolderInfo) filedb.ReadSharedObject (basePath' GetDomain (folderPath)' ".data"' Path.GetFullPath (folderPath)' typeMap' out fileName); " is 172.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,RegisterFileToScan,The length of the statement  "			if (finfo != null && (!finfo.IsAddin || finfo.Domain == folderInfo.GetDomain (finfo.IsRoot)) && fs.GetLastWriteTime (file) == finfo.LastScan && !scanResult.RegenerateAllData) { " is 176.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanFile,The length of the statement  "					bool res = database.GetAddinDescription (monitor' folderInfo.Domain' config.AddinId' config.AddinFile' out existingDescription); " is 128.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanFile,The length of the statement  "								if (scanResult.Domain != null && scanResult.Domain != AddinDatabase.UnknownDomain && scanResult.Domain != AddinDatabase.GlobalDomain) " is 133.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanFile,The length of the statement  "				AddinFileInfo ainfo = folderInfo.SetLastScanTime (file' scannedAddinId' scannedIsRoot' fs.GetLastWriteTime (file)' !scanSuccessful); " is 132.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssemblyAddinHeaders,The length of the statement  "			AddinLocalizerGettextAttribute locat = (AddinLocalizerGettextAttribute) reflector.GetCustomAttribute (asm' typeof(AddinLocalizerGettextAttribute)' false); " is 154.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssemblyContents,The length of the statement  "				var conditionAtts = new Lazy<List<CustomAttribute>> (() => reflector.GetRawCustomAttributes (t' typeof (CustomConditionAttribute)' false)); " is 139.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanAssemblyContents,The length of the statement  "					foreach (ExtensionAttributeAttribute eat in reflector.GetCustomAttributes (t' typeof(ExtensionAttributeAttribute)' false)) { " is 124.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanNodeType,The length of the statement  "			ExtensionNodeAttribute nodeAtt = (ExtensionNodeAttribute) reflector.GetCustomAttribute (ntype' typeof(ExtensionNodeAttribute)' true); " is 133.
Long Statement,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,ScanNodeType,The length of the statement  "				NodeAttributeAttribute fatt = (NodeAttributeAttribute) reflector.GetCustomAttribute (field' typeof(NodeAttributeAttribute)' false); " is 131.
Long Statement,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,RegisterNodeSet,The length of the statement  "				List<ExtensionPoint> compatExtensions = GetCompatibleExtensionPoints (nset.Id' description' description.MainModule' extensions); " is 128.
Long Statement,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,RegisterExtensionPoint,The length of the statement  "				List<ExtensionPoint> compatExtensions = GetCompatibleExtensionPoints (ep.Path' description' description.MainModule' extensions); " is 128.
Long Statement,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,RegisterExtension,The length of the statement  "					monitor.ReportWarning ("The add-in '" + description.AddinId + "' is trying to register the class '" + extension.Path.Substring (1) + "'' but there isn't any add-in defining a suitable extension point"); " is 202.
Long Statement,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,RegisterExtension,The length of the statement  "					monitor.ReportWarning ("The add-in '" + description.AddinId + "' is trying to register the class '" + extension.Path.Substring (1) + "'' but there isn't any add-in defining a suitable extension point"); " is 202.
Long Statement,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,RegisterExtension,The length of the statement  "				monitor.ReportWarning ("The add-in '" + description.AddinId + "' is trying to extend '" + path + "'' but there isn't any add-in defining this extension point"); " is 160.
Long Statement,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,RegisterExtension,The length of the statement  "				monitor.ReportWarning ("The add-in '" + description.AddinId + "' is trying to extend '" + path + "'' but there isn't any compatible add-in defining this extension point"); " is 171.
Long Statement,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,IsAddinCompatible,The length of the statement  "			if (installedDescription.CompatVersion.Length > 0 && Addin.CompareVersions (installedDescription.CompatVersion' requiredVersion) < 0) " is 133.
Long Statement,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,Scan,The length of the statement  "			ExecuteCommand (monitor' registry.RegistryPath' registry.StartupDirectory' registry.DefaultAddinsFolder' registry.AddinCachePath' "scan"' scanFolder' filesToIgnore); " is 165.
Long Statement,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,GetAddinDescription,The length of the statement  "			ExecuteCommand (monitor' registry.RegistryPath' registry.StartupDirectory' registry.DefaultAddinsFolder' registry.AddinCachePath' "get-desc"' file' outFile); " is 157.
Long Statement,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,CreateHostExe,The length of the statement  "			AssemblyBuilder ab = AppDomain.CurrentDomain.DefineDynamicAssembly (aname' AssemblyBuilderAccess.Save' Path.GetTempPath ()); " is 124.
Long Statement,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,CreateHostExe,The length of the statement  "			MethodInfo mi = typeof(SetupProcess).GetMethod ("Main"' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static); " is 124.
Long Statement,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,IsManagedAssembly,The length of the statement  "				using (Stream fileStream = new FileStream(filePath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite | FileShare.Delete)) " is 124.
Long Statement,Mono.Addins.Database,DefaultAssemblyReflector,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\DefaultAssemblyReflector.cs,ConvertAttribute,The length of the statement  "					NodeAttributeAttribute bt = (NodeAttributeAttribute) Attribute.GetCustomAttribute (prop' typeof(NodeAttributeAttribute)' true); " is 127.
Long Statement,Mono.Addins.Database,DefaultAssemblyReflector,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\DefaultAssemblyReflector.cs,ConvertAttribute,The length of the statement  "					NodeAttributeAttribute bt = (NodeAttributeAttribute) Attribute.GetCustomAttribute (field' typeof(NodeAttributeAttribute)' true); " is 128.
Long Statement,Mono.Addins.Database,SetupDomain,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupDomain.cs,Scan,The length of the statement  "				rsd.Scan (remMonitor' registry.RegistryPath' registry.StartupDirectory' registry.DefaultAddinsFolder' registry.AddinCachePath' scanFolder' filesToIgnore); " is 154.
Long Statement,Mono.Addins.Database,SetupDomain,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupDomain.cs,GetAddinDescription,The length of the statement  "				rsd.GetAddinDescription (remMonitor' registry.RegistryPath' registry.StartupDirectory' registry.DefaultAddinsFolder' registry.AddinCachePath' file' outFile); " is 157.
Long Statement,Mono.Addins.Database,SetupLocal,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupLocal.cs,Scan,The length of the statement  "			AddinRegistry reg = new AddinRegistry (registry.RegistryPath' registry.StartupDirectory' registry.DefaultAddinsFolder' registry.AddinCachePath); " is 144.
Long Statement,Mono.Addins.Localization,StringTableLocalizer,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Localization\StringTableLocalizer.cs,CreateLocalizer,The length of the statement  "						throw new InvalidOperationException ("Locale '" + ln + "': Invalid element found: '" + nmsg.NodeName + "'. Expected: 'Msg'"); " is 125.
Complex Conditional,Mono.Addins.Description,Extension,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\Extension.cs,VerifyConditionNode,The conditional expression  "nodeName != "Or" && nodeName != "And" && nodeName != "Not" && nodeName != "Condition""  is complex.
Complex Conditional,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GetInstalledDomainAddin,The conditional expression  "(!enabledOnly || ia.Enabled) &&  						    (version.Length == 0 || ia.SupportsVersion (version)) &&   						    (bestVersion == null || Addin.CompareVersions (bestVersion' ia.Version) > 0)"  is complex.
Complex Conditional,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,Update,The conditional expression  "changesFound && domain != null && addinEngine != null && addinEngine.IsInitialized"  is complex.
Complex Conditional,Mono.Addins.Database,AddinScanner,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanner.cs,RegisterFileToScan,The conditional expression  "finfo != null && (!finfo.IsAddin || finfo.Domain == folderInfo.GetDomain (finfo.IsRoot)) && fs.GetLastWriteTime (file) == finfo.LastScan && !scanResult.RegenerateAllData"  is complex.
Empty Catch Block,Mono.Addins,RuntimeAddin,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\RuntimeAddin.cs,LoadModule,The method has an empty catch block.
Empty Catch Block,Mono.Addins,AddinManager,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinManager.cs,CheckAssembliesLoaded,The method has an empty catch block.
Empty Catch Block,Mono.Addins,AddinRegistry,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinRegistry.cs,CreateHostAddinsFile,The method has an empty catch block.
Empty Catch Block,Mono.Addins,AddinRegistry,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinRegistry.cs,GetRegisteredStartupFolders,The method has an empty catch block.
Empty Catch Block,Mono.Addins,AddinEngine,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinEngine.cs,ReportAddinLoad,The method has an empty catch block.
Empty Catch Block,Mono.Addins,AddinEngine,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\AddinEngine.cs,ReportAddinUnload,The method has an empty catch block.
Empty Catch Block,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GetUniqueDomainId,The method has an empty catch block.
Empty Catch Block,Mono.Addins.Database,AddinScanResult,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinScanResult.cs,GetAssemblyLocation,The method has an empty catch block.
Empty Catch Block,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,ExecuteCommand,The method has an empty catch block.
Empty Catch Block,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,NormalizePath,The method has an empty catch block.
Magic Number,Mono.Addins,Addin,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\Addin.cs,GetFullId,The following statement contains a magic number: if (id.StartsWith ("::"))  				res = id.Substring (2);  			else if (ns != null && ns.Length > 0)  				res = ns + "." + id;  			else  				res = id;
Magic Number,Mono.Addins,ConsoleProgressStatus,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins\ConsoleProgressStatus.cs,ConsoleProgressStatus,The following statement contains a magic number: if (verboseLog)  				logLevel = 2;  			else  				logLevel = 1;
Magic Number,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,ParseString,The following statement contains a magic number: if (input == null || input.Length < 4)  				return input;
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,SaveXml,The following statement contains a magic number: if (Element == null) {  				Element = parent.OwnerDocument.CreateElement (nodeName);  				parent.AppendChild (Element);  				if (attributes != null) {  					for (int n=0; n<attributes.Length; n+=2)  						Element.SetAttribute (attributes[n]' attributes[n+1]);  				}  				ChildNodes.SaveXml (Element);  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,GetAttribute,The following statement contains a magic number: for (int n=0; n<attributes.Length; n+=2) {  				if (attributes [n] == key)  					return attributes [n+1];  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,SetAttribute,The following statement contains a magic number: if (attributes == null) {  				attributes = new string [2];  				attributes [0] = key;  				attributes [1] = value;  				return;  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,SetAttribute,The following statement contains a magic number: for (int n=0; n<attributes.Length; n+=2) {  				if (attributes [n] == key) {  					attributes [n+1] = value;  					return;  				}  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,SetAttribute,The following statement contains a magic number: string[] newList = new string [attributes.Length + 2];
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,SetAttribute,The following statement contains a magic number: attributes [attributes.Length - 2] = key;
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,RemoveAttribute,The following statement contains a magic number: for (int n=0; n<attributes.Length; n+=2) {  				if (attributes [n] == name) {  					string[] newar = new string [attributes.Length - 2];  					Array.Copy (attributes' 0' newar' 0' n);  					Array.Copy (attributes' n+2' newar' n' attributes.Length - n - 2);  					attributes = newar;  					break;  				}  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,RemoveAttribute,The following statement contains a magic number: for (int n=0; n<attributes.Length; n+=2) {  				if (attributes [n] == name) {  					string[] newar = new string [attributes.Length - 2];  					Array.Copy (attributes' 0' newar' 0' n);  					Array.Copy (attributes' n+2' newar' n' attributes.Length - n - 2);  					attributes = newar;  					break;  				}  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,RemoveAttribute,The following statement contains a magic number: for (int n=0; n<attributes.Length; n+=2) {  				if (attributes [n] == name) {  					string[] newar = new string [attributes.Length - 2];  					Array.Copy (attributes' 0' newar' 0' n);  					Array.Copy (attributes' n+2' newar' n' attributes.Length - n - 2);  					attributes = newar;  					break;  				}  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,RemoveAttribute,The following statement contains a magic number: for (int n=0; n<attributes.Length; n+=2) {  				if (attributes [n] == name) {  					string[] newar = new string [attributes.Length - 2];  					Array.Copy (attributes' 0' newar' 0' n);  					Array.Copy (attributes' n+2' newar' n' attributes.Length - n - 2);  					attributes = newar;  					break;  				}  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,SaveXmlAttributes,The following statement contains a magic number: attributes = new string [Element.Attributes.Count * 2];
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,SaveXmlAttributes,The following statement contains a magic number: for (int n=0; n<attributes.Length; n+=2) {  				XmlAttribute at = Element.Attributes [n/2];  				attributes [n] = at.LocalName;  				attributes [n+1] = at.Value;  			}
Magic Number,Mono.Addins.Description,ExtensionNodeDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\ExtensionNodeDescription.cs,SaveXmlAttributes,The following statement contains a magic number: for (int n=0; n<attributes.Length; n+=2) {  				XmlAttribute at = Element.Attributes [n/2];  				attributes [n] = at.LocalName;  				attributes [n+1] = at.Value;  			}
Magic Number,Mono.Addins.Serialization,BinaryXmlReader,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Serialization\BinaryXmlReader.cs,ReadString,The following statement contains a magic number: if (len < -1)  				return (string) stringTable [-(len + 2)];
Magic Number,Mono.Addins.Serialization,BinaryXmlReader,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Serialization\BinaryXmlReader.cs,DumpValue,The following statement contains a magic number: if (t != TypeCode.Object) {  				object ob = ReadValueInternal (t);  				if (ob == null) ob = "(null)";  				Console.Write (ob);  			} else {  				byte ot = reader.ReadByte ();  				switch (ot) {  					case TagObjectNull: {  						Console.Write ("(null)");  						break;  					}  					case TagObject: {  						string tname = ReadString ();  						Console.WriteLine ("(" + tname + ")");  						DumpElement (ind + IndSize);  						break;  					}  					case TagObjectArray: {  						TypeCode tc = (TypeCode) reader.ReadByte ();  						int len = reader.ReadInt32 ();  						Console.WriteLine ("(" + tc + "[" + len + "])");  						for (int n=0; n<len; n++) {  							Console.Write (new string (' '' ind + IndSize) + n + ": ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  						}  						break;  					}  					case TagObjectDictionary: {  						int len = reader.ReadInt32 ();  						Console.WriteLine ("(IDictionary)");  						for (int n=0; n<len; n++) {  							Console.Write (new string (' '' ind + IndSize) + "key: ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  							Console.Write (new string (' '' ind + IndSize) + "val: ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  						}  						break;  					}  					default:  						throw new InvalidOperationException ("Invalid object tag: " + ot);  				}  			}
Magic Number,Mono.Addins.Serialization,BinaryXmlReader,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Serialization\BinaryXmlReader.cs,DumpValue,The following statement contains a magic number: if (t != TypeCode.Object) {  				object ob = ReadValueInternal (t);  				if (ob == null) ob = "(null)";  				Console.Write (ob);  			} else {  				byte ot = reader.ReadByte ();  				switch (ot) {  					case TagObjectNull: {  						Console.Write ("(null)");  						break;  					}  					case TagObject: {  						string tname = ReadString ();  						Console.WriteLine ("(" + tname + ")");  						DumpElement (ind + IndSize);  						break;  					}  					case TagObjectArray: {  						TypeCode tc = (TypeCode) reader.ReadByte ();  						int len = reader.ReadInt32 ();  						Console.WriteLine ("(" + tc + "[" + len + "])");  						for (int n=0; n<len; n++) {  							Console.Write (new string (' '' ind + IndSize) + n + ": ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  						}  						break;  					}  					case TagObjectDictionary: {  						int len = reader.ReadInt32 ();  						Console.WriteLine ("(IDictionary)");  						for (int n=0; n<len; n++) {  							Console.Write (new string (' '' ind + IndSize) + "key: ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  							Console.Write (new string (' '' ind + IndSize) + "val: ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  						}  						break;  					}  					default:  						throw new InvalidOperationException ("Invalid object tag: " + ot);  				}  			}
Magic Number,Mono.Addins.Serialization,BinaryXmlReader,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Serialization\BinaryXmlReader.cs,DumpValue,The following statement contains a magic number: if (t != TypeCode.Object) {  				object ob = ReadValueInternal (t);  				if (ob == null) ob = "(null)";  				Console.Write (ob);  			} else {  				byte ot = reader.ReadByte ();  				switch (ot) {  					case TagObjectNull: {  						Console.Write ("(null)");  						break;  					}  					case TagObject: {  						string tname = ReadString ();  						Console.WriteLine ("(" + tname + ")");  						DumpElement (ind + IndSize);  						break;  					}  					case TagObjectArray: {  						TypeCode tc = (TypeCode) reader.ReadByte ();  						int len = reader.ReadInt32 ();  						Console.WriteLine ("(" + tc + "[" + len + "])");  						for (int n=0; n<len; n++) {  							Console.Write (new string (' '' ind + IndSize) + n + ": ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  						}  						break;  					}  					case TagObjectDictionary: {  						int len = reader.ReadInt32 ();  						Console.WriteLine ("(IDictionary)");  						for (int n=0; n<len; n++) {  							Console.Write (new string (' '' ind + IndSize) + "key: ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  							Console.Write (new string (' '' ind + IndSize) + "val: ");  							DumpValue (ind + IndSize*2);  							Console.WriteLine ();  						}  						break;  					}  					default:  						throw new InvalidOperationException ("Invalid object tag: " + ot);  				}  			}
Magic Number,Mono.Addins.Serialization,BinaryXmlWriter,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Serialization\BinaryXmlWriter.cs,WriteString,The following statement contains a magic number: if (s == null)  				writer.Write (-1);  			else {  				object ind = stringTable [s];  				if (ind == null) {  					stringTable.Add (s' stringTable.Count);  					byte[] bytes = Encoding.UTF8.GetBytes (s);  					writer.Write (bytes.Length);  					writer.Write (bytes);  				} else {  					// +2 because -1 is reserved for null' and 0 is considered positive  					writer.Write (-((int)ind + 2));  				}  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The following statement contains a magic number: if (partialGeneration) {  				changedAddins = new Hashtable ();  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Doing a partial registry update.\nAdd-ins to be updated:");  				// Get the files and ids of all add-ins that have to be updated  				// Include removed add-ins: if there are several instances of the same add-in' removing one of  				// them will make other instances to show up. If there is a single instance' its files are  				// already removed.  				foreach (string sa in addinsToUpdate.Union (removedAddins)) {  					changedAddins [sa] = sa;  					if (monitor.LogLevel > 2)  						monitor.Log (" - " + sa);  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							files.Add (file);  							string an = Path.GetFileNameWithoutExtension (file);  							changedAddins [an] = an;  							if (monitor.LogLevel > 2 && an != sa)  								monitor.Log (" - " + an);  						}  					}  				}  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Add-ins whose relations have to be updated:");  				  				// Get the files and ids of all add-ins whose relations have to be updated  				foreach (string sa in addinsToUpdateRelations) {  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							if (monitor.LogLevel > 2) {  								string an = Path.GetFileNameWithoutExtension (file);  								monitor.Log (" - " + an);  							}  							files.Add (file);  						}  					}  				}  			}  			else {  				foreach (var dom in domains)  					files.AddRange (fileDatabase.GetDirectoryFiles (Path.Combine (AddinCachePath' dom)' "*.maddin"));  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The following statement contains a magic number: if (partialGeneration) {  				changedAddins = new Hashtable ();  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Doing a partial registry update.\nAdd-ins to be updated:");  				// Get the files and ids of all add-ins that have to be updated  				// Include removed add-ins: if there are several instances of the same add-in' removing one of  				// them will make other instances to show up. If there is a single instance' its files are  				// already removed.  				foreach (string sa in addinsToUpdate.Union (removedAddins)) {  					changedAddins [sa] = sa;  					if (monitor.LogLevel > 2)  						monitor.Log (" - " + sa);  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							files.Add (file);  							string an = Path.GetFileNameWithoutExtension (file);  							changedAddins [an] = an;  							if (monitor.LogLevel > 2 && an != sa)  								monitor.Log (" - " + an);  						}  					}  				}  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Add-ins whose relations have to be updated:");  				  				// Get the files and ids of all add-ins whose relations have to be updated  				foreach (string sa in addinsToUpdateRelations) {  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							if (monitor.LogLevel > 2) {  								string an = Path.GetFileNameWithoutExtension (file);  								monitor.Log (" - " + an);  							}  							files.Add (file);  						}  					}  				}  			}  			else {  				foreach (var dom in domains)  					files.AddRange (fileDatabase.GetDirectoryFiles (Path.Combine (AddinCachePath' dom)' "*.maddin"));  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The following statement contains a magic number: if (partialGeneration) {  				changedAddins = new Hashtable ();  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Doing a partial registry update.\nAdd-ins to be updated:");  				// Get the files and ids of all add-ins that have to be updated  				// Include removed add-ins: if there are several instances of the same add-in' removing one of  				// them will make other instances to show up. If there is a single instance' its files are  				// already removed.  				foreach (string sa in addinsToUpdate.Union (removedAddins)) {  					changedAddins [sa] = sa;  					if (monitor.LogLevel > 2)  						monitor.Log (" - " + sa);  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							files.Add (file);  							string an = Path.GetFileNameWithoutExtension (file);  							changedAddins [an] = an;  							if (monitor.LogLevel > 2 && an != sa)  								monitor.Log (" - " + an);  						}  					}  				}  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Add-ins whose relations have to be updated:");  				  				// Get the files and ids of all add-ins whose relations have to be updated  				foreach (string sa in addinsToUpdateRelations) {  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							if (monitor.LogLevel > 2) {  								string an = Path.GetFileNameWithoutExtension (file);  								monitor.Log (" - " + an);  							}  							files.Add (file);  						}  					}  				}  			}  			else {  				foreach (var dom in domains)  					files.AddRange (fileDatabase.GetDirectoryFiles (Path.Combine (AddinCachePath' dom)' "*.maddin"));  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The following statement contains a magic number: if (partialGeneration) {  				changedAddins = new Hashtable ();  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Doing a partial registry update.\nAdd-ins to be updated:");  				// Get the files and ids of all add-ins that have to be updated  				// Include removed add-ins: if there are several instances of the same add-in' removing one of  				// them will make other instances to show up. If there is a single instance' its files are  				// already removed.  				foreach (string sa in addinsToUpdate.Union (removedAddins)) {  					changedAddins [sa] = sa;  					if (monitor.LogLevel > 2)  						monitor.Log (" - " + sa);  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							files.Add (file);  							string an = Path.GetFileNameWithoutExtension (file);  							changedAddins [an] = an;  							if (monitor.LogLevel > 2 && an != sa)  								monitor.Log (" - " + an);  						}  					}  				}  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Add-ins whose relations have to be updated:");  				  				// Get the files and ids of all add-ins whose relations have to be updated  				foreach (string sa in addinsToUpdateRelations) {  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							if (monitor.LogLevel > 2) {  								string an = Path.GetFileNameWithoutExtension (file);  								monitor.Log (" - " + an);  							}  							files.Add (file);  						}  					}  				}  			}  			else {  				foreach (var dom in domains)  					files.AddRange (fileDatabase.GetDirectoryFiles (Path.Combine (AddinCachePath' dom)' "*.maddin"));  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The following statement contains a magic number: if (partialGeneration) {  				changedAddins = new Hashtable ();  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Doing a partial registry update.\nAdd-ins to be updated:");  				// Get the files and ids of all add-ins that have to be updated  				// Include removed add-ins: if there are several instances of the same add-in' removing one of  				// them will make other instances to show up. If there is a single instance' its files are  				// already removed.  				foreach (string sa in addinsToUpdate.Union (removedAddins)) {  					changedAddins [sa] = sa;  					if (monitor.LogLevel > 2)  						monitor.Log (" - " + sa);  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							files.Add (file);  							string an = Path.GetFileNameWithoutExtension (file);  							changedAddins [an] = an;  							if (monitor.LogLevel > 2 && an != sa)  								monitor.Log (" - " + an);  						}  					}  				}  				  				if (monitor.LogLevel > 2)  					monitor.Log ("Add-ins whose relations have to be updated:");  				  				// Get the files and ids of all add-ins whose relations have to be updated  				foreach (string sa in addinsToUpdateRelations) {  					foreach (string file in GetAddinFiles (sa' domains)) {  						if (!files.Contains (file)) {  							if (monitor.LogLevel > 2) {  								string an = Path.GetFileNameWithoutExtension (file);  								monitor.Log (" - " + an);  							}  							files.Add (file);  						}  					}  				}  			}  			else {  				foreach (var dom in domains)  					files.AddRange (fileDatabase.GetDirectoryFiles (Path.Combine (AddinCachePath' dom)' "*.maddin"));  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The following statement contains a magic number: if (monitor.LogLevel > 2)  				monitor.Log ("Registering new extensions:");
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,GenerateAddinExtensionMapsInternal,The following statement contains a magic number: foreach (AddinDescription conf in sorted) {  				if (changedAddins == null || changedAddins.ContainsKey (conf.AddinId)) {  					if (monitor.LogLevel > 2)  						monitor.Log ("- " + conf.AddinId + " (" + conf.Domain + ")");  					CollectExtensionData (monitor' addinHash' conf' updateData);  				}  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,AddNodeSorted,The following statement contains a magic number: if (node.InsertAfter.Length > 0) {  				string afterId = node.InsertAfter;  				for (int n=0; n<list.Count; n++) {  					if (list[n].Id == afterId) {  						list.Insert (n + 1' node);  						curPos = n + 2;  						return;  					}  				}  			}  			else if (node.InsertBefore.Length > 0) {  				string beforeId = node.InsertBefore;  				for (int n=0; n<list.Count; n++) {  					if (list[n].Id == beforeId) {  						list.Insert (n' node);  						curPos = n + 1;  						return;  					}  				}  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,RunScannerProcess,The following statement contains a magic number: do {  				try {  					if (monitor.LogLevel > 1)  						monitor.Log ("Looking for addins");  					setup.Scan (scanMonitor' registry' null' (string[]) pparams.ToArray (typeof(string)));  					retry = false;  				}  				catch (Exception ex) {  					ProcessFailedException pex = ex as ProcessFailedException;  					if (pex != null) {  						// Get the last logged operation.  						if (pex.LastLog.StartsWith ("scan:")) {  							// It crashed while scanning a file. Add the file to the ignore list and try again.  							string file = pex.LastLog.Substring (5);  							pparams.Add (file);  							monitor.ReportWarning ("Could not scan file: " + file);  							retry = true;  							continue;  						}  					}  					fatalDatabseError = true;  					// If the process has crashed' try to do a new scan' this time using verbose log'  					// to give the user more information about the origin of the crash.  					if (pex != null && !retry) {  						monitor.ReportError ("Add-in scan operation failed. The runtime may have encountered an error while trying to load an assembly."' null);  						if (monitor.LogLevel <= 1) {  							// Re-scan again using verbose log' to make it easy to find the origin of the error.  							retry = true;  							scanMonitor = new ConsoleProgressStatus (true);  						}  					} else  						retry = false;  					  					if (!retry) {  						var pfex = ex as ProcessFailedException;  						monitor.ReportError ("Add-in scan operation failed"' pfex != null? pfex.InnerException : ex);  						monitor.Cancel ();  						return;  					}  				}  			}  			while (retry);
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,RemoveAddinDescriptionFile,The following statement contains a magic number: if (file.EndsWith (".maddin"))  				dversion = 2;  			else {  				int i = file.LastIndexOf ('_');  				dversion = 1 + int.Parse (file.Substring (i + 1));  				file = file.Substring (0' i);  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,RemoveAddinDescriptionFile,The following statement contains a magic number: while (fileDatabase.Exists (file + "_" + dversion)) {  				string newFile = dversion == 2 ? file : file + "_" + (dversion-1);  				try {  					fileDatabase.Rename (file + "_" + dversion' newFile);  				} catch (Exception ex) {  					if (monitor.LogLevel > 1) {  						monitor.Log ("Could not rename file '" + file + "_" + dversion + "' to '" + newFile + "'");  						monitor.Log (ex.ToString ());  					}  				}  				dversion++;  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,RemoveAddinDescriptionFile,The following statement contains a magic number: if (dversion == 2) {  				// All versions of the add-in removed.  				SafeDeleteDir (monitor' Path.Combine (AddinPrivateDataPath' Path.GetFileNameWithoutExtension (file)));  			}
Magic Number,Mono.Addins.Database,AddinDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinDatabase.cs,SaveDescription,The following statement contains a magic number: try {  				if (replaceFileName != null)  					desc.SaveBinary (fileDatabase' replaceFileName);  				else {  					string file = GetDescriptionPath (desc.Domain' desc.AddinId);  					string dir = Path.GetDirectoryName (file);  					if (!fileDatabase.DirExists (dir))  						fileDatabase.CreateDir (dir);  					if (fileDatabase.Exists (file)) {  						// Another AddinDescription already exists with the same name.  						// Create an alternate AddinDescription file  						int altNum = 2;  						while (fileDatabase.Exists (file + "_" + altNum))  							altNum++;  						file = file + "_" + altNum;  					}  					desc.SaveBinary (fileDatabase' file);  				}  				return true;  			}  			catch (Exception ex) {  				monitor.ReportError ("Add-in info file could not be saved"' ex);  				return false;  			}
Magic Number,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,FileLock,The following statement contains a magic number: do {  				try {  					return new FileStream (DatabaseLockFile' FileMode.OpenOrCreate' access' share);  				}  				catch (IOException) {  					// Wait and try again  					if ((DateTime.Now - wt).TotalSeconds >= 4) {  						Console.WriteLine ("Waiting for " + access + " add-in database lock");  						wt = DateTime.Now;  					}    				}  				System.Threading.Thread.Sleep (100);  			}  			while (timeout <= 0 || (DateTime.Now - tim).TotalMilliseconds < timeout);
Magic Number,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,FileLock,The following statement contains a magic number: do {  				try {  					return new FileStream (DatabaseLockFile' FileMode.OpenOrCreate' access' share);  				}  				catch (IOException) {  					// Wait and try again  					if ((DateTime.Now - wt).TotalSeconds >= 4) {  						Console.WriteLine ("Waiting for " + access + " add-in database lock");  						wt = DateTime.Now;  					}    				}  				System.Threading.Thread.Sleep (100);  			}  			while (timeout <= 0 || (DateTime.Now - tim).TotalMilliseconds < timeout);
Magic Number,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,GetDirectoryFiles,The following statement contains a magic number: if (inTransaction) {  				Hashtable files = new Hashtable ();  				foreach (string f in Directory.GetFiles (dir' pattern)) {  					if (!deletedFiles.Contains (f))  						files [f] = f;  				}  				foreach (string f in Directory.GetFiles (dir' pattern + ".new")) {  					string ofile = f.Substring (0' f.Length - 4);  					files [ofile] = ofile;  				}  				string[] res = new string [files.Count];  				int n = 0;  				foreach (string s in files.Keys)  					res [n++] = s;  				return res;  			}  			else  				return Directory.GetFiles (dir' pattern);
Magic Number,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,CommitTransaction,The following statement contains a magic number: try {  				transactionLock.Dispose ();  				transactionLock = LockWrite ();  				foreach (string dir in foldersToUpdate.Keys) {  					foreach (string file in Directory.GetFiles (dir' "*.new")) {  						string dst = file.Substring (0' file.Length - 4);  						File.Delete (dst);  						File.Move (file' dst);  					}  				}  				foreach (string file in deletedFiles.Keys)  					File.Delete (file);  				foreach (string dir in deletedDirs.Keys)  					Directory.Delete (dir' true);  			}  			finally {  				transactionLock.Dispose ();  				EndTransaction ();  			}
Magic Number,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,GetFileKey,The following statement contains a magic number: int avlen = System.Math.Min (System.Math.Max (240 - directory.Length' 10)' 130);
Magic Number,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,GetFileKey,The following statement contains a magic number: int avlen = System.Math.Min (System.Math.Max (240 - directory.Length' 10)' 130);
Magic Number,Mono.Addins.Database,FileDatabase,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\FileDatabase.cs,GetFileKey,The following statement contains a magic number: int avlen = System.Math.Min (System.Math.Max (240 - directory.Length' 10)' 130);
Magic Number,Mono.Addins.Database,AddinUpdateData,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\AddinUpdateData.cs,RegisterExtension,The following statement contains a magic number: foreach (RootExtensionPoint einfo in extensions) {  				if (IsAddinCompatible (einfo.Description' description' module)) {  					if (!einfo.ExtensionPoint.Addins.Contains (description.AddinId))  						einfo.ExtensionPoint.Addins.Add (description.AddinId);  					found = true;  					if (monitor.LogLevel > 2) {  						monitor.Log ("  * " + einfo.Description.AddinId + "(" + einfo.Description.Domain + ") <- " + path);  					}  				}  			}
Magic Number,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,Main,The following statement contains a magic number: try {  				string registryPath = Console.In.ReadLine ();  				string startupDir = Console.In.ReadLine ();  				string addinsDir = Console.In.ReadLine ();  				string databaseDir = Console.In.ReadLine ();  				  				AddinDatabase.RunningSetupProcess = true;  				AddinRegistry reg = new AddinRegistry (registryPath' startupDir' addinsDir' databaseDir);  			  				switch (args [1]) {  				case "scan":  					string folder = args.Length > 2 ? args [2] : null;  					if (folder.Length == 0) folder = null;  					StringCollection filesToIgnore = new StringCollection ();  					for (int n=3; n<args.Length; n++)  						filesToIgnore.Add (args[n]);  					reg.ScanFolders (monitor' folder' filesToIgnore);  					break;  				case "get-desc":  					reg.ParseAddin (monitor' args[2]' args[3]);  					break;  				}  			} catch (Exception ex) {  				monitor.ReportError ("Unexpected error in setup process"' ex);  				return 1;  			}
Magic Number,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,Main,The following statement contains a magic number: try {  				string registryPath = Console.In.ReadLine ();  				string startupDir = Console.In.ReadLine ();  				string addinsDir = Console.In.ReadLine ();  				string databaseDir = Console.In.ReadLine ();  				  				AddinDatabase.RunningSetupProcess = true;  				AddinRegistry reg = new AddinRegistry (registryPath' startupDir' addinsDir' databaseDir);  			  				switch (args [1]) {  				case "scan":  					string folder = args.Length > 2 ? args [2] : null;  					if (folder.Length == 0) folder = null;  					StringCollection filesToIgnore = new StringCollection ();  					for (int n=3; n<args.Length; n++)  						filesToIgnore.Add (args[n]);  					reg.ScanFolders (monitor' folder' filesToIgnore);  					break;  				case "get-desc":  					reg.ParseAddin (monitor' args[2]' args[3]);  					break;  				}  			} catch (Exception ex) {  				monitor.ReportError ("Unexpected error in setup process"' ex);  				return 1;  			}
Magic Number,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,Main,The following statement contains a magic number: try {  				string registryPath = Console.In.ReadLine ();  				string startupDir = Console.In.ReadLine ();  				string addinsDir = Console.In.ReadLine ();  				string databaseDir = Console.In.ReadLine ();  				  				AddinDatabase.RunningSetupProcess = true;  				AddinRegistry reg = new AddinRegistry (registryPath' startupDir' addinsDir' databaseDir);  			  				switch (args [1]) {  				case "scan":  					string folder = args.Length > 2 ? args [2] : null;  					if (folder.Length == 0) folder = null;  					StringCollection filesToIgnore = new StringCollection ();  					for (int n=3; n<args.Length; n++)  						filesToIgnore.Add (args[n]);  					reg.ScanFolders (monitor' folder' filesToIgnore);  					break;  				case "get-desc":  					reg.ParseAddin (monitor' args[2]' args[3]);  					break;  				}  			} catch (Exception ex) {  				monitor.ReportError ("Unexpected error in setup process"' ex);  				return 1;  			}
Magic Number,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,Main,The following statement contains a magic number: try {  				string registryPath = Console.In.ReadLine ();  				string startupDir = Console.In.ReadLine ();  				string addinsDir = Console.In.ReadLine ();  				string databaseDir = Console.In.ReadLine ();  				  				AddinDatabase.RunningSetupProcess = true;  				AddinRegistry reg = new AddinRegistry (registryPath' startupDir' addinsDir' databaseDir);  			  				switch (args [1]) {  				case "scan":  					string folder = args.Length > 2 ? args [2] : null;  					if (folder.Length == 0) folder = null;  					StringCollection filesToIgnore = new StringCollection ();  					for (int n=3; n<args.Length; n++)  						filesToIgnore.Add (args[n]);  					reg.ScanFolders (monitor' folder' filesToIgnore);  					break;  				case "get-desc":  					reg.ParseAddin (monitor' args[2]' args[3]);  					break;  				}  			} catch (Exception ex) {  				monitor.ReportError ("Unexpected error in setup process"' ex);  				return 1;  			}
Magic Number,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,Main,The following statement contains a magic number: try {  				string registryPath = Console.In.ReadLine ();  				string startupDir = Console.In.ReadLine ();  				string addinsDir = Console.In.ReadLine ();  				string databaseDir = Console.In.ReadLine ();  				  				AddinDatabase.RunningSetupProcess = true;  				AddinRegistry reg = new AddinRegistry (registryPath' startupDir' addinsDir' databaseDir);  			  				switch (args [1]) {  				case "scan":  					string folder = args.Length > 2 ? args [2] : null;  					if (folder.Length == 0) folder = null;  					StringCollection filesToIgnore = new StringCollection ();  					for (int n=3; n<args.Length; n++)  						filesToIgnore.Add (args[n]);  					reg.ScanFolders (monitor' folder' filesToIgnore);  					break;  				case "get-desc":  					reg.ParseAddin (monitor' args[2]' args[3]);  					break;  				}  			} catch (Exception ex) {  				monitor.ReportError ("Unexpected error in setup process"' ex);  				return 1;  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,CheckWrittableFloder,The following statement contains a magic number: do {  				testFile = Path.Combine (path' random.Next ().ToString ());  				n++;  			} while (File.Exists (testFile) && n < 100);
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,CheckWrittableFloder,The following statement contains a magic number: if (n == 100)  				throw new InvalidOperationException ("Could not create file in directory: " + path);
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,NormalizePath,The following statement contains a magic number: if (path.Length > 2 && path [0] == '[') {  				int i = path.IndexOf (']'' 1);  				if (i != -1) {  					try {  						string fname = path.Substring (1' i - 1);  						Environment.SpecialFolder sf = (Environment.SpecialFolder) Enum.Parse (typeof(Environment.SpecialFolder)' fname' true);  						path = Environment.GetFolderPath (sf) + path.Substring (i + 1);  					} catch {  						// Ignore  					}  				}  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetStringHashCode,The following statement contains a magic number: for (; n < s.Length - 1; n+=2) {  				h = unchecked ((h << 5) - h + s[n]);  				h = unchecked ((h << 5) - h + s[n+1]);  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetStringHashCode,The following statement contains a magic number: for (; n < s.Length - 1; n+=2) {  				h = unchecked ((h << 5) - h + s[n]);  				h = unchecked ((h << 5) - h + s[n+1]);  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetStringHashCode,The following statement contains a magic number: for (; n < s.Length - 1; n+=2) {  				h = unchecked ((h << 5) - h + s[n]);  				h = unchecked ((h << 5) - h + s[n+1]);  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetStringHashCode,The following statement contains a magic number: if (n < s.Length)  				h = unchecked ((h << 5) - h + s[n]);
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetGacPath,The following statement contains a magic number: if (parts.Length != 4) return null;
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetGacPath,The following statement contains a magic number: i = parts[2].IndexOf ('=');
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetGacPath,The following statement contains a magic number: string culture = i != -1 ? parts[2].Substring (i+1).Trim () : parts[2].Trim ();
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetGacPath,The following statement contains a magic number: string culture = i != -1 ? parts[2].Substring (i+1).Trim () : parts[2].Trim ();
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetGacPath,The following statement contains a magic number: i = parts[3].IndexOf ('=');
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetGacPath,The following statement contains a magic number: string token = i != -1 ? parts[3].Substring (i+1).Trim () : parts[3].Trim ();
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,GetGacPath,The following statement contains a magic number: string token = i != -1 ? parts[3].Substring (i+1).Trim () : parts[3].Trim ();
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,IsManagedAssembly,The following statement contains a magic number: try  			{  				using (Stream fileStream = new FileStream(filePath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite | FileShare.Delete))  				using (BinaryReader binaryReader = new BinaryReader(fileStream))  				{  					if (fileStream.Length < 64)  					{  						return false;  					}    					// PE Header starts @ 0x3C (60). Its a 4 byte header.  					fileStream.Position = 0x3C;  					uint peHeaderPointer = binaryReader.ReadUInt32();  					if (peHeaderPointer == 0)  					{  						peHeaderPointer = 0x80;  					}    					// Ensure there is at least enough room for the following structures:  					//     24 byte PE Signature & Header  					//     28 byte Standard Fields         (24 bytes for PE32+)  					//     68 byte NT Fields               (88 bytes for PE32+)  					// >= 128 byte Data Dictionary Table  					if (peHeaderPointer > fileStream.Length - 256)  					{  						return false;  					}    					// Check the PE signature.  Should equal 'PE\0\0'.  					fileStream.Position = peHeaderPointer;  					uint peHeaderSignature = binaryReader.ReadUInt32();  					if (peHeaderSignature != 0x00004550)  					{  						return false;  					}    					// skip over the PEHeader fields  					fileStream.Position += 20;    					const ushort PE32 = 0x10b;  					const ushort PE32Plus = 0x20b;    					// Read PE magic number from Standard Fields to determine format.  					var peFormat = binaryReader.ReadUInt16();  					if (peFormat != PE32 && peFormat != PE32Plus)  					{  						return false;  					}    					// Read the 15th Data Dictionary RVA field which contains the CLI header RVA.  					// When this is non-zero then the file contains CLI data otherwise not.  					ushort dataDictionaryStart = (ushort)(peHeaderPointer + (peFormat == PE32 ? 232 : 248));  					fileStream.Position = dataDictionaryStart;    					uint cliHeaderRva = binaryReader.ReadUInt32();  					if (cliHeaderRva == 0)  					{  						return false;  					}    					return true;  				}  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,IsManagedAssembly,The following statement contains a magic number: try  			{  				using (Stream fileStream = new FileStream(filePath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite | FileShare.Delete))  				using (BinaryReader binaryReader = new BinaryReader(fileStream))  				{  					if (fileStream.Length < 64)  					{  						return false;  					}    					// PE Header starts @ 0x3C (60). Its a 4 byte header.  					fileStream.Position = 0x3C;  					uint peHeaderPointer = binaryReader.ReadUInt32();  					if (peHeaderPointer == 0)  					{  						peHeaderPointer = 0x80;  					}    					// Ensure there is at least enough room for the following structures:  					//     24 byte PE Signature & Header  					//     28 byte Standard Fields         (24 bytes for PE32+)  					//     68 byte NT Fields               (88 bytes for PE32+)  					// >= 128 byte Data Dictionary Table  					if (peHeaderPointer > fileStream.Length - 256)  					{  						return false;  					}    					// Check the PE signature.  Should equal 'PE\0\0'.  					fileStream.Position = peHeaderPointer;  					uint peHeaderSignature = binaryReader.ReadUInt32();  					if (peHeaderSignature != 0x00004550)  					{  						return false;  					}    					// skip over the PEHeader fields  					fileStream.Position += 20;    					const ushort PE32 = 0x10b;  					const ushort PE32Plus = 0x20b;    					// Read PE magic number from Standard Fields to determine format.  					var peFormat = binaryReader.ReadUInt16();  					if (peFormat != PE32 && peFormat != PE32Plus)  					{  						return false;  					}    					// Read the 15th Data Dictionary RVA field which contains the CLI header RVA.  					// When this is non-zero then the file contains CLI data otherwise not.  					ushort dataDictionaryStart = (ushort)(peHeaderPointer + (peFormat == PE32 ? 232 : 248));  					fileStream.Position = dataDictionaryStart;    					uint cliHeaderRva = binaryReader.ReadUInt32();  					if (cliHeaderRva == 0)  					{  						return false;  					}    					return true;  				}  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,IsManagedAssembly,The following statement contains a magic number: try  			{  				using (Stream fileStream = new FileStream(filePath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite | FileShare.Delete))  				using (BinaryReader binaryReader = new BinaryReader(fileStream))  				{  					if (fileStream.Length < 64)  					{  						return false;  					}    					// PE Header starts @ 0x3C (60). Its a 4 byte header.  					fileStream.Position = 0x3C;  					uint peHeaderPointer = binaryReader.ReadUInt32();  					if (peHeaderPointer == 0)  					{  						peHeaderPointer = 0x80;  					}    					// Ensure there is at least enough room for the following structures:  					//     24 byte PE Signature & Header  					//     28 byte Standard Fields         (24 bytes for PE32+)  					//     68 byte NT Fields               (88 bytes for PE32+)  					// >= 128 byte Data Dictionary Table  					if (peHeaderPointer > fileStream.Length - 256)  					{  						return false;  					}    					// Check the PE signature.  Should equal 'PE\0\0'.  					fileStream.Position = peHeaderPointer;  					uint peHeaderSignature = binaryReader.ReadUInt32();  					if (peHeaderSignature != 0x00004550)  					{  						return false;  					}    					// skip over the PEHeader fields  					fileStream.Position += 20;    					const ushort PE32 = 0x10b;  					const ushort PE32Plus = 0x20b;    					// Read PE magic number from Standard Fields to determine format.  					var peFormat = binaryReader.ReadUInt16();  					if (peFormat != PE32 && peFormat != PE32Plus)  					{  						return false;  					}    					// Read the 15th Data Dictionary RVA field which contains the CLI header RVA.  					// When this is non-zero then the file contains CLI data otherwise not.  					ushort dataDictionaryStart = (ushort)(peHeaderPointer + (peFormat == PE32 ? 232 : 248));  					fileStream.Position = dataDictionaryStart;    					uint cliHeaderRva = binaryReader.ReadUInt32();  					if (cliHeaderRva == 0)  					{  						return false;  					}    					return true;  				}  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,IsManagedAssembly,The following statement contains a magic number: try  			{  				using (Stream fileStream = new FileStream(filePath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite | FileShare.Delete))  				using (BinaryReader binaryReader = new BinaryReader(fileStream))  				{  					if (fileStream.Length < 64)  					{  						return false;  					}    					// PE Header starts @ 0x3C (60). Its a 4 byte header.  					fileStream.Position = 0x3C;  					uint peHeaderPointer = binaryReader.ReadUInt32();  					if (peHeaderPointer == 0)  					{  						peHeaderPointer = 0x80;  					}    					// Ensure there is at least enough room for the following structures:  					//     24 byte PE Signature & Header  					//     28 byte Standard Fields         (24 bytes for PE32+)  					//     68 byte NT Fields               (88 bytes for PE32+)  					// >= 128 byte Data Dictionary Table  					if (peHeaderPointer > fileStream.Length - 256)  					{  						return false;  					}    					// Check the PE signature.  Should equal 'PE\0\0'.  					fileStream.Position = peHeaderPointer;  					uint peHeaderSignature = binaryReader.ReadUInt32();  					if (peHeaderSignature != 0x00004550)  					{  						return false;  					}    					// skip over the PEHeader fields  					fileStream.Position += 20;    					const ushort PE32 = 0x10b;  					const ushort PE32Plus = 0x20b;    					// Read PE magic number from Standard Fields to determine format.  					var peFormat = binaryReader.ReadUInt16();  					if (peFormat != PE32 && peFormat != PE32Plus)  					{  						return false;  					}    					// Read the 15th Data Dictionary RVA field which contains the CLI header RVA.  					// When this is non-zero then the file contains CLI data otherwise not.  					ushort dataDictionaryStart = (ushort)(peHeaderPointer + (peFormat == PE32 ? 232 : 248));  					fileStream.Position = dataDictionaryStart;    					uint cliHeaderRva = binaryReader.ReadUInt32();  					if (cliHeaderRva == 0)  					{  						return false;  					}    					return true;  				}  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Mono.Addins.Database,Util,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\Util.cs,IsManagedAssembly,The following statement contains a magic number: try  			{  				using (Stream fileStream = new FileStream(filePath' FileMode.Open' FileAccess.Read' FileShare.ReadWrite | FileShare.Delete))  				using (BinaryReader binaryReader = new BinaryReader(fileStream))  				{  					if (fileStream.Length < 64)  					{  						return false;  					}    					// PE Header starts @ 0x3C (60). Its a 4 byte header.  					fileStream.Position = 0x3C;  					uint peHeaderPointer = binaryReader.ReadUInt32();  					if (peHeaderPointer == 0)  					{  						peHeaderPointer = 0x80;  					}    					// Ensure there is at least enough room for the following structures:  					//     24 byte PE Signature & Header  					//     28 byte Standard Fields         (24 bytes for PE32+)  					//     68 byte NT Fields               (88 bytes for PE32+)  					// >= 128 byte Data Dictionary Table  					if (peHeaderPointer > fileStream.Length - 256)  					{  						return false;  					}    					// Check the PE signature.  Should equal 'PE\0\0'.  					fileStream.Position = peHeaderPointer;  					uint peHeaderSignature = binaryReader.ReadUInt32();  					if (peHeaderSignature != 0x00004550)  					{  						return false;  					}    					// skip over the PEHeader fields  					fileStream.Position += 20;    					const ushort PE32 = 0x10b;  					const ushort PE32Plus = 0x20b;    					// Read PE magic number from Standard Fields to determine format.  					var peFormat = binaryReader.ReadUInt16();  					if (peFormat != PE32 && peFormat != PE32Plus)  					{  						return false;  					}    					// Read the 15th Data Dictionary RVA field which contains the CLI header RVA.  					// When this is non-zero then the file contains CLI data otherwise not.  					ushort dataDictionaryStart = (ushort)(peHeaderPointer + (peFormat == PE32 ? 232 : 248));  					fileStream.Position = dataDictionaryStart;    					uint cliHeaderRva = binaryReader.ReadUInt32();  					if (cliHeaderRva == 0)  					{  						return false;  					}    					return true;  				}  			}  			catch (Exception)  			{  				return false;  			}
Magic Number,Mono.Addins.Database,ProcessProgressStatus,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\ProcessProgressStatus.cs,Log,The following statement contains a magic number: if (msg.StartsWith ("plog:"))  				// This is an special type of log that will be provided to the  				// main process in case of a crash in the setup process  				Console.WriteLine ("process-ps-plog:" + Encode (msg.Substring (5)));  			else  				Console.WriteLine ("process-ps-log:" + Encode (msg));
Magic Number,Mono.Addins.Database,RemoteProgressStatus,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupDomain.cs,Log,The following statement contains a magic number: if (msg.StartsWith ("plog:"))  				progessLog.Add (msg.Substring (5));  			else  				local.Log (msg);
Magic Number,Mono.Addins.Localization,StringTableLocalizer,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Localization\StringTableLocalizer.cs,GetString,The following statement contains a magic number: if (loc == null) {  				string sn = cname.Substring (0' 2);  				loc = (Hashtable) locales [sn];  				if (loc != null)  					locales [cname] = loc;  				else {  					locales [cname] = nullLocale;  					return id;  				}  			}
Magic Number,Mono.Addins.Localization,StringTableLocalizer,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Localization\StringTableLocalizer.cs,GetString,The following statement contains a magic number: if (msg == null) {  				if (cname.Length > 2) {  					// Try again without the country  					cname = cname.Substring (0' 2);  					loc = (Hashtable) locales [cname];  					if (loc != null) {  						msg = (string) loc [id];  						if (msg != null)  							return msg;  					}  				}  				return id;  			}  			else  				return msg;
Magic Number,Mono.Addins.Localization,StringTableLocalizer,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Localization\StringTableLocalizer.cs,GetString,The following statement contains a magic number: if (msg == null) {  				if (cname.Length > 2) {  					// Try again without the country  					cname = cname.Substring (0' 2);  					loc = (Hashtable) locales [cname];  					if (loc != null) {  						msg = (string) loc [id];  						if (msg != null)  							return msg;  					}  				}  				return id;  			}  			else  				return msg;
Missing Default,Mono.Addins.Description,AddinDescription,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Description\AddinDescription.cs,TryGetVariableValue,The following switch statement is missing a default case: switch (name) {  				case "Id": value = id; return true;  				case "Namespace": value = ns; return true;  				case "Version": value = version; return true;  				case "CompatVersion": value = compatVersion; return true;  				case "DefaultEnabled": value = defaultEnabled.ToString (); return true;  				case "IsRoot": value = isroot.ToString (); return true;  				case "Flags": value = flags.ToString (); return true;  			}
Missing Default,Mono.Addins.Database,SetupProcess,C:\repos\mono_mono-addins\Mono.Addins\Mono.Addins.Database\SetupProcess.cs,Main,The following switch statement is missing a default case: switch (args [1]) {  				case "scan":  					string folder = args.Length > 2 ? args [2] : null;  					if (folder.Length == 0) folder = null;  					StringCollection filesToIgnore = new StringCollection ();  					for (int n=3; n<args.Length; n++)  						filesToIgnore.Add (args[n]);  					reg.ScanFolders (monitor' folder' filesToIgnore);  					break;  				case "get-desc":  					reg.ParseAddin (monitor' args[2]' args[3]);  					break;  				}
