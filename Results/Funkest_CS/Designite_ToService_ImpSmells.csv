Implementation smell,Namespace,Class,File,Method,Description
Long Method,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The method has 123 lines of code.
Complex Method,winsw,SizeBasedRollingLogAppender,C:\repos\Funkest_CS\ToService\ToService\LogAppenders.cs,CopyStreamWithRotation,Cyclomatic complexity of the method is 11
Complex Method,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,Cyclomatic complexity of the method is 27
Complex Method,winsw,PeriodicRollingCalendar,C:\repos\Funkest_CS\ToService\ToService\PeriodicRollingCalendar.cs,nextTriggeringTime,Cyclomatic complexity of the method is 17
Complex Method,DynamicProxy,ProxyFactory,C:\repos\Funkest_CS\ToService\ToService\DynamicProxy.cs,GenerateMethod,Cyclomatic complexity of the method is 10
Long Parameter List,winsw,Kernel32,C:\repos\Funkest_CS\ToService\ToService\Kernel32.cs,CreateProcess,The method has 10 parameters.
Long Parameter List,WMI,Win32Services,C:\repos\Funkest_CS\ToService\ToService\WmiSchema.cs,Create,The method has 10 parameters.
Long Parameter List,WMI,Win32Services,C:\repos\Funkest_CS\ToService\ToService\WmiSchema.cs,Create,The method has 8 parameters.
Long Statement,winsw,ServiceManager,C:\repos\Funkest_CS\ToService\ToService\Advapi32.cs,Open,The length of the statement  "		throw new Exception (String.Format ("Error opening service for modifying. Error returned was: 0x{0:X}"' Marshal.GetLastWin32Error ())); " is 135.
Long Statement,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,SignalShutdownPending,The length of the statement  "	//            WriteEvent("SignalShutdownPending " + wrapperServiceStatus.checkPoint + ":" + wrapperServiceStatus.waitHint); " is 123.
Long Statement,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,SignalShutdownComplete,The length of the statement  "	//            WriteEvent("SignalShutdownComplete " + wrapperServiceStatus.checkPoint + ":" + wrapperServiceStatus.waitHint); " is 124.
Long Statement,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,StartProcess,The length of the statement  "	// ps.EnvironmentVariables[key] = envs[key]; // bugged (lower cases all variable names due to StringDictionary being used' see http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=326163) " is 214.
Long Statement,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The length of the statement  "			svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' WMI.ServiceType.OwnProcess' ErrorControl.UserNotified' StartMode.Automatic' d.Interactive' username' password' d.ServiceDependencies); " is 195.
Long Statement,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The length of the statement  "			Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description); " is 165.
Long Statement,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The length of the statement  "			bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi); " is 178.
Long Statement,DynamicProxy,ProxyFactory,C:\repos\Funkest_CS\ToService\ToService\DynamicProxy.cs,CreateType,The length of the statement  "		ConstructorBuilder delegateConstructor = typeBuilder.DefineConstructor (MethodAttributes.Public' CallingConventions.Standard' new Type[] { " is 138.
Long Statement,DynamicProxy,ProxyFactory,C:\repos\Funkest_CS\ToService\ToService\DynamicProxy.cs,GenerateMethod,The length of the statement  "		MethodBuilder methodBuilder = typeBuilder.DefineMethod (methodInfo.Name' /*MethodAttributes.Public | MethodAttributes.Virtual | */methodInfo.Attributes & ~MethodAttributes.Abstract' CallingConventions.Standard' methodInfo.ReturnType' methodParameters); " is 252.
Long Statement,DynamicProxy,ProxyFactory,C:\repos\Funkest_CS\ToService\ToService\DynamicProxy.cs,GenerateMethod,The length of the statement  "	//    PropertyBuilder pb = typeBuilder.DefineProperty(p.Name' p.Attributes' p.PropertyType' new Type[] { p.PropertyType }); " is 123.
Empty Catch Block,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,StopIt,The method has an empty catch block.
Empty Catch Block,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,StopProcessAndChildren,The method has an empty catch block.
Empty Catch Block,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,WaitForProcessToExit,The method has an empty catch block.
Magic Number,winsw,SizeBasedRollingLogAppender,C:\repos\Funkest_CS\ToService\ToService\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: while (true) {  	int len = data.Read (buf' 0' buf.Length);  	if (len == 0)  		break;  	// EOF  	if (sz + len < sizeThreshold) {  		// typical case. write the whole thing into the current file  		w.Write (buf' 0' len);  		sz += len;  	}  	else {  		// rotate at the line boundary  		int s = 0;  		for (int i = 0; i < len; i++) {  			if (buf [i] != 0x0A)  				continue;  			if (sz + i < sizeThreshold)  				continue;  			// at the line boundary and exceeded the rotation unit.  			// time to rotate.  			w.Write (buf' s' i + 1);  			w.Close ();  			s = i + 1;  			try {  				for (int j = filesToKeep; j >= 1; j--) {  					string dst = BaseLogFileName + "." + (j - 1) + ext;  					string src = BaseLogFileName + "." + (j - 2) + ext;  					if (File.Exists (dst))  						File.Delete (dst);  					if (File.Exists (src))  						File.Move (src' dst);  				}  				File.Move (BaseLogFileName + ext' BaseLogFileName + ".0" + ext);  			}  			catch (IOException e) {  				EventLogger.LogEvent ("Failed to rotate log: " + e.Message);  			}  			// even if the log rotation fails' create a new one' or else  			// we'll infinitely try to rotate.  			w = new FileStream (BaseLogFileName + ext' FileMode.Create);  			sz = new FileInfo (BaseLogFileName + ext).Length;  		}  	}  	w.Flush ();  }  
Magic Number,winsw,SizeBasedRollingLogAppender,C:\repos\Funkest_CS\ToService\ToService\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: if (sz + len < sizeThreshold) {  	// typical case. write the whole thing into the current file  	w.Write (buf' 0' len);  	sz += len;  }  else {  	// rotate at the line boundary  	int s = 0;  	for (int i = 0; i < len; i++) {  		if (buf [i] != 0x0A)  			continue;  		if (sz + i < sizeThreshold)  			continue;  		// at the line boundary and exceeded the rotation unit.  		// time to rotate.  		w.Write (buf' s' i + 1);  		w.Close ();  		s = i + 1;  		try {  			for (int j = filesToKeep; j >= 1; j--) {  				string dst = BaseLogFileName + "." + (j - 1) + ext;  				string src = BaseLogFileName + "." + (j - 2) + ext;  				if (File.Exists (dst))  					File.Delete (dst);  				if (File.Exists (src))  					File.Move (src' dst);  			}  			File.Move (BaseLogFileName + ext' BaseLogFileName + ".0" + ext);  		}  		catch (IOException e) {  			EventLogger.LogEvent ("Failed to rotate log: " + e.Message);  		}  		// even if the log rotation fails' create a new one' or else  		// we'll infinitely try to rotate.  		w = new FileStream (BaseLogFileName + ext' FileMode.Create);  		sz = new FileInfo (BaseLogFileName + ext).Length;  	}  }  
Magic Number,winsw,SizeBasedRollingLogAppender,C:\repos\Funkest_CS\ToService\ToService\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: for (int i = 0; i < len; i++) {  	if (buf [i] != 0x0A)  		continue;  	if (sz + i < sizeThreshold)  		continue;  	// at the line boundary and exceeded the rotation unit.  	// time to rotate.  	w.Write (buf' s' i + 1);  	w.Close ();  	s = i + 1;  	try {  		for (int j = filesToKeep; j >= 1; j--) {  			string dst = BaseLogFileName + "." + (j - 1) + ext;  			string src = BaseLogFileName + "." + (j - 2) + ext;  			if (File.Exists (dst))  				File.Delete (dst);  			if (File.Exists (src))  				File.Move (src' dst);  		}  		File.Move (BaseLogFileName + ext' BaseLogFileName + ".0" + ext);  	}  	catch (IOException e) {  		EventLogger.LogEvent ("Failed to rotate log: " + e.Message);  	}  	// even if the log rotation fails' create a new one' or else  	// we'll infinitely try to rotate.  	w = new FileStream (BaseLogFileName + ext' FileMode.Create);  	sz = new FileInfo (BaseLogFileName + ext).Length;  }  
Magic Number,winsw,SizeBasedRollingLogAppender,C:\repos\Funkest_CS\ToService\ToService\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: try {  	for (int j = filesToKeep; j >= 1; j--) {  		string dst = BaseLogFileName + "." + (j - 1) + ext;  		string src = BaseLogFileName + "." + (j - 2) + ext;  		if (File.Exists (dst))  			File.Delete (dst);  		if (File.Exists (src))  			File.Move (src' dst);  	}  	File.Move (BaseLogFileName + ext' BaseLogFileName + ".0" + ext);  }  catch (IOException e) {  	EventLogger.LogEvent ("Failed to rotate log: " + e.Message);  }  
Magic Number,winsw,SizeBasedRollingLogAppender,C:\repos\Funkest_CS\ToService\ToService\LogAppenders.cs,CopyStreamWithRotation,The following statement contains a magic number: for (int j = filesToKeep; j >= 1; j--) {  	string dst = BaseLogFileName + "." + (j - 1) + ext;  	string src = BaseLogFileName + "." + (j - 2) + ext;  	if (File.Exists (dst))  		File.Delete (dst);  	if (File.Exists (src))  		File.Move (src' dst);  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,HandleFileCopies,The following statement contains a magic number: try {  	using (var tr = new StreamReader (file' Encoding.UTF8)) {  		string line;  		while ((line = tr.ReadLine ()) != null) {  			LogEvent ("Handling copy: " + line);  			string[] tokens = line.Split ('>');  			if (tokens.Length > 2) {  				LogEvent ("Too many delimiters in " + line);  				continue;  			}  			CopyFile (tokens [0]' tokens [1]);  		}  	}  }  finally {  	File.Delete (file);  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,HandleFileCopies,The following statement contains a magic number: using (var tr = new StreamReader (file' Encoding.UTF8)) {  	string line;  	while ((line = tr.ReadLine ()) != null) {  		LogEvent ("Handling copy: " + line);  		string[] tokens = line.Split ('>');  		if (tokens.Length > 2) {  			LogEvent ("Too many delimiters in " + line);  			continue;  		}  		CopyFile (tokens [0]' tokens [1]);  	}  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,HandleFileCopies,The following statement contains a magic number: while ((line = tr.ReadLine ()) != null) {  	LogEvent ("Handling copy: " + line);  	string[] tokens = line.Split ('>');  	if (tokens.Length > 2) {  		LogEvent ("Too many delimiters in " + line);  		continue;  	}  	CopyFile (tokens [0]' tokens [1]);  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,HandleFileCopies,The following statement contains a magic number: if (tokens.Length > 2) {  	LogEvent ("Too many delimiters in " + line);  	continue;  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (_args.Length > 0) {  	var d = new ServiceDescriptor ();  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f);  		w.AutoFlush = true;  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.Handle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		string username = null' password = null;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  		}  		else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  			}  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' WMI.ServiceType.OwnProcess' ErrorControl.UserNotified' StartMode.Automatic' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		if (actions.Count > 0) {  			// set the failure actions  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					sc.ChangeConfig (d.ResetFailureAfter' actions);  				}  			}  		}  	}  	if (args [0] == "uninstall") {  		if (s == null)  			return;  		// there's no such service' so consider it already uninstalled  		try {  			s.Delete ();  		}  		catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion)  				return;  			// it's already uninstalled' so consider it a success  			throw e;  		}  	}  	if (args [0] == "start") {  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  	}  	if (args [0] == "stop") {  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  	}  	if (args [0] == "restart") {  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  	}  	if (args [0] == "restart!") {  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  	}  	if (args [0] == "status") {  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  	}  	return;  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (_args.Length > 0) {  	var d = new ServiceDescriptor ();  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f);  		w.AutoFlush = true;  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.Handle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		string username = null' password = null;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  		}  		else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  			}  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' WMI.ServiceType.OwnProcess' ErrorControl.UserNotified' StartMode.Automatic' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		if (actions.Count > 0) {  			// set the failure actions  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					sc.ChangeConfig (d.ResetFailureAfter' actions);  				}  			}  		}  	}  	if (args [0] == "uninstall") {  		if (s == null)  			return;  		// there's no such service' so consider it already uninstalled  		try {  			s.Delete ();  		}  		catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion)  				return;  			// it's already uninstalled' so consider it a success  			throw e;  		}  	}  	if (args [0] == "start") {  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  	}  	if (args [0] == "stop") {  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  	}  	if (args [0] == "restart") {  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  	}  	if (args [0] == "restart!") {  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  	}  	if (args [0] == "status") {  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  	}  	return;  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (_args.Length > 0) {  	var d = new ServiceDescriptor ();  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f);  		w.AutoFlush = true;  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.Handle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		string username = null' password = null;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  		}  		else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  			}  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' WMI.ServiceType.OwnProcess' ErrorControl.UserNotified' StartMode.Automatic' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		if (actions.Count > 0) {  			// set the failure actions  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					sc.ChangeConfig (d.ResetFailureAfter' actions);  				}  			}  		}  	}  	if (args [0] == "uninstall") {  		if (s == null)  			return;  		// there's no such service' so consider it already uninstalled  		try {  			s.Delete ();  		}  		catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion)  				return;  			// it's already uninstalled' so consider it a success  			throw e;  		}  	}  	if (args [0] == "start") {  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  	}  	if (args [0] == "stop") {  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  	}  	if (args [0] == "restart") {  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  	}  	if (args [0] == "restart!") {  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  	}  	if (args [0] == "status") {  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  	}  	return;  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (_args.Length > 0) {  	var d = new ServiceDescriptor ();  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f);  		w.AutoFlush = true;  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.Handle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		string username = null' password = null;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  		}  		else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  			}  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' WMI.ServiceType.OwnProcess' ErrorControl.UserNotified' StartMode.Automatic' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		if (actions.Count > 0) {  			// set the failure actions  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					sc.ChangeConfig (d.ResetFailureAfter' actions);  				}  			}  		}  	}  	if (args [0] == "uninstall") {  		if (s == null)  			return;  		// there's no such service' so consider it already uninstalled  		try {  			s.Delete ();  		}  		catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion)  				return;  			// it's already uninstalled' so consider it a success  			throw e;  		}  	}  	if (args [0] == "start") {  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  	}  	if (args [0] == "stop") {  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  	}  	if (args [0] == "restart") {  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  	}  	if (args [0] == "restart!") {  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  	}  	if (args [0] == "status") {  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  	}  	return;  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (_args.Length > 0) {  	var d = new ServiceDescriptor ();  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f);  		w.AutoFlush = true;  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.Handle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		string username = null' password = null;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  		}  		else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  			}  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' WMI.ServiceType.OwnProcess' ErrorControl.UserNotified' StartMode.Automatic' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		if (actions.Count > 0) {  			// set the failure actions  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					sc.ChangeConfig (d.ResetFailureAfter' actions);  				}  			}  		}  	}  	if (args [0] == "uninstall") {  		if (s == null)  			return;  		// there's no such service' so consider it already uninstalled  		try {  			s.Delete ();  		}  		catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion)  				return;  			// it's already uninstalled' so consider it a success  			throw e;  		}  	}  	if (args [0] == "start") {  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  	}  	if (args [0] == "stop") {  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  	}  	if (args [0] == "restart") {  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  	}  	if (args [0] == "restart!") {  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  	}  	if (args [0] == "status") {  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  	}  	return;  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (_args.Length > 0) {  	var d = new ServiceDescriptor ();  	Win32Services svc = new WmiRoot ().GetCollection<Win32Services> ();  	Win32Service s = svc.Select (d.Id);  	var args = new List<string> (Array.AsReadOnly (_args));  	if (args [0] == "/redirect") {  		// Redirect output  		// One might ask why we support this when the caller   		// can redirect the output easily. The answer is for supporting UAC.  		// On UAC-enabled Windows such as Vista' SCM operation requires  		// elevated privileges' thus winsw.exe needs to be launched  		// accordingly. This in turn limits what the caller can do'  		// and among other things it makes it difficult for the caller  		// to read stdout/stderr. Thus redirection becomes handy.  		var f = new FileStream (args [1]' FileMode.Create);  		var w = new StreamWriter (f);  		w.AutoFlush = true;  		Console.SetOut (w);  		Console.SetError (w);  		var handle = f.Handle;  		Kernel32.SetStdHandle (-11' handle);  		// set stdout  		Kernel32.SetStdHandle (-12' handle);  		// set stder  		args = args.GetRange (2' args.Count - 2);  	}  	args [0] = args [0].ToLower ();  	if (args [0] == "install") {  		string username = null' password = null;  		if (args.Count > 1 && args [1] == "/p") {  			// we expected username/password on stdin  			Console.Write ("Username: ");  			username = Console.ReadLine ();  			Console.Write ("Password: ");  			password = ReadPassword ();  		}  		else {  			if (d.HasServiceAccount ()) {  				username = d.ServiceAccountUser;  				password = d.ServiceAccountPassword;  			}  		}  		svc.Create (d.Id' d.Caption' "\"" + d.ExecutablePath + "\""' WMI.ServiceType.OwnProcess' ErrorControl.UserNotified' StartMode.Automatic' d.Interactive' username' password' d.ServiceDependencies);  		// update the description  		/* Somehow this doesn't work' even though it doesn't report an error                     Win32Service s = svc.Select(d.Id);                     s.Description = d.Description;                     s.Commit();                      */// so using a classic method to set the description. Ugly.  		Registry.LocalMachine.OpenSubKey ("System").OpenSubKey ("CurrentControlSet").OpenSubKey ("Services").OpenSubKey (d.Id' true).SetValue ("Description"' d.Description);  		var actions = d.FailureActions;  		if (actions.Count > 0) {  			// set the failure actions  			using (ServiceManager scm = new ServiceManager ()) {  				using (Service sc = scm.Open (d.Id)) {  					sc.ChangeConfig (d.ResetFailureAfter' actions);  				}  			}  		}  	}  	if (args [0] == "uninstall") {  		if (s == null)  			return;  		// there's no such service' so consider it already uninstalled  		try {  			s.Delete ();  		}  		catch (WmiException e) {  			if (e.ErrorCode == ReturnValue.ServiceMarkedForDeletion)  				return;  			// it's already uninstalled' so consider it a success  			throw e;  		}  	}  	if (args [0] == "start") {  		if (s == null)  			ThrowNoSuchService ();  		s.StartService ();  	}  	if (args [0] == "stop") {  		if (s == null)  			ThrowNoSuchService ();  		s.StopService ();  	}  	if (args [0] == "restart") {  		if (s == null)  			ThrowNoSuchService ();  		if (s.Started)  			s.StopService ();  		while (s.Started) {  			Thread.Sleep (1000);  			s = svc.Select (d.Id);  		}  		s.StartService ();  	}  	if (args [0] == "restart!") {  		// run restart from another process group. see README.md for why this is useful.  		STARTUPINFO si = new STARTUPINFO ();  		PROCESS_INFORMATION pi = new PROCESS_INFORMATION ();  		bool result = Kernel32.CreateProcess (null' d.ExecutablePath + " restart"' IntPtr.Zero' IntPtr.Zero' false' 0x200/*CREATE_NEW_PROCESS_GROUP*/' IntPtr.Zero' null' ref si' out pi);  		if (!result) {  			throw new Exception ("Failed to invoke restart: " + Marshal.GetLastWin32Error ());  		}  	}  	if (args [0] == "status") {  		if (s == null)  			Console.WriteLine ("NonExistent");  		else if (s.Started)  			Console.WriteLine ("Started");  		else  			Console.WriteLine ("Stopped");  	}  	if (args [0] == "test") {  		WrapperService wsvc = new WrapperService ();  		wsvc.OnStart (args.ToArray ());  		Thread.Sleep (1000);  		wsvc.OnStop ();  	}  	return;  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (args [0] == "/redirect") {  	// Redirect output  	// One might ask why we support this when the caller   	// can redirect the output easily. The answer is for supporting UAC.  	// On UAC-enabled Windows such as Vista' SCM operation requires  	// elevated privileges' thus winsw.exe needs to be launched  	// accordingly. This in turn limits what the caller can do'  	// and among other things it makes it difficult for the caller  	// to read stdout/stderr. Thus redirection becomes handy.  	var f = new FileStream (args [1]' FileMode.Create);  	var w = new StreamWriter (f);  	w.AutoFlush = true;  	Console.SetOut (w);  	Console.SetError (w);  	var handle = f.Handle;  	Kernel32.SetStdHandle (-11' handle);  	// set stdout  	Kernel32.SetStdHandle (-12' handle);  	// set stder  	args = args.GetRange (2' args.Count - 2);  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (args [0] == "/redirect") {  	// Redirect output  	// One might ask why we support this when the caller   	// can redirect the output easily. The answer is for supporting UAC.  	// On UAC-enabled Windows such as Vista' SCM operation requires  	// elevated privileges' thus winsw.exe needs to be launched  	// accordingly. This in turn limits what the caller can do'  	// and among other things it makes it difficult for the caller  	// to read stdout/stderr. Thus redirection becomes handy.  	var f = new FileStream (args [1]' FileMode.Create);  	var w = new StreamWriter (f);  	w.AutoFlush = true;  	Console.SetOut (w);  	Console.SetError (w);  	var handle = f.Handle;  	Kernel32.SetStdHandle (-11' handle);  	// set stdout  	Kernel32.SetStdHandle (-12' handle);  	// set stder  	args = args.GetRange (2' args.Count - 2);  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (args [0] == "/redirect") {  	// Redirect output  	// One might ask why we support this when the caller   	// can redirect the output easily. The answer is for supporting UAC.  	// On UAC-enabled Windows such as Vista' SCM operation requires  	// elevated privileges' thus winsw.exe needs to be launched  	// accordingly. This in turn limits what the caller can do'  	// and among other things it makes it difficult for the caller  	// to read stdout/stderr. Thus redirection becomes handy.  	var f = new FileStream (args [1]' FileMode.Create);  	var w = new StreamWriter (f);  	w.AutoFlush = true;  	Console.SetOut (w);  	Console.SetError (w);  	var handle = f.Handle;  	Kernel32.SetStdHandle (-11' handle);  	// set stdout  	Kernel32.SetStdHandle (-12' handle);  	// set stder  	args = args.GetRange (2' args.Count - 2);  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (args [0] == "/redirect") {  	// Redirect output  	// One might ask why we support this when the caller   	// can redirect the output easily. The answer is for supporting UAC.  	// On UAC-enabled Windows such as Vista' SCM operation requires  	// elevated privileges' thus winsw.exe needs to be launched  	// accordingly. This in turn limits what the caller can do'  	// and among other things it makes it difficult for the caller  	// to read stdout/stderr. Thus redirection becomes handy.  	var f = new FileStream (args [1]' FileMode.Create);  	var w = new StreamWriter (f);  	w.AutoFlush = true;  	Console.SetOut (w);  	Console.SetError (w);  	var handle = f.Handle;  	Kernel32.SetStdHandle (-11' handle);  	// set stdout  	Kernel32.SetStdHandle (-12' handle);  	// set stder  	args = args.GetRange (2' args.Count - 2);  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: Kernel32.SetStdHandle (-11' handle);  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: Kernel32.SetStdHandle (-12' handle);  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: args = args.GetRange (2' args.Count - 2);  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: args = args.GetRange (2' args.Count - 2);  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (args [0] == "restart") {  	if (s == null)  		ThrowNoSuchService ();  	if (s.Started)  		s.StopService ();  	while (s.Started) {  		Thread.Sleep (1000);  		s = svc.Select (d.Id);  	}  	s.StartService ();  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: while (s.Started) {  	Thread.Sleep (1000);  	s = svc.Select (d.Id);  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: Thread.Sleep (1000);  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: if (args [0] == "test") {  	WrapperService wsvc = new WrapperService ();  	wsvc.OnStart (args.ToArray ());  	Thread.Sleep (1000);  	wsvc.OnStop ();  }  
Magic Number,winsw,WrapperService,C:\repos\Funkest_CS\ToService\ToService\Main.cs,Run,The following statement contains a magic number: Thread.Sleep (1000);  
Magic Number,winsw,ServiceDescriptor,C:\repos\Funkest_CS\ToService\ToService\ServiceDescriptor.cs,ServiceDescriptor,The following statement contains a magic number: if (baseName.EndsWith (".vshost"))  	baseName = baseName.Substring (0' baseName.Length - 7);  
Magic Number,winsw,ServiceDescriptor,C:\repos\Funkest_CS\ToService\ToService\ServiceDescriptor.cs,ServiceDescriptor,The following statement contains a magic number: baseName = baseName.Substring (0' baseName.Length - 7);  
