Implementation smell,Namespace,Class,File,Method,Description
Long Method,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,InternalUpdate,The method has 164 lines of code.
Long Method,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,InternalUpdate,The method has 163 lines of code.
Long Method,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The method has 122 lines of code.
Long Method,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,NextToken,The method has 200 lines of code.
Long Method,EntityFramework.Reflection,DelegateFactory,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\DelegateFactory.cs,CreateMethod,The method has 105 lines of code.
Complex Method,EntityFramework.Audit,AuditLogger,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Audit\AuditLogger.cs,UpdateLog,Cyclomatic complexity of the method is 8
Complex Method,EntityFramework.Audit,AuditLogger,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Audit\AuditLogger.cs,WriteRelationships,Cyclomatic complexity of the method is 13
Complex Method,EntityFramework.Audit,AuditLogger,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Audit\AuditLogger.cs,GetDisplayValue,Cyclomatic complexity of the method is 9
Complex Method,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,InternalUpdate,Cyclomatic complexity of the method is 15
Complex Method,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,InternalUpdate,Cyclomatic complexity of the method is 15
Complex Method,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseIdentifier,Cyclomatic complexity of the method is 9
Complex Method,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,CompareConversions,Cyclomatic complexity of the method is 8
Complex Method,EntityFramework.Extensions,BatchExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Extensions\BatchExtensions.cs,Update,Cyclomatic complexity of the method is 8
Complex Method,EntityFramework.Mapping,MappingResolver,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Mapping\MappingResolver.cs,CreateEntitySetMappings,Cyclomatic complexity of the method is 9
Complex Method,EntityFramework.Reflection,DelegateFactory,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\DelegateFactory.cs,CreateMethod,Cyclomatic complexity of the method is 14
Complex Method,EntityFramework.Reflection,ReflectionHelper,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ReflectionHelper.cs,CoerceValue,Cyclomatic complexity of the method is 12
Complex Method,EntityFramework.Reflection,TypeAccessor,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\TypeAccessor.cs,FindMethod,Cyclomatic complexity of the method is 10
Long Parameter List,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,InternalUpdate,The method has 5 parameters. Parameters: objectContext' entityMap' query' updateExpression' async
Long Parameter List,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,InternalUpdate,The method has 5 parameters. Parameters: objectContext' entityMap' query' updateExpression' async
Long Parameter List,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,CheckAndPromoteOperands,The method has 5 parameters. Parameters: signatures' opName' left' right' errorPos
Long Parameter List,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,FindMethod,The method has 5 parameters. Parameters: type' methodName' staticAccess' args' method
Long Identifier,System.Linq.Dynamic,Res,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,,The length of the parameter AmbiguousConstructorInvocation is 30.
Long Statement,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,InternalUpdate,The length of the statement  "                        throw new ArgumentException("The update expression MemberBinding must only by type MemberAssignment."' "updateExpression"); " is 123.
Long Statement,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,InternalUpdate,The length of the statement  "                        string regex = @"SELECT\s*\r\n(?<ColumnValue>.+)?\s*AS\s*(?<ColumnAlias>\w+)\r\nFROM\s*(?<TableName>\w+\.\w+|\w+)\s*AS\s*(?<TableAlias>\w+)"; " is 141.
Long Statement,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,InternalUpdate,The length of the statement  "                        throw new ArgumentException("The update expression MemberBinding must only by type MemberAssignment."' "updateExpression"); " is 123.
Long Statement,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,InternalUpdate,The length of the statement  "                        string regex = @"SELECT\s*\r\n\s*(?<ColumnValue>.+)?\s*AS\s*(?<ColumnAlias>\[\w+\])\r\n\s*FROM\s*(?<TableName>\[\w+\]\.\[\w+\]|\[\w+\])\s*AS\s*(?<TableAlias>\[\w+\])"; " is 167.
Long Statement,EntityFramework.Caching,CacheManager,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Caching\CacheManager.cs,ResolveProvider,The length of the statement  "                throw new InvalidOperationException("Could not resolve the ICacheProvider. Make sure ICacheProvider is registered in the Locator.Current container."); " is 150.
Long Statement,EntityFramework.Future,FutureQueryBase<T>,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Future\FutureQueryBase.cs,SetResult,The length of the statement  "                dynamic shaper = shaperFactory.Create(reader' dataContext' dataContext.MetadataWorkspace' MergeOption.AppendOnly' false' true' false); " is 134.
Long Statement,EntityFramework.Future,FutureRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Future\FutureRunner.cs,ExecuteFutureQueries,The length of the statement  "                using (var reader = DbInterception.Dispatch.Command.Reader(command' new DbCommandInterceptionContext(interceptionContext))) " is 123.
Long Statement,EntityFramework.Future,FutureContext,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Future\FutureContext.cs,ExecuteFutureQueries,The length of the statement  "                throw new InvalidOperationException("Could not resolve the IFutureRunner. Make sure IFutureRunner is registered in the Locator.Current container."); " is 148.
Long Statement,EntityFramework.Extensions,BatchExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Extensions\BatchExtensions.cs,ResolveRunner,The length of the statement  "                throw new InvalidOperationException("Could not resolve the IBatchRunner. Make sure IBatchRunner is registered in the Locator.Current container."); " is 146.
Long Statement,EntityFramework.Extensions,FutureExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Extensions\FutureExtensions.cs,FutureValue,The length of the statement  "                throw new ArgumentException("The body of lambda expression must be a Count' Min' Max' Sum or Average method call"' "selector"); " is 127.
Long Statement,EntityFramework.Mapping,MetadataMappingProvider,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Mapping\MetadataMappingProvider.cs,GetEntityMap,The length of the statement  "            var entityType = metadata.GetItems<EntityType>(DataSpace.OSpace).Single(e => objectItemCollection.GetClrType(e) == type); " is 121.
Long Statement,EntityFramework.Mapping,MetadataMappingProvider,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Mapping\MetadataMappingProvider.cs,GetEntityMap,The length of the statement  "            var entitySetMappings = metadata.GetItems<EntityContainerMapping>(DataSpace.CSSpace).Single().EntitySetMappings.ToList(); " is 121.
Long Statement,EntityFramework.Mapping,MetadataMappingProvider,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Mapping\MetadataMappingProvider.cs,GetMapping,The length of the statement  "            return entitySetMappings.Single(x => x.EntityTypeMappings.Any(y => y.IsOfEntityTypes.Any(z => z.Name == entitySet.Name))); " is 122.
Long Statement,EntityFramework.Mapping,MetadataMappingProvider,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Mapping\MetadataMappingProvider.cs,SetTableName,The length of the statement  "                storeSet.MetadataProperties.TryGetValue("http://schemas.microsoft.com/ado/2007/12/edm/EntityStoreSchemaGenerator:Table"' " is 120.
Long Statement,EntityFramework.Mapping,MetadataMappingProvider,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Mapping\MetadataMappingProvider.cs,SetTableName,The length of the statement  "                storeSet.MetadataProperties.TryGetValue("http://schemas.microsoft.com/ado/2007/12/edm/EntityStoreSchemaGenerator:Schema"' " is 121.
Long Statement,EntityFramework.Reflection,DelegateFactory,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\DelegateFactory.cs,CreateConstructor,The length of the statement  "      var constructorInfo = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 141.
Long Statement,EntityFramework.Reflection,DelegateFactory,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\DelegateFactory.cs,CreateConstructor,The length of the statement  "        ConstructorInfo constructorInfo = type.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 153.
Complex Conditional,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseComparison,The conditional expression  "token.id == TokenId.Equal || token.id == TokenId.DoubleEqual ||                  token.id == TokenId.ExclamationEqual || token.id == TokenId.LessGreater ||                  token.id == TokenId.GreaterThan || token.id == TokenId.GreaterThanEqual ||                  token.id == TokenId.LessThan || token.id == TokenId.LessThanEqual"  is complex.
Complex Conditional,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseMultiplicative,The conditional expression  "token.id == TokenId.Asterisk || token.id == TokenId.Slash ||                  token.id == TokenId.Percent || TokenIdentifierIs("mod")"  is complex.
Complex Conditional,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,GenerateConversion,The conditional expression  "(IsNumericType(exprType) || IsEnumType(exprType)) &&                      (IsNumericType(type)) || IsEnumType(type)"  is complex.
Complex Conditional,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,GenerateConversion,The conditional expression  "exprType.IsAssignableFrom(type) || type.IsAssignableFrom(exprType) ||                  exprType.IsInterface || type.IsInterface"  is complex.
Complex Conditional,EntityFramework.Reflection,ReflectionHelper,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ReflectionHelper.cs,CoerceValue,The conditional expression  "(desiredType.IsPrimitive || desiredType.Equals(typeof(decimal)))            && valueType.Equals(_stringType)            && String.IsNullOrEmpty((string)value)"  is complex.
Magic Number,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,InternalDelete,The following statement contains a magic number: try              {                  // get store connection and transaction                  var store = GetStore(objectContext);                  deleteConnection = store.Item1;                  deleteTransaction = store.Item2;                    if (deleteConnection.State != ConnectionState.Open)                  {                      deleteConnection.Open();                      ownConnection = true;                  }                    if (deleteTransaction == null)                  {                      deleteTransaction = deleteConnection.BeginTransaction();                      ownTransaction = true;                  }                      deleteCommand = deleteConnection.CreateCommand();                  deleteCommand.Transaction = deleteTransaction;                  if (objectContext.CommandTimeout.HasValue)                      deleteCommand.CommandTimeout = objectContext.CommandTimeout.Value;                    var innerSelect = GetSelectSql(query' entityMap' deleteCommand);                    var sqlBuilder = new StringBuilder(innerSelect.Length * 2);                    sqlBuilder.Append("DELETE j0");                  sqlBuilder.AppendLine();                    sqlBuilder.AppendFormat("FROM {0} AS j0 INNER JOIN ("' entityMap.TableName);                  sqlBuilder.AppendLine();                  sqlBuilder.AppendLine(innerSelect);                  sqlBuilder.Append(") AS j1 ON (");                    bool wroteKey = false;                  foreach (var keyMap in entityMap.KeyMaps)                  {                      if (wroteKey)                          sqlBuilder.Append(" AND ");                        sqlBuilder.AppendFormat("j0.{0} = j1.{0}"' keyMap.ColumnName);                      wroteKey = true;                  }                  sqlBuilder.Append(")");                    deleteCommand.CommandText = sqlBuilder.ToString().Replace("["' "").Replace("]"' "");    #if NET45                  int result = async                      ? await deleteCommand.ExecuteNonQueryAsync().ConfigureAwait(false)                      : deleteCommand.ExecuteNonQuery();  #else                  int result = deleteCommand.ExecuteNonQuery();  #endif                    // only commit if created transaction                  if (ownTransaction)                      deleteTransaction.Commit();                    return result;              }              finally              {                  if (deleteCommand != null)                      deleteCommand.Dispose();                    if (deleteTransaction != null && ownTransaction)                      deleteTransaction.Dispose();                    if (deleteConnection != null && ownConnection)                      deleteConnection.Close();              }
Magic Number,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,InternalUpdate,The following statement contains a magic number: try              {                  // get store connection and transaction                  var store = GetStore(objectContext);                  updateConnection = store.Item1;                  updateTransaction = store.Item2;                    if (updateConnection.State != ConnectionState.Open)                  {                      updateConnection.Open();                      ownConnection = true;                  }                    // use existing transaction or create new                  if (updateTransaction == null)                  {                      updateTransaction = updateConnection.BeginTransaction();                      ownTransaction = true;                  }                    updateCommand = updateConnection.CreateCommand();                  updateCommand.Transaction = updateTransaction;                  if (objectContext.CommandTimeout.HasValue)                      updateCommand.CommandTimeout = objectContext.CommandTimeout.Value;                    var innerSelect = GetSelectSql(query' entityMap' updateCommand);                  var sqlBuilder = new StringBuilder(innerSelect.Length * 2);                    sqlBuilder.Append("UPDATE ");                  sqlBuilder.Append(entityMap.TableName);                  sqlBuilder.AppendFormat(" AS j0 INNER JOIN ("' entityMap.TableName);                  sqlBuilder.AppendLine();                  sqlBuilder.AppendLine(innerSelect);                  sqlBuilder.Append(") AS j1 ON (");                    bool wroteKey = false;                  foreach (var keyMap in entityMap.KeyMaps)                  {                      if (wroteKey)                          sqlBuilder.Append(" AND ");                        sqlBuilder.AppendFormat("j0.{0} = j1.{0}"' keyMap.ColumnName);                      wroteKey = true;                  }                  sqlBuilder.Append(")");                  sqlBuilder.AppendLine(" ");                    sqlBuilder.AppendLine(" SET ");                    var memberInitExpression = updateExpression.Body as MemberInitExpression;                  if (memberInitExpression == null)                      throw new ArgumentException("The update expression must be of type MemberInitExpression."' "updateExpression");                    int nameCount = 0;                  bool wroteSet = false;                  foreach (MemberBinding binding in memberInitExpression.Bindings)                  {                      if (wroteSet)                          sqlBuilder.AppendLine("' ");                        string propertyName = binding.Member.Name;                      string columnName = entityMap.PropertyMaps                          .Where(p => p.PropertyName == propertyName)                          .Select(p => p.ColumnName)                          .FirstOrDefault();                          var memberAssignment = binding as MemberAssignment;                      if (memberAssignment == null)                          throw new ArgumentException("The update expression MemberBinding must only by type MemberAssignment."' "updateExpression");                        Expression memberExpression = memberAssignment.Expression;                        ParameterExpression parameterExpression = null;                      memberExpression.Visit((ParameterExpression p) =>                      {                          if (p.Type == entityMap.EntityType)                              parameterExpression = p;                            return p;                      });                          if (parameterExpression == null)                      {                          object value;                            if (memberExpression.NodeType == ExpressionType.Constant)                          {                              var constantExpression = memberExpression as ConstantExpression;                              if (constantExpression == null)                                  throw new ArgumentException(                                      "The MemberAssignment expression is not a ConstantExpression."' "updateExpression");                                value = constantExpression.Value;                          }                          else                          {                              LambdaExpression lambda = Expression.Lambda(memberExpression' null);                              value = lambda.Compile().DynamicInvoke();                          }                            if (value != null)                          {                              string parameterName = "p__update__" + nameCount++;                              var parameter = updateCommand.CreateParameter();                              parameter.ParameterName = parameterName;                              parameter.Value = value;                              updateCommand.Parameters.Add(parameter);                                sqlBuilder.AppendFormat("{0} = @{1}"' columnName' parameterName);                          }                          else                          {                              sqlBuilder.AppendFormat("{0} = NULL"' columnName);                          }                      }                      else                      {                          // create clean objectset to build query from                          var objectSet = objectContext.CreateObjectSet<TEntity>();                            Type[] typeArguments = new[] { entityMap.EntityType' memberExpression.Type };                            ConstantExpression constantExpression = Expression.Constant(objectSet);                          LambdaExpression lambdaExpression = Expression.Lambda(memberExpression' parameterExpression);                            MethodCallExpression selectExpression = Expression.Call(                              typeof(Queryable)'                              "Select"'                              typeArguments'                              constantExpression'                              lambdaExpression);                            // create query from expression                          var selectQuery = objectSet.CreateQuery(selectExpression' entityMap.EntityType);                          string sql = selectQuery.ToTraceString();                            // parse select part of sql to use as update                          string regex = @"SELECT\s*\r\n(?<ColumnValue>.+)?\s*AS\s*(?<ColumnAlias>\w+)\r\nFROM\s*(?<TableName>\w+\.\w+|\w+)\s*AS\s*(?<TableAlias>\w+)";                          Match match = Regex.Match(sql' regex);                          if (!match.Success)                              throw new ArgumentException("The MemberAssignment expression could not be processed."' "updateExpression");                            string value = match.Groups["ColumnValue"].Value;                          string alias = match.Groups["TableAlias"].Value;                            value = value.Replace(alias + "."' "");                            foreach (ObjectParameter objectParameter in selectQuery.Parameters)                          {                              string parameterName = "p__update__" + nameCount++;                                var parameter = updateCommand.CreateParameter();                              parameter.ParameterName = parameterName;                              parameter.Value = objectParameter.Value;                              updateCommand.Parameters.Add(parameter);                                value = value.Replace(objectParameter.Name' parameterName);                          }                          sqlBuilder.AppendFormat("{0} = {1}"' columnName' value);                      }                      wroteSet = true;                  }                      updateCommand.CommandText = sqlBuilder.ToString().Replace("["' "").Replace("]"' "");    #if NET45                  int result = async                      ? await updateCommand.ExecuteNonQueryAsync().ConfigureAwait(false)                      : updateCommand.ExecuteNonQuery();  #else                  int result = updateCommand.ExecuteNonQuery();  #endif                    // only commit if created transaction                  if (ownTransaction)                      updateTransaction.Commit();                    return result;              }              finally              {                  if (updateCommand != null)                      updateCommand.Dispose();                  if (updateTransaction != null && ownTransaction)                      updateTransaction.Dispose();                  if (updateConnection != null && ownConnection)                      updateConnection.Close();              }
Magic Number,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,GetSelectSql,The following statement contains a magic number: var selector = new StringBuilder(50);
Magic Number,EntityFramework.Batch,MySqlBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\MySqlBatchRunner.cs,GetSelectSql,The following statement contains a magic number: foreach (var propertyMap in entityMap.KeyMaps)              {                  if (selector.Length > 4)                      selector.Append(("' "));                    selector.Append(propertyMap.PropertyName);              }
Magic Number,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,InternalDelete,The following statement contains a magic number: try              {                  // get store connection and transaction                  var store = GetStore(objectContext);                  deleteConnection = store.Item1;                  deleteTransaction = store.Item2;                    if (deleteConnection.State != ConnectionState.Open)                  {                      deleteConnection.Open();                      ownConnection = true;                  }                    if (deleteTransaction == null)                  {                      deleteTransaction = deleteConnection.BeginTransaction();                      ownTransaction = true;                  }                      deleteCommand = deleteConnection.CreateCommand();                  deleteCommand.Transaction = deleteTransaction;                  if (objectContext.CommandTimeout.HasValue)                      deleteCommand.CommandTimeout = objectContext.CommandTimeout.Value;                    var innerSelect = GetSelectSql(query' entityMap' deleteCommand);                    var sqlBuilder = new StringBuilder(innerSelect.Length * 2);                    sqlBuilder.Append("DELETE ");                  sqlBuilder.Append(entityMap.TableName);                  sqlBuilder.AppendLine();                    sqlBuilder.AppendFormat("FROM {0} AS j0 INNER JOIN ("' entityMap.TableName);                  sqlBuilder.AppendLine();                  sqlBuilder.AppendLine(innerSelect);                  sqlBuilder.Append(") AS j1 ON (");                    bool wroteKey = false;                  foreach (var keyMap in entityMap.KeyMaps)                  {                      if (wroteKey)                          sqlBuilder.Append(" AND ");                        sqlBuilder.AppendFormat("j0.[{0}] = j1.[{0}]"' keyMap.ColumnName);                      wroteKey = true;                  }                  sqlBuilder.Append(")");                    deleteCommand.CommandText = sqlBuilder.ToString();    #if NET45                  int result = async                      ? await deleteCommand.ExecuteNonQueryAsync().ConfigureAwait(false)                      : deleteCommand.ExecuteNonQuery();  #else                  int result = deleteCommand.ExecuteNonQuery();  #endif                  // only commit if created transaction                  if (ownTransaction)                      deleteTransaction.Commit();                    return result;              }              finally              {                  if (deleteCommand != null)                      deleteCommand.Dispose();                    if (deleteTransaction != null && ownTransaction)                      deleteTransaction.Dispose();                    if (deleteConnection != null && ownConnection)                      deleteConnection.Close();              }
Magic Number,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,InternalUpdate,The following statement contains a magic number: try              {                  // get store connection and transaction                  var store = GetStore(objectContext);                  updateConnection = store.Item1;                  updateTransaction = store.Item2;                    if (updateConnection.State != ConnectionState.Open)                  {                      updateConnection.Open();                      ownConnection = true;                  }                    // use existing transaction or create new                  if (updateTransaction == null)                  {                      updateTransaction = updateConnection.BeginTransaction();                      ownTransaction = true;                  }                    updateCommand = updateConnection.CreateCommand();                  updateCommand.Transaction = updateTransaction;                  if (objectContext.CommandTimeout.HasValue)                      updateCommand.CommandTimeout = objectContext.CommandTimeout.Value;                    var innerSelect = GetSelectSql(query' entityMap' updateCommand);                  var sqlBuilder = new StringBuilder(innerSelect.Length * 2);                    sqlBuilder.Append("UPDATE ");                  sqlBuilder.Append(entityMap.TableName);                  sqlBuilder.AppendLine(" SET ");                    var memberInitExpression = updateExpression.Body as MemberInitExpression;                  if (memberInitExpression == null)                      throw new ArgumentException("The update expression must be of type MemberInitExpression."' "updateExpression");                    int nameCount = 0;                  bool wroteSet = false;                  foreach (MemberBinding binding in memberInitExpression.Bindings)                  {                      if (wroteSet)                          sqlBuilder.AppendLine("' ");                        string propertyName = binding.Member.Name;                      string columnName = entityMap.PropertyMaps                          .Where(p => p.PropertyName == propertyName)                          .Select(p => p.ColumnName)                          .FirstOrDefault();                          var memberAssignment = binding as MemberAssignment;                      if (memberAssignment == null)                          throw new ArgumentException("The update expression MemberBinding must only by type MemberAssignment."' "updateExpression");                        Expression memberExpression = memberAssignment.Expression;                        ParameterExpression parameterExpression = null;                      memberExpression.Visit((ParameterExpression p) =>                      {                          if (p.Type == entityMap.EntityType)                              parameterExpression = p;                            return p;                      });                          if (parameterExpression == null)                      {                          object value;                            if (memberExpression.NodeType == ExpressionType.Constant)                          {                              var constantExpression = memberExpression as ConstantExpression;                              if (constantExpression == null)                                  throw new ArgumentException(                                      "The MemberAssignment expression is not a ConstantExpression."' "updateExpression");                                value = constantExpression.Value;                          }                          else                          {                              LambdaExpression lambda = Expression.Lambda(memberExpression' null);                              value = lambda.Compile().DynamicInvoke();                          }                            if (value != null)                          {                              string parameterName = "p__update__" + nameCount++;                              var parameter = updateCommand.CreateParameter();                              parameter.ParameterName = parameterName;                              parameter.Value = value;                              updateCommand.Parameters.Add(parameter);                                sqlBuilder.AppendFormat("[{0}] = @{1}"' columnName' parameterName);                          }                          else                          {                              sqlBuilder.AppendFormat("[{0}] = NULL"' columnName);                          }                      }                      else                      {                          // create clean objectset to build query from                          var objectSet = objectContext.CreateObjectSet<TEntity>();                            Type[] typeArguments = new[] { entityMap.EntityType' memberExpression.Type };                            ConstantExpression constantExpression = Expression.Constant(objectSet);                          LambdaExpression lambdaExpression = Expression.Lambda(memberExpression' parameterExpression);                            MethodCallExpression selectExpression = Expression.Call(                              typeof(Queryable)'                              "Select"'                              typeArguments'                              constantExpression'                              lambdaExpression);                            // create query from expression                          var selectQuery = objectSet.CreateQuery(selectExpression' entityMap.EntityType);                          string sql = selectQuery.ToTraceString();                            // parse select part of sql to use as update                          string regex = @"SELECT\s*\r\n\s*(?<ColumnValue>.+)?\s*AS\s*(?<ColumnAlias>\[\w+\])\r\n\s*FROM\s*(?<TableName>\[\w+\]\.\[\w+\]|\[\w+\])\s*AS\s*(?<TableAlias>\[\w+\])";                          Match match = Regex.Match(sql' regex);                          if (!match.Success)                              throw new ArgumentException("The MemberAssignment expression could not be processed."' "updateExpression");                            string value = match.Groups["ColumnValue"].Value;                          string alias = match.Groups["TableAlias"].Value;                            value = value.Replace(alias + "."' "");                            foreach (ObjectParameter objectParameter in selectQuery.Parameters)                          {                              string parameterName = "p__update__" + nameCount++;                                var parameter = updateCommand.CreateParameter();                              parameter.ParameterName = parameterName;                              parameter.Value = objectParameter.Value ?? DBNull.Value;                              updateCommand.Parameters.Add(parameter);                                value = value.Replace(objectParameter.Name' parameterName);                          }                          sqlBuilder.AppendFormat("[{0}] = {1}"' columnName' value);                      }                      wroteSet = true;                  }                    sqlBuilder.AppendLine(" ");                  sqlBuilder.AppendFormat("FROM {0} AS j0 INNER JOIN ("' entityMap.TableName);                  sqlBuilder.AppendLine();                  sqlBuilder.AppendLine(innerSelect);                  sqlBuilder.Append(") AS j1 ON (");                    bool wroteKey = false;                  foreach (var keyMap in entityMap.KeyMaps)                  {                      if (wroteKey)                          sqlBuilder.Append(" AND ");                        sqlBuilder.AppendFormat("j0.[{0}] = j1.[{0}]"' keyMap.ColumnName);                      wroteKey = true;                  }                  sqlBuilder.Append(")");                    updateCommand.CommandText = sqlBuilder.ToString();    #if NET45                  int result = async                      ? await updateCommand.ExecuteNonQueryAsync().ConfigureAwait(false)                      : updateCommand.ExecuteNonQuery();  #else                  int result = updateCommand.ExecuteNonQuery();  #endif                  // only commit if created transaction                  if (ownTransaction)                      updateTransaction.Commit();                    return result;              }              finally              {                  if (updateCommand != null)                      updateCommand.Dispose();                  if (updateTransaction != null && ownTransaction)                      updateTransaction.Dispose();                  if (updateConnection != null && ownConnection)                      updateConnection.Close();              }
Magic Number,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,GetSelectSql,The following statement contains a magic number: var selector = new StringBuilder(50);
Magic Number,EntityFramework.Batch,SqlServerBatchRunner,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Batch\SqlServerBatchRunner.cs,GetSelectSql,The following statement contains a magic number: foreach (var propertyMap in entityMap.KeyMaps)              {                  if (selector.Length > 4)                      selector.Append(("' "));                    selector.Append(propertyMap.PropertyName);              }
Magic Number,EntityFramework.Caching,MemoryCacheProvider,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Caching\MemoryCacheProvider.cs,ClearCache,The following statement contains a magic number: return MemoryCache.Default.Trim(100);
Magic Number,EntityFramework.Caching,Utility,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Caching\Query\Utility.cs,ToMd5Fingerprint,The following statement contains a magic number: return hash.Aggregate(new StringBuilder(32)'                  (sb' b) => sb.Append(b.ToString("X2")))                  .ToString();
Magic Number,EntityFramework.Future,FutureStore,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Future\FutureStore.cs,FutureStore,The following statement contains a magic number: Threshold = 70;
Magic Number,EntityFramework.Future,FutureStore,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Future\FutureStore.cs,ShouldCleanup,The following statement contains a magic number: int percent = (int)(100 * diff);
Magic Number,EntityFramework.Future,FutureStore,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Future\FutureStore.cs,ShouldCleanup,The following statement contains a magic number: return percent >= MakeFit(Threshold' 0' 100);
Magic Number,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseStringLiteral,The following statement contains a magic number: string s = token.text.Substring(1' token.text.Length - 2);
Magic Number,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseIif,The following statement contains a magic number: if (args.Length != 3)                  throw ParseError(errorPos' Res.IifRequiresThreeArgs);
Magic Number,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseIif,The following statement contains a magic number: return GenerateConditional(args[0]' args[1]' args[2]' errorPos);
Magic Number,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsSignedIntegralType,The following statement contains a magic number: return GetNumericTypeKind(type) == 2;
Magic Number,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsUnsignedIntegralType,The following statement contains a magic number: return GetNumericTypeKind(type) == 3;
Magic Number,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,GetNumericTypeKind,The following statement contains a magic number: switch (Type.GetTypeCode(type))              {                  case TypeCode.Char:                  case TypeCode.Single:                  case TypeCode.Double:                  case TypeCode.Decimal:                      return 1;                  case TypeCode.SByte:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                      return 2;                  case TypeCode.Byte:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                      return 3;                  default:                      return 0;              }
Magic Number,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,GetNumericTypeKind,The following statement contains a magic number: switch (Type.GetTypeCode(type))              {                  case TypeCode.Char:                  case TypeCode.Single:                  case TypeCode.Double:                  case TypeCode.Decimal:                      return 1;                  case TypeCode.SByte:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                      return 2;                  case TypeCode.Byte:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                      return 3;                  default:                      return 0;              }
Magic Number,EntityFramework.Mapping,MetadataMappingProvider,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Mapping\MetadataMappingProvider.cs,SetTableName,The following statement contains a magic number: var builder = new StringBuilder(50);
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: switch (value)            {              case -1:                il.Emit(OpCodes.Ldc_I4_M1);                return;              case 0:                il.Emit(OpCodes.Ldc_I4_0);                return;              case 1:                il.Emit(OpCodes.Ldc_I4_1);                return;              case 2:                il.Emit(OpCodes.Ldc_I4_2);                return;              case 3:                il.Emit(OpCodes.Ldc_I4_3);                return;              case 4:                il.Emit(OpCodes.Ldc_I4_4);                return;              case 5:                il.Emit(OpCodes.Ldc_I4_5);                return;              case 6:                il.Emit(OpCodes.Ldc_I4_6);                return;              case 7:                il.Emit(OpCodes.Ldc_I4_7);                return;              case 8:                il.Emit(OpCodes.Ldc_I4_8);                return;            }
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: switch (value)            {              case -1:                il.Emit(OpCodes.Ldc_I4_M1);                return;              case 0:                il.Emit(OpCodes.Ldc_I4_0);                return;              case 1:                il.Emit(OpCodes.Ldc_I4_1);                return;              case 2:                il.Emit(OpCodes.Ldc_I4_2);                return;              case 3:                il.Emit(OpCodes.Ldc_I4_3);                return;              case 4:                il.Emit(OpCodes.Ldc_I4_4);                return;              case 5:                il.Emit(OpCodes.Ldc_I4_5);                return;              case 6:                il.Emit(OpCodes.Ldc_I4_6);                return;              case 7:                il.Emit(OpCodes.Ldc_I4_7);                return;              case 8:                il.Emit(OpCodes.Ldc_I4_8);                return;            }
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: switch (value)            {              case -1:                il.Emit(OpCodes.Ldc_I4_M1);                return;              case 0:                il.Emit(OpCodes.Ldc_I4_0);                return;              case 1:                il.Emit(OpCodes.Ldc_I4_1);                return;              case 2:                il.Emit(OpCodes.Ldc_I4_2);                return;              case 3:                il.Emit(OpCodes.Ldc_I4_3);                return;              case 4:                il.Emit(OpCodes.Ldc_I4_4);                return;              case 5:                il.Emit(OpCodes.Ldc_I4_5);                return;              case 6:                il.Emit(OpCodes.Ldc_I4_6);                return;              case 7:                il.Emit(OpCodes.Ldc_I4_7);                return;              case 8:                il.Emit(OpCodes.Ldc_I4_8);                return;            }
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: switch (value)            {              case -1:                il.Emit(OpCodes.Ldc_I4_M1);                return;              case 0:                il.Emit(OpCodes.Ldc_I4_0);                return;              case 1:                il.Emit(OpCodes.Ldc_I4_1);                return;              case 2:                il.Emit(OpCodes.Ldc_I4_2);                return;              case 3:                il.Emit(OpCodes.Ldc_I4_3);                return;              case 4:                il.Emit(OpCodes.Ldc_I4_4);                return;              case 5:                il.Emit(OpCodes.Ldc_I4_5);                return;              case 6:                il.Emit(OpCodes.Ldc_I4_6);                return;              case 7:                il.Emit(OpCodes.Ldc_I4_7);                return;              case 8:                il.Emit(OpCodes.Ldc_I4_8);                return;            }
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: switch (value)            {              case -1:                il.Emit(OpCodes.Ldc_I4_M1);                return;              case 0:                il.Emit(OpCodes.Ldc_I4_0);                return;              case 1:                il.Emit(OpCodes.Ldc_I4_1);                return;              case 2:                il.Emit(OpCodes.Ldc_I4_2);                return;              case 3:                il.Emit(OpCodes.Ldc_I4_3);                return;              case 4:                il.Emit(OpCodes.Ldc_I4_4);                return;              case 5:                il.Emit(OpCodes.Ldc_I4_5);                return;              case 6:                il.Emit(OpCodes.Ldc_I4_6);                return;              case 7:                il.Emit(OpCodes.Ldc_I4_7);                return;              case 8:                il.Emit(OpCodes.Ldc_I4_8);                return;            }
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: switch (value)            {              case -1:                il.Emit(OpCodes.Ldc_I4_M1);                return;              case 0:                il.Emit(OpCodes.Ldc_I4_0);                return;              case 1:                il.Emit(OpCodes.Ldc_I4_1);                return;              case 2:                il.Emit(OpCodes.Ldc_I4_2);                return;              case 3:                il.Emit(OpCodes.Ldc_I4_3);                return;              case 4:                il.Emit(OpCodes.Ldc_I4_4);                return;              case 5:                il.Emit(OpCodes.Ldc_I4_5);                return;              case 6:                il.Emit(OpCodes.Ldc_I4_6);                return;              case 7:                il.Emit(OpCodes.Ldc_I4_7);                return;              case 8:                il.Emit(OpCodes.Ldc_I4_8);                return;            }
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: switch (value)            {              case -1:                il.Emit(OpCodes.Ldc_I4_M1);                return;              case 0:                il.Emit(OpCodes.Ldc_I4_0);                return;              case 1:                il.Emit(OpCodes.Ldc_I4_1);                return;              case 2:                il.Emit(OpCodes.Ldc_I4_2);                return;              case 3:                il.Emit(OpCodes.Ldc_I4_3);                return;              case 4:                il.Emit(OpCodes.Ldc_I4_4);                return;              case 5:                il.Emit(OpCodes.Ldc_I4_5);                return;              case 6:                il.Emit(OpCodes.Ldc_I4_6);                return;              case 7:                il.Emit(OpCodes.Ldc_I4_7);                return;              case 8:                il.Emit(OpCodes.Ldc_I4_8);                return;            }
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: if (value > -129 && value < 128)            {              il.Emit(OpCodes.Ldc_I4_S' (SByte)value);            }            else            {              il.Emit(OpCodes.Ldc_I4' value);            }
Magic Number,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following statement contains a magic number: if (value > -129 && value < 128)            {              il.Emit(OpCodes.Ldc_I4_S' (SByte)value);            }            else            {              il.Emit(OpCodes.Ldc_I4' value);            }
Magic Number,EntityFramework.Reflection,MethodAccessor,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\MethodAccessor.cs,GetKey,The following statement contains a magic number: unchecked        {          int result = (name != null ? name.GetHashCode() : 0);          result = parameterTypes.Aggregate(result'            (r' p) => (r * 397) ^ (p != null ? p.GetHashCode() : 0));            return result;        }
Missing Default,EntityFramework.Audit,AuditLogger,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Audit\AuditLogger.cs,WriteProperties,The following switch statement is missing a default case: switch (state.AuditEntity.Action)                      {                          case AuditAction.Added:                              auditProperty.Current = currentValue;                              break;                          case AuditAction.Modified:                              auditProperty.Current = currentValue;                                if (originalValues != null)                              {                                  object originalValue = originalValues.GetValue(edmProperty.Name);                                  originalValue = FormatValue(state' name' originalValue);                                    auditProperty.Original = originalValue;                              }                              break;                          case AuditAction.Deleted:                              auditProperty.Original = currentValue;                              break;                      }
Missing Default,EntityFramework.Audit,AuditLogger,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Audit\AuditLogger.cs,WriteRelationships,The following switch statement is missing a default case: switch (state.AuditEntity.Action)                      {                          case AuditAction.Added:                              auditProperty.Current = currentValue;                              break;                          case AuditAction.Modified:                              auditProperty.Current = currentValue ?? _nullText;                                if (Configuration.LoadRelationships)                              {                                  object originalValue = GetDisplayValue(state' navigationProperty' displayMember' originalValues);                                  originalValue = FormatValue(state' name' originalValue);                                    auditProperty.Original = originalValue;                              }                                break;                          case AuditAction.Deleted:                              auditProperty.Original = currentValue;                              break;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseComparison,The following switch statement is missing a default case: switch (op.id)                  {                      case TokenId.Equal:                      case TokenId.DoubleEqual:                          left = GenerateEqual(left' right);                          break;                      case TokenId.ExclamationEqual:                      case TokenId.LessGreater:                          left = GenerateNotEqual(left' right);                          break;                      case TokenId.GreaterThan:                          left = GenerateGreaterThan(left' right);                          break;                      case TokenId.GreaterThanEqual:                          left = GenerateGreaterThanEqual(left' right);                          break;                      case TokenId.LessThan:                          left = GenerateLessThan(left' right);                          break;                      case TokenId.LessThanEqual:                          left = GenerateLessThanEqual(left' right);                          break;                  }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseAdditive,The following switch statement is missing a default case: switch (op.id)                  {                      case TokenId.Plus:                          if (left.Type == typeof(string) || right.Type == typeof(string))                              goto case TokenId.Amphersand;                          CheckAndPromoteOperands(typeof(IAddSignatures)' op.text' ref left' ref right' op.pos);                          left = GenerateAdd(left' right);                          break;                      case TokenId.Minus:                          CheckAndPromoteOperands(typeof(ISubtractSignatures)' op.text' ref left' ref right' op.pos);                          left = GenerateSubtract(left' right);                          break;                      case TokenId.Amphersand:                          left = GenerateStringConcat(left' right);                          break;                  }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseMultiplicative,The following switch statement is missing a default case: switch (op.id)                  {                      case TokenId.Asterisk:                          left = Expression.Multiply(left' right);                          break;                      case TokenId.Slash:                          left = Expression.Divide(left' right);                          break;                      case TokenId.Percent:                      case TokenId.Identifier:                          left = Expression.Modulo(left' right);                          break;                  }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,PromoteExpression,The following switch statement is missing a default case: switch (Type.GetTypeCode(ce.Type))                          {                              case TypeCode.Int32:                              case TypeCode.UInt32:                              case TypeCode.Int64:                              case TypeCode.UInt64:                                  value = ParseNumber(text' target);                                  break;                              case TypeCode.Double:                                  if (target == typeof(decimal)) value = ParseNumber(text' target);                                  break;                              case TypeCode.String:                                  value = ParseEnum(text' target);                                  break;                          }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,ParseNumber,The following switch statement is missing a default case: switch (Type.GetTypeCode(GetNonNullableType(type)))              {                  case TypeCode.SByte:                      sbyte sb;                      if (sbyte.TryParse(text' out sb)) return sb;                      break;                  case TypeCode.Byte:                      byte b;                      if (byte.TryParse(text' out b)) return b;                      break;                  case TypeCode.Int16:                      short s;                      if (short.TryParse(text' out s)) return s;                      break;                  case TypeCode.UInt16:                      ushort us;                      if (ushort.TryParse(text' out us)) return us;                      break;                  case TypeCode.Int32:                      int i;                      if (int.TryParse(text' out i)) return i;                      break;                  case TypeCode.UInt32:                      uint ui;                      if (uint.TryParse(text' out ui)) return ui;                      break;                  case TypeCode.Int64:                      long l;                      if (long.TryParse(text' out l)) return l;                      break;                  case TypeCode.UInt64:                      ulong ul;                      if (ulong.TryParse(text' out ul)) return ul;                      break;                  case TypeCode.Single:                      float f;                      if (float.TryParse(text' out f)) return f;                      break;                  case TypeCode.Double:                      double d;                      if (double.TryParse(text' out d)) return d;                      break;                  case TypeCode.Decimal:                      decimal e;                      if (decimal.TryParse(text' out e)) return e;                      break;              }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.SByte:                          case TypeCode.Int16:                          case TypeCode.Int32:                          case TypeCode.Int64:                          case TypeCode.Single:                          case TypeCode.Double:                          case TypeCode.Decimal:                              return true;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.Byte:                          case TypeCode.Int16:                          case TypeCode.UInt16:                          case TypeCode.Int32:                          case TypeCode.UInt32:                          case TypeCode.Int64:                          case TypeCode.UInt64:                          case TypeCode.Single:                          case TypeCode.Double:                          case TypeCode.Decimal:                              return true;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.Int16:                          case TypeCode.Int32:                          case TypeCode.Int64:                          case TypeCode.Single:                          case TypeCode.Double:                          case TypeCode.Decimal:                              return true;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.UInt16:                          case TypeCode.Int32:                          case TypeCode.UInt32:                          case TypeCode.Int64:                          case TypeCode.UInt64:                          case TypeCode.Single:                          case TypeCode.Double:                          case TypeCode.Decimal:                              return true;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.Int32:                          case TypeCode.Int64:                          case TypeCode.Single:                          case TypeCode.Double:                          case TypeCode.Decimal:                              return true;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.UInt32:                          case TypeCode.Int64:                          case TypeCode.UInt64:                          case TypeCode.Single:                          case TypeCode.Double:                          case TypeCode.Decimal:                              return true;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.Int64:                          case TypeCode.Single:                          case TypeCode.Double:                          case TypeCode.Decimal:                              return true;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.UInt64:                          case TypeCode.Single:                          case TypeCode.Double:                          case TypeCode.Decimal:                              return true;                      }
Missing Default,System.Linq.Dynamic,ExpressionParser,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Dynamic\DynamicQueryable.cs,IsCompatibleWith,The following switch statement is missing a default case: switch (tc)                      {                          case TypeCode.Single:                          case TypeCode.Double:                              return true;                      }
Missing Default,EntityFramework.Reflection,ILGeneratorExtensions,C:\repos\loresoft_EntityFramework.Extended\Source\EntityFramework.Extended\Reflection\ILGeneratorExtensions.cs,FastInt,The following switch statement is missing a default case: switch (value)            {              case -1:                il.Emit(OpCodes.Ldc_I4_M1);                return;              case 0:                il.Emit(OpCodes.Ldc_I4_0);                return;              case 1:                il.Emit(OpCodes.Ldc_I4_1);                return;              case 2:                il.Emit(OpCodes.Ldc_I4_2);                return;              case 3:                il.Emit(OpCodes.Ldc_I4_3);                return;              case 4:                il.Emit(OpCodes.Ldc_I4_4);                return;              case 5:                il.Emit(OpCodes.Ldc_I4_5);                return;              case 6:                il.Emit(OpCodes.Ldc_I4_6);                return;              case 7:                il.Emit(OpCodes.Ldc_I4_7);                return;              case 8:                il.Emit(OpCodes.Ldc_I4_8);                return;            }
