Implementation smell,Namespace,Class,File,Method,Description
Long Method,DotVVM.Framework.Compilation,DefaultViewCompilerCodeEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompilerCodeEmitter.cs,EmitEnsureCollectionInitialized,The method has 113 lines of code.
Long Method,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The method has 106 lines of code.
Long Method,DotVVM.Framework.Compilation.Parser.Binding.Tokenizer,BindingTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Tokenizer\BindingTokenizer.cs,TokenizeBindingValue,The method has 205 lines of code.
Long Method,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,Parse,The method has 127 lines of code.
Long Method,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ProcessRequestCore,The method has 184 lines of code.
Long Method,DotVVM.Framework.Hosting.ErrorPages,ErrorPageTemplate,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorPageTemplate.cs,TransformText,The method has 135 lines of code.
Long Method,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,The method has 140 lines of code.
Long Method,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The method has 236 lines of code.
Long Method,DotVVM.Framework.Utils,JsonUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\JsonUtils.cs,Diff,The method has 111 lines of code.
Long Method,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateReaderFactory,The method has 122 lines of code.
Long Method,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateWriterFactory,The method has 121 lines of code.
Complex Method,DotVVM.Framework.Binding,BindingCompilationService,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCompilationService.cs,ComputeProperty,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,Cyclomatic complexity of the method is 13
Complex Method,DotVVM.Framework.Compilation,DefaultControlBuilderFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultControlBuilderFactory.cs,TryFindAssembly,Cyclomatic complexity of the method is 12
Complex Method,DotVVM.Framework.Compilation,RoslynValueEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\RoslynValueEmitter.cs,EmitValueCore,Cyclomatic complexity of the method is 17
Complex Method,DotVVM.Framework.Compilation.Binding,ExpressionBuildingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionBuildingVisitor.cs,VisitBinaryOperator,Cyclomatic complexity of the method is 18
Complex Method,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetMember,Cyclomatic complexity of the method is 12
Complex Method,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,TryCallMethod,Cyclomatic complexity of the method is 16
Complex Method,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,EqualsMethod,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetBinaryOperator,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,Cyclomatic complexity of the method is 13
Complex Method,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,ImplicitConstantConversion,Cyclomatic complexity of the method is 22
Complex Method,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttribute,Cyclomatic complexity of the method is 15
Complex Method,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessControlContent,Cyclomatic complexity of the method is 16
Complex Method,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessElementProperty,Cyclomatic complexity of the method is 10
Complex Method,DotVVM.Framework.Compilation.Javascript.Ast,JsBinaryExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\JsBinaryExpression.cs,GetOperatorString,Cyclomatic complexity of the method is 26
Complex Method,DotVVM.Framework.Compilation.Javascript.Ast,JsNode,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\JsNode.cs,ReplaceWith,Cyclomatic complexity of the method is 10
Complex Method,DotVVM.Framework.Compilation.Javascript.Ast,JsNode,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\JsNode.cs,ReplaceWith,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.Compilation.Javascript.Ast,JsUnaryExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\JsUnaryExpression.cs,GetOperatorString,Cyclomatic complexity of the method is 10
Complex Method,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,TryTranslateCall,Cyclomatic complexity of the method is 15
Complex Method,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,Translate,Cyclomatic complexity of the method is 14
Complex Method,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateBinary,Cyclomatic complexity of the method is 26
Complex Method,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateUnary,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,Cyclomatic complexity of the method is 19
Complex Method,DotVVM.Framework.Compilation.Javascript,JsTemporaryVariableResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsTemporaryVariableResolver.cs,ResolveVariables,Cyclomatic complexity of the method is 11
Complex Method,DotVVM.Framework.Compilation.Javascript,JsViewModelPropertyAdjuster,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsViewModelPropertyAdjuster.cs,DefaultVisit,Cyclomatic complexity of the method is 12
Complex Method,DotVVM.Framework.Compilation.Javascript,ParametrizedCode,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\ParametrizedCode.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ParseNumberLiteral,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ParseNumberLiteralSuffix,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ParseStringLiteral,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParserNodeVisitor<T>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParserNodeVisitor.cs,Visit,Cyclomatic complexity of the method is 16
Complex Method,DotVVM.Framework.Compilation.Parser.Binding.Tokenizer,BindingTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Tokenizer\BindingTokenizer.cs,TokenizeBindingValue,Cyclomatic complexity of the method is 34
Complex Method,DotVVM.Framework.Compilation.Parser.Binding.Tokenizer,TokenTypeDispalay,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Tokenizer\TokenTypeDispalay.cs,ToDisplayString,Cyclomatic complexity of the method is 31
Complex Method,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,Parse,Cyclomatic complexity of the method is 17
Complex Method,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,ReadWhiteSpaceOrComment,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadDocument,Cyclomatic complexity of the method is 11
Complex Method,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadElement,Cyclomatic complexity of the method is 16
Complex Method,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadBinding,Cyclomatic complexity of the method is 11
Complex Method,DotVVM.Framework.Compilation.Validation,DefaultControlUsageValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Validation\DefaultControlUsageValidator.cs,Validate,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.Controls,DotvvmControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControl.cs,GetClientIdFragments,Cyclomatic complexity of the method is 11
Complex Method,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,SetParent,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,InvokeMissedPageLifeCycleEvent,Cyclomatic complexity of the method is 10
Complex Method,DotVVM.Framework.Controls,DotvvmControlProperties,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlProperties.cs,AssignBulk,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,TouchProperty,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GetPostBackHandlersScript,Cyclomatic complexity of the method is 13
Complex Method,DotVVM.Framework.Controls,Literal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Literal.cs,RenderControl,Cyclomatic complexity of the method is 12
Complex Method,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ProcessRequestCore,Cyclomatic complexity of the method is 18
Complex Method,DotVVM.Framework.Hosting.ErrorPages,ExceptionSectionFormatter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ExceptionSectionFormatter.cs,WriteException,Cyclomatic complexity of the method is 13
Complex Method,DotVVM.Framework.Routing,DotvvmRouteParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteParser.cs,ParseParameter,Cyclomatic complexity of the method is 15
Complex Method,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AssertConfigurationIsValid,Cyclomatic complexity of the method is 11
Complex Method,DotVVM.Framework.Routing,UrlHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\UrlHelper.cs,IsLocalUrl,Cyclomatic complexity of the method is 9
Complex Method,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,Cyclomatic complexity of the method is 24
Complex Method,DotVVM.Framework.Utils,JsonUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\JsonUtils.cs,Diff,Cyclomatic complexity of the method is 24
Complex Method,DotVVM.Framework.Utils,JsonUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\JsonUtils.cs,Diff,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.Utils,ReflectionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ReflectionUtils.cs,ConvertValue,Cyclomatic complexity of the method is 19
Complex Method,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,BuildViewModel,Cyclomatic complexity of the method is 8
Complex Method,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateWriterFactory,Cyclomatic complexity of the method is 18
Complex Method,DotVVM.Framework.ViewModel.Validation,ViewModelValidationRuleTranslator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ViewModelValidationRuleTranslator.cs,TranslateValidationRules,Cyclomatic complexity of the method is 10
Complex Method,DotVVM.Framework.ViewModel.Validation,ViewModelValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ViewModelValidator.cs,ValidateViewModel,Cyclomatic complexity of the method is 21
Long Parameter List,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,Register,The method has 8 parameters. Parameters: propertyName' propertyType' declaringType' defaultValue' isValueInherited' property' attributeProvider' throwOnDuplicitRegistration
Long Parameter List,DotVVM.Framework.Binding.Properties,LocationInfoBindingProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingProperties.cs,LocationInfoBindingProperty,The method has 5 parameters. Parameters: fileName' ranges' lineNumber' controlType' relatedProperty
Long Parameter List,DotVVM.Framework.Compilation,BindingParserException,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingParserException.cs,BindingParserException,The method has 5 parameters. Parameters: dataContext' bindingExpression' dataContextAncestors' controlType' innerException
Long Parameter List,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,DefaultViewCompiler,The method has 5 parameters. Parameters: config' controlTreeResolver' bindingCompiler' controlValidatorFactory' markupConfiguration
Long Parameter List,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,CompileView,The method has 5 parameters. Parameters: sourceCode' fileName' compilation' namespaceName' className
Long Parameter List,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,AddToCompilation,The method has 5 parameters. Parameters: compilation' emitter' fileName' namespaceName' className
Long Parameter List,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,CompileView,The method has 5 parameters. Parameters: sourceCode' fileName' assemblyName' namespaceName' className
Long Parameter List,DotVVM.Framework.Compilation,IViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\IViewCompiler.cs,CompileView,The method has 5 parameters. Parameters: sourceCode' fileName' assemblyName' namespaceName' className
Long Parameter List,DotVVM.Framework.Compilation,IViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\IViewCompiler.cs,CompileView,The method has 5 parameters. Parameters: sourceCode' fileName' compilation' namespaceName' className
Long Parameter List,DotVVM.Framework.Compilation.Binding,BindingExpressionBuilderExtension,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\BindingExpressionBuilder.cs,ParseWithLambdaConversion,The method has 6 parameters. Parameters: builder' expression' dataContexts' options' expectedType' additionalSymbols
Long Parameter List,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetMember,The method has 5 parameters. Parameters: target' name' typeArguments' throwExceptions' onlyMemberTypes
Long Parameter List,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,CallMethod,The method has 6 parameters. Parameters: target' flags' name' typeArguments' arguments' namedArgs
Long Parameter List,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,CallMethod,The method has 6 parameters. Parameters: target' flags' name' typeArguments' arguments' namedArgs
Long Parameter List,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,FindValidMethodOveloads,The method has 6 parameters. Parameters: type' name' flags' typeArguments' arguments' namedArgs
Long Parameter List,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,CreateBindingId,The method has 5 parameters. Parameters: originalString' expression' dataContext' resolvedBinding' locationInfo
Long Parameter List,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,DataContextStack,The method has 5 parameters. Parameters: type' parent' imports' extensionParameters' bindingPropertyResolvers
Long Parameter List,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,Create,The method has 5 parameters. Parameters: type' parent' imports' extensionParameters' bindingPropertyResolvers
Long Parameter List,DotVVM.Framework.Compilation.ControlTree,IAbstractTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\IAbstractTreeBuilder.cs,BuildTreeRoot,The method has 5 parameters. Parameters: controlTreeResolver' metadata' node' dataContext' directives
Long Parameter List,DotVVM.Framework.Compilation.ControlTree,DotvvmPropertyGroup,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\PropertyGroupDescriptor.cs,DotvvmPropertyGroup,The method has 5 parameters. Parameters: prefixes' valueType' descriptorField' name' defaultValue
Long Parameter List,DotVVM.Framework.Compilation.ControlTree,DotvvmPropertyGroup,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\PropertyGroupDescriptor.cs,Register,The method has 5 parameters. Parameters: declaringType' prefixes' name' valueType' defaultValue
Long Parameter List,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedBinding,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedBinding.cs,ResolvedBinding,The method has 6 parameters. Parameters: bindingService' bindingOptions' dataContext' code' parsedExpression' property
Long Parameter List,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedTreeBuilder.cs,BuildTreeRoot,The method has 5 parameters. Parameters: controlTreeResolver' metadata' node' dataContext' directives
Long Parameter List,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddMethodTranslator,The method has 6 parameters. Parameters: declaringType' methodName' translator' parameters' allowGeneric' allowMultipleMethods
Long Parameter List,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddMethodTranslator,The method has 5 parameters. Parameters: declaringType' methodName' translator' parameterCount' allowMultipleMethods
Long Parameter List,DotVVM.Framework.Compilation.Parser,BeginWithLastTokenOfTypeTokenError<TToken;TTokenType>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\BeginWithLastTokenOfTypeTokenError.cs,BeginWithLastTokenOfTypeTokenError,The method has 5 parameters. Parameters: errorMessage' tokenizer' lastToken' firstTokenType' isCritical
Long Parameter List,DotVVM.Framework.Compilation.Parser,TokenBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\TokenBase.cs,TokenBase,The method has 5 parameters. Parameters: text' lineNumber' columnNumber' length' startPosition
Long Parameter List,DotVVM.Framework.Compilation.Parser,TokenBase<TTokenType>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\TokenBase.cs,TokenBase,The method has 6 parameters. Parameters: text' type' lineNumber' columnNumber' length' startPosition
Long Parameter List,DotVVM.Framework.Compilation.Parser,TokenizerBase<TToken;TTokenType>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\TokenizerBase.cs,NewToken,The method has 6 parameters. Parameters: text' type' lineNumber' columnNumber' length' startPosition
Long Parameter List,DotVVM.Framework.Compilation.Parser.Binding.Tokenizer,BindingToken,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Tokenizer\BindingToken.cs,BindingToken,The method has 6 parameters. Parameters: text' type' lineNumber' columnNumber' length' startPosition
Long Parameter List,DotVVM.Framework.Compilation.Parser.Binding.Tokenizer,BindingTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Tokenizer\BindingTokenizer.cs,NewToken,The method has 6 parameters. Parameters: text' type' lineNumber' columnNumber' length' startPosition
Long Parameter List,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlBindingNode,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlBindingNode.cs,DothtmlBindingNode,The method has 5 parameters. Parameters: startToken' endToken' separatorToken' nameNode' valueNode
Long Parameter List,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlToken,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlToken.cs,DothtmlToken,The method has 6 parameters. Parameters: text' type' lineNumber' columnNumber' length' startPosition
Long Parameter List,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,NewToken,The method has 6 parameters. Parameters: text' type' lineNumber' columnNumber' length' startPosition
Long Parameter List,DotVVM.Framework.Compilation.Styles,PropertyControlCollectionInsertionInfo,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Styles\CompileTimeStyleBase.cs,PropertyControlCollectionInsertionInfo,The method has 5 parameters. Parameters: dotvvmProperty' type' metadata' innerControlStyle' ctorParameters
Long Parameter List,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiClient,The method has 6 parameters. Parameters: configuration' clientType' apiServerUrl' jsApiClientFile' identifier' customFetchFunction
Long Parameter List,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiGroup,The method has 6 parameters. Parameters: configuration' wrapperType' apiServerUrl' jsApiClientFile' identifier' customFetchFunction
Long Parameter List,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiDependencies,The method has 5 parameters. Parameters: configuration' identifier' jsApiClientFile' jsinitializer' descriptor
Long Parameter List,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,CreateNavigationButton,The method has 5 parameters. Parameters: defaultText' userDefinedContentTemplate' enabledValue' clickCommandBindingExpression' context
Long Parameter List,DotVVM.Framework.Controls,DotvvmControlException,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlException.cs,DotvvmControlException,The method has 6 parameters. Parameters: message' innerException' controlType' lineNumber' fileName' ranges
Long Parameter List,DotVVM.Framework.Controls,GridViewColumn,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridViewColumn.cs,CreateHeaderControls,The method has 5 parameters. Parameters: context' gridView' sortCommand' cell' gridViewDataSet
Long Parameter List,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,AddKnockoutDataBind,The method has 8 parameters. Parameters: writer' name' control' property' nullBindingAction' valueUpdate' renderEvenInServerRenderingMode' setValueBack
Long Parameter List,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,AddKnockoutDataBind,The method has 5 parameters. Parameters: writer' name' expressions' control' property
Long Parameter List,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateClientPostBackScript,The method has 7 parameters. Parameters: propertyName' expression' control' useWindowSetTimeout' returnValue' isOnChange' elementAccessor
Long Parameter List,DotVVM.Framework.Controls,PostbackScriptOptions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PostbackScriptOptions.cs,PostbackScriptOptions,The method has 7 parameters. Parameters: useWindowSetTimeout' returnValue' isOnChange' elementAccessor' koContext' commandArgs' allowPostbackHandlers
Long Parameter List,DotVVM.Framework.Controls,Repeater,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Repeater.cs,GetItem,The method has 5 parameters. Parameters: context' item' index' allowMemoizationRetrive' allowMemoizationStore
Long Parameter List,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,DotvvmPresenter,The method has 8 parameters. Parameters: configuration' viewBuilder' viewModelLoader' viewModelSerializer' outputRender' csrfProtector' viewModelParameterBinder' staticCommandServiceLoader
Long Parameter List,DotVVM.Framework.Hosting,IHttpRedirectService,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\HttpRedirectService.cs,WriteRedirectResponse,The method has 5 parameters. Parameters: httpContext' url' statusCode' replaceInHistory' allowSpaRedirect
Long Parameter List,DotVVM.Framework.Hosting,DefaultHttpRedirectService,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\HttpRedirectService.cs,WriteRedirectResponse,The method has 5 parameters. Parameters: httpContext' url' statusCode' replaceInHistory' allowSpaRedirect
Long Parameter List,DotVVM.Framework.Hosting.ErrorPages,ErrorFormatter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorFormatter.cs,LoadSourcePiece,The method has 5 parameters. Parameters: fileName' lineNumber' additionalLineCount' errorColumn' errorLength
Long Parameter List,DotVVM.Framework.Routing,DotvvmRoute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRoute.cs,DotvvmRoute,The method has 5 parameters. Parameters: url' virtualPath' defaultValues' presenterFactory' configuration
Long Parameter List,DotVVM.Framework.Routing,DotvvmRoute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRoute.cs,DotvvmRoute,The method has 5 parameters. Parameters: url' virtualPath' defaultValues' presenterFactory' configuration
Long Parameter List,DotVVM.Framework.Routing,DotvvmRoute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRoute.cs,DotvvmRoute,The method has 6 parameters. Parameters: url' virtualPath' name' defaultValues' presenterFactory' configuration
Long Parameter List,DotVVM.Framework.Routing,DotvvmRouteTable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteTable.cs,AddGroup,The method has 5 parameters. Parameters: groupName' urlPrefix' virtualPathPrefix' content' presenterFactory
Long Parameter List,DotVVM.Framework.Routing,DotvvmRouteTable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteTable.cs,Add,The method has 5 parameters. Parameters: routeName' url' virtualPath' defaultValues' presenterFactory
Long Parameter List,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AutoRegisterRoutes,The method has 5 parameters. Parameters: routeTable' config' getRouteList' path' pattern
Long Parameter List,DotVVM.Framework.Routing,RouteTableGroup,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteTableGroup.cs,RouteTableGroup,The method has 6 parameters. Parameters: groupName' routeNamePrefix' urlPrefix' virtualPathPrefix' addToParentRouteTable' presenterFactory
Long Parameter List,DotVVM.Framework.Routing,ErrorRoute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteTableJsonConverter.cs,ErrorRoute,The method has 5 parameters. Parameters: url' virtualPath' name' defaultValues' error
Long Parameter List,DotVVM.Framework.Runtime.Commands,CommandResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\CommandResolver.cs,GetFunction,The method has 6 parameters. Parameters: targetControl' viewRootControl' context' path' commandId' args
Long Parameter List,DotVVM.Framework.Runtime.Commands,CommandResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\CommandResolver.cs,GetFunction,The method has 5 parameters. Parameters: viewRootControl' context' path' command' args
Long Parameter List,DotVVM.Framework.Runtime.Commands,EventValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\EventValidator.cs,FindCommandBinding,The method has 6 parameters. Parameters: path' commandId' viewRootControl' targetControl' validationTargetPath' findControl
Long Parameter List,DotVVM.Framework.Runtime.Commands,EventValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\EventValidator.cs,ValidateControlCommand,The method has 5 parameters. Parameters: path' commandId' viewRootControl' targetControl' validationTargetPath
Long Parameter List,DotVVM.Framework.Runtime.Commands,EventValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\EventValidator.cs,FindControlCommandBinding,The method has 5 parameters. Parameters: path' commandId' viewRootControl' targetControl' validationTargetPath
Long Parameter List,DotVVM.Framework.Utils,ExpressionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionUtils.cs,Replace,The method has 5 parameters. Parameters: ex' p1' p2' p3' p4
Long Parameter List,DotVVM.Framework.Utils,ExpressionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionUtils.cs,Replace,The method has 5 parameters. Parameters: ex' p1' p2' p3' p4
Long Identifier,DotVVM.Framework.Binding.Expressions,CommandBindingExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\Expressions\CommandBindingExpression.cs,,The length of the parameter javascriptPostbackInvocation_requiredCommandArgs is 48.
Long Identifier,DotVVM.Framework.Binding.Expressions,CommandBindingExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\Expressions\CommandBindingExpression.cs,,The length of the parameter javascriptPostbackInvocation_noCommandArgs is 42.
Long Identifier,DotVVM.Framework.Compilation,BindingRequiredResourceVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingRequiredResourceVisitor.cs,BindingRequiredResourceVisitor,The length of the parameter requiredResourceConrolMetadata is 30.
Long Identifier,DotVVM.Framework.Compilation,BindingRequiredResourceVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingRequiredResourceVisitor.cs,,The length of the parameter requiredResourceConrolMetadata is 30.
Long Identifier,DotVVM.Framework.Compilation,DefaultViewCompilerCodeEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompilerCodeEmitter.cs,,The length of the parameter ControlBuilderFactoryParameterName is 34.
Long Identifier,DotVVM.Framework.Compilation,RoslynValueEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\RoslynValueEmitter.cs,,The length of the parameter _ViewImmutableObjects_PropArray is 31.
Long Identifier,DotVVM.Framework.Compilation,RoslynValueEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\RoslynValueEmitter.cs,,The length of the parameter _ViewImmutableObjects_ObjArray is 30.
Long Identifier,DotVVM.Framework.Compilation.ControlTree,LifecycleRequirementsAssigningVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\LifecycleRequirementsAssigningVisitor.cs,,The length of the parameter CompileTimeLifecycleRequirementsProperty is 40.
Long Identifier,DotVVM.Framework.Controls,AuthenticatedView,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\AuthenticatedView.cs,,The length of the parameter NotAuthenticatedTemplateProperty is 32.
Long Identifier,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,,The length of the parameter RenderLinkForCurrentPageProperty is 32.
Long Identifier,DotVVM.Framework.Controls,DotvvmBindableObject,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObject.cs,GetClosestWithPropertyValue,The length of the parameter includeDataContextChangeOnMatchedControl is 40.
Long Identifier,DotVVM.Framework.Controls,DotvvmBindableObject,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObject.cs,,The length of the parameter _dotvvmProperty_ResolveProperties is 33.
Long Identifier,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,SetParent,The length of the parameter lifecycleEventUpdatingDisabled is 30.
Long Identifier,DotVVM.Framework.Controls,DotvvmMarkupControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmMarkupControl.cs,ContainsPropertyStaticValue,The length of the parameter isValueOrServerSideValueBinding is 31.
Long Identifier,DotVVM.Framework.Controls,EnvironmentView,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\EnvironmentView.cs,,The length of the parameter IsNotEnvironmentTemplateProperty is 32.
Long Identifier,DotVVM.Framework.Controls,FileUpload,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\FileUpload.cs,,The length of the parameter NumberOfFilesIndicatorTextProperty is 34.
Long Identifier,DotVVM.Framework.Controls,FileUpload,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\FileUpload.cs,,The length of the parameter UploadErrorMessageTextProperty is 30.
Long Identifier,DotVVM.Framework.Controls,GridViewColumn,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridViewColumn.cs,,The length of the parameter SortAscendingHeaderCssClassProperty is 35.
Long Identifier,DotVVM.Framework.Controls,GridViewColumn,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridViewColumn.cs,,The length of the parameter SortDescendingHeaderCssClassProperty is 36.
Long Identifier,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,HtmlGenericControl,The length of the parameter allowImplicitLifecycleRequirements is 34.
Long Identifier,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,HtmlGenericControl,The length of the parameter allowImplicitLifecycleRequirements is 34.
Long Identifier,DotVVM.Framework.Controls,Internal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Internal.cs,,The length of the parameter IsControlBindingTargetProperty is 30.
Long Identifier,DotVVM.Framework.Controls,Internal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Internal.cs,,The length of the parameter UseHistoryApiSpaNavigationProperty is 34.
Long Identifier,DotVVM.Framework.Controls,Internal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Internal.cs,,The length of the parameter IsMasterPageCompositionFinishedProperty is 39.
Long Identifier,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,AddKnockoutDataBind,The length of the parameter renderEvenInServerRenderingMode is 31.
Long Identifier,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,,The length of the parameter RootValidationTargetExpression is 30.
Long Identifier,DotVVM.Framework.Controls,Literal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Literal.cs,Literal,The length of the parameter allowImplicitLifecycleRequirements is 34.
Long Identifier,DotVVM.Framework.Controls,Literal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Literal.cs,Literal,The length of the parameter allowImplicitLifecycleRequirements is 34.
Long Identifier,DotVVM.Framework.Controls,PostBack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PostBack.cs,,The length of the parameter ConcurrencyQueueSettingsProperty is 32.
Long Identifier,DotVVM.Framework.Controls,Repeater,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Repeater.cs,Repeater,The length of the parameter allowImplicitLifecycleRequirements is 34.
Long Identifier,DotVVM.Framework.Controls,Repeater,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Repeater.cs,GetForeachKnockoutBindingGroup,The length of the parameter javascriptDataSourceExpression is 30.
Long Identifier,DotVVM.Framework.Controls,RouteLink,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\RouteLink.cs,,The length of the parameter QueryParametersGroupDescriptor is 30.
Long Identifier,DotVVM.Framework.Controls,TextBox,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\TextBox.cs,,The length of the parameter UpdateTextAfterKeydownProperty is 30.
Long Identifier,DotVVM.Framework.Controls,ValidationSummary,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\ValidationSummary.cs,,The length of the parameter IncludeErrorsFromChildrenProperty is 33.
Long Identifier,DotVVM.Framework.Controls,ValidationSummary,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\ValidationSummary.cs,,The length of the parameter IncludeErrorsFromTargetProperty is 31.
Long Identifier,DotVVM.Framework.Hosting,HostingConstants,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\HostingConstants.cs,,The length of the parameter GlobalizeCultureUrlIdParameter is 30.
Long Identifier,DotVVM.Framework.Hosting,HostingConstants,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\HostingConstants.cs,,The length of the parameter SpaContentPlaceHolderHeaderName is 31.
Long Identifier,DotVVM.Framework.Hosting,HostingConstants,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\HostingConstants.cs,,The length of the parameter SpaContentPlaceHolderDataAttributeName is 38.
Long Identifier,DotVVM.Framework.Hosting,HostingConstants,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\HostingConstants.cs,,The length of the parameter SpaContentPlaceHolderDefaultRouteDataAttributeName is 50.
Long Identifier,DotVVM.Framework.Hosting,HostingConstants,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\HostingConstants.cs,,The length of the parameter DotvvmFileUploadAsyncHeaderName is 31.
Long Identifier,DotVVM.Framework.Hosting.Middlewares,DotvvmRoutingMiddleware,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\Middlewares\DotvvmRoutingMiddleware.cs,,The length of the parameter GooglebotHashbangEscapedFragment is 32.
Long Identifier,DotVVM.Framework.ResourceManagement,ResourceConstants,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ResourceConstants.cs,,The length of the parameter DotvvmFileUploadCssResourceName is 31.
Long Identifier,DotVVM.Framework.ResourceManagement.ClientGlobalize,JQueryGlobalizeScriptCreator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ClientGlobalize\JQueryGlobalizeScriptCreator.cs,,The length of the parameter currencyNegativePatternStrings is 30.
Long Identifier,DotVVM.Framework.ResourceManagement.ClientGlobalize,JQueryGlobalizeScriptCreator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ClientGlobalize\JQueryGlobalizeScriptCreator.cs,,The length of the parameter currencyPositivePatternStrings is 30.
Long Identifier,DotVVM.Framework.Utils,FunctionalExtensions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\FunctionalExtensions.cs,GetValueOrDefault,The length of the parameter justAddAParameterSoCsharpDoesNotPreferThisMethodOverStandard is 60.
Long Identifier,DotVVM.Framework.ViewModel,ChildViewModelsCache,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\ChildViewModelsCache.cs,GetChildViewModelsCollection,The length of the parameter childViewModelsPropertyInfoFactory is 34.
Long Identifier,DotVVM.Framework.ViewModel,ChildViewModelsCache,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\ChildViewModelsCache.cs,GetChildViewModelsProperties,The length of the parameter childViewModelsPropertyInfoFactory is 34.
Long Identifier,DotVVM.Framework.ViewModel,ChildViewModelsCache,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\ChildViewModelsCache.cs,,The length of the parameter childViewModelsCollectionCache is 30.
Long Identifier,DotVVM.Framework.ViewModel,ChildViewModelsCache,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\ChildViewModelsCache.cs,,The length of the parameter childViewModelsPropertiesCache is 30.
Long Identifier,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,,The length of the parameter GeneralViewModelRecommendations is 31.
Long Statement,DotVVM.Framework.Binding,ActiveDotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\ActiveDotvvmProperty.cs,RegisterCommandToAttribute,The length of the statement  "                var binding = control.GetCommandBinding(property) ?? throw new Exception($"Command binding expression was expected in {property}."); " is 132.
Long Statement,DotVVM.Framework.Binding,BindingCollectionInfo,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCollectionInfo.cs,RegisterJavascriptTranslations,The length of the statement  "                    check: (_m' a' _a) => a.GetParameterAnnotation() is BindingParameterAnnotation ann && ann.ExtensionParameter is BindingCollectionInfoExtensionParameter " is 151.
Long Statement,DotVVM.Framework.Binding,BindingCombinator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCombinator.cs,AndAssignProperty,The length of the statement  "            if (property.PropertyType != typeof(bool)) throw new NotSupportedException($"Can only AND boolean properties' {property} is of type {property.PropertyType}"); " is 158.
Long Statement,DotVVM.Framework.Binding,BindingCombinator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCombinator.cs,AndAssignProperty,The length of the statement  "                                throw new NotSupportedException($"A IBinding instance or bool was expected in property {property}' got {obj.GetValue(property)?.GetType().Name ?? "null"}")' " is 156.
Long Statement,DotVVM.Framework.Binding,BindingCombinator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCombinator.cs,AndAssignProperty,The length of the statement  "                                throw new NotSupportedException($"A IBinding instance or bool was expected to AndAssign to property {property}' got {obj.GetValue(property)?.GetType().Name ?? "null"}") " is 168.
Long Statement,DotVVM.Framework.Binding,BindingCompilationService,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCompilationService.cs,ComputeProperty,The length of the statement  "            object? getParameterValue(ParameterInfo p) => binding.GetProperty(p.ParameterType' p.HasDefaultValue ? ErrorHandlingMode.ReturnNull : ErrorHandlingMode.ReturnException) ?? p.DefaultValue; " is 187.
Long Statement,DotVVM.Framework.Binding,BindingCompilationService,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCompilationService.cs,ComputeProperty,The length of the statement  "            else return new BindingPropertyException(binding' type' "resolver not found"); // don't throw the exception' since it creates noise for debugger " is 144.
Long Statement,DotVVM.Framework.Binding,BindingCompilationService,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCompilationService.cs,GetDefaultRequirements,The length of the statement  "                t.GetTypeInfo().GetCustomAttributes<BindingCompilationRequirementsAttribute>(inherit: true).Aggregate((a' b) => a.ApplySecond(b))); " is 131.
Long Statement,DotVVM.Framework.Binding,BindingCompilationService,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingCompilationService.cs,GetRequirements,The length of the statement  "            if (binding.GetProperty<BindingCompilationRequirementsAttribute>(ErrorHandlingMode.ReturnNull) is var second && second != null) " is 127.
Long Statement,DotVVM.Framework.Binding,BindingFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingFactory.cs,CreateBinding,The length of the statement  "                Debug.Assert(nonGenericBase != null && !nonGenericBase.ContainsGenericParameters && nonGenericBase.Name  + "`1" == binding.Name); " is 129.
Long Statement,DotVVM.Framework.Binding,BindingFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingFactory.cs,CreateBinding,The length of the statement  "                if (ctor == null) throw new NotSupportedException($"Could not find .ctor(BindingCompilationService service' object[] properties) on binding '{binding.FullName}'."); " is 164.
Long Statement,DotVVM.Framework.Binding,BindingFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingFactory.cs,CreateBinding,The length of the statement  "                var expression = Expression.New(ctor' bindingServiceParam' TypeConversion.ImplicitConversion(propertiesParam' ctor.GetParameters()[1].ParameterType)); " is 150.
Long Statement,DotVVM.Framework.Binding,BindingFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingFactory.cs,CreateBinding,The length of the statement  "                return Expression.Lambda<Func<BindingCompilationService' object?[]' IBinding>>(expression' bindingServiceParam' propertiesParam).Compile(); " is 139.
Long Statement,DotVVM.Framework.Binding,BindingHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingHelper.cs,FindDataContextTarget,The length of the statement  "            throw new NotSupportedException($"Could not find DataContext space of binding '{binding}'. The DataContextType property of the binding does not correspond to DataContextType of the {control.GetType().Name} not any of its ancestor. Control's context is {controlContext}' binding's context is {bindingContext}."); " is 311.
Long Statement,DotVVM.Framework.Binding,BindingHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingHelper.cs,GetDataContextType,The length of the statement  "                return property.DataContextManipulationAttribute.ChangeStackForChildren(dataContextType' obj' property' (parent' changeType) => DataContextStack.Create(changeType' parent)); " is 173.
Long Statement,DotVVM.Framework.Binding,BindingHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingHelper.cs,GetDataContextType,The length of the statement  "            var (childType' extensionParameters) = ApplyDataContextChange(dataContextType' property.DataContextChangeAttributes' obj' property); " is 132.
Long Statement,DotVVM.Framework.Binding,BindingHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingHelper.cs,GetDataContextType,The length of the statement  "            if (childType is null) return null; // childType is null in case there is some error in processing (e.g. enumerable was expected). " is 130.
Long Statement,DotVVM.Framework.Binding,ParameterAnnotatingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingHelper.cs,VisitParameter,The length of the statement  "                else if (node.Name == "_parent") return node.AddParameterAnnotation(new BindingParameterAnnotation(DataContext.Parent)); " is 120.
Long Statement,DotVVM.Framework.Binding,ParameterAnnotatingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingHelper.cs,VisitParameter,The length of the statement  "                else if (node.Name == "_root") return node.AddParameterAnnotation(new BindingParameterAnnotation(DataContext.EnumerableItems().Last())); " is 136.
Long Statement,DotVVM.Framework.Binding,ParameterAnnotatingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingHelper.cs,VisitParameter,The length of the statement  "                else if (node.Name.StartsWith("_parent"' StringComparison.Ordinal) && int.TryParse(node.Name.Substring("_parent".Length)' out int index)) " is 137.
Long Statement,DotVVM.Framework.Binding,CollectionElementDataContextChangeAttribute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\CollectionElementDataContextChangeAttribute.cs,GetExtensionParameters,The length of the statement  "            return base.GetExtensionParameters(dataContext).Concat(new BindingExtensionParameter[] { new CurrentCollectionIndexExtensionParameter()' new BindingCollectionInfoExtensionParameter("_collection") }); " is 199.
Long Statement,DotVVM.Framework.Binding,ControlPropertyBindingDataContextChangeAttribute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\ControlPropertyBindingDataContextChangeAttribute.cs,GetChildDataContextType,The length of the statement  "                    ? binding.Binding.ResultType ?? throw new Exception($"The '{controlProperty.Name}' property contains invalid data-binding") " is 123.
Long Statement,DotVVM.Framework.Binding,ControlPropertyBindingDataContextChangeAttribute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\ControlPropertyBindingDataContextChangeAttribute.cs,GetChildDataContextType,The length of the statement  "            var controlPropertyField = controlType.GetField($"{PropertyName}Property"' BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy); " is 150.
Long Statement,DotVVM.Framework.Binding,ControlPropertyTypeDataContextChangeAttribute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\ControlPropertyTypeDataContextChangeAttribute.cs,GetChildDataContextType,The length of the statement  "            var controlPropertyField = controlType.GetField($"{PropertyName}Property"' BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy); " is 150.
Long Statement,DotVVM.Framework.Binding,ControlPropertyTypeDataContextChangeAttribute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\ControlPropertyTypeDataContextChangeAttribute.cs,GetChildDataContextType,The length of the statement  "            if (control.properties.Contains(controlProperty) && control.GetValueBinding(controlProperty) is IValueBinding valueBinding) " is 123.
Long Statement,DotVVM.Framework.Binding,DelegateActionProperty<TValue>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DelegateActionProperty.cs,Register,The length of the statement  "            return (DelegateActionProperty<TValue>)DotvvmProperty.Register<TValue' TDeclaringType>(name' defaultValue' false' new DelegateActionProperty<TValue>(func)); " is 156.
Long Statement,DotVVM.Framework.Binding,DotvvmBindingCacheHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmBindingCacheHelper.cs,CreateCachedBinding,The length of the statement  "            return CreateCachedBinding<T>(identifier' keys' () => (T)BindingFactory.CreateBinding(this.compilationService' typeof(T)' properties)); " is 135.
Long Statement,DotVVM.Framework.Binding,DotvvmBindingCacheHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmBindingCacheHelper.cs,CheckEqualsImplementation,The length of the statement  "            var eqMethod = t.GetMethod("Equals"' BindingFlags.Public | BindingFlags.Instance' null' new [] { typeof(object) }' null); " is 121.
Long Statement,DotVVM.Framework.Binding,DotvvmBindingCacheHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmBindingCacheHelper.cs,CheckEqualsImplementation,The length of the statement  "                throw new Exception($"Instance of type {t} can not be used as a cache key' because it does not have Object.Equals method overridden. If you really want to use referential equality (you are using a singleton as a cache key or something like that)' you can wrap in Tuple<T>."); " is 275.
Long Statement,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,Register,The length of the statement  "            if (field == null || !field.IsStatic) throw new ArgumentException("The expression should be simple static field access"' nameof(fieldAccessor)); " is 144.
Long Statement,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,Register,The length of the statement  "            if (!field.Name.EndsWith("Property"' StringComparison.Ordinal)) throw new ArgumentException($"DotVVM property backing field's '{field.Name}' name should end with 'Property'"); " is 175.
Long Statement,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,Register,The length of the statement  "            return Register<TPropertyType' TDeclaringType>(field.Name.Remove(field.Name.Length - "Property".Length)' defaultValue' isValueInherited); " is 137.
Long Statement,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,Register,The length of the statement  "            if (property == null) throw new ArgumentException("The expression should be simple property access"' nameof(propertyAccessor)); " is 127.
Long Statement,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,Register,The length of the statement  "            var field = typeof(TDeclaringType).GetField(propertyName + "Property"' BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic); " is 139.
Long Statement,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,Register,The length of the statement  "            if (field == null) throw new ArgumentException($"'{typeof(TDeclaringType).Name}' does not contain static field '{propertyName}Property'."); " is 139.
Long Statement,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,Register,The length of the statement  "            return Register(propertyName' typeof(TPropertyType)' typeof(TDeclaringType)' defaultValue' isValueInherited' property' field); " is 126.
Long Statement,DotVVM.Framework.Binding,DotvvmProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmProperty.cs,InitializeProperty,The length of the statement  "            if (property.DataContextManipulationAttribute != null && property.DataContextChangeAttributes.Any()) throw new ArgumentException($"{nameof(DataContextChangeAttributes)} and {nameof(DataContextManipulationAttribute)} can not be set both at property '{property.FullName}'."); " is 273.
Long Statement,DotVVM.Framework.Binding,DotvvmPropertyWithFallback,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmPropertyWithFallback.cs,Register,The length of the statement  "            if (property == null) throw new ArgumentException("The expression should be simple property access"' nameof(propertyAccessor)); " is 127.
Long Statement,DotVVM.Framework.Binding,DotvvmPropertyWithFallback,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmPropertyWithFallback.cs,Register,The length of the statement  "            return (DotvvmPropertyWithFallback)Register<TPropertyType' TDeclaringType>(propertyName' isValueInherited: isValueInherited' property: property); " is 145.
Long Statement,DotVVM.Framework.Binding,ExtensionCommands,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\ExtensionCommands.cs,RegisterExtensionCommand,The length of the statement  "            var property = DotvvmProperty.ResolveProperty(typeof(PropertyBox)' propertyName) ?? DotvvmProperty.Register(propertyName' typeof(object)' typeof(PropertyBox)' null' false' null' typeof(PropertyBox)' throwOnDuplicitRegistration: false); " is 235.
Long Statement,DotVVM.Framework.Binding.Properties,BindingErrorReporterProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingProperties.cs,GetErrorMessage,The length of the statement  "            var badRequirements = Errors.Where(e => e.severity == Microsoft.CodeAnalysis.DiagnosticSeverity.Error).Select(e => e.req).Distinct().ToArray(); " is 143.
Long Statement,DotVVM.Framework.Binding.Properties,BindingErrorReporterProperty,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\BindingProperties.cs,GetErrorMessage,The length of the statement  "            return $"Could not initialize binding '{binding}'' requirement{(badRequirements.Length > 1 ? "s" : "")} {string.Join<Type>("' "' badRequirements)} {(badRequirements.Length > 1 ? "were" : "was")} not met."; " is 205.
Long Statement,DotVVM.Framework.Binding.Expressions,Methods,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\Expressions\CommandBindingExpression.cs,GetExpectedType,The length of the statement  "                    return new ExpectedTypeBindingProperty(prop.IsBindingProperty ? (prop.PropertyType.GenericTypeArguments.SingleOrDefault() ?? typeof(Command)) : prop.PropertyType); " is 163.
Long Statement,DotVVM.Framework.Binding.Expressions,ValueBindingExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\Expressions\ValueBindingExpression.cs,CreateBinding,The length of the statement  "                new ParsedExpressionBindingProperty(BindingHelper.AnnotateStandardContextParams(expression' dataContext).OptimizeConstants())' " is 126.
Long Statement,DotVVM.Framework.Compilation,BindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingCompiler.cs,GetParameter,The length of the statement  "            return new KeyValuePair<string' Expression>(name' Expression.Convert(Expression.ArrayIndex(vmArray' Expression.Constant(index))' parents[index])); " is 146.
Long Statement,DotVVM.Framework.Compilation,BindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingCompiler.cs,GetMinimalCloneProperties,The length of the statement  "                    .Concat(new[] { typeof(OriginalStringBindingProperty)' typeof(DataContextStack)' typeof(LocationInfoBindingProperty)' typeof(BindingParserOptions)' typeof(BindingCompilationRequirementsAttribute)' typeof(ExpectedTypeBindingProperty)' typeof(AssignedPropertyBindingProperty) }) " is 276.
Long Statement,DotVVM.Framework.Compilation,ParameterReplacementVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingCompiler.cs,Visit,The length of the statement  "                        return Expression.Convert(Expression.ArrayIndex(ViewModelsParameter' Expression.Constant(ContextMap[ann.DataContext]))' ann.DataContext.DataContextType); " is 153.
Long Statement,DotVVM.Framework.Compilation,ParameterReplacementVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingCompiler.cs,VisitParameter,The length of the statement  "                if (AssertAllReplaced && node != CurrentControlParameter && node != ViewModelsParameter && !contextParameters.Contains(node)) " is 125.
Long Statement,DotVVM.Framework.Compilation,BindingParserOptions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingParserOptions.cs,CreateTypeLoader,The length of the statement  "                        else if (t.Length > import.Alias.Length + 1 && t[import.Alias.Length] == '.') name = import.Namespace + "." + t.Substring(import.Alias.Length + 1); " is 147.
Long Statement,DotVVM.Framework.Compilation,BindingRequiredResourceVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingRequiredResourceVisitor.cs,VisitPropertyBinding,The length of the statement  "            var requiredResourceProperty = propertyBinding.Binding.Binding.GetProperty<RequiredRuntimeResourcesBindingProperty>(ErrorHandlingMode.ReturnNull); " is 146.
Long Statement,DotVVM.Framework.Compilation,ControlType,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlType.cs,GetHashCode,The length of the statement  "                return ((Type != null ? Type.GetHashCode() : 53515466) * 397) ^ (VirtualPath != null ? VirtualPath.GetHashCode() : 145132); " is 123.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The length of the statement  "                return new ResolvedPropertyControlCollection(property' Enumerable.Concat(firstCollection.Controls' secondCollection.Controls).ToList()); " is 136.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The length of the statement  "                return new ResolvedPropertyTemplate(property' Enumerable.Concat(firstTemplate.Content' secondTemplate.Content).ToList()); " is 121.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The length of the statement  "                bindingB != null && !typeof(IStaticValueBinding).IsAssignableFrom(bindingB.BindingType)) { error = $"Can not merge values of non-value bindings."; return null; } " is 161.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The length of the statement  "                if (bindingA.BindingType != bindingB.BindingType) { error = $"Can not merge values of different binding types"; return null; } " is 126.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The length of the statement  "            var resultExpression = TryOptimizeMethodCall(TryFindMethod(GetType()' MergeExpressionsMethodName' Expression.Constant(property)' Expression.Constant(valA)' Expression.Constant(valB))) as Expression; " is 198.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The length of the statement  "            // Try to find MegeValues method if MergeExpression does not exists' or try to eval it to constant if expression is not constant " is 128.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The length of the statement  "            if (resultExpression == null || valA.NodeType == ExpressionType.Constant && valB.NodeType == ExpressionType.Constant && resultExpression.NodeType != ExpressionType.Constant) " is 173.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,EmitBinding,The length of the statement  "                new ResolvedBinding(originalBidning.BindingService' originalBidning.Binding.GetProperty<BindingParserOptions>()' originalBidning.DataContextTypeStack' null' expression' property)) { DothtmlNode = originalBidning.DothtmlNode }; " is 226.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,TryOptimizeMethodCall,The length of the statement  "            if (methodCall != null && methodCall.Arguments.All(a => a.NodeType == ExpressionType.Constant) && (methodCall.Object == null || methodCall.Object.NodeType == ExpressionType.Constant)) " is 183.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,TryFindMethod,The length of the statement  "                new[] { CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType' null) } " is 124.
Long Statement,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,TryFindMethod,The length of the statement  "            var result = binder.Bind(DynamicMetaObject.Create(context' Expression.Constant(context))' parameters.Select(e => DynamicMetaObject.Create(null' e)).ToArray()); " is 159.
Long Statement,DotVVM.Framework.Compilation,DefaultControlBuilderFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultControlBuilderFactory.cs,GetControlBuilder,The length of the statement  "            var markupFile = markupFileLoader.GetMarkup(configuration' virtualPath) ?? throw new DotvvmCompilationException($"File '{virtualPath}' was not found. This exception is possibly caused because of incorrect route registration."); " is 227.
Long Statement,DotVVM.Framework.Compilation,DefaultControlBuilderFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultControlBuilderFactory.cs,CreateControlBuilder,The length of the statement  "                    var (descriptor' factory) = ViewCompilerFactory().CompileView(file.ContentsReaderFactory()' file.FileName' assemblyName' namespaceName' className); " is 147.
Long Statement,DotVVM.Framework.Compilation,DefaultControlBuilderFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultControlBuilderFactory.cs,TryFindAssembly,The length of the statement  "            foreach (var assemblyDirectory in new[] { Path.GetDirectoryName(typeof(DefaultControlBuilderFactory).GetTypeInfo().Assembly.GetCodeBasePath())' configuration.ApplicationPhysicalPath }) " is 184.
Long Statement,DotVVM.Framework.Compilation,DefaultControlBuilderFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultControlBuilderFactory.cs,LoadCompiledViewsAssembly,The length of the statement  "                var args = initMethod.GetParameters().Select(p => configuration.ServiceProvider.GetRequiredService(p.ParameterType)).ToArray(); " is 127.
Long Statement,DotVVM.Framework.Compilation,DefaultControlBuilderFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultControlBuilderFactory.cs,RegisterControlBuilder,The length of the statement  "            controlBuilders.TryAdd(markup' (new ControlBuilderDescriptor(builder.DataContextType' builder.ControlType)' new Lazy<IControlBuilder>(() => builder))); " is 151.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,CompileView,The length of the statement  "            return (new ControlBuilderDescriptor(resolvedView.DataContextTypeStack.DataContextType' resolvedView.Metadata.Type)' () => { " is 124.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,CompileView,The length of the statement  "                        throw new DotvvmCompilationException(token.Error.ErrorMessage' new[] { (token.Error as BeginWithLastTokenOfTypeTokenError<DothtmlToken' DothtmlTokenType>)?.LastToken ?? token }); " is 178.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,BuildReferencedAssembliesCache,The length of the statement  "            var netstandardAssembly = AppDomain.CurrentDomain.GetAssemblies().FirstOrDefault(a => a.GetName().Name == "netstandard"); " is 121.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,CreateCompilation,The length of the statement  "            return CSharpCompilation.Create(assemblyName' options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary)) " is 121.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompilerCodeEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompilerCodeEmitter.cs,EmitSetDotvvmProperty,The length of the statement  "                    EmitAddToDictionary(controlName' property.CastTo<GroupedDotvvmProperty>().PropertyGroup.Name' gProperty.GroupMemberName' value); " is 128.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompilerCodeEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompilerCodeEmitter.cs,CommitDotvvmProperties,The length of the statement  "            var (hashSeed' keys' values) = PropertyImmutableHashtable.CreateTableWithValues(properties.Select(p => p.prop).ToArray()' properties.Select(p => p.value).ToArray()); " is 165.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompilerCodeEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompilerCodeEmitter.cs,EmitEnsureCollectionInitialized,The length of the statement  "                            new[] { EmitValue($"Property '{ property.FullName }' can't be used as control collection since it is not initialized and does not have setter available for automatic initialization") } " is 184.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompilerCodeEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompilerCodeEmitter.cs,BuildTree,The length of the statement  "                throw new Exception($"Control {uncommittedControl.Key} has unresolved properties {String.Join("' "' uncommittedControl.Value.Select(p => p.prop.FullName + " " + p.value))}"); " is 174.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompilerCodeEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompilerCodeEmitter.cs,BuildTree,The length of the statement  "            // WORKAROUND: serializing and parsing the tree is necessary here because Roslyn throws compilation errors when pass the original tree which uses markup controls (they reference in-memory assemblies) " is 199.
Long Statement,DotVVM.Framework.Compilation,DefaultViewCompilerCodeEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompilerCodeEmitter.cs,BuildTree,The length of the statement  "            // the trees are the same (root2.GetChanges(root) returns empty collection) but without serialization and parsing it does not work " is 130.
Long Statement,DotVVM.Framework.Compilation,HtmlAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\HtmlAttributeValueMerger.cs,MergeExpressions,The length of the statement  "            return Expression.Call(typeof(string).GetMethod("Concat"' new[] { typeof(string)' typeof(string)' typeof(string) })' a' Expression.Constant(separator)' b); " is 155.
Long Statement,DotVVM.Framework.Compilation,RoslynValueEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\RoslynValueEmitter.cs,AddObjectToStaticField,The length of the statement  "                    (AddObject(propArray' ref _ViewImmutableObjects_PropArray' ref _viewObjectsCount_PropArray)' nameof(_ViewImmutableObjects_PropArray)) : " is 135.
Long Statement,DotVVM.Framework.Compilation,RoslynValueEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\RoslynValueEmitter.cs,AddObjectToStaticField,The length of the statement  "                    (AddObject(objArray' ref _ViewImmutableObjects_ObjArray' ref _viewObjectsCount_ObjArray)' nameof(_ViewImmutableObjects_ObjArray)) : " is 131.
Long Statement,DotVVM.Framework.Compilation,RoslynValueEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\RoslynValueEmitter.cs,EmitStrangeIntegerValue,The length of the statement  "            return SyntaxFactory.CastExpression(this.UseType(type)' SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression' SyntaxFactory.Literal(value))); " is 156.
Long Statement,DotVVM.Framework.Compilation,ViewCompilingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ViewCompilingVisitor.cs,VisitView,The length of the statement  "            emitter.PushNewMethod(nameof(IControlBuilder.BuildControl)' typeof(DotvvmControl)' emitter.EmitControlBuilderParameters()); " is 123.
Long Statement,DotVVM.Framework.Compilation,ViewCompilingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ViewCompilingVisitor.cs,VisitView,The length of the statement  "            emitter.EmitSetDotvvmProperty(pageName' Internal.DataContextTypeProperty' emitter.EmitValue(view.DataContextTypeStack)); " is 120.
Long Statement,DotVVM.Framework.Compilation,ViewCompilingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ViewCompilingVisitor.cs,EmitCreateControl,The length of the statement  "            if (type.GetTypeInfo().GetCustomAttribute(typeof(DependencyInjection.RequireDependencyInjectionAttribute)) is DependencyInjection.RequireDependencyInjectionAttribute requireDiAttr) " is 180.
Long Statement,DotVVM.Framework.Compilation,ViewCompilingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ViewCompilingVisitor.cs,EmitCreateControl,The length of the statement  "                return emitter.EmitCreateObject(type' arguments == null ? optionalArguments.ToArray() : arguments.Concat(optionalArguments).ToArray()); " is 135.
Long Statement,DotVVM.Framework.Compilation,ViewCompilingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ViewCompilingVisitor.cs,VisitPropertyTemplate,The length of the statement  "            var methodName = DefaultViewCompilerCodeEmitter.BuildTemplateFunctionName + $"_{propertyTemplate.Property.DeclaringType.Name}_{propertyTemplate.Property.Name}_{currentTemplateIndex++}"; " is 185.
Long Statement,DotVVM.Framework.Compilation,ViewCompilingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ViewCompilingVisitor.cs,VisitPropertyTemplate,The length of the statement  "            emitter.PushNewMethod(methodName' typeof(void)' emitter.EmitControlBuilderParameters().Concat(new [] { emitter.EmitParameter("templateContainer"' typeof(DotvvmControl))}).ToArray()); " is 182.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingExpressionBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\BindingExpressionBuilder.cs,Parse,The length of the statement  "                        $"Unexpected token '{expression.Substring(0' parser.Peek().StartPosition)} ---->{parser.Peek().Text}<---- {expression.Substring(parser.Peek().EndPosition)}'"' " is 158.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingExpressionBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\BindingExpressionBuilder.cs,InitSymbols,The length of the statement  "            return AddTypeSymbols(TypeRegistry.Default.AddSymbols(GetParameters(dataContext).Select(d => new KeyValuePair<string' Expression>(d.Name' d)))' dataContext); " is 157.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingExpressionBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\BindingExpressionBuilder.cs,AddTypeSymbols,The length of the statement  "            .AddSymbols(namespaces.Select(ns => (Func<string' Expression>)(typeName => TypeRegistry.CreateStatic(ReflectionUtils.FindType(ns + "." + typeName))))); " is 151.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionBuildingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionBuildingVisitor.cs,ThrowOnErrors,The length of the statement  "                        || (currentErrors[0] is BindingCompilationException && (currentErrors[0] as BindingCompilationException).Tokens == null) " is 120.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionBuildingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionBuildingVisitor.cs,VisitConditionalExpression,The length of the statement  "            var condition = HandleErrors(node.ConditionExpression' n => TypeConversion.ImplicitConversion(Visit(n)' typeof(bool)' true)); " is 125.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionBuildingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionBuildingVisitor.cs,VisitMemberAccess,The length of the statement  "                var resolvedTypeExpression = Registry.Resolve(name' throwOnNotFound: false) ?? new UnknownStaticClassIdentifierExpression(name); " is 128.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionBuildingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionBuildingVisitor.cs,GetMemberOrTypeExpression,The length of the statement  "                : (ExpressionHelper.GetMember(Scope' node.Name' typeParameters' throwExceptions: false' onlyMemberTypes: ResolveOnlyTypeName) " is 125.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionBuildingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionBuildingVisitor.cs,GetMemberOrTypeExpression,The length of the statement  "            if (expr is ParameterExpression && expr.Type == typeof(ExpressionHelper.UnknownTypeSentinel)) throw new Exception($"Type of '{expr}' could not be resolved."); " is 158.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetMember,The length of the statement  "            if (type == typeof(UnknownTypeSentinel)) if (throwExceptions) throw new Exception($"Type of '{target}' could not be resolved."); else return null; " is 146.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetMember,The length of the statement  "                if (throwExceptions) throw new Exception($"Could not find { (isStatic ? "static" : "instance") } member { name } on type { type.FullName }."); " is 142.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,CallMethod,The length of the statement  "            // the following piece of code is nicer and more readable than method recognition done in roslyn' C# dynamic and also expression evaluator :) " is 141.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,CallMethod,The length of the statement  "            // the following piece of code is nicer and more readable than method recognition done in roslyn' C# dynamic and also expression evaluator :) " is 141.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,FindValidMethodOveloads,The length of the statement  "            var methods = FindValidMethodOveloads(type.GetAllMembers(flags).OfType<MethodInfo>().Where(m => m.Name == name)' typeArguments' arguments' namedArgs); " is 150.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,TryCallMethod,The length of the statement  "                        var arg = Array.FindIndex(parameters' p => p.ParameterType.IsGenericParameter && p.ParameterType.GenericParameterPosition == i); " is 128.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,EqualsMethod,The length of the statement  "                var m = CallMethod(equatable' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy' "Equals"' null' new[] { theOther }); " is 168.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,EqualsMethod,The length of the statement  "            return CallMethod(left' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy' "Equals"' null' new[] { right }); " is 159.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,CompareMethod,The length of the statement  "                return CallMethod(equatable' BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy' "Compare"' null' new[] { theOther }); " is 168.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,RewriteTaskSequence,The length of the statement  "                return Expression.Call(typeof(CommandTaskSequenceHelper)' nameof(CommandTaskSequenceHelper.JoinTasks)' new[] { rightTask.Type.GetGenericArguments()[0] }' left' Expression.Lambda(rightTask)); " is 190.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,RewriteTaskSequence,The length of the statement  "                return Expression.Call(typeof(CommandTaskSequenceHelper)' nameof(CommandTaskSequenceHelper.JoinTasks)' Type.EmptyTypes' left' Expression.Lambda(rightTask)); " is 156.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetIndexer,The length of the statement  "            if (indexProp.Length == 0) throw new Exception($"could not find and indexer property on type { expr.Type } that accepts { index.Type } as argument"); " is 149.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetIndexer,The length of the statement  "            if (indexProp.Length > 1) throw new Exception($"more than one indexer found on type { expr.Type } that accepts { index.Type } as argument"); " is 140.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionNullPropagationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionNullPropagationVisitor.cs,VisitBinary,The length of the statement  "                        return Expression.MakeBinary(node.NodeType' left' right' left.Type.IsNullable() && node.NodeType != ExpressionType.Equal && node.NodeType != ExpressionType.NotEqual' node.Method); " is 179.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionNullPropagationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionNullPropagationVisitor.cs,CheckForNulls,The length of the statement  "                cc = e => { list.Add(e); return CheckForNull(parameters[iCopy]' ccc' suppress: suppressThisOne?.Invoke(parameters[iCopy]' iCopy) ?? false); }; " is 142.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionNullPropagationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionNullPropagationVisitor.cs,CheckForNull,The length of the statement  "            if (suppress || parameter == null || (parameter.Type.GetTypeInfo().IsValueType && !parameter.Type.IsNullable()) || !checkReferenceTypes && !parameter.Type.GetTypeInfo().IsValueType) " is 181.
Long Statement,DotVVM.Framework.Compilation.Binding,ExpressionNullPropagationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionNullPropagationVisitor.cs,CheckForNull,The length of the statement  "                Expression.Condition(parameter.Type.IsNullable() ? (Expression)Expression.Property(p2' "HasValue") : Expression.NotEqual(p2' Expression.Constant(null' p2.Type))' " is 161.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,CompileToDelegate,The length of the statement  "            return Expression.Lambda<BindingDelegate>(expr' BindingCompiler.ViewModelsParameter' BindingCompiler.CurrentControlParameter); " is 126.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,ConvertExpressionToType,The length of the statement  "            var convertedExpr = TypeConversion.ImplicitConversion(expr.Expression' destType' throwException: false' allowToString: true); " is 125.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetExpression,The length of the statement  "            var expr = bindingParser.ParseWithLambdaConversion(originalString.Code' dataContext' options' expectedType?.Type ?? typeof(object)); " is 132.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,FormatSimplePath,The length of the statement  "            if (expression.Expression.DescendantNodes().Any(n => n.TryGetAnnotation(out ViewModelInfoAnnotation vmInfo) && vmInfo.ExtensionParameter is RestApiRegistrationHelpers.ApiExtensionParameter apiParameter)) " is 203.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,FormatJavascript,The length of the statement  "            expr = new JsParenthesizedExpression((JsExpression)JsTemporaryVariableResolver.ResolveVariables(expr.Expression.Detach())); " is 123.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,FormatJavascript,The length of the statement  "            return (StartsWithStatementLikeExpression(expr.Expression) ? expr : expr.Expression).FormatParametrizedScript(niceMode); " is 120.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetExpectedType,The length of the statement  "            return new ExpectedTypeBindingProperty(prop.IsBindingProperty ? (prop.PropertyType.GenericTypeArguments.SingleOrDefault() ?? typeof(object)) : prop.PropertyType); " is 162.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetAdditionalResolversFromProperty,The length of the statement  "                (prop.PropertyInfo?.GetCustomAttributes<BindingCompilationOptionsAttribute>() ?? Enumerable.Empty<BindingCompilationOptionsAttribute>()) " is 136.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetAdditionalResolversFromProperty,The length of the statement  "                .Concat(prop.PropertyInfo?.GetCustomAttributes<BindingCompilationRequirementsAttribute>() ?? Enumerable.Empty<BindingCompilationRequirementsAttribute>()) " is 153.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,CreateBindingId,The length of the statement  "                var bindingIndex = bindingCounts.GetOrCreateValue(resolvedBinding.TreeRoot).AddOrUpdate(dataContext' 0' (_' i) => i + 1); " is 121.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,NegateBinding,The length of the statement  "                    // Not' Equals and NotEquals are safe to optimize for both .NET and Javascript (if that the negated value was already a boolean) " is 128.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,NegateBinding,The length of the statement  "                    // but comparison operators are not safe to optimize as `null > 0` and `null <= 0` are both true on .NET (not JS' so it's possible to optimize this in the JsAST) " is 161.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,NegateBinding,The length of the statement  "                    // On the other hand it would not be possible to optimize Not(Not(...)) in the JsAST' because you can't be so sure about the type of the expression " is 147.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,NegateBinding,The length of the statement  "                    e.Expression.NodeType == ExpressionType.Equal ? e.Expression.CastTo<BinaryExpression>().UpdateType(ExpressionType.NotEqual) : " is 125.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,NegateBinding,The length of the statement  "                    e.Expression.NodeType == ExpressionType.NotEqual ? e.Expression.CastTo<BinaryExpression>().UpdateType(ExpressionType.Equal) : " is 125.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetDataSourceAccess,The length of the statement  "            if (typeof(IBaseGridViewDataSet).IsAssignableFrom(expression.Expression.Type) && !expression.Expression.Type.IsInterface) " is 121.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetDataSourceAccess,The length of the statement  "            else throw new NotSupportedException($"Can not make datasource from binding '{expression.Expression}' of type '{expression.Expression.Type}'."); " is 144.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetDataSourceLength,The length of the statement  "            if (expression.Expression.Type.Implements(typeof(ICollection)' out var ifc) || expression.Expression.Type.Implements(typeof(ICollection<>)' out ifc)) " is 149.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetDataSourceLength,The length of the statement  "                        Expression.Property(Expression.Property(expression.Expression' igridviewdataset.GetProperty(nameof(IBaseGridViewDataSet.Items)))' typeof(ICollection).GetProperty(nameof(ICollection.Count))) " is 189.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetDataSourceLength,The length of the statement  "                        Expression.Call(typeof(Enumerable)' "Count"' new [] { ReflectionUtils.GetEnumerableType(expression.Expression.Type) }'expression.Expression) " is 140.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetDataSourceCurrentElement,The length of the statement  "                    (Expression)Expression.Call(typeof(Enumerable).GetMethod("ElementAt"' BindingFlags.Public | BindingFlags.Static).MakeGenericMethod(ienumerable.GetGenericArguments())' expression.Expression' indexParameter()) : " is 209.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetDataSourceCurrentElement,The length of the statement  "                    new ParsedExpressionBindingProperty(makeIndexer(Expression.Property(expression.Expression' nameof(IBaseGridViewDataSet.Items)))))); " is 131.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetDataSourceCurrentElement,The length of the statement  "            else throw new NotSupportedException($"Can not access current element on binding '{expression.Expression}' of type '{expression.Expression.Type}'."); " is 149.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetThisBinding,The length of the statement  "                new ParsedExpressionBindingProperty(Expression.Parameter(stack.DataContextType' "_this").AddParameterAnnotation(new BindingParameterAnnotation(stack))) " is 151.
Long Statement,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,GetCollectionElementDataContext,The length of the statement  "                extensionParameters: new CollectionElementDataContextChangeAttribute(0).GetExtensionParameters(new ResolvedTypeDescriptor(dataContext.DataContextType)).ToArray() " is 161.
Long Statement,DotVVM.Framework.Compilation.Binding,MethodGroupExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\MethodGroupExpression.cs,CreateDelegateExpression,The length of the statement  "            if (!typeof(Delegate).IsAssignableFrom(delegateType)) if (throwException) throw new Exception("Could not convert method group expression to a non delegate type."); else return null; " is 181.
Long Statement,DotVVM.Framework.Compilation.Binding,MethodGroupExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\MethodGroupExpression.cs,CreateDelegateExpression,The length of the statement  "                .FirstOrDefault(m => m.Name == MethodName && m.GetParameters().Select(p => p.ParameterType).SequenceEqual(args) && m.ReturnType == invokeMethod.ReturnType); " is 156.
Long Statement,DotVVM.Framework.Compilation.Binding,MethodGroupExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\MethodGroupExpression.cs,CreateDelegateExpression,The length of the statement  "                if (throwException) throw new Exception($"Could not convert method group '{Target.Type.Name}.{ MethodName }' to delegate '{ delegateType.FullName }'"); " is 151.
Long Statement,DotVVM.Framework.Compilation.Binding,MethodGroupExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\MethodGroupExpression.cs,CreateDelegateExpression,The length of the statement  "                return Expression.Call(CreateDelegateMethodInfo' Expression.Constant(delegateType)' Target' Expression.Constant(method)) " is 120.
Long Statement,DotVVM.Framework.Compilation.Binding,MethodGroupExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\MethodGroupExpression.cs,CreateDelegateExpression,The length of the statement  "            if (methodInfo == null) throw new Exception($"can not create delegate from method '{ MethodName }' on type '{ Target.Type.FullName }'"); " is 136.
Long Statement,DotVVM.Framework.Compilation.Binding,MethodGroupExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\MethodGroupExpression.cs,CreateDelegateExpression,The length of the statement  "                return Expression.Call(CreateDelegateMethodInfo' Expression.Constant(delegateType)' Target' Expression.Constant(methodInfo)) " is 124.
Long Statement,DotVVM.Framework.Compilation.Binding,MethodGroupExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\MethodGroupExpression.cs,CreateMethodCall,The length of the statement  "                return ExpressionHelper.CallMethod((Target as StaticClassIdentifierExpression).Type' BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy' MethodName' TypeArgs' argsArray); " is 193.
Long Statement,DotVVM.Framework.Compilation.Binding,MethodGroupExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\MethodGroupExpression.cs,CreateMethodCall,The length of the statement  "                return ExpressionHelper.CallMethod(Target' BindingFlags.Instance | BindingFlags.Public | BindingFlags.FlattenHierarchy' MethodName' TypeArgs' argsArray); " is 153.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                    defaultAssignment: new JsIdentifierExpression("ko").Member("contextFor").Invoke(new JsSymbolicParameter(CommandBindingExpression.SenderElementParameter)).FormatParametrizedScript() " is 180.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "            var senderVariable = new JsTemporaryVariableParameter(new JsSymbolicParameter(CommandBindingExpression.SenderElementParameter)); " is 128.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                    if (javascriptTranslator.TryTranslateMethodCall(methodCall.Object' methodCall.Arguments.ToArray()' methodCall.Method' dataContext) is JsExpression jsTranslation) " is 161.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                            return (p => new BindingParameterAnnotation(extensionParameter: new JavascriptTranslationVisitor.FakeExtensionParameter(_ => new JsIdentifierExpression(p.Name).WithAnnotations(promiseAnnotation.ResultAnnotations)' p.Name' new ResolvedTypeDescriptor(p.Type)))); " is 260.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                    return p => new BindingParameterAnnotation(extensionParameter: new JavascriptTranslationVisitor.FakeExtensionParameter(_ => new JsIdentifierExpression(p.Name).WithAnnotation(new ViewModelInfoAnnotation(p.Type))' p.Name' new ResolvedTypeDescriptor(p.Type))); " is 257.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "            var js = SouldCompileCallback(rootCallback) ? new JsIdentifierExpression("resolve").Invoke(javascriptTranslator.CompileToJavascript(rootCallback' dataContext)) : null; " is 167.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                var replacedNode = js.DescendantNodes().SingleOrDefault(n => n is JsIdentifierExpression identifier && identifier.Identifier == param.Name); " is 140.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                var callback = new JsFunctionExpression(new[] { new JsIdentifier(param.Name) }' new JsBlockStatement(new JsExpressionStatement(js))); " is 133.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                    methodInvocation is JsInvocationExpression invocation && invocation.Target.ToString() == "dotvvm.staticCommandPostback" ? " is 121.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                                c.parameter == null ? (JsStatement)c.node : new JsExpressionStatement(new JsAssignmentExpression(new JsSymbolicParameter(c.parameter)' (JsExpression)c.node)) " is 157.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                else if (sp.Symbol == JavascriptTranslator.KnockoutViewModelParameter) sp.ReplaceWith(new JsSymbolicParameter(currentContextVariable).Member("$data")); " is 151.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The length of the statement  "                if (js is JsInvocationExpression invocation && invocation.Target is JsIdentifierExpression identifier && identifier.Identifier == "resolve") " is 140.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileMethodCall,The length of the statement  "            var jsTranslation = javascriptTranslator.TryTranslateMethodCall(methodExpression.Object' methodExpression.Arguments.ToArray()' methodExpression.Method' dataContext) " is 164.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileMethodCall,The length of the statement  "                throw new Exception($"Method '{methodExpression.Method.DeclaringType.Name}.{methodExpression.Method.Name}' used in static command has to be marked with [AllowStaticCommand] attribute."); " is 186.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileMethodCall,The length of the statement  "                .Invoke(new JsSymbolicParameter(CommandBindingExpression.ViewModelNameParameter)' new JsSymbolicParameter(CommandBindingExpression.SenderElementParameter)' new JsLiteral(encryptedPlan)' new JsArrayExpression(args)' callbackFunction' errorCallback) " is 247.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CreateExecutionPlan,The length of the statement  "            var arguments = (expression.Object == null ? new Expression[0] : new[] { expression.Object }).Concat(expression.Arguments).ToArray(); " is 133.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CreateExecutionPlan,The length of the statement  "                if (arg.GetParameterAnnotation() is BindingParameterAnnotation annotation && annotation.ExtensionParameter is InjectedServiceExtensionParameter service) " is 152.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CreateExecutionPlan,The length of the statement  "                    return new StaticCommandParameterPlan(StaticCommandParameterType.Inject' ResolvedTypeDescriptor.ToSystemType(service.ParameterType)); " is 133.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,DeserializePlan,The length of the statement  "                .Select((a' i) => (type: a' arg: jarray.Count <= i + 4 ? JValue.CreateNull() : jarray[i + 4]' parameter: (methodFound.IsStatic ? methodParameters[i] : (i == 0 ? null : methodParameters[i - 1])))) " is 195.
Long Statement,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,DecryptJson,The length of the statement  "            using (var reader = new JsonTextReader(new StreamReader(new MemoryStream(protector.Unprotect(data' GetEncryptionPurposes()))))) " is 127.
Long Statement,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,NullableConversion,The length of the statement  "                if (liftedConverted != null && liftedConverted.NodeType == ExpressionType.Convert && liftedConverted.CastTo<UnaryExpression>().Operand == srcLift) " is 146.
Long Statement,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,ImplicitConversion,The length of the statement  "            if (throwException && result == null) throw new InvalidOperationException($"Could not implicitly convert expression of type { src.Type } to { destType }."); " is 156.
Long Statement,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,IsStringConversionAllowed,The length of the statement  "			return fromType.GetTypeInfo().IsPrimitive || typeof(IConvertible).IsAssignableFrom(fromType) || fromType.GetTypeInfo().GetMethod("ToString"' Type.EmptyTypes)?.DeclaringType != typeof(object); " is 191.
Long Statement,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,ToStringConversion,The length of the statement  "                    toStringMethod != null ? toStringMethod.Invoke(constant.Value' new object[0]) : System.Convert.ToString(constant.Value)' " is 120.
Long Statement,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,ImplicitConstantConversion,The length of the statement  "            //	A constant-expression (7.19) of type int can be converted to type sbyte' byte' short' ushort' uint' or ulong' provided the value of the constant-expression is within the range of the destination type. " is 204.
Long Statement,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,ImplicitConstantConversion,The length of the statement  "            //	A constant-expression of type long can be converted to type ulong' provided the value of the constant-expression is not negative. " is 132.
Long Statement,DotVVM.Framework.Compilation.ControlTree,CurrentMarkupControlExtensionParameter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\BindingExtensionParameter.cs,GetServerEquivalent,The length of the statement  "            return Expression.Convert(ExpressionUtils.Replace((DotvvmBindableObject c) => c.GetClosestControlBindingTarget()' controlParameter)' ResolvedTypeDescriptor.ToSystemType(ParameterType)); " is 185.
Long Statement,DotVVM.Framework.Compilation.ControlTree,CurrentMarkupControlExtensionParameter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\BindingExtensionParameter.cs,GetJsTranslation,The length of the statement  "            return dataContext.Member("$control").WithAnnotation(new ViewModelInfoAnnotation(ResolvedTypeDescriptor.ToSystemType(this.ParameterType)' isControl: true)); " is 156.
Long Statement,DotVVM.Framework.Compilation.ControlTree,BindingPageInfoExtensionParameter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\BindingExtensionParameter.cs,GetJsTranslation,The length of the statement  "                new JsObjectProperty(nameof(BindingPageInfo.IsPostbackRunning)' new JsIdentifierExpression("dotvvm").Member("isPostbackRunning").Invoke()) " is 138.
Long Statement,DotVVM.Framework.Compilation.ControlTree,BindingCollectionInfoExtensionParameter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\BindingExtensionParameter.cs,GetJsTranslation,The length of the statement  "                new JsObjectProperty(nameof(BindingCollectionInfo.IsFirst)' new JsBinaryExpression(index()' BinaryOperatorType.Equal' new JsLiteral(0)))' " is 137.
Long Statement,DotVVM.Framework.Compilation.ControlTree,BindingCollectionInfoExtensionParameter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\BindingExtensionParameter.cs,GetJsTranslation,The length of the statement  "                new JsObjectProperty(nameof(BindingCollectionInfo.IsOdd)' new JsBinaryExpression(new JsBinaryExpression(index()' BinaryOperatorType.Modulo' new JsLiteral(2))' BinaryOperatorType.Equal' new JsLiteral(1)))' " is 204.
Long Statement,DotVVM.Framework.Compilation.ControlTree,BindingCollectionInfoExtensionParameter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\BindingExtensionParameter.cs,GetJsTranslation,The length of the statement  "                new JsObjectProperty(nameof(BindingCollectionInfo.IsEven)' new JsBinaryExpression(new JsBinaryExpression(index()' BinaryOperatorType.Modulo' new JsLiteral(2))' BinaryOperatorType.Equal' new JsLiteral(0))) " is 204.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlResolverBase.cs,FindControlType,The length of the statement  "			throw new Exception($"The control <{tagPrefix}:{tagName}> could not be resolved! Make sure that the tagPrefix is registered in DotvvmConfiguration.Markup.Controls collection!"); " is 177.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlResolverMetadata,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlResolverMetadata.cs,LoadProperties,The length of the statement  "            foreach (var property in DotvvmProperty.ResolveProperties(controlType.Type).Concat(DotvvmProperty.GetVirtualProperties(controlType.Type))) " is 138.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeHelper.cs,GetPropertyGroupMember,The length of the statement  "            if (group == null) throw new NotSupportedException($"Control { metadata.Type.Name } does not support property group with prefix '{prefix}'."); " is 142.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ResolveTree,The length of the statement  "            // We need to call BuildControlMetadata instead of ResolveControl. The control builder for the control doesn't have to be compiled yet so the " is 141.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ResolveTree,The length of the statement  "            // metadata would be incomplete and ResolveControl caches them internally. BuildControlMetadata just builds the metadata and the control is " is 139.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ResolveTree,The length of the statement  "            var dataContextTypeStack = CreateDataContextTypeStack(viewModelType' null' namespaceImports' new BindingExtensionParameter[] { " is 126.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ResolveRootContent,The length of the statement  "            // if there is a control in root of a MarkupControl that has DataContext assigned' it will not find the data context space' because the space of DataContext property does not include the control itself and the space of MarkupControl also does not include the MarkupControl. And because the MarkupControl is a direct parent of the DataContext-bound control there is no space in between. " is 385.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ResolveViewModelType,The length of the statement  "            if (!directives.ContainsKey(ParserConstants.ViewModelDirectiveName) || directives[ParserConstants.ViewModelDirectiveName].Count == 0) " is 133.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "            var controlMetadata = controlResolver.ResolveControl(element.TagPrefix' element.TagName' out var constructorParameters); " is 120.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "                element.AddError($"The control <{element.FullTagName}> could not be resolved! Make sure that the tagPrefix is registered in DotvvmConfiguration.Markup.Controls collection!"); " is 174.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "            if (control.TryGetProperty(DotvvmBindableObject.DataContextProperty' out dataContextProperty) && dataContextProperty is IAbstractPropertyBinding) " is 145.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "            if (controlMetadata.DataContextConstraint != null && dataContext != null && !controlMetadata.DataContextConstraint.IsAssignableFrom(dataContext.DataContextType)) " is 161.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "                   .AddError($"The control '{controlMetadata.Type.Name}' requires a DataContext of type '{controlMetadata.DataContextConstraint.FullName}'!"); " is 139.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "            ProcessAttributeProperties(control' element.Attributes.Where(a => a.AttributeName != "DataContext").ToArray()' dataContext); " is 124.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "            var missingProperties = control.Metadata.AllProperties.Where(p => p.MarkupOptions.Required && !control.TryGetProperty(p' out missingProperty)).ToList(); " is 152.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "                element.AddError($"The control '{ control.Metadata.Type.FullName }' is missing required properties: { string.Join("' "' missingProperties.Select(p => "'" + p.Name + "'")) }."); " is 176.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "            var unknownContent = control.Content.Where(c => !c.Metadata.Type.IsAssignableTo(new ResolvedTypeDescriptor(typeof(DotvvmControl)))); " is 132.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessObjectElement,The length of the statement  "                unknownControl.DothtmlNode.AddError($"The control '{ unknownControl.Metadata.Type.FullName }' does not inherit from DotvvmControl and thus cannot be used in content."); " is 168.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessDirective,The length of the statement  "            if (string.Equals(ParserConstants.ImportNamespaceDirective' directiveNode.Name) || string.Equals(ParserConstants.ResourceNamespaceDirective' directiveNode.Name)) " is 161.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessServiceInjectDirective,The length of the statement  "                directiveNode.AddError($"Assignment operation expected - the correct form is `@{ParserConstants.ServiceInjectDirective} myStringService = ISomeService<string>`"); " is 162.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessServiceInjectDirective,The length of the statement  "                return treeBuilder.BuildServiceInjectDirective(directiveNode' new SimpleNameBindingParserNode("service")' valueSyntaxRoot); " is 123.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttributeProperties,The length of the statement  "            string getName(DothtmlAttributeNode n) => n.AttributePrefix == null ? n.AttributeName : n.AttributePrefix + ":" + n.AttributeName; " is 130.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttributeProperties,The length of the statement  "                    attribute.AddError($"The control '{control.Metadata.Type}' does not have a property '{attribute.AttributeName}' and does not allow HTML attributes!"); " is 150.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttribute,The length of the statement  "        if (property.IsBindingProperty || property.DataContextManipulationAttribute != null) // when DataContextManipulationAttribute is set' lets hope that author knows what is he doing. " is 179.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttribute,The length of the statement  "                if (property.PropertyType.IsEqualTo(new ResolvedTypeDescriptor(typeof(bool))) || property.PropertyType.IsEqualTo(new ResolvedTypeDescriptor(typeof(bool?)))) " is 156.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttribute,The length of the statement  "                    if (!treeBuilder.AddProperty(control' treeBuilder.BuildPropertyValue(property' true' attribute)' out error)) attribute.AddError(error); " is 135.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttribute,The length of the statement  "                    if (!treeBuilder.AddProperty(control' treeBuilder.BuildPropertyValue(property' (property as DotVVM.Framework.Binding.DotvvmProperty)?.DefaultValue' attribute)' out error)) attribute.AddError(error); " is 198.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttribute,The length of the statement  "                else attribute.AddError($"The attribute '{property.Name}' on the control '{control.Metadata.Type.FullName}' must have a value!"); " is 129.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessAttribute,The length of the statement  "                    attribute.ValueNode.AddError($"The property '{ property.FullName }' cannot contain bindings because it's not DotvvmProperty."); " is 127.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessControlContent,The length of the statement  "                    if (property != null && string.IsNullOrEmpty(element.TagPrefix) && property.MarkupOptions.MappingMode.HasFlag(MappingMode.InnerElement)) " is 136.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessControlContent,The length of the statement  "                        if (!treeBuilder.AddProperty(control' ProcessElementProperty(control' property' element.Content' element)' out error)) element.AddError(error); " is 143.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessControlContent,The length of the statement  "                    if (!treeBuilder.AddProperty(control' ProcessElementProperty(control' control.Metadata.DefaultContentProperty' content' null)' out error)) " is 138.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessElementProperty,The length of the statement  "                                c.DothtmlNode.AddError($"Control type {c.Metadata.Type.FullName} can't be used in collection of type {type.FullName}."); " is 120.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessElementProperty,The length of the statement  "                return treeBuilder.BuildPropertyTemplate(property' ProcessTemplate(control' elementContent' dataContext)' propertyWrapperElement); " is 130.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessElementProperty,The length of the statement  "                var collection = elementContent.Select(childObject => ProcessNode(control' childObject' control.Metadata' dataContext)); " is 120.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessElementProperty,The length of the statement  "                var children = filterByType(property.PropertyType' elementContent.Select(childObject => ProcessNode(control' childObject' control.Metadata' dataContext))).ToArray(); " is 165.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ProcessTemplate,The length of the statement  "            var content = elementContent.Select(e => ProcessNode(parent' e' placeholderMetadata.Value' dataContext)).Where(e => e != null); " is 127.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,FilterNodes,The length of the statement  "                    child.AddError($"Content is not allowed inside the property '{property.FullName}'! (Conflicting node: Node {child.GetType().Name})"); " is 133.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,ResolveWrapperType,The length of the statement  "                    baseControlDirective.DothtmlNode.AddError($"The type '{baseControlDirective.Value}' specified in baseType directive was not found!"); " is 133.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,GetDataContextChange,The length of the statement  "            var manipulationAttribute = property != null ? property.DataContextManipulationAttribute : control.Metadata.DataContextManipulationAttribute; " is 141.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,GetDataContextChange,The length of the statement  "                return manipulationAttribute.ChangeStackForChildren(dataContext' control' property' (parent' changeType) => CreateDataContextTypeStack(changeType' parentDataContextStack: parent)); " is 180.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,GetDataContextChange,The length of the statement  "            var attributes = property != null ? property.DataContextChangeAttributes : control.Metadata.DataContextChangeAttributes; " is 120.
Long Statement,DotVVM.Framework.Compilation.ControlTree,ControlTreeResolverBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlTreeResolverBase.cs,GetDataContextChange,The length of the statement  "                else return CreateDataContextTypeStack(type' parentDataContextStack: dataContext' extensionParameters: extensionParameters.ToArray()); " is 134.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,GetCurrentExtensionParameters,The length of the statement  "                foreach (var p in current.ExtensionParameters.Where(p => blackList.Add(p.Identifier) && (current == this || p.Inherit))) " is 120.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,ToString,The length of the statement  "                this.ExtensionParameters.Any() ? "ext=[" + string.Join("' "' this.ExtensionParameters.Select(e => e.Identifier + ": " + e.ParameterType.Name)) + "]" : null' " is 156.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,ToString,The length of the statement  "                this.BindingPropertyResolvers.Any() ? "resolvers=[" + string.Join("' "' this.BindingPropertyResolvers.Select(s => s.Method)) + "]" : null' " is 138.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DefaultControlResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DefaultControlResolver.cs,InvokeStaticConstructorsOnAllControls,The length of the statement  "            // PERF: too many allocations - type.GetCustomAttribute<T> does ~220k allocs -> 4MB' get all types allocates additional 1.5MB " is 125.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DefaultControlResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DefaultControlResolver.cs,InvokeStaticConstructorsOnAllControls,The length of the statement  "                .SelectRecursively(a => a.GetReferencedAssemblies().Where(an => visitedAssemblies.Add(an.FullName)).Select(an => Assembly.Load(an))) " is 132.
Long Statement,DotVVM.Framework.Compilation.ControlTree,LifecycleRequirementsAssigningVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\LifecycleRequirementsAssigningVisitor.cs,VisitControl,The length of the statement  "                               .Select(c => c.GetValue(CompileTimeLifecycleRequirementsProperty).As<ResolvedPropertyValue>()?.Value as ControlLifecycleRequirements? ?? ControlLifecycleRequirements.None) " is 171.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DotvvmPropertyGroup,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\PropertyGroupDescriptor.cs,GetValueType,The length of the statement  "            throw new NotSupportedException($"Could not initialize {declaringType.Name} as property group collection - no suitable constructor found"); " is 139.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DotvvmPropertyGroup,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\PropertyGroupDescriptor.cs,Register,The length of the statement  "                if (field == null) throw new InvalidOperationException($"Could not declare property group '{fullName}' because backing field was not found."); " is 142.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DotvvmPropertyGroup,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\PropertyGroupDescriptor.cs,GetPropertyGroups,The length of the statement  "            foreach (var property in controlType.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.FlattenHierarchy)) " is 128.
Long Statement,DotVVM.Framework.Compilation.ControlTree,DotvvmPropertyGroup,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\PropertyGroupDescriptor.cs,GetPropertyGroups,The length of the statement  "                if (pg.PropertyGroupMode == PropertyGroupMode.GeneratedDotvvmProperty && pg.DeclaringType.IsAssignableFrom(controlType)) " is 120.
Long Statement,DotVVM.Framework.Compilation.ControlTree,TypeDescriptorUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\TypeDescriptorUtils.cs,GetCollectionItemType,The length of the statement  "                return itemsType.TryGetArrayElementOrIEnumerableType() ?? throw new Exception("This is strange and should not happen. IBaseGridViewDataSet.Items is not IEnumerable."); " is 167.
Long Statement,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedControl.cs,SetProperty,The length of the statement  "                if (!value.Property.MarkupOptions.AllowValueMerging) error = $"Property '{value.Property}' is already set and it's value can't be merged."; " is 139.
Long Statement,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedTreeBuilder.cs,BuildBinding,The length of the statement  "            return new ResolvedBinding(bindingService' bindingOptions' (DataContextStack)dataContext' node.Value' property: property as DotvvmProperty) { " is 141.
Long Statement,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedTreeBuilder.cs,BuildPropertyBinding,The length of the statement  "            return new ResolvedPropertyBinding((DotvvmProperty)property' (ResolvedBinding)binding) { DothtmlNode = sourceAttribute }; " is 121.
Long Statement,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedTreeBuilder.cs,BuildPropertyControl,The length of the statement  "            return new ResolvedPropertyControl((DotvvmProperty)property' (ResolvedControl)control) { DothtmlNode = wrapperElement }; " is 120.
Long Statement,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedTreeBuilder.cs,BuildPropertyControlCollection,The length of the statement  "            return new ResolvedPropertyControlCollection((DotvvmProperty)property' controls.Cast<ResolvedControl>().ToList()) { DothtmlNode = wrapperElement }; " is 147.
Long Statement,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedTreeBuilder.cs,BuildPropertyTemplate,The length of the statement  "            return new ResolvedPropertyTemplate((DotvvmProperty)property' templateControls.Cast<ResolvedControl>().ToList()) { DothtmlNode = wrapperElement }; " is 146.
Long Statement,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedTreeBuilder.cs,BuildServiceInjectDirective,The length of the statement  "            foreach (var syntaxNode in nameSyntax.EnumerateNodes().Concat(typeSyntax?.EnumerateNodes() ?? Enumerable.Empty<BindingParserNode>())) " is 133.
Long Statement,DotVVM.Framework.Compilation.ControlTree.Resolved,ResolvedTreeBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\Resolved\ResolvedTreeBuilder.cs,BuildImportDirective,The length of the statement  "            foreach (var syntaxNode in nameSyntax.EnumerateNodes().Concat(aliasSyntax?.EnumerateNodes() ?? Enumerable.Empty<BindingParserNode>())) " is 134.
Long Statement,DotVVM.Framework.Compilation.Javascript.Ast,JsAstHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\JsAstHelpers.cs,EnsureObservableWrapped,The length of the statement  "            if (!expression.DescendantNodes().Any(n => (n.HasAnnotation<ResultIsObservableAnnotation>() && !n.HasAnnotation<ShouldBeObservableAnnotation>()) || n.HasAnnotation<ObservableUnwrapInvocationAnnotation>())) " is 205.
Long Statement,DotVVM.Framework.Compilation.Javascript.Ast,JsAstHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\JsAstHelpers.cs,EnsureObservableWrapped,The length of the statement  "                        bodyBlock: new JsBlockStatement(new JsReturnStatement(expression.WithAnnotation(ShouldBeObservableAnnotation.Instance))) " is 120.
Long Statement,DotVVM.Framework.Compilation.Javascript.Ast,JsNode,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\JsNode.cs,ReplaceWith,The length of the statement  "                throw new ArgumentException($"The new node '{newNode.GetType().Name}' is not valid in the role {this.Role.ToString()}"' "newNode"); " is 131.
Long Statement,DotVVM.Framework.Compilation.Javascript.Ast,JsNode,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\JsNode.cs,ReplaceWith,The length of the statement  "                    throw new InvalidOperationException(string.Format("The new node '{0}' is not valid in the role {1}"' replacement.GetType().Name' oldRole.ToString())); " is 150.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptCompilationHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptCompilationHelper.cs,GetResultType,The length of the statement  "            else if (expr is JsAssignmentExpression assignment && assignment.Operator == null) return GetResultType(assignment.Right); " is 122.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptCompilationHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptCompilationHelper.cs,GetResultType,The length of the statement  "            else if (expr is JsBinaryExpression binary && (binary.Operator == BinaryOperatorType.ConditionalAnd || binary.Operator == BinaryOperatorType.ConditionalOr)) " is 156.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptCompilationHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptCompilationHelper.cs,GetResultType,The length of the statement  "            else if (expr is JsLiteral literal) return literal.Value != null ? new ViewModelInfoAnnotation(literal.Value.GetType()' containsObservables: false) : null; " is 155.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptNullCheckAdder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptNullCheckAdder.cs,VisitInvocationExpression,The length of the statement  "            ProcessTargetedExpression(invocationExpression' invocationExpression.Arguments.Count == 0 ? new JsIdentifierExpression("eval") : null); " is 135.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptNullCheckAdder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptNullCheckAdder.cs,CreateNullCondition,The length of the statement  "                return new JsConditionalExpression(new JsBinaryExpression(target' BinaryOperatorType.Equal' new JsLiteral(null))' new JsLiteral(null)' expression); " is 147.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptNullCheckAdder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptNullCheckAdder.cs,IntroduceVariableFor,The length of the statement  "                              expression is JsInvocationExpression invocation && invocation.Arguments.Count == 0 && invocation.HasAnnotation<ObservableUnwrapInvocationAnnotation>())) " is 152.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptNullCheckAdder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptNullCheckAdder.cs,GetDependentAncestorNode,The length of the statement  "            while (expr.Parent is JsExpression parent && !expr.HasAnnotation<MayBeNullAnnotation>() && expr.Role == JsTreeRoles.TargetExpression) " is 133.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddMethodTranslator,The length of the statement  "                    return mp.Length == parameters.Length && parameters.Zip(mp' (specified' method) => method.ParameterType.IsAssignableFrom(specified)).All(t => t); " is 145.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "            AddMethodTranslator(typeof(Enumerable)' "Count"' parameterCount: 1' translator: new GenericMethodCompiler(a => a[1].Member("length"))); " is 135.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "            AddMethodTranslator(typeof(Enumerable).GetMethod("ElementAt"' BindingFlags.Static | BindingFlags.Public)' new GenericMethodCompiler((args' method) => " is 149.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "                args => new JsIdentifierExpression("dotvvm").Member("globalize").Member("format").Invoke(args[1]' new JsArrayExpression(args.Skip(2))) " is 134.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "            AddMethodTranslator(typeof(string).GetMethod("Format"' new[] { typeof(string)' typeof(object) })' stringFormatTranslator); " is 122.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "            AddMethodTranslator(typeof(string).GetMethod("Format"' new[] { typeof(string)' typeof(object)' typeof(object) })' stringFormatTranslator); " is 138.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "            AddMethodTranslator(typeof(string).GetMethod("Format"' new[] { typeof(string)' typeof(object)' typeof(object)' typeof(object) })' stringFormatTranslator); " is 154.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "            AddMethodTranslator(typeof(string).GetMethod("Format"' new[] { typeof(string)' typeof(object[]) })' new GenericMethodCompiler( " is 126.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "                AddMethodTranslator(typeof(Nullable<>).MakeGenericType(num).GetMethod("ToString"' Type.EmptyTypes)' new GenericMethodCompiler( " is 126.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "            AddPropertyGetterTranslator(typeof(Task<>)' "Result"' new GenericMethodCompiler(args => FunctionalExtensions.ApplyAction(args[0]' a => a.RemoveAnnotations(typeof(ViewModelInfoAnnotation))))); " is 191.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "            AddMethodTranslator(typeof(DotvvmBindableObject).GetMethods(BindingFlags.Instance | BindingFlags.Public).Single(m => m.Name == "GetValue" && !m.ContainsGenericParameters)' new GenericMethodCompiler( " is 198.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The length of the statement  "                    return JavascriptTranslationVisitor.TranslateViewModelProperty(args[0]' (MemberInfo)dotvvmproperty.PropertyInfo ?? dotvvmproperty.PropertyType.GetTypeInfo()' name: dotvvmproperty.Name); " is 185.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,TryTranslateCall,The length of the statement  "                if (MethodTranslators.TryGetValue(method' out var translator) && translator.TryTranslateCall(context' args' method) is JsExpression result) " is 139.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,TryTranslateCall,The length of the statement  "                if (MethodTranslators.TryGetValue(genericMethod' out var translator) && translator.TryTranslateCall(context' args' method) is JsExpression result) " is 146.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,TryTranslateCall,The length of the statement  "                    if (imIndex >= 0 && MethodTranslators.TryGetValue(map.InterfaceMethods[imIndex]' out var translator) && translator.TryTranslateCall(context' args' method) is JsExpression result) " is 178.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,TryTranslateCall,The length of the statement  "                var m2 = typeof(Array).GetMethod(method.Name' BindingFlags.Instance | BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public); " is 138.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,ReplaceVariables,The length of the statement  "            return ExpressionUtils.Replace(Expression.Lambda(node' variables)' args.Zip(variables' (o' a) => Expression.Parameter(a.Type' a.Name).AddParameterAnnotation( " is 157.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,ReplaceVariables,The length of the statement  "                new BindingParameterAnnotation(extensionParameter: new FakeExtensionParameter(_ => new JsSymbolicParameter(o)' a.Name' new ResolvedTypeDescriptor(a.Type))) " is 155.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateLambda,The length of the statement  "            var (body' additionalVariables' additionalVarNames) = TranslateLambdaBody(ReplaceVariables(expression.Body' expression.Parameters' args)); " is 138.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateLambda,The length of the statement  "            var usedNames = new HashSet<string>(body.DescendantNodesAndSelf().OfType<JsIdentifierExpression>().Select(i => i.Identifier)); " is 126.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateLambda,The length of the statement  "            var argsNames = expression.Parameters.Select(p => JsTemporaryVariableResolver.GetNames(p.Name).First(usedNames.Add)).ToArray(); " is 127.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateLambda,The length of the statement  "            additionalVarNames = additionalVarNames.Select(p => JsTemporaryVariableResolver.GetNames(p).First(usedNames.Add)).ToArray(); " is 124.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateLambdaBody,The length of the statement  "                        expressions.Take(expressions.Length - 1).Select(e => (JsStatement)new JsExpressionStatement(e)).Concat(new[] { new JsReturnStatement(expressions.Last()) }).ToArray() " is 165.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateAssign,The length of the statement  "                return TryTranslateMethodCall((property.Member as PropertyInfo)?.SetMethod' property.Expression' new[] { expression.Right }) ?? " is 127.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateAssign,The length of the statement  "                if (annotation.ExtensionParameter == null) throw new NotSupportedException($"Can not assign to data context parameter {expression.Left}"); " is 138.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateParameter,The length of the statement  "                    .WithAnnotation(new ViewModelInfoAnnotation(annotation.ExtensionParameter.ParameterType.Apply(ResolvedTypeDescriptor.ToSystemType)' extensionParameter: annotation.ExtensionParameter)' append: false); " is 199.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateParameter,The length of the statement  "                    return new JsSymbolicParameter(JavascriptTranslator.KnockoutViewModelParameter).WithAnnotation(new ViewModelInfoAnnotation(expression.Type)); " is 141.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateParameter,The length of the statement  "            if (WriteUnknownParameters && !string.IsNullOrEmpty(expression.Name)) return new JsIdentifierExpression(expression.Name); " is 121.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateMethodCall,The length of the statement  "                throw new NotSupportedException($"Method { expression.Method.DeclaringType.Name }.{ expression.Method.Name } can not be translated to Javascript"); " is 147.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateBinary,The length of the statement  "                case ExpressionType.ArrayIndex: return new JsIndexerExpression(left' right).WithAnnotation(ResultIsObservableAnnotation.Instance); " is 130.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateBinary,The length of the statement  "            if (mayInduceDecimals && ReflectionUtils.IsNumericType(expression.Type) && expression.Type != typeof(float) && expression.Type != typeof(double) && expression.Type != typeof(decimal)) " is 183.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslator.cs,TryTranslateMethodCall,The length of the statement  "            return new JavascriptTranslationVisitor(dataContext' DefaultMethodTranslator).TryTranslateMethodCall(method' context' arguments); " is 129.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslator.cs,AdjustKnockoutScriptContext,The length of the statement  "            var (context' data) = (CodeParameterAssignment.FromExpression(contextExpresion)' CodeParameterAssignment.FromExpression(dataExpression)); " is 137.
Long Statement,DotVVM.Framework.Compilation.Javascript,JavascriptTranslator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslator.cs,FormatKnockoutScript,The length of the statement  "            if (dataVariable == null) dataVariable = new ParametrizedCode.Builder { contextVariable' ".$data" }.Build(OperatorPrecedence.Max); " is 130.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsFormattingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsFormattingVisitor.cs,SpaceBeforeOp,The length of the statement  "            if (result.Length > 0 && op.Length > 0 && parameters?.LastOrDefault().index != result.Length && IsDangerousTuple(result[result.Length - 1]' op.First())) " is 152.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,IsPreferedSide,The length of the statement  "                    // associativity' it is important to avoid common string concat patterns (((a+b)+c)+d)+e). Be aware JS + is not associative - (""+3+5)==="35" vs (""+(3+5))==="8" " is 161.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,GetOperatorPrecedence,The length of the statement  "            if (expression.Role == JsTreeRoles.Argument && expression is JsBinaryExpression binary && binary.Operator == BinaryOperatorType.Sequence) " is 137.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsTemporaryVariableResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsTemporaryVariableResolver.cs,ResolveVariables,The length of the statement  "                        allVariables[parameter] = (Math.Min(currentInterval.from' eulerPath.IndexOf((symExpr' true)))' Math.Max(currentInterval.to' eulerPath.IndexOf((symExpr' false)))); " is 162.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsTemporaryVariableResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsTemporaryVariableResolver.cs,ResolveVariables,The length of the statement  "                    else allVariables.Add(parameter' (parameter.Initializer == null ? eulerPath.IndexOf((symExpr' true)) : 0' eulerPath.IndexOf((symExpr' false)))); " is 144.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsTemporaryVariableResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsTemporaryVariableResolver.cs,ResolveVariables,The length of the statement  "            var namedGroups = groups.Zip(GetNames().Where(n => !usedNames.Contains(n))' (g' name) => (vars: g.Value' name: name)).ToArray(); " is 128.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsTemporaryVariableResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsTemporaryVariableResolver.cs,ResolveVariables,The length of the statement  "                foreach (var symbolNode in node.DescendantNodesAndSelf().OfType<JsSymbolicParameter>().Where(s => s.Symbol is JsTemporaryVariableParameter p && group.vars.Contains(p))) " is 168.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsTemporaryVariableResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsTemporaryVariableResolver.cs,ResolveVariables,The length of the statement  "            JsNode iife = new JsFunctionExpression(namedGroups.OrderBy(g => !g.vars.Any(v => v.Initializer != null)).Select(g => new JsIdentifier(g.name))' " is 143.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsTemporaryVariableResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsTemporaryVariableResolver.cs,ResolveVariables,The length of the statement  "                throw new Exception()).Invoke(namedGroups.Select(g => g.vars.SingleOrDefault(v => v.Initializer != null)?.Initializer).Where(v => v != null)); " is 142.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsViewModelPropertyAdjuster,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsViewModelPropertyAdjuster.cs,DefaultVisit,The length of the statement  "                if (propAnnotation.SerializationMap == null && target?.Annotation<ViewModelInfoAnnotation>() is ViewModelInfoAnnotation targetAnnotation) " is 137.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsViewModelPropertyAdjuster,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsViewModelPropertyAdjuster.cs,DefaultVisit,The length of the statement  "                    propAnnotation.SerializationMap = targetAnnotation.SerializationMap.Properties.FirstOrDefault(p => p.PropertyInfo == propAnnotation.MemberInfo); " is 144.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsViewModelPropertyAdjuster,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsViewModelPropertyAdjuster.cs,DefaultVisit,The length of the statement  "                    if (propertyMap.ViewModelProtection == ViewModel.ProtectMode.EncryptData) throw new Exception($"Property {propAnnotation.MemberInfo.Name} is encrypted and cannot be used in JS."); " is 179.
Long Statement,DotVVM.Framework.Compilation.Javascript,JsViewModelPropertyAdjuster,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsViewModelPropertyAdjuster.cs,DefaultVisit,The length of the statement  "            if (node.Annotation<ViewModelInfoAnnotation>() is var vmAnnotation && vmAnnotation?.Type != null && vmAnnotation.SerializationMap == null) " is 138.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,HandleNode,The length of the statement  "            if (node is JsExpression expression2) foreach (var transform in node.Annotations.OfType<ObservableTransformationAnnotation>()) " is 126.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,HandleNode,The length of the statement  "            if (node is JsExpression expression && IsObservableResult(node) && !node.Parent.HasAnnotation<ObservableUnwrapInvocationAnnotation>() && !(node.Role == JsAssignmentExpression.LeftRole && node.Parent is JsAssignmentExpression) && node.Parent != null) " is 249.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,HandleNode,The length of the statement  "                    // may be null means that the value in the observable may be null. Which is not unwrapped' so the annotation is removed. " is 120.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,HandleNode,The length of the statement  "            else if (node is JsSymbolicParameter sp && sp.Symbol == JavascriptTranslator.KnockoutViewModelParameter && !ShouldUnwrap(node)) " is 127.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,VisitAssignmentExpression,The length of the statement  "                throw new NotSupportedException($"Can't assign value to expression {assignmentExpression.Left}' as it may be knockout observable but is not guaranteed to be."); " is 160.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,VisitAssignmentExpression,The length of the statement  "                    resultExpression = assignmentExpression.ReplaceWith(_ => new JsIdentifierExpression("dotvvm").Member("serialization").Member("deserialize").Invoke(value' assignee' new JsLiteral(true)) " is 184.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,VisitAssignmentExpression,The length of the statement  "                        value = new JsIdentifierExpression("dotvvm").Member("serialization").Member("serializeDate").Invoke(value' new JsLiteral(false)); " is 129.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,VisitAssignmentExpression,The length of the statement  "                            newExpression = AddAnnotations(newExpression.Member(memberAccess.MemberName).WithAnnotation(ResultIsObservableAnnotation.Instance)' value); " is 139.
Long Statement,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,VisitAssignmentExpression,The length of the statement  "                            newExpression = AddAnnotations(new JsBinaryExpression(newExpression' BinaryOperatorType.Sequence' new JsSymbolicParameter(tmp))' value); " is 136.
Long Statement,DotVVM.Framework.Compilation.Javascript,CodeParameterInfo,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\ParametrizedCode.cs,FromExpression,The length of the statement  "            return new CodeParameterInfo(expression.Symbol' JsParensFixingVisitor.OperatorLevel(expression.Parent as JsExpression)' expression.Parent is JsMemberAccessExpression' expression.DefaultAssignment); " is 197.
Long Statement,DotVVM.Framework.Compilation.Parser,BeginWithLastTokenOfTypeTokenError<TToken;TTokenType>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\BeginWithLastTokenOfTypeTokenError.cs,GetRange,The length of the statement  "            } while (tokenIndex >= 0 && EqualityComparer<TTokenType>.Default.Equals(Tokenizer.Tokens[tokenIndex].Type' FirstTokenType)); " is 124.
Long Statement,DotVVM.Framework.Compilation.Parser,TokenizerBase<TToken;TTokenType>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\TokenizerBase.cs,CreateTokenError,The length of the statement  "			return new BeginWithLastTokenOfTypeTokenError<TToken' TTokenType>(errorMessage' this' lastToken' firstTokenType' isCritical); " is 125.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadDirectiveTypeName,The length of the statement  "                if (!(assemblyName is SimpleNameBindingParserNode)) typeName.NodeErrors.Add($"Generic identifier name is not allowed in assembly name."); " is 137.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadMultiExpression,The length of the statement  "            return CreateNode(new MultiExpressionBindingParserNode(expressions)' startIndex' Peek() is BindingToken token ? $"Unexpected token: {token.Text}" : null); " is 154.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadUnsupportedOperatorExpression,The length of the statement  "                first = CreateNode(new BinaryOperatorBindingParserNode(first' second' BindingTokenType.UnsupportedOperator)' startIndex' $"Unsupported operator: {operatorToken.Text}"); " is 168.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadConditionalExpression,The length of the statement  "                return CreateNode(new ConditionalExpressionBindingParserNode(first' second' third)' startIndex' error ? "The ':' was expected." : null); " is 136.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadNullCoalescingExpression,The length of the statement  "                first = CreateNode(new BinaryOperatorBindingParserNode(first' second' BindingTokenType.NullCoalescingOperator)' startIndex); " is 124.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadMultiplicativeExpression,The length of the statement  "                if (@operator == BindingTokenType.MultiplyOperator || @operator == BindingTokenType.DivideOperator || @operator == BindingTokenType.ModulusOperator) " is 148.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadUnaryExpression,The length of the statement  "                if (@operator == BindingTokenType.NotOperator || @operator == BindingTokenType.SubtractOperator || isOperatorUnsupported) " is 121.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadUnaryExpression,The length of the statement  "                    return CreateNode(new UnaryOperatorBindingParserNode(target' @operator)' startIndex' isOperatorUnsupported ? $"Unsupported operator {operatorToken.Text}" : null); " is 162.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadArrayAccess,The length of the statement  "            expression = CreateNode(new ArrayAccessBindingParserNode(expression' innerExpression)' startIndex' error ? "The ']' was expected." : null); " is 139.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadFunctionCall,The length of the statement  "            while (Peek() is BindingToken operatorToken && operatorToken.Type != BindingTokenType.CloseParenthesis && previousInnerIndex != CurrentIndex) " is 141.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadFunctionCall,The length of the statement  "            expression = CreateNode(new FunctionCallBindingParserNode(expression' arguments)' startIndex' error ? "The ')' was expected." : null); " is 134.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadAtomicExpression,The length of the statement  "                return CreateNode(new ParenthesizedExpressionBindingParserNode(innerExpression)' startIndex' error ? "The ')' was expected." : null); " is 133.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadAtomicExpression,The length of the statement  "                var node = CreateNode(new LiteralExpressionBindingParserNode(ParseStringLiteral(token.Text' out var error))' startIndex); " is 121.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,TryParse,The length of the statement  "            error = $"could not parse { text } using { method.GetMethodInfo().DeclaringType.FullName + "." + method.GetMethodInfo().Name }"; " is 128.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Tokenizer,BindingTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Tokenizer\BindingTokenizer.cs,TokenizeBindingValue,The length of the statement  "                        if (CurrentTokenChars.Length > 0 && Enumerable.Range(0' CurrentTokenChars.Length).All(i => Char.IsDigit(CurrentTokenChars[i]))) " is 127.
Long Statement,DotVVM.Framework.Compilation.Parser.Binding.Tokenizer,BindingTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Tokenizer\BindingTokenizer.cs,TokenizeBindingValue,The length of the statement  "                        CreateToken(BindingTokenType.StringLiteralToken' errorProvider: t => CreateTokenError(t' errorMessage ?? "unknown error")); " is 123.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,Parse,The length of the statement  "                ElementHierarchy.Peek().AddError($"Unexpected end of file! The tag '<{ElementHierarchy.Peek().CastTo<DothtmlElementNode>().TagName}>' was not closed!"); " is 152.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,ResolveWrongClosingTag,The length of the statement  "            while (startElement != null && !startElement.FullTagName.Equals(element.FullTagName' StringComparison.OrdinalIgnoreCase)) " is 121.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,ResolveWrongClosingTag,The length of the statement  "                    var sameElementIndex = startElement.Content.FindIndex(a => (a as DothtmlElementNode)?.FullTagName == startElement.FullTagName); " is 127.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,ResolveWrongClosingTag,The length of the statement  "                        startElement.AddWarning($"End tag is missing' the element is implicitly closed with its parent tag or by the end of file."); " is 124.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,ResolveWrongClosingTag,The length of the statement  "                        startElement.AddWarning($"End tag is missing' the element is implicitly closed by following <{startElement.Content[sameElementIndex].As<DothtmlElementNode>()?.FullTagName}> tag."); " is 180.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,ReadAttribute,The length of the statement  "                var quoteToken = Peek() ?? throw new DotvvmCompilationException("Unexpected end of stream' expected attribute value"' new [] { Tokens.Last() }); " is 144.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,HierarchyBuildingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\HierarchyBuildingVisitor.cs,Condition,The length of the statement  "            return node.StartPosition <= CursorPosition && (CursorPosition < tagEnd || (node.Tokens.Last().Length == 0 && node.Tokens.Last().StartPosition == tagEnd));  " is 155.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,ParserBase<TToken;TTokenType>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\ParserBase.cs,GetTokensFrom,The length of the statement  "            return new AggregateList<TToken>.Part(Tokens' startIndex' CurrentIndex - startIndex); // Enumerable.Skip<TToken>(Tokens' startIndex).Take(CurrentIndex - startIndex); " is 165.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadDirective,The length of the statement  "                CreateToken(DothtmlTokenType.DirectiveName' errorProvider: t => CreateTokenError(t' DothtmlTokenType.DirectiveStart' DothtmlTokenizerErrors.DirectiveNameExpected)); " is 164.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadDirective,The length of the statement  "                CreateToken(DothtmlTokenType.WhiteSpace' errorProvider: t => CreateTokenError(t' DothtmlTokenType.DirectiveStart' DothtmlTokenizerErrors.DirectiveValueExpected)); " is 162.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadDirective,The length of the statement  "                CreateToken(DothtmlTokenType.DirectiveValue' errorProvider: t => CreateTokenError(t' DothtmlTokenType.DirectiveStart' DothtmlTokenizerErrors.DirectiveValueExpected)); " is 166.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadElement,The length of the statement  "                CreateToken(DothtmlTokenType.Text' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenTag' DothtmlTokenizerErrors.TagNameExpected)); " is 142.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadElement,The length of the statement  "                            CreateToken(DothtmlTokenType.CloseTag' charsFromEndToSkip: 1' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenTag' DothtmlTokenizerErrors.InvalidCharactersInTag' isCritical: true)); " is 194.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadElement,The length of the statement  "                        CreateToken(DothtmlTokenType.CloseTag' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenTag' DothtmlTokenizerErrors.InvalidCharactersInTag' isCritical: true)); " is 171.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadElement,The length of the statement  "                CreateToken(DothtmlTokenType.CloseTag' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenTag' DothtmlTokenizerErrors.TagNotClosed)); " is 143.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadCData,The length of the statement  "                CreateToken(DothtmlTokenType.CloseCData' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenCData' DothtmlTokenizerErrors.CDataNotClosed)); " is 149.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadComment,The length of the statement  "                CreateToken(DothtmlTokenType.CloseComment' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenComment' DothtmlTokenizerErrors.CommentNotClosed)); " is 155.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadServerComment,The length of the statement  "                CreateToken(DothtmlTokenType.CloseComment' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenComment' DothtmlTokenizerErrors.CommentNotClosed)); " is 155.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadDoctype,The length of the statement  "                CreateToken(DothtmlTokenType.CloseDoctype' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenDoctype' DothtmlTokenizerErrors.DoctypeNotClosed)); " is 155.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadXmlPI,The length of the statement  "                CreateToken(DothtmlTokenType.CloseXmlProcessingInstruction' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenXmlProcessingInstruction' DothtmlTokenizerErrors.XmlProcessingInstructionNotClosed)); " is 206.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadTagOrAttributeName,The length of the statement  "            var readIdentifierFunc = isAttributeName ? (Func<DothtmlTokenType' char[]' bool>)ReadAttributeName : (Func<DothtmlTokenType' char[]' bool>)ReadIdentifier; " is 154.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadTagOrAttributeName,The length of the statement  "                CreateToken(DothtmlTokenType.Text' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenTag' DothtmlTokenizerErrors.MissingTagPrefix)); " is 143.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadTagOrAttributeName,The length of the statement  "                    CreateToken(DothtmlTokenType.Text' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenTag' DothtmlTokenizerErrors.MissingTagName)); " is 141.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadUnquotedAttributeValue,The length of the statement  "                    CreateToken(DothtmlTokenType.Text' errorProvider: t => CreateTokenError(t' DothtmlTokenType.Text' DothtmlTokenizerErrors.MissingAttributeValue)); " is 145.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadQuotedAttributeValue,The length of the statement  "                        CreateToken(quotesToken' errorProvider: t => CreateTokenError(t' quotesToken' DothtmlTokenizerErrors.AttributeValueNotClosed)); " is 127.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadQuotedAttributeValue,The length of the statement  "                CreateToken(quotesToken' errorProvider: t => CreateTokenError(t' quotesToken' DothtmlTokenizerErrors.AttributeValueNotClosed)); " is 127.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadBinding,The length of the statement  "                CreateToken(DothtmlTokenType.Text' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenBinding' DothtmlTokenizerErrors.BindingInvalidFormat)); " is 151.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadBinding,The length of the statement  "                CreateToken(DothtmlTokenType.Colon' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenBinding' DothtmlTokenizerErrors.BindingInvalidFormat)); " is 152.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadBinding,The length of the statement  "                CreateToken(DothtmlTokenType.Text' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenBinding' DothtmlTokenizerErrors.BindingInvalidFormat)); " is 151.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadBinding,The length of the statement  "                        CreateToken(DothtmlTokenType.CloseBinding' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenBinding' DothtmlTokenizerErrors.BindingNotClosed)); " is 155.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadBinding,The length of the statement  "                CreateToken(DothtmlTokenType.CloseBinding' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenBinding' DothtmlTokenizerErrors.BindingNotClosed)); " is 155.
Long Statement,DotVVM.Framework.Compilation.Parser.Dothtml.Tokenizer,DothtmlTokenizer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Tokenizer\DothtmlTokenizer.cs,ReadBinding,The length of the statement  "                    CreateToken(DothtmlTokenType.CloseBinding' errorProvider: t => CreateTokenError(t' DothtmlTokenType.OpenBinding' DothtmlTokenizerErrors.DoubleBraceBindingNotClosed)); " is 166.
Long Statement,DotVVM.Framework.Compilation.Styles,StyleBuilder<T>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Styles\StyleBuilder.cs,GetProperty,The length of the statement  "            var field = typeof(T).GetField(name + "Property"' BindingFlags.Static | BindingFlags.Public | BindingFlags.FlattenHierarchy); " is 125.
Long Statement,DotVVM.Framework.Compilation.Styles,StyleBuilder<T>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Styles\StyleBuilder.cs,SetHtmlControlProperty,The length of the statement  "                new ControlResolverMetadata(typeof(HtmlGenericControl))' innerControlStyleBuilder.GetStyle()' ctorParameters: new object[] { tag }); " is 132.
Long Statement,DotVVM.Framework.Compilation.Validation,ControlUsageValidationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Validation\ControlUsageValidationVisitor.cs,VisitAndAssert,The length of the statement  "                throw new DotvvmCompilationException(controlUsageError.ErrorMessage' controlUsageError.Nodes.SelectMany(n => n.Tokens)); " is 120.
Long Statement,DotVVM.Framework.Compilation.Validation,DefaultControlUsageValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Validation\DefaultControlUsageValidator.cs,FindMethods,The length of the statement  "            var overrideValidation = attributes.OfType<ControlUsageValidatorAttribute>().Select(s => s.Override).Distinct().ToList(); " is 121.
Long Statement,DotVVM.Framework.Compilation.Validation,DefaultControlUsageValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Validation\DefaultControlUsageValidator.cs,FindMethods,The length of the statement  "                throw new Exception($"ControlUsageValidator attributes on '{type.FullName}' are in an inconsistent state. Make sure all attributes have an Override property set to the same value."); " is 182.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,CreateDefault,The length of the statement  "            config.Markup.Controls.Add(new DotvvmControlConfiguration() { TagPrefix = "dot"' Namespace = "DotVVM.Framework.Controls"' Assembly = "DotVVM.Framework" }); " is 155.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "            configuration.RouteConstraints.Add("decimal"' GenericRouteParameterType.Create<decimal>("-?[0-9.e]*?"' Invariant.TryParse)); " is 124.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "            configuration.RouteConstraints.Add("double"' GenericRouteParameterType.Create<double>("-?[0-9.e]*?"' Invariant.TryParse)); " is 122.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "            configuration.RouteConstraints.Add("float"' GenericRouteParameterType.Create<float>("-?[0-9.e]*?"' Invariant.TryParse)); " is 120.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "            configuration.RouteConstraints.Add("guid"' GenericRouteParameterType.Create<Guid>("[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"' Guid.TryParse)); " is 162.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "            configuration.RouteConstraints.Add("max"' new GenericRouteParameterType(p => "-?[0-9.e]*?"' (valueString' parameter) => { " is 121.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "            configuration.RouteConstraints.Add("min"' new GenericRouteParameterType(p => "-?[0-9.e]*?"' (valueString' parameter) => { " is 121.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "            configuration.RouteConstraints.Add("range"' new GenericRouteParameterType(p => "-?[0-9.e]*?"' (valueString' parameter) => { " is 123.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "                if (double.Parse(split[0]' CultureInfo.InvariantCulture) > value || double.Parse(split[1]' CultureInfo.InvariantCulture) < value) return ParameterParseResult.Failed; " is 165.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "                if (p.StartsWith("^")) throw new ArgumentException("Regex in route constraint should not start with `^`' it's always looking for full-match."); " is 143.
Long Statement,DotVVM.Framework.Configuration,DotvvmConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmConfiguration.cs,RegisterConstraints,The length of the statement  "                if (p.EndsWith("$")) throw new ArgumentException("Regex in route constraint should not end with `$`' it's always looking for full-match."); " is 139.
Long Statement,DotVVM.Framework.Configuration,DotvvmControlConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmControlConfiguration.cs,IsMatch,The length of the statement  "            return tagPrefix.Equals(TagPrefix' StringComparison.OrdinalIgnoreCase) && (string.IsNullOrEmpty(TagName) || tagName.Equals(TagName' StringComparison.OrdinalIgnoreCase)); " is 169.
Long Statement,DotVVM.Framework.Configuration,DotvvmControlConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmControlConfiguration.cs,Validate,The length of the statement  "                throw new Exception("The TagPrefix must not be empty and must not contain non-alphanumeric characters!");       // TODO: exception handling " is 139.
Long Statement,DotVVM.Framework.Configuration,DotvvmControlConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmControlConfiguration.cs,Validate,The length of the statement  "                    throw new Exception(@"Invalid combination of parameters found in the configuration. Path markup/controls. Only these combinations of parameters are valid: " is 154.
Long Statement,DotVVM.Framework.Configuration,DotvvmControlConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmControlConfiguration.cs,Validate,The length of the statement  "                    throw new Exception(@"Invalid combination of parameters found in the configuration. Path markup/controls. Only these combinations of parameters are valid: " is 154.
Long Statement,DotVVM.Framework.Configuration,DotvvmMarkupConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\DotvvmMarkupConfiguration.cs,AddCodeControls,The length of the statement  "            Controls.Add(new DotvvmControlConfiguration { TagPrefix = tagPrefix' Namespace = exampleControl.Namespace' Assembly = exampleControl.GetTypeInfo().Assembly.FullName }); " is 168.
Long Statement,DotVVM.Framework.Configuration,HtmlAttributeTransformConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\HtmlAttributeTransformConfiguration.cs,GetInstance,The length of the statement  "                throw new NotSupportedException("This HtmlAttributeTransformConfiguration must be frozen before the IHtmlAttributeTransformer instance can be returned."); " is 154.
Long Statement,DotVVM.Framework.Configuration,HtmlAttributeTransformConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\HtmlAttributeTransformConfiguration.cs,CreateInstance,The length of the statement  "            var transformer = (IHtmlAttributeTransformer?)Activator.CreateInstance(type) ?? throw new Exception($"Could not initialize type {type} for html attribute transformer"); " is 168.
Long Statement,DotVVM.Framework.Configuration,HtmlAttributeTransformConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\HtmlAttributeTransformConfiguration.cs,CreateInstance,The length of the statement  "                    var prop = type.GetProperty(extension.Key) ?? throw new Exception($"Property {extension.Key} from ExtensionData was not found."); " is 129.
Long Statement,DotVVM.Framework.Configuration,HtmlTagAttributePair,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\HtmlTagAttributePair.cs,Equals,The length of the statement  "            return string.Equals(TagName' other.TagName' StringComparison.OrdinalIgnoreCase) && string.Equals(AttributeName' other.AttributeName' StringComparison.OrdinalIgnoreCase); " is 170.
Long Statement,DotVVM.Framework.Configuration,HtmlTagAttributePair,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\HtmlTagAttributePair.cs,GetHashCode,The length of the statement  "                return ((TagName != null ? StringComparer.OrdinalIgnoreCase.GetHashCode(TagName) : 0) * 397) ^ (AttributeName != null ? StringComparer.OrdinalIgnoreCase.GetHashCode(AttributeName) : 0); " is 185.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiDtoProperties,The length of the statement  "            bool isSameAssembly(Type type) => type.GetTypeInfo().Assembly == currentAssembly || type.GetGenericArguments().Any(isSameAssembly); " is 131.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiDtoProperties,The length of the statement  "                if (typeof(System.Collections.IEnumerable).IsAssignableFrom(obj) && ReflectionUtils.GetEnumerableType(obj) is Type element && isSameAssembly(element)) " is 150.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,ReplaceDefaultWithUndefined,The length of the statement  "            var replaced = arguments.Zip(parameters' (a' p) => a is JsLiteral literal && literal.Value == p.DefaultValue ? new JsIdentifierExpression("undefined") : a).ToArray(); " is 166.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,ReplaceDefaultWithUndefined,The length of the statement  "            while (trimCount < replaced.Length && replaced[replaced.Length - trimCount - 1] is JsIdentifierExpression identifier && identifier.Identifier == "undefined") " is 157.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterJsTranslation,The length of the statement  "                                    new JsArrayExpression(isRead ? new JsIdentifierExpression("dotvvm").Member("eventHub").Member("get").Invoke(autoRefreshKeyExpression.Clone()) : null) " is 149.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterJsTranslation,The length of the statement  "                                isRead ? (JsExpression)new JsLiteral(null) : new JsSymbolicParameter(CommandBindingExpression.SenderElementParameter' new CodeParameterAssignment("$element"' OperatorPrecedence.Max))' " is 183.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,BuildMethodSharingKeyExpression,The length of the statement  "            // takes an URL pattern (e.g. /api/customer/{id}) and generates an JS expression that substitutes the parameters with actual values from the args[] array " is 153.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiClient,The length of the statement  "            var descriptor = new ApiGroupDescriptor(clientType' new [] { new ApiDescriptor(null' null' clientType' jsidentifier) }' instance); " is 130.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiGroup,The length of the statement  "                              select new { instance' jsName' desc = new ApiDescriptor(prop.Name' prop' prop.PropertyType' jsidentifier.Clone().Member(jsName)) }).ToArray(); " is 142.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,CreateHttpObj,The length of the statement  "            return customFetchFunction == null ? null : new JsObjectExpression(new JsObjectProperty("fetch"' new JsIdentifierExpression(customFetchFunction))); " is 147.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiDependencies,The length of the statement  "            configuration.Resources.Register("apiClient" + identifier' new ScriptResource(new FileResourceLocation(jsApiClientFile))); " is 122.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiDependencies,The length of the statement  "            configuration.Resources.Register("apiInit" + identifier' new InlineScriptResource(jsinitializer.FormatScript(niceMode: configuration.Debug)) { Dependencies = new[] { "dotvvm"' "apiClient" + identifier } }); " is 206.
Long Statement,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiDependencies,The length of the statement  "                prop.JsExpression.AddAnnotation(new RequiredRuntimeResourcesBindingProperty(ImmutableArray.Create("apiInit" + identifier))); " is 124.
Long Statement,DotVVM.Framework.Controls,Button,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Button.cs,OnPreRender,The length of the statement  "                throw new DotvvmControlException(this' "Text property and inner content of the <dot:Button> control cannot be set at the same time!"); " is 134.
Long Statement,DotVVM.Framework.Controls,Button,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Button.cs,AddAttributesToRender,The length of the statement  "                            throw new DotvvmControlException(this' "The <dot:Button> control cannot have inner HTML connect unless the 'ButtonTagName' property is set to 'button'!"); " is 154.
Long Statement,DotVVM.Framework.Controls,Button,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Button.cs,AddAttributesToRender,The length of the statement  "                writer.AddAttribute("onclick"' KnockoutHelper.GenerateClientPostBackScript(nameof(Click)' clickBinding' this)' true' ";"); " is 122.
Long Statement,DotVVM.Framework.Controls,Button,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Button.cs,RenderContents,The length of the statement  "                        throw new DotvvmControlException(this' "Text property and inner content of the <dot:Button> control cannot be set at the same time!"); " is 134.
Long Statement,DotVVM.Framework.Controls,Button,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Button.cs,ValidateUsage,The length of the statement  "                yield return new ControlUsageError("Text property and inner content of the <dot:Button> control cannot be set at the same time!"' control.DothtmlNode); " is 151.
Long Statement,DotVVM.Framework.Controls,Button,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Button.cs,ValidateUsage,The length of the statement  "            //if (!allowcontent && control.Content.Any(n => n.DothtmlNode.IsNotEmpty())) yield return new ControlUsageError("The <dot:Button> control cannot have inner HTML connect unless the 'ButtonTagName' property is set to 'button'!"' control.DothtmlNode); " is 248.
Long Statement,DotVVM.Framework.Controls,CheckableControlBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\CheckableControlBase.cs,AddAttributesToInput,The length of the statement  "                writer.AddAttribute("onclick"' KnockoutHelper.GenerateClientPostBackScript(nameof(Changed)' changedBinding' this' useWindowSetTimeout: true' returnValue: true' isOnChange: true)); " is 179.
Long Statement,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,DataBind,The length of the statement  "            GoToFirstPageButton = CreateNavigationButton(""' FirstPageTemplate'enabledValue' bindings.GoToFirstPageCommand'context); " is 122.
Long Statement,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,DataBind,The length of the statement  "            GoToPreviousPageButton = CreateNavigationButton(""' PreviousPageTemplate'enabledValue' bindings.GoToPrevPageCommand'context); " is 126.
Long Statement,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,DataBind,The length of the statement  "            GoToNextPageButton = CreateNavigationButton(""' NextPageTemplate' enabledValue' bindings.GoToNextPageCommand' context); " is 120.
Long Statement,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,DataBind,The length of the statement  "            GoToLastPageButton = CreateNavigationButton(""' LastPageTemplate' enabledValue' bindings.GoToLastPageCommand' context); " is 121.
Long Statement,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,AddAttributesToRender,The length of the statement  "                throw new DotvvmControlException(this' "The DataPager control cannot be rendered in the RenderSettings.Mode='Server'."); " is 120.
Long Statement,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,AddAttributesToRender,The length of the statement  "                    throw new Exception("Visible can't be set on a DataPager when HideWhenOnlyOnePage is true. You can wrap it in an element that hide that or set HideWhenOnlyOnePage to false"); " is 174.
Long Statement,DotVVM.Framework.Controls,DataPager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataPager.cs,AddAttributesToRender,The length of the statement  "                writer.AddKnockoutDataBind("visible"' $"ko.unwrap({GetDataSetBinding().GetKnockoutBindingExpression(this)}).PagingOptions().PagesCount() > 1"); " is 143.
Long Statement,DotVVM.Framework.Controls,DotvvmBindableObject,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObject.cs,EvalPropertyValue,The length of the statement  "                    control = control.Parent ?? throw new DotvvmControlException(this' "Can not set DataContext binding on the root control"); " is 122.
Long Statement,DotVVM.Framework.Controls,DotvvmBindableObject,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObject.cs,CopyProperty,The length of the statement  "                throw new DotvvmControlException(this' $"TargetProperty: {targetProperty.FullName} doesn't allow bindings nor hard coded values"); " is 130.
Long Statement,DotVVM.Framework.Controls,DotvvmBindableObject,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObject.cs,CopyProperty,The length of the statement  "                throw new DotvvmControlException(this' $"Value of {sourceProperty.FullName} couldn't be copied to targetProperty: {targetProperty.FullName}' because {targetProperty.FullName} is not set."); " is 189.
Long Statement,DotVVM.Framework.Controls,DotvvmBindableObjectHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObjectHelper.cs,GetDotvvmProperty,The length of the statement  "            return DotvvmProperty.ResolveProperty(property.DeclaringType!' property.Name) ?? throw new Exception($"Property '{property.DeclaringType!.Name}.{property.Name}' is not a registered DotvvmProperty."); " is 199.
Long Statement,DotVVM.Framework.Controls,DotvvmBindableObjectHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObjectHelper.cs,DebugString,The length of the statement  "            var location = (file: control.TryGeyValue(Internal.MarkupFileNameProperty) as string' line: control.TryGeyValue(Internal.MarkupLineNumberProperty) as int? ?? -1); " is 162.
Long Statement,DotVVM.Framework.Controls,DotvvmBindableObjectHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObjectHelper.cs,DebugString,The length of the statement  "            var reg = config?.Markup.Controls.FirstOrDefault(c => c.Namespace == type.Namespace && Type.GetType(c.Namespace + "." + type.Name + "' " + c.Assembly) == type) ?? " is 162.
Long Statement,DotVVM.Framework.Controls,DotvvmControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControl.cs,AddDotvvmUniqueIdAttribute,The length of the statement  "                throw new DotvvmControlException(this' "Postback.Update can not be set on property which don't render html attributes."); " is 121.
Long Statement,DotVVM.Framework.Controls,DotvvmControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControl.cs,FindControlInContainer,The length of the statement  "                throw new DotvvmControlException(this' $"The control with ID '{id}' was found' however it is not an instance of the desired type '{typeof(T)}'."); " is 146.
Long Statement,DotVVM.Framework.Controls,DotvvmControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControl.cs,FindControlByClientId,The length of the statement  "                throw new DotvvmControlException(this' $"The control with ID '{id}' was found' however it is not an instance of the desired type '{typeof(T)}'."); " is 146.
Long Statement,DotVVM.Framework.Controls,DotvvmControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControl.cs,JoinValuesOrBindings,The length of the statement  "                return ValueBindingExpression.CreateBinding<string?>(service.WithoutInitialization()' h => null' result.Build(new OperatorPrecedence())' this.GetDataContextType()); " is 164.
Long Statement,DotVVM.Framework.Controls,DotvvmControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControl.cs,GetUniqueIdFragments,The length of the statement  "                    fragments.Add(ancestor.GetValueRaw(Internal.ClientIDFragmentProperty) ?? ancestor.GetValueRaw(Internal.UniqueIDProperty)); " is 122.
Long Statement,DotVVM.Framework.Controls,DotvvmControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControl.cs,TryGetTextContent,The length of the statement  "            textContent = string.Join(string.Empty' Children.OfType<RawLiteral>().Where(l => !l.IsWhitespace).Select(l => l.UnencodedText)); " is 128.
Long Statement,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,SetParent,The length of the statement  "                while (currentParent != null && (item.LifecycleRequirements & ~currentParent.LifecycleRequirements) != ControlLifecycleRequirements.None) " is 137.
Long Statement,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,SetParent,The length of the statement  "                    if (!lifecycleEventUpdatingDisabled && currentParent.Children.lastLifeCycleEvent > updatedLastEvent) updatedLastEvent = currentParent.Children.lastLifeCycleEvent; " is 162.
Long Statement,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,SetParent,The length of the statement  "                if (!lifecycleEventUpdatingDisabled && currentParent != null && currentParent.Children.lastLifeCycleEvent > updatedLastEvent) updatedLastEvent = currentParent.Children.lastLifeCycleEvent; " is 187.
Long Statement,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,SetParent,The length of the statement  "                while (currentParent != null &&!currentParent.Children.isInvokingEvent && currentParent.Children.lastLifeCycleEvent < updatedLastEvent) " is 135.
Long Statement,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,ValidateParentsLifecycleEvents,The length of the statement  "            if (!parent.GetAllAncestors(onlyWhenInChildren: true).OfType<DotvvmControl>().All(c => (c.LifecycleRequirements & parent.LifecycleRequirements) == parent.LifecycleRequirements)) " is 177.
Long Statement,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,InvokeMissedPageLifeCycleEvents,The length of the statement  "                throw new DotvvmControlException(parent' "InvokeMissedPageLifeCycleEvents must be called on a control rooted in a view."); " is 122.
Long Statement,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,InvokeMissedPageLifeCycleEvents,The length of the statement  "                throw new DotvvmControlException(lastProcessedControl' "Unhandled exception occurred while executing page lifecycle event."' ex); " is 129.
Long Statement,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,InvokeMissedPageLifeCycleEvent,The length of the statement  "                    child.Children.InvokeMissedPageLifeCycleEvent(context' eventType' isMissingInvoke && eventType == targetEventType' ref lastProcessedControl); " is 141.
Long Statement,DotVVM.Framework.Controls,DotvvmMarkupControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmMarkupControl.cs,OnPreInit,The length of the statement  "                throw new DotvvmControlException(this' $"Control cannot have {ParserConstants.WrapperTagNameDirective} and {ParserConstants.NoWrapperTagNameDirective} at the same time"); " is 170.
Long Statement,DotVVM.Framework.Controls,DotvvmMarkupControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmMarkupControl.cs,ContainsPropertyStaticValue,The length of the statement  "            var isValueOrServerSideValueBinding = binding == null || (binding is IStaticValueBinding && !(binding is IValueBinding)); " is 121.
Long Statement,DotVVM.Framework.Controls,FileUpload,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\FileUpload.cs,AddAttributesToRender,The length of the statement  "            writer.AddKnockoutDataBind("with"' this' UploadedFilesProperty' () => { throw new DotvvmControlException(this' "The UploadedFiles property of the FileUpload control must be bound!"); }); " is 186.
Long Statement,DotVVM.Framework.Controls,FileUpload,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\FileUpload.cs,AddAttributesToRender,The length of the statement  "                writer.AddAttribute("data-dotvvm-upload-completed"' KnockoutHelper.GenerateClientPostBackScript(nameof(UploadCompleted)' uploadCompletedBinding' this' useWindowSetTimeout: true' returnValue: null)); " is 198.
Long Statement,DotVVM.Framework.Controls,FileUpload,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\FileUpload.cs,RenderResultTitle,The length of the statement  "            writer.AddKnockoutDataBind("html"' $"Error() ? {JsonConvert.SerializeObject(UploadErrorMessageText)} : {JsonConvert.SerializeObject(SuccessMessageText)}"); " is 155.
Long Statement,DotVVM.Framework.Controls,FileUpload,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\FileUpload.cs,RenderUploadedFilesTitle,The length of the statement  "            writer.AddKnockoutDataBind("html"' $"dotvvm.globalize.format({JsonConvert.SerializeObject(NumberOfFilesIndicatorText)}' Files().length)"); " is 138.
Long Statement,DotVVM.Framework.Controls,FileUploadPageTemplate,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\FileUploadPageTemplate.cs,TransformText,The length of the statement  "	parent.window.dotvvm.fileUpload.reportProgress(window.frameElement.attributes[""data-dotvvm-upload-id""]' isBusy' percent' resultOrError); " is 138.
Long Statement,DotVVM.Framework.Controls,GridView,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridView.cs,SetCellAttributes,The length of the statement  "                if (column.IsPropertySet(GridViewColumn.VisibleProperty)) cell.SetValue(TableUtils.ColumnVisibleProperty' GridViewColumn.VisibleProperty.GetValue(column)); " is 155.
Long Statement,DotVVM.Framework.Controls,GridView,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridView.cs,SetCellAttributes,The length of the statement  "                if (column.IsPropertySet(GridViewColumn.HeaderCssClassProperty)) // transfer all bindings (even StaticValue)' because column has wrong DataContext for them " is 155.
Long Statement,DotVVM.Framework.Controls,GridView,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridView.cs,RenderBeginTag,The length of the statement  "                    GetForeachDataBindExpression().GetProperty<DataSourceLengthBinding>().Binding.CastTo<IValueBinding>().GetKnockoutBindingExpression(this)); " is 138.
Long Statement,DotVVM.Framework.Controls,GridViewColumn,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridViewColumn.cs,CreateHeaderControls,The length of the statement  "                    throw new DotvvmControlException(this' "Cannot use column sorting where no sort command is specified. Either put IGridViewDataSet in the DataSource property of the GridView' or set the SortChanged command on the GridView to implement custom sorting logic!"); " is 258.
Long Statement,DotVVM.Framework.Controls,GridViewColumn,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridViewColumn.cs,CreateHeaderControls,The length of the statement  "                var binding = new CommandBindingExpression(context.Services.GetRequiredService<BindingCompilationService>().WithoutInitialization()' h => sortCommand(sortExpression)' bindingId); " is 178.
Long Statement,DotVVM.Framework.Controls,GridViewColumn,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridViewColumn.cs,SetSortedCssClass,The length of the statement  "                    cell.Attributes["data-bind"] = $"css: {{ '{SortDescendingHeaderCssClass}': ko.unwrap(ko.unwrap($gridViewDataSet).SortingOptions().SortExpression) == '{GetSortExpression()}' && ko.unwrap(ko.unwrap($gridViewDataSet).SortingOptions().SortDescending)' '{SortAscendingHeaderCssClass}': ko.unwrap(ko.unwrap($gridViewDataSet).SortingOptions().SortExpression) == '{GetSortExpression()}' && !ko.unwrap(ko.unwrap($gridViewDataSet).SortingOptions().SortDescending)}}"; " is 457.
Long Statement,DotVVM.Framework.Controls,GridViewTemplateColumn,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridViewTemplateColumn.cs,CreateEditControls,The length of the statement  "            if (EditTemplate == null) throw new DotvvmControlException(this' "EditTemplate must be set when editing is allowed in a GridView."); " is 132.
Long Statement,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,EnsureNoAttributesSet,The length of the statement  "            if (Attributes.Count > 0 || r.HasClass || r.HasStyle || (r.Visible != null && !true.Equals(r.Visible)) || r.HasPostbackUpdate) " is 126.
Long Statement,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,EnsureNoAttributesSet,The length of the statement  "                throw new DotvvmControlException(this' "Cannot set HTML attributes' Visible' ID' Postback.Update' ... bindings on a control which does not render its own element!"); " is 165.
Long Statement,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,CheckInnerTextUsage,The length of the statement  "                throw new DotvvmControlException(this' "The DotVVM controls do not support the 'InnerText' property. It can be only used on HTML elements."); " is 141.
Long Statement,DotVVM.Framework.Controls,HtmlLiteral,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlLiteral.cs,AddAttributesToRender,The length of the statement  "                throw new DotvvmControlException(this' "The HtmlLiteral control doesn't support client-side rendering without wrapper tag. Enable server rendering or the wrapper tag."); " is 169.
Long Statement,DotVVM.Framework.Controls,HtmlWriter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlWriter.cs,AddKnockoutDataBind,The length of the statement  "                throw new InvalidOperationException($"The binding handler '{name}' already contains a KnockoutBindingGroup. The expression could not be added. Please call AddKnockoutDataBind(string' KnockoutBindingGroup) overload!"); " is 217.
Long Statement,DotVVM.Framework.Controls,HtmlWriter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlWriter.cs,AddKnockoutDataBind,The length of the statement  "                throw new InvalidOperationException($"The value of binding handler '{name}' cannot be combined with a KnockoutBindingGroup!"); " is 126.
Long Statement,DotVVM.Framework.Controls,HtmlWriter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlWriter.cs,RenderSelfClosingTag,The length of the statement  "                Warn($"Element {name} is not self-closing but is rendered as so. It may be interpreted as a start tag without an end tag by the browsers."); " is 140.
Long Statement,DotVVM.Framework.Controls,HtmlWriter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlWriter.cs,WriteHtmlAttribute,The length of the statement  "                        (separator == "'" ? attributeValue.Replace("&"' "&amp;").Replace("'"' "&#39;") : attributeValue.Replace("&"' "&amp;").Replace("\""' "&quot;")) " is 142.
Long Statement,DotVVM.Framework.Controls,HtmlWriter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlWriter.cs,RenderEndTag,The length of the statement  "                    Warn($"Element {tag} is self-closing but contains content. The browser may interpret the start tag as self-closing and put the 'content' into its parent."); " is 156.
Long Statement,DotVVM.Framework.Controls,BodyResourceLinks,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Infrastructure\BodyResourceLinks.cs,RenderControl,The length of the statement  "            resourceManager.BodyRendered = true;  // set the flag before the resources are rendered' so they can't add more resources to the list during the render " is 151.
Long Statement,DotVVM.Framework.Controls,BodyResourceLinks,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Infrastructure\BodyResourceLinks.cs,RenderControl,The length of the statement  "    window.dotvvm.init('root'' {JsonConvert.ToString(CultureInfo.CurrentCulture.Name' '"'' StringEscapeHandling.EscapeHtml)}); " is 122.
Long Statement,DotVVM.Framework.Controls,InlineScript,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\InlineScript.cs,GetScriptUniqueId,The length of the statement  "            if (uniqueId == null) throw new DotvvmControlException(this' $"Can not generate ID for InlineScript inside client template. Try to assign it ID manually."); " is 156.
Long Statement,DotVVM.Framework.Controls,ItemsControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\ItemsControl.cs,OnCompilation,The length of the statement  "            var dataContext = dataSourceBinding.Binding.Binding.GetProperty<CollectionElementDataContextBindingProperty>().DataContext; " is 123.
Long Statement,DotVVM.Framework.Controls,KnockoutBindingGroup,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutBindingGroup.cs,Add,The length of the statement  "                else Add(name' JsonConvert.SerializeObject(control.GetValue(property)' DefaultViewModelSerializer.CreateDefaultSettings())); " is 124.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,AddKnockoutDataBind,The length of the statement  "            writer.AddKnockoutDataBind(name' $"{{{String.Join("'"' expressions.Select(e => "'" + e.Key + "': " + e.Value.GetKnockoutBindingExpression(control)))}}}"); " is 154.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,WriteKnockoutDataBindComment,The length of the statement  "                throw new Exception("Knockout data bind comment can't contain substring '-->'. If you have discovered this exception in your log' you probably have a XSS vulnerability in you website."); " is 186.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,WriteKnockoutDataBindComment,The length of the statement  "            if (binding is null) throw new DotvvmControlException(control' $"A value binding expression was expected in property {property}."); " is 131.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateClientPostBackScript,The length of the statement  "            return GenerateClientPostBackScript(propertyName' expression' control' new PostbackScriptOptions(useWindowSetTimeout' returnValue' isOnChange' elementAccessor)); " is 161.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateClientPostBackExpression,The length of the statement  "            // when the expression changes the dataContext' we need to override the default knockout context fo the command binding. " is 120.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateClientPostBackExpression,The length of the statement  "                new CodeParameterAssignment(new ParametrizedCode.Builder { "ko.contextFor("' options.ElementAccessor.Code' ")" }.Build(OperatorPrecedence.Max)) : " is 145.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateClientPostBackExpression,The length of the statement  "                p == CommandBindingExpression.ViewModelNameParameter ? new CodeParameterAssignment("\"root\""' OperatorPrecedence.Max) : " is 120.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateClientPostBackExpression,The length of the statement  "                    (uniqueControlId is IValueBinding ? "{ expr: " + JsonConvert.ToString(((IValueBinding)uniqueControlId).GetKnockoutBindingExpression(control)) + "}" : '"' + (string?)uniqueControlId + '"')' OperatorPrecedence.Max) : " is 214.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateClientPostBackExpression,The length of the statement  "                p == CommandBindingExpression.PostbackHandlersParameter ? new CodeParameterAssignment(generatedPostbackHandlers ?? (generatedPostbackHandlers = getHandlerScript())' OperatorPrecedence.Max) : " is 190.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateClientPostBackExpression,The length of the statement  "                return $"dotvvm.applyPostbackHandlers(function(){{return {call}}}.bind(this)'{options.ElementAccessor.Code.ToString(e => default(CodeParameterAssignment))}'{getHandlerScript()})"; " is 179.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateHandlerOptions,The length of the statement  "                options.Where(o => o.Value != null).Select(o => new JsObjectProperty(o.Key' TransformOptionValueToExpression(handler' o.Value))) " is 128.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,TransformOptionValueToExpression,The length of the statement  "                    throw new ArgumentException("Option value can contains only IValueBinding or IStaticValueBinding. Other bindings are not supported."); " is 134.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateConcurrencyModeHandler,The length of the statement  "                queueName = queueSettings.FirstOrDefault(q => string.Equals(q.EventName' propertyName' StringComparison.OrdinalIgnoreCase))?.ConcurrencyQueue; " is 142.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,GenerateConcurrencyModeHandler,The length of the statement  "                return $"[{JsonConvert.ToString(handlerName)}'{GenerateHandlerOptions(obj' new Dictionary<string' object?> { ["q"] = queueName })}]"; " is 133.
Long Statement,DotVVM.Framework.Controls,KnockoutHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\KnockoutHelper.cs,AddCommentAliasBinding,The length of the statement  "            writer.WriteKnockoutDataBindComment("dotvvm_introduceAlias"' "{" + string.Join("' "' properties.Select(p => JsonConvert.ToString(p.Key' '"'' StringEscapeHandling.EscapeHtml) + ":" + properties.Values)) + "}"); " is 209.
Long Statement,DotVVM.Framework.Controls,LinkButton,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\LinkButton.cs,AddAttributesToRender,The length of the statement  "                throw new DotvvmControlException(this' "The <dot:LinkButton> control cannot have both inner content and the Text property set!"); " is 129.
Long Statement,DotVVM.Framework.Controls,LinkButton,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\LinkButton.cs,AddAttributesToRender,The length of the statement  "                writer.AddAttribute("onclick"' KnockoutHelper.GenerateClientPostBackScript(nameof(Click)' clickBinding' this)' true' ";"); " is 122.
Long Statement,DotVVM.Framework.Controls,Literal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Literal.cs,NeedsFormatting,The length of the statement  "                type != null && (type == typeof(float) || type == typeof(double) || type == typeof(decimal) || type == typeof(DateTime) || isFormattedType(Nullable.GetUnderlyingType(type))); " is 174.
Long Statement,DotVVM.Framework.Controls,Literal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Literal.cs,NeedsFormatting,The length of the statement  "            return isFormattedType(binding?.ResultType) && isFormattedTypeOrObj(binding?.GetProperty<ExpectedTypeBindingProperty>(ErrorHandlingMode.ReturnNull)?.Type); " is 155.
Long Statement,DotVVM.Framework.Controls,Literal,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Literal.cs,RenderControl,The length of the statement  "                    // almost always the Literal will be rendered before script resources are' so requesting the resource in render should be safe. In case it's not' user can always add it manually (the error message should be quite clear). " is 220.
Long Statement,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,BuildTable,The length of the statement  "            // make sure that all tables have the same keys so that they don't take much RAM (and remain in cache and make things go faster) " is 128.
Long Statement,DotVVM.Framework.Controls,RadioButton,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\RadioButton.cs,RenderCheckedAttribute,The length of the statement  "                    throw new DotvvmControlException(this' "The 'CheckedValue' of the RadioButton control must be set. Remember that all RadioButtons with the same GroupName have to be bound to the same property in the viewmodel."); " is 212.
Long Statement,DotVVM.Framework.Controls,Repeater,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Repeater.cs,GetItem,The length of the statement  "            if (allowMemoizationRetrive && item != null && childrenCache.TryGetValue(item' out var container2) && container2.Parent == null) " is 128.
Long Statement,DotVVM.Framework.Controls,Repeater,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Repeater.cs,SetChildren,The length of the statement  "                        allowMemoizationRetrive: context.IsPostBack && !memoizeReferences' // on GET request we are not initializing the Repeater twice " is 127.
Long Statement,DotVVM.Framework.Controls,RouteLink,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\RouteLink.cs,WriteOnClickAttribute,The length of the statement  "            // a hack that makes the RouteLink work even in container with Events.Click. This does not solve the problem in general' but better than nothing. " is 145.
Long Statement,DotVVM.Framework.Controls,RouteLinkHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\RouteLinkHelpers.cs,EvaluateRouteUrl,The length of the statement  "            if ((bool)control.GetValue(Internal.IsSpaPageProperty)! && !(bool)control.GetValue(Internal.UseHistoryApiSpaNavigationProperty)!) " is 129.
Long Statement,DotVVM.Framework.Controls,RouteLinkHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\RouteLinkHelpers.cs,TranslateRouteParameter,The length of the statement  "                    ?? JsonConvert.SerializeObject((param.Value as IStaticValueBinding)?.Evaluate(control)' DefaultViewModelSerializer.CreateDefaultSettings()); " is 140.
Long Statement,DotVVM.Framework.Controls,SelectHtmlControlHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SelectHtmlControlHelpers.cs,RenderOptionsProperties,The length of the statement  "            writer.AddKnockoutDataBind("options"' selector' ItemsControl.DataSourceProperty' renderEvenInServerRenderingMode: true); " is 120.
Long Statement,DotVVM.Framework.Controls,SelectHtmlControlHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SelectHtmlControlHelpers.cs,RenderOptionsProperties,The length of the statement  "                writer.AddKnockoutDataBind("optionsText"' selector.ItemTextBinding.GetProperty<SelectorItemBindingProperty>().Expression' selector); " is 132.
Long Statement,DotVVM.Framework.Controls,SelectHtmlControlHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SelectHtmlControlHelpers.cs,RenderOptionsProperties,The length of the statement  "                writer.AddKnockoutDataBind("optionsValue"' selector.ItemValueBinding.GetProperty<SelectorItemBindingProperty>().Expression' selector); " is 134.
Long Statement,DotVVM.Framework.Controls,SelectHtmlControlHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SelectHtmlControlHelpers.cs,RenderOptionsProperties,The length of the statement  "                writer.AddKnockoutDataBind("optionsTitle"' selector.ItemTitleBinding.GetProperty<SelectorItemBindingProperty>().Expression' selector); " is 134.
Long Statement,DotVVM.Framework.Controls,SelectHtmlControlHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SelectHtmlControlHelpers.cs,RenderChangedEvent,The length of the statement  "                writer.AddAttribute("onchange"' KnockoutHelper.GenerateClientPostBackScript(nameof(SelectorBase.SelectionChanged)' selectionChangedBinding' selector' isOnChange: true' useWindowSetTimeout: true)' true' ";"); " is 207.
Long Statement,DotVVM.Framework.Controls,Selector,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Selector.cs,ValidateUsage,The length of the statement  "                    yield return new ControlUsageError($"Type '{from.FullName}' is not assignable to '{to.FullName}'."' selectedValueBinding.DothtmlNode); " is 134.
Long Statement,DotVVM.Framework.Controls,Selector,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Selector.cs,ValidateUsage,The length of the statement  "                    yield return new ControlUsageError($"Type '{from.FullName}' is not assignable to '{to.FullName}'."' selectedValueBinding.DothtmlNode); " is 134.
Long Statement,DotVVM.Framework.Controls,SelectorBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SelectorBase.cs,ValidateUsage,The length of the statement  "                    yield return new ControlUsageError("Return type of ItemValueBinding has to be a primitive type!"' valueBinding.DothtmlNode); " is 124.
Long Statement,DotVVM.Framework.Controls,SelectorBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SelectorBase.cs,ValidateObsoleteProperties,The length of the statement  "                yield return new ControlUsageError("Property DisplayMemberProperty is obsolete. Please use ItemTextBinding instead."' displayMember.DothtmlNode); " is 145.
Long Statement,DotVVM.Framework.Controls,SelectorBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SelectorBase.cs,ValidateObsoleteProperties,The length of the statement  "                yield return new ControlUsageError("Property DisplayMemberProperty is obsolete. Please use ItemValueBinding instead."' valueMember.DothtmlNode); " is 144.
Long Statement,DotVVM.Framework.Controls,SpaContentPlaceHolder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\SpaContentPlaceHolder.cs,AddAttributesToRender,The length of the statement  "                    throw new DotvvmControlException(this' $"The route '{DefaultRouteName}' specified in SpaContentPlaceHolder DefaultRouteName property cannot contain route parameters!"); " is 168.
Long Statement,DotVVM.Framework.Controls,UpdateProgress,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\UpdateProgress.cs,ValidateUsage,The length of the statement  "                yield return new ControlUsageError("The IncludedQueues must contain comma-separated list of queue names (which can contain alphanumeric characters' underscore or dash)!"); " is 171.
Long Statement,DotVVM.Framework.Controls,UpdateProgress,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\UpdateProgress.cs,ValidateUsage,The length of the statement  "                yield return new ControlUsageError("The ExcludedQueues must contain comma-separated list of queue names (which can contain alphanumeric characters' underscore or dash)!"); " is 171.
Long Statement,DotVVM.Framework.Controls,Validator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Validator.cs,AddValidatedValue,The length of the statement  "                    bindingGroup.Add(javascriptName' JsonConvert.SerializeObject(optionValue' DefaultViewModelSerializer.CreateDefaultSettings())); " is 127.
Long Statement,Microsoft.Extensions.DependencyInjection,DotvvmBuilderExtensions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\DependencyInjection\DotvvmBuilderExtensions.cs,AddDiagnosticServices,The length of the statement  "            services.Services.AddScoped<DiagnosticsRequestTracer>(s => new DiagnosticsRequestTracer(s.GetRequiredService<IDiagnosticsInformationSender>())); " is 144.
Long Statement,Microsoft.Extensions.DependencyInjection,DotvvmServiceCollectionExtensions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\DependencyInjection\DotVVMServiceCollectionExtensions.cs,RegisterDotVVMServices,The length of the statement  "            services.TryAddSingleton<Func<ControlUsageValidationVisitor>>(s => () => ActivatorUtilities.CreateInstance<ControlUsageValidationVisitor>(s)); " is 142.
Long Statement,Microsoft.Extensions.DependencyInjection,DotvvmServiceCollectionExtensions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\DependencyInjection\DotVVMServiceCollectionExtensions.cs,ConfigureWithServices,The length of the statement  "            services.AddSingleton<IConfigureOptions<TObject>>(s => new ConfigureOptions<TObject>(o => configure(o' s.GetRequiredService<TService>()))); " is 139.
Long Statement,Microsoft.Extensions.DependencyInjection,DotvvmServiceCollectionExtensions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\DependencyInjection\DotVVMServiceCollectionExtensions.cs,ConfigureWithServices,The length of the statement  "            services.AddSingleton<IConfigureOptions<TObject>>(s => new ConfigureOptions<TObject>(o => configure(o' s.GetRequiredService<TService1>()' s.GetRequiredService<TService2>()))); " is 175.
Long Statement,DotVVM.Framework.Diagnostics,DiagnosticsRenderer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Diagnostics\DiagnosticsRenderer.cs,RenderPage,The length of the statement  "            if (context.Configuration.Debug && context.Services.GetService<DiagnosticsRequestTracer>() is DiagnosticsRequestTracer tracer) " is 126.
Long Statement,DotVVM.Framework.Diagnostics,DiagnosticsRenderer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Diagnostics\DiagnosticsRenderer.cs,WriteViewModelResponse,The length of the statement  "            if (context.Configuration.Debug && context.Services.GetService<DiagnosticsRequestTracer>() is DiagnosticsRequestTracer tracer) " is 126.
Long Statement,DotVVM.Framework.Hosting,DefaultMarkupFileLoader,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DefaultMarkupFileLoader.cs,GetMarkup,The length of the statement  "            if (!fullPath.Replace('\\'' '/').StartsWith(configuration.ApplicationPhysicalPath.Replace('\\'' '/')' StringComparison.CurrentCultureIgnoreCase)) " is 145.
Long Statement,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ProcessRequest,The length of the statement  "                // TODO this should be done by IOutputRender or something like that. IOutputRenderer does not support that' so should we make another IJsonErrorOutputWriter? " is 157.
Long Statement,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ProcessRequest,The length of the statement  "                await context.HttpContext.Response.WriteAsync(JsonConvert.SerializeObject(new { action = "invalidCsrfToken"' message = ex.Message })); " is 134.
Long Statement,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ProcessRequestCore,The length of the statement  "            var viewModelFilters = ActionFilterHelper.GetActionFilters<IViewModelActionFilter>(context.ViewModel.GetType().GetTypeInfo()) " is 125.
Long Statement,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ProcessRequestCore,The length of the statement  "                    if (actionInfo.Binding.GetProperty<ActionFiltersBindingProperty>(ErrorHandlingMode.ReturnNull) is ActionFiltersBindingProperty filters) " is 135.
Long Statement,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ProcessRequestCore,The length of the statement  "                if (string.IsNullOrEmpty(context.CsrfToken) && !context.Configuration.ExperimentalFeatures.LazyCsrfToken.IsEnabledForRoute(context.Route!.RouteName)) " is 149.
Long Statement,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ExecuteStaticCommandPlan,The length of the statement  "                a.Type == StaticCommandParameterType.Invocation ? ExecuteStaticCommandPlan((StaticCommandInvocationPlan)a.Arg' arguments' context) : " is 132.
Long Statement,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ExecuteStaticCommandPlan,The length of the statement  "            return plan.Method.Invoke(plan.Method.IsStatic ? null : methodArgs.First()' plan.Method.IsStatic ? methodArgs : methodArgs.Skip(1).ToArray()); " is 142.
Long Statement,DotVVM.Framework.Hosting,DotvvmPresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\DotvvmPresenter.cs,ProcessStaticCommandRequest,The length of the statement  "                    StaticCommandBindingCompiler.DecryptJson(Convert.FromBase64String(command)' context.Services.GetRequiredService<IViewModelProtector>()) " is 135.
Long Statement,DotVVM.Framework.Hosting,DefaultHttpRedirectService,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\HttpRedirectService.cs,WriteRedirectResponse,The length of the statement  "               //   ^ we just wait for this Task. Redirect API never was async and the response size is small enough that we can't quite safely wait for the result " is 148.
Long Statement,DotVVM.Framework.Hosting,LocalizablePresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\LocalizablePresenter.cs,BasedOnParameter,The length of the statement  "                context.Parameters!.TryGetValue(name' out var value) && !string.IsNullOrEmpty(value as string) ? CultureInfo.GetCultureInfo((string)value!) : null; " is 147.
Long Statement,DotVVM.Framework.Hosting,LocalizablePresenter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\LocalizablePresenter.cs,BasedOnQuery,The length of the statement  "                context.Query.TryGetValue(name' out var value) && !string.IsNullOrEmpty(value) ? CultureInfo.GetCultureInfo(value) : null; " is 122.
Long Statement,DotVVM.Framework.Hosting,MarkupFile,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\MarkupFile.cs,Equals,The length of the statement  "            return other != null && string.Equals(FullPath' other.FullPath' StringComparison.CurrentCultureIgnoreCase) && LastWriteDateTimeUtc.Equals(other.LastWriteDateTimeUtc); " is 166.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,DotvvmMarkupErrorSection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\DotvvmMarkupErrorSection.cs,ExtractSourceFromDotvvmCompilationException,The length of the statement  "                var errorLength = compilationException.Tokens.Where(t => t.LineNumber == compilationException.LineNumber).Sum(t => t.Length); " is 125.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,DotvvmMarkupErrorSection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\DotvvmMarkupErrorSection.cs,ExtractSourceFromDotvvmCompilationException,The length of the statement  "                return ErrorFormatter.LoadSourcePiece(compilationException.FileName' compilationException.LineNumber ?? 0' errorColumn: compilationException.ColumnNumber ?? 0' errorLength: compilationException.ColumnNumber != null ? 1 : 0); " is 224.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,DotvvmMarkupErrorSection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\DotvvmMarkupErrorSection.cs,ExtractSourceFromBindingCompilationException,The length of the statement  "                return CreateAnonymousLine(bce.Expression' first' (bce.Tokens.LastOrDefault()?.StartPosition ?? 0) + (bce.Tokens.LastOrDefault()?.Length ?? 0) - first); " is 152.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,ErrorFormatter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorFormatter.cs,LoadException,The length of the statement  "            if (exception.InnerException != null) m.InnerException = LoadException(exception.InnerException' m.Stack' stackFrameGetter' methodFormatter); " is 141.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,ErrorFormatter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorFormatter.cs,ErrorHtml,The length of the statement  "                    .Concat(context.GetEnvironmentTabs().Select(o => DictionarySection.Create(o.Item1' "env_" + o.Item1.GetHashCode()' o.Item2))) " is 125.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,ErrorFormatter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorFormatter.cs,CreateDefault,The length of the statement  "                var b = e.AllInnerExceptions().OfType<BindingPropertyException>().Select(a => a.Binding).OfType<ICloneableBinding>().FirstOrDefault(); " is 134.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,ErrorPageTemplate,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorPageTemplate.cs,WriteSourceCode,The length of the statement  "            if (source.CurrentLine != null) WriteErrorLine(source.LineNumber' source.CurrentLine' source.ErrorColumn' source.ErrorLength); " is 126.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,ErrorPageTemplate,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorPageTemplate.cs,WriteErrorLine,The length of the statement  "            var errorUnderline = WebUtility.HtmlEncode(line.Substring(errorColumn' Math.Min(line.Length - errorColumn' errorLength))); " is 122.
Long Statement,DotVVM.Framework.Hosting.ErrorPages,ErrorPageTemplate,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorPageTemplate.cs,TransformText,The length of the statement  "th' td { border-right: 1px #ddd solid; border-bottom: 1px #ddd solid; border-left: 1px transparent solid; border-top: 1px transparent solid; box-sizing: border-box; } " is 166.
Long Statement,DotVVM.Framework.Hosting.Middlewares,DotvvmFileUploadMiddleware,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\Middlewares\DotvvmFileUploadMiddleware.cs,StoreFile,The length of the statement  "            var fileNameGroup = Regex.Match(section.ContentDisposition' @"filename=""?(?<fileName>[^\""]*)"' RegexOptions.IgnoreCase).Groups["fileName"]; " is 141.
Long Statement,DotVVM.Framework.ResourceManagement,DotvvmResourceRepository,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\DotvvmResourceRepository.cs,ValidateResourceName,The length of the statement  "                throw new ArgumentException($"The resource name {name} is not valid! Only alphanumeric characters' dots' underscores and dashes are allowed! Also please note that two or more subsequent dots' underscores and dashes are reserved for internal use' and are allowed only in the middle of the resource name."); " is 305.
Long Statement,DotVVM.Framework.ResourceManagement,EmbeddedResourceLocation,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\EmbeddedResourceLocation.cs,LoadResource,The length of the statement  "            var debugPath = DebugFilePath == null ? null : Path.Combine(context.Configuration.ApplicationPhysicalPath' DebugFilePath); " is 122.
Long Statement,DotVVM.Framework.ResourceManagement,InlineScriptResource,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\InlineScriptResource.cs,InlineScriptContentGuard,The length of the statement  "            // <style> and <script> tags have "raw text" content - https://html.spec.whatwg.org/multipage/syntax.html#raw-text-elements " is 123.
Long Statement,DotVVM.Framework.ResourceManagement,InlineScriptResource,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\InlineScriptResource.cs,InlineScriptContentGuard,The length of the statement  "            // and those element must not contain "</name-of-the-element" substring - https://html.spec.whatwg.org/multipage/syntax.html#cdata-rcdata-restrictions " is 150.
Long Statement,DotVVM.Framework.ResourceManagement,InlineStylesheetResource,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\InlineStylesheetResource.cs,InlineStyleContentGuard,The length of the statement  "            // <style> and <script> tags have "raw text" content - https://html.spec.whatwg.org/multipage/syntax.html#raw-text-elements " is 123.
Long Statement,DotVVM.Framework.ResourceManagement,InlineStylesheetResource,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\InlineStylesheetResource.cs,InlineStyleContentGuard,The length of the statement  "            // and those element must not contain "</name-of-the-element" substring - https://html.spec.whatwg.org/multipage/syntax.html#cdata-rcdata-restrictions " is 150.
Long Statement,DotVVM.Framework.ResourceManagement,LocalResourceUrlManager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\LocalResourceUrlManager.cs,FindResource,The length of the statement  "                if (GetVersionHash(location' context' name) == hash) // check if the resource matches so that nobody can guess the url by chance " is 128.
Long Statement,DotVVM.Framework.ResourceManagement,PolyfillResource,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\PolyfillResource.cs,Render,The length of the statement  "            writer.WriteUnencodedText($"dotvvm__polyfillUrl = {JsonConvert.ToString(resourceUrl' '\''' StringEscapeHandling.EscapeHtml)};"); " is 128.
Long Statement,DotVVM.Framework.ResourceManagement,RegistrationUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\RegistrationUtils.cs,SetEmbeddedResourceDebugFile,The length of the statement  "            var location = repo.FindResource(resourceName).As<ILinkResource>()?.GetLocations()?.OfType<EmbeddedResourceLocation>()?.FirstOrDefault(); " is 137.
Long Statement,DotVVM.Framework.ResourceManagement,ResourceManager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ResourceManager.cs,AddRequiredResourceCore,The length of the statement  "                    throw new Exception($"Can't add {resource.GetType().Name} '{name}' to {resource.RenderPosition}' it is already rendered."); " is 123.
Long Statement,DotVVM.Framework.ResourceManagement,ResourceManager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ResourceManager.cs,ThrowResourceNotFound,The length of the statement  "            throw new ArgumentException($"The resource '{name}' could not be found. Make sure it is registered in the startup class."); " is 123.
Long Statement,DotVVM.Framework.ResourceManagement,ResourceRepositoryJsonConverter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ResourceRepositoryJsonConverter.cs,ResolveAllTypesDerivedFromIResource,The length of the statement  "                .SelectMany(a => a.GetLoadableTypes().Where(t => t.GetTypeInfo().IsClass && !t.GetTypeInfo().IsAbstract && resourceBaseType.IsAssignableFrom(t))); " is 146.
Long Statement,DotVVM.Framework.ResourceManagement,UnknownResourceLocation,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ResourceRepositoryJsonConverter.cs,GetUrl,The length of the statement  "            throw new InvalidOperationException($"The Location of the resource {name} is unknown! This should happen only when deserializing DotVVM 1.0.x configuration."); " is 159.
Long Statement,DotVVM.Framework.ResourceManagement,ResourcesRenderer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ResourcesRenderer.cs,WriteResourceInfo,The length of the statement  "            //                               ^~~~ most likely this info will be written directly in the <body> or <head>' so it should be indented by one level. " is 148.
Long Statement,DotVVM.Framework.ResourceManagement,ResourcesRenderer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ResourcesRenderer.cs,RenderResources,The length of the statement  "                else if (position == ResourceRenderPosition.Head && resource.Resource.RenderPosition != ResourceRenderPosition.Head && resource.Resource is IPreloadResource preloadResource) " is 173.
Long Statement,DotVVM.Framework.Routing,DefaultRouteStrategy,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DefaultRouteStrategy.cs,GetRoutes,The length of the statement  "            var existingRouteNames = new HashSet<string>(configuration.RouteTable.Select(r => r.RouteName)' StringComparer.OrdinalIgnoreCase); " is 130.
Long Statement,DotVVM.Framework.Routing,DefaultRouteStrategy,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DefaultRouteStrategy.cs,DiscoverMarkupFiles,The length of the statement  "                throw new DotvvmRouteStrategyException($"Cannot auto-discover DotVVM routes. The directory '{viewsFolderDirectoryInfo.FullName}' was not found!"); " is 146.
Long Statement,DotVVM.Framework.Routing,DefaultRouteStrategy,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DefaultRouteStrategy.cs,DiscoverMarkupFiles,The length of the statement  "                    ViewsFolderRelativePath = file.FullName.Substring(viewsFolderDirectoryInfo.FullName.Length).Replace('\\'' '/').TrimStart('/') " is 125.
Long Statement,DotVVM.Framework.Routing,DefaultRouteStrategy,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DefaultRouteStrategy.cs,GetRouteUrl,The length of the statement  "            var pathWithoutExtension = file.ViewsFolderRelativePath.Substring(0' file.ViewsFolderRelativePath.Length - ".dothtml".Length); " is 126.
Long Statement,DotVVM.Framework.Routing,CustomListRoutingStrategy,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DefaultRouteStrategy.cs,BuildRoutes,The length of the statement  "                   .Select(url => new DotvvmRoute(url' file.AppRelativePath' GetRouteDefaultParameters(file)' GetRoutePresenterFactory(file)' this.configuration) { RouteName = url }); " is 164.
Long Statement,DotVVM.Framework.Routing,DotvvmRoute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRoute.cs,BuildUrlCore,The length of the statement  "                throw new Exception($"Could not build URL for route '{ this.Url }' with values {{{ string.Join("' "' values.Select(kvp => kvp.Key + ": " + kvp.Value)) }}}"' ex); " is 161.
Long Statement,DotVVM.Framework.Routing,DotvvmRouteParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteParser.cs,ParseParameter,The length of the statement  "                        if (url.Length == index) throw new AggregateException($"The route constraint parameter of '{name}:{type}' is not closed: {url}"); " is 129.
Long Statement,DotVVM.Framework.Routing,DotvvmRouteParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteParser.cs,ParseParameter,The length of the statement  "                if (url[index] == ':') throw new NotImplementedException("Support for multiple route constraints is not implemented."); // TODO " is 127.
Long Statement,DotVVM.Framework.Routing,DotvvmRouteParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteParser.cs,ParseParameter,The length of the statement  "                urlBuilder = v => prefix + (v[name]?.ToString() ?? throw new ArgumentNullException($"Could not build route' parameter '{name}' is null")); " is 138.
Long Statement,DotVVM.Framework.Routing,DotvvmRouteTable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteTable.cs,Add,The length of the statement  "            Add(group?.RouteNamePrefix + routeName' new DotvvmRoute(CombinePath(group?.UrlPrefix' url)' CombinePath(group?.VirtualPathPrefix' virtualPath)' defaultValues' presenterFactory ?? GetDefaultPresenter' configuration)); " is 216.
Long Statement,DotVVM.Framework.Routing,DotvvmRouteTable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteTable.cs,Add,The length of the statement  "            Add(group?.RouteNamePrefix + routeName' new DotvvmRoute(CombinePath(group?.UrlPrefix' url)' group?.VirtualPathPrefix ?? ""' defaultValues' presenterFactory ?? GetDefaultPresenter' configuration)); " is 196.
Long Statement,DotVVM.Framework.Routing,DotvvmRouteTable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteTable.cs,Add,The length of the statement  "                throw new ArgumentException($@"{nameof(presenterType)} has to inherit from DotVVM.Framework.Hosting.IDotvvmPresenter."' nameof(presenterType)); " is 143.
Long Statement,DotVVM.Framework.Routing,DotvvmRouteTable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\DotvvmRouteTable.cs,Add,The length of the statement  "            Func<IServiceProvider' IDotvvmPresenter> presenterFactory = provider => (IDotvvmPresenter)provider.GetRequiredService(presenterType); " is 133.
Long Statement,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AssertConfigurationIsValid,The length of the statement  "                    invalidRoutes.Add(new DotvvmConfigurationAssertResult<RouteBase>(route' DotvvmConfigurationAssertReason.MissingRouteName)); " is 123.
Long Statement,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AssertConfigurationIsValid,The length of the statement  "                    throw new Exception("The TagPrefix must not be empty and must not contain non-alphanumeric characters!");       // TODO: exception handling " is 139.
Long Statement,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AssertConfigurationIsValid,The length of the statement  "                    if (!string.IsNullOrEmpty(control.Src) || string.IsNullOrEmpty(control.Namespace) || string.IsNullOrEmpty(control.Assembly)) " is 124.
Long Statement,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AssertConfigurationIsValid,The length of the statement  "                        invalidControls.Add(new DotvvmConfigurationAssertResult<DotvvmControlConfiguration>(control' DotvvmConfigurationAssertReason.InvalidCombination)); " is 146.
Long Statement,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AssertConfigurationIsValid,The length of the statement  "                    if (string.IsNullOrEmpty(control.Src) || !string.IsNullOrEmpty(control.Namespace) || !string.IsNullOrEmpty(control.Assembly)) " is 125.
Long Statement,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AssertConfigurationIsValid,The length of the statement  "                        invalidControls.Add(new DotvvmConfigurationAssertResult<DotvvmControlConfiguration>(control' DotvvmConfigurationAssertReason.InvalidCombination)); " is 146.
Long Statement,DotVVM.Framework.Routing,RouteHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteHelper.cs,AssertConfigurationIsValid,The length of the statement  "                    invalidControls.Add(new DotvvmConfigurationAssertResult<DotvvmControlConfiguration>(control' DotvvmConfigurationAssertReason.MissingFile)); " is 139.
Long Statement,DotVVM.Framework.Routing,RouteTableJsonConverter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteTableJsonConverter.cs,ReadJson,The length of the statement  "                    rt.Add(prop.Key' route["url"].Value<string>()' route["virtualPath"].Value<string>()' route["defaultValues"].ToObject<IDictionary<string' object>>()); " is 149.
Long Statement,DotVVM.Framework.Routing,RouteTableJsonConverter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\RouteTableJsonConverter.cs,ReadJson,The length of the statement  "                    rt.Add(prop.Key' new ErrorRoute(route["url"].Value<string>()' route["virtualPath"].Value<string>()' prop.Key' route["defaultValues"].ToObject<IDictionary<string' object>>()' error)); " is 182.
Long Statement,DotVVM.Framework.Routing,UrlHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\UrlHelper.cs,ContainsOnlyValidUrlChars,The length of the statement  "                    && url[i] != '!' && url[i] != '$' && url[i] != '&' && url[i] != '\'' && url[i] != '(' && url[i] != ')' && url[i] != '*' && url[i] != '+' && url[i] != ''' && url[i] != ';' && url[i] != '=' " is 187.
Long Statement,DotVVM.Framework.Runtime,AttributeViewModelParameterBinder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\AttributeViewModelParameterBinder.cs,BuildParameterBindingMethod,The length of the statement  "            var lambda = Expression.Lambda<Action<IDotvvmRequestContext' object>>(Expression.Block(statements)' contextParameter' viewModelParameter); " is 138.
Long Statement,DotVVM.Framework.Runtime,AttributeViewModelParameterBinder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\AttributeViewModelParameterBinder.cs,TryFindWritableSetter,The length of the statement  "            // when the property is declared in the base class and has private set' we need to find the property on the base class to see the SetMethod " is 139.
Long Statement,DotVVM.Framework.Runtime,AttributeViewModelParameterBinder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\AttributeViewModelParameterBinder.cs,TryFindWritableSetter,The length of the statement  "            // WORKAROUND: When the type contains non-overridden property with the same name as it's parent (using a `new` modifier) the `GetProperty` method throws an AmbiguousMatchException' so we have to find the property using a collection query " is 237.
Long Statement,DotVVM.Framework.Runtime,AttributeViewModelParameterBinder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\AttributeViewModelParameterBinder.cs,GenerateParameterBindStatement,The length of the statement  "            var methodCall = Expression.Call(null' setPropertyMethod.MakeGenericMethod(property.Key.PropertyType)' contextParameter' Expression.Constant(property.Value)' propAccess); " is 170.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,BuildView,The length of the statement  "                var masterPage = (DotvvmView)controlBuilderFactory.GetControlBuilder(masterPageFile).builder.Value.BuildControl(controlBuilderFactory' context.Services); " is 153.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,VerifySpaRequest,The length of the statement  "                    throw new Exception("Multiple controls of type <dot:SpaContentPlaceHolder /> found on the page! This control can be used only once!");   // TODO: exception handling " is 164.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,VerifySpaRequest,The length of the statement  "                if (spaContentPlaceHolders.Count == 0 || spaContentPlaceHolders[0].GetSpaContentPlaceHolderUniqueId() != context.GetSpaContentPlaceHolderUniqueId()) " is 148.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,VerifySpaRequest,The length of the statement  "                    // the client has loaded different page which does not contain current SpaContentPlaceHolder - he needs to be redirected " is 120.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,VerifySpaRequest,The length of the statement  "                    context.RedirectToUrl(context.HttpContext.Request.Url.AbsoluteUri.Replace("/" + HostingConstants.SpaUrlIdentifier' "")); " is 120.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,PerformMasterPageComposition,The length of the statement  "                throw new DotvvmControlException(childPage' $"Master page requires viewModel of type '{masterPage.ViewModelType}' and it is not assignable from '{childPage.ViewModelType}'."); " is 175.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,PerformMasterPageComposition,The length of the statement  "                    throw new DotvvmControlException(content' $"The placeholder with ID '{content.ContentPlaceHolderID}' was not found in the master page '{masterPage.GetValue(Internal.MarkupFileNameProperty)}'!"); " is 194.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,GetMasterPageContentPlaceHolders,The length of the statement  "                    throw new Exception(string.Format("The ContentPlaceHolder with ID '{0}' cannot be nested in another ContentPlaceHolder!"' placeHolder.ID)); // TODO: exception handling " is 167.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,GetChildPageContents,The length of the statement  "                        new Exception($"Error occurred near line: {(s.GetValue(Internal.MarkupLineNumberProperty)?.ToString() ?? "")}.")).ToList(); // the message cannot be specifically to the line' because MarkupLineNumber shows the last character position which is a line under the error in some cases. " is 280.
Long Statement,DotVVM.Framework.Runtime,DefaultDotvvmViewBuilder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultDotvvmViewBuilder.cs,GetChildPageContents,The length of the statement  "                throw new AggregateException("If the page contains @masterpage directive' it can only contain white space and <dot:Content /> controls! \r\n" " is 141.
Long Statement,DotVVM.Framework.Runtime,DefaultOutputRenderer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultOutputRenderer.cs,CheckRenderedResources,The length of the statement  "                throw new Exception($"Required resources were not rendered' make sure that page contains <head> and <body> elements or <dot:HeadResourceLinks> and <dot:BodyResourceLinks> controls."); " is 183.
Long Statement,DotVVM.Framework.Runtime,DefaultOutputRenderer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\DefaultOutputRenderer.cs,RenderPostbackUpdatedControls,The length of the statement  "                            throw new DotvvmControlException(control' "This control cannot use PostBack.Update=\"true\" because it has dynamic ID. This happens when the control is inside a Repeater or other data-bound control and the RenderSettings.Mode=\"Client\"."); " is 240.
Long Statement,DotVVM.Framework.Runtime.Commands,CommandResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\CommandResolver.cs,GetFunction,The length of the statement  "            context.ModelState.ValidationTarget = findResult.Control.GetValue(DotVVM.Framework.Controls.Validation.TargetProperty) ?? context.ViewModel; " is 140.
Long Statement,DotVVM.Framework.Runtime.Commands,EventValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\EventValidator.cs,FindCommandBinding,The length of the statement  "                                $"Expected DataContext path: '{string.Join("/"' path)}' Command binding DataContext path: '{string.Join("/"' walker.CurrentPathArray)}'"); " is 138.
Long Statement,DotVVM.Framework.Runtime.Commands,EventValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\EventValidator.cs,FindCommandBinding,The length of the statement  "                            infoMessage.Append($"Expected validation path: '{string.Join("/"' validationTargetPath)}' Command binding validation path: '{string.Join("/"' currentValidationTargetPath)}'"); " is 175.
Long Statement,DotVVM.Framework.Runtime.Commands,EventValidator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Runtime\Commands\EventValidator.cs,FindCommandBinding,The length of the statement  "                ErrorMessage = bindingInPath ? errorMessage : "Nothing was found in found inside specified DataContext check if ViewModel is populated"' " is 136.
Long Statement,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,The length of the statement  "            if (HashCache != null && HashCache.TryGetValue(x' out var hashx) && HashCache.TryGetValue(x' out var hashy) && hashy.Item1 != hashx.Item1) return false; " is 152.
Long Statement,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,The length of the statement  "                    return Equals(callX.Method' callY.Method) && Equals(callX.Object' callY.Object) && callX.Arguments.Zip(callY.Arguments' Equals).All(f => f); " is 140.
Long Statement,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,The length of the statement  "                    return lamX.Name == lamY.Name && lamX.Parameters.Count == lamY.Parameters.Count && lamX.Parameters.Zip(lamY.Parameters' Equals).All(f => f) && Equals(lamX.Body' lamY.Body); " is 172.
Long Statement,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,The length of the statement  "                    return Equals(linitX.NewExpression' linitY.NewExpression) && linitX.Initializers.Zip(linitY.Initializers' Equals).All(f => f); " is 126.
Long Statement,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,The length of the statement  "                //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f); " is 150.
Long Statement,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,The length of the statement  "                    return paramX.Name == paramY.Name && paramX.IsByRef == paramY.IsByRef && paramX.Name != null && !paramX.Name.StartsWith("__"); " is 126.
Long Statement,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The length of the statement  "                    //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f); " is 150.
Long Statement,DotVVM.Framework.Utils,ExpressionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionUtils.cs,AllDescendants,The length of the statement  "            new AnonymousActionVisitor(a => { if (a is T t && predicate?.Invoke(t) != false) result.Add(t); return a; }).Visit(expression); " is 127.
Long Statement,DotVVM.Framework.Utils,FunctionalExtensions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\FunctionalExtensions.cs,GetDebugFunctionInfo,The length of the statement  "            var fieldsFormatted = string.Join("; "' fields.Select(f => f.Name + ": " + f.GetValue(func.Target)?.ToString() ?? "null")); " is 123.
Long Statement,DotVVM.Framework.Utils,JsonUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\JsonUtils.cs,Diff,The length of the statement  "                        // IfInPostbackPath and ServerToClient items should be sent every time because we might not have received them from the client and we still remember their value so they look unchanged " is 183.
Long Statement,DotVVM.Framework.Utils,JsonUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\JsonUtils.cs,Patch,The length of the statement  "                else if (prop.Value.Type == JTokenType.Null && removeOnNull || (prop.Value as JConstructor)?.Name == "$rm") target.Remove(prop.Key); " is 132.
Long Statement,DotVVM.Framework.Utils,ReflectionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ReflectionUtils.cs,GetObjectPropertyValue,The length of the statement  "                throw new Exception(String.Format("The object of type {0} does not have a property named {1}!"' type' propertyName));     // TODO: exception handling " is 149.
Long Statement,DotVVM.Framework.Utils,ReflectionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ReflectionUtils.cs,ConvertValue,The length of the statement  "                if (!isFlags && split.Length > 1) throw new Exception($"Enum {type} does allow multiple values. Use [FlagsAttribute] to allow it."); " is 132.
Long Statement,DotVVM.Framework.Utils,ReflectionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ReflectionUtils.cs,ConvertValue,The length of the statement  "            const NumberStyles numberStyle = NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent | NumberStyles.AllowLeadingSign | NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite; " is 192.
Long Statement,DotVVM.Framework.Utils,ReflectionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ReflectionUtils.cs,ConvertValue,The length of the statement  "                    return Convert.ChangeType(long.Parse(str2' numberStyle & NumberStyles.Integer' CultureInfo.InvariantCulture)' type' CultureInfo.InvariantCulture); " is 146.
Long Statement,DotVVM.Framework.Utils,ReflectionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ReflectionUtils.cs,FindTypeCore,The length of the statement  "            type = assemblies.Where(a => a.GetName().Name is string assemblyName && name.StartsWith(assemblyName' stringComparison)) " is 120.
Long Statement,DotVVM.Framework.Utils,ReflectionUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ReflectionUtils.cs,MakeNullableType,The length of the statement  "            return type.GetTypeInfo().IsValueType && Nullable.GetUnderlyingType(type) == null && type != typeof(void) ? typeof(Nullable<>).MakeGenericType(type) : type; " is 156.
Long Statement,Microsoft.AspNet.WebUtilities,BufferedReadStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\BufferedReadStream.cs,EnsureBuffered,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(minCount)' minCount' "The value must be smaller than the buffer size: " + _buffer.Length); " is 135.
Long Statement,Microsoft.AspNet.WebUtilities,BufferedReadStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\BufferedReadStream.cs,EnsureBufferedAsync,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(minCount)' minCount' "The value must be smaller than the buffer size: " + _buffer.Length); " is 135.
Long Statement,Microsoft.AspNet.WebUtilities,BufferedReadStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\BufferedReadStream.cs,EnsureBufferedAsync,The length of the statement  "                int read = await _inner.ReadAsync(_buffer' _bufferOffset + _bufferCount' _buffer.Length - _bufferCount - _bufferOffset' cancellationToken); " is 139.
Long Statement,Microsoft.AspNet.WebUtilities,MultipartReaderStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReaderStream.cs,Read,The length of the statement  "                Debug.Assert(FinalBoundaryFound || string.Equals(string.Empty' remainder' StringComparison.Ordinal)' "Un-expected data found on the boundary line: " + remainder); " is 162.
Long Statement,Microsoft.AspNet.WebUtilities,MultipartReaderStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReaderStream.cs,ReadAsync,The length of the statement  "                var remainder = await _innerStream.ReadLineAsync(lengthLimit: 100' cancellationToken: cancellationToken); // Whitespace may exceed the buffer. " is 142.
Long Statement,Microsoft.AspNet.WebUtilities,MultipartReaderStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReaderStream.cs,ReadAsync,The length of the statement  "                Debug.Assert(FinalBoundaryFound || string.Equals(string.Empty' remainder' StringComparison.Ordinal)' "Un-expected data found on the boundary line: " + remainder); " is 162.
Long Statement,DotVVM.Framework.ViewModel,ChildViewModelsCache,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\ChildViewModelsCache.cs,GetChildViewModelsCollection,The length of the statement  "            var childViewModelsPropertyInfoFactory = childViewModelsCollectionCache.GetOrAdd(viewModelType' type => GetChildViewModelsCollectionCore(type)); " is 144.
Long Statement,DotVVM.Framework.ViewModel,ChildViewModelsCache,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\ChildViewModelsCache.cs,GetChildViewModelsProperties,The length of the statement  "            var childViewModelsPropertyInfoFactory = childViewModelsPropertiesCache.GetOrAdd(viewModelType' type => GetChildViewModelsPropertiesCore(type)); " is 144.
Long Statement,DotVVM.Framework.ViewModel,DotvvmViewModelBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\DotvvmViewModelBase.cs,GetChildViewModels,The length of the statement  "            var properties = ChildViewModelsCache.GetChildViewModelsProperties(thisType).Select(p => (IDotvvmViewModel)p.GetValue(this' null)); " is 131.
Long Statement,DotVVM.Framework.ViewModel,DotvvmViewModelBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\DotvvmViewModelBase.cs,GetChildViewModels,The length of the statement  "            var collection = ChildViewModelsCache.GetChildViewModelsCollection(thisType).SelectMany(p => (IEnumerable<IDotvvmViewModel>)p.GetValue(this' null) ?? new IDotvvmViewModel[0]); " is 175.
Long Statement,DotVVM.Framework.ViewModel,DotvvmViewModelBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\DotvvmViewModelBase.cs,ExecuteOnViewModelRecursive,The length of the statement  "            // TODO: viewmodel hierarchy should be managed in a separate class - we need something like IHierarchicalDotvvmViewModel and IViewModelHierarchyManager " is 151.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,SerializeViewModel,The length of the statement  "                context.ViewModelJson["viewModelDiff"] = JsonUtils.Diff((JObject)context.ReceivedViewModelJson["viewModel"]' (JObject)context.ViewModelJson["viewModel"]' false); " is 161.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,BuildViewModel,The length of the statement  "                throw new Exception($"Could not serialize viewModel of type { context.ViewModel.GetType().Name }. Serialization failed at property { writer.Path }. {GeneralViewModelRecommendations}"' ex); " is 188.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,BuildViewModel,The length of the statement  "                viewModelToken["$encryptedValues"] = viewModelProtector.Protect(viewModelConverter.EncryptedValues.ToString(Formatting.None)' context); " is 135.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,AddNewResources,The length of the statement  "            var renderedResources = new HashSet<string>(context.ReceivedViewModelJson?["renderedResources"]?.Values<string>() ?? new string[] { }); " is 135.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,BuildStaticCommandResponse,The length of the statement  "                throw new Exception($"Could not serialize viewModel of type { context.ViewModel.GetType().Name }. Serialization failed at property { writer.Path }. {GeneralViewModelRecommendations}"' ex); " is 188.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,PopulateViewModel,The length of the statement  "                viewModelToken = viewModelServerCache.TryRestoreViewModel(context' (string)data["viewModelCacheId"]' (JObject)data["viewModelDiff"]); " is 133.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,PopulateViewModel,The length of the statement  "                viewModelConverter = new ViewModelJsonConverter(context.IsPostBack' viewModelMapper' context.Services' JObject.Parse(viewModelProtector.Unprotect(encryptedValuesString' context))); " is 180.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,PopulateViewModel,The length of the statement  "                throw new Exception($"Could not deserialize viewModel of type { context.ViewModel.GetType().Name }. {GeneralViewModelRecommendations}"' ex); " is 140.
Long Statement,DotVVM.Framework.ViewModel.Serialization,DefaultViewModelSerializer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\DefaultViewModelSerializer.cs,ResolveCommand,The length of the statement  "            var data = context.ReceivedViewModelJson ?? throw new NotSupportedException("Could not find ReceivedViewModelJson in request context."); " is 136.
Long Statement,DotVVM.Framework.ViewModel.Serialization,InMemoryViewModelServerStore,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\InMemoryViewModelServerStore.cs,Store,The length of the statement  "            cacheAdapter.GetOrAdd(BuildKey(hash)' k => new DotvvmCachedItem<byte[]>(cacheData' DotvvmCacheItemPriority.Low' slidingExpiration: cacheConfigurationOptions.Value.CacheLifetime)); " is 179.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelJsonConverter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelJsonConverter.cs,CanConvert,The length of the statement  "            return !ReflectionUtils.IsEnumerable(objectType) && ReflectionUtils.IsComplexType(objectType) && !ReflectionUtils.IsTuple(objectType) && !ReflectionUtils.IsObject(objectType); " is 175.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelMapperHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelMapperHelper.cs,Bind,The length of the statement  "            property.TransferToServer = direction.HasFlag(Direction.ClientToServerNotInPostbackPath) || direction.HasFlag(Direction.ClientToServerInPostbackPath); " is 150.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelMapperHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelMapperHelper.cs,Bind,The length of the statement  "            property.TransferToServerOnlyInPath = !direction.HasFlag(Direction.ClientToServerNotInPostbackPath) && property.TransferToServer; " is 129.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelPropertyMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelPropertyMap.cs,ValidateSettings,The length of the statement  "                throw new DotvvmCompilationException($"The property {PropertyInfo.Name} of type {Type} uses the Protect attribute' therefore its Bind Direction must be set to {Direction.Both}."); " is 179.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateConstructorFactory,The length of the statement  "            var ex = Expression.Lambda<Func<IServiceProvider' object>>(Expression.New(Type)' new [] { Expression.Parameter(typeof(IServiceProvider)) }); " is 140.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateReaderFactory,The length of the statement  "            // add current object to encrypted values' this is needed because one property can potentially contain more objects (is a collection) " is 133.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateReaderFactory,The length of the statement  "            block.Add(ExpressionUtils.Replace((JsonReader rdr) => rdr.TokenType == JsonToken.StartObject ? rdr.Read() : ExpressionUtils.Stub.Throw<bool>(new Exception($"TokenType = StartObject was expected."))' reader)); " is 208.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateReaderFactory,The length of the statement  "            // it's important for the index to count with all the properties that viewModel contains because the client will send some of them only sometimes " is 145.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateReaderFactory,The length of the statement  "                    // value.{property} = ({property.Type})Deserialize(serializer' encryptedValuesReader.ReadValue({propertyIndex})' {property}' (object)value.{PropertyInfo}); " is 155.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateReaderFactory,The length of the statement  "                                (JsonSerializer s' EncryptedValuesReader ev' object existing) => Deserialize(s' ev.ReadValue(propertyIndex).CreateReader()' property' existing)' " is 144.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateReaderFactory,The length of the statement  "                        propertyblock.Add(Expression.Call(encryptedValuesReader' nameof(EncryptedValuesReader.Nest)' Type.EmptyTypes' Expression.Constant(propertyIndex))); " is 147.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateReaderFactory,The length of the statement  "                            ExpressionUtils.Replace((JsonReader rdr) => rdr.TokenType == JsonToken.StartArray || rdr.TokenType == JsonToken.StartConstructor || rdr.TokenType == JsonToken.StartObject' reader)' " is 180.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,GetSerializeExpression,The length of the statement  "                return ExpressionUtils.Replace((JsonSerializer s' JsonWriter w' object v) => Serialize(s' w' property' v)' serializer' jsonWriter' Expression.Convert(value' typeof(object))); " is 174.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,GetSerializeExpression,The length of the statement  "                return Expression.Call(serializer' "Serialize"' Type.EmptyTypes' new [] { jsonWriter' Expression.Convert(value' typeof(object)) }); " is 131.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,Serialize,The length of the statement  "            if (property.JsonConverter != null && property.JsonConverter.CanWrite && property.JsonConverter.CanConvert(property.Type)) " is 122.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,Deserialize,The length of the statement  "            if (property.JsonConverter != null && property.JsonConverter.CanRead && property.JsonConverter.CanConvert(property.Type)) " is 121.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateWriterFactory,The length of the statement  "                block.Add(ExpressionUtils.Replace((JsonSerializer s' JsonWriter w' string t) => w.WriteValue(t)' serializer' writer' Expression.Constant(Type.GetTypeHash()))); " is 159.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateWriterFactory,The length of the statement  "                            Expression.Call(encryptedValuesWriter' nameof(EncryptedValuesWriter.WriteValue)' Type.EmptyTypes' Expression.Constant(propertyIndex)' Expression.Convert(prop' typeof(object)))); " is 177.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateWriterFactory,The length of the statement  "                            block.Add(Expression.Call(encryptedValuesWriter' nameof(EncryptedValuesWriter.Nest)' Type.EmptyTypes' Expression.Constant(propertyIndex))); " is 139.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateWriterFactory,The length of the statement  "                    if (configuration.ExperimentalFeatures.ServerSideViewModelCache.IsEnabledForAnyRoute() && !property.TransferAfterPostback) " is 122.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,CreateWriterFactory,The length of the statement  "                Expression.Block(new[] { value }' block).OptimizeConstants()' writer' valueParam' serializer' encryptedValuesWriter' isPostback); " is 129.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,AddTypeOptions,The length of the statement  "            if ((property.TransferToClient || property.TransferToServer) && property.ViewModelProtection != ProtectMode.EncryptData) " is 120.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMap,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMap.cs,AddTypeOptions,The length of the statement  "                if ((property.Type == typeof(DateTime) || property.Type == typeof(DateTime?)) && property.JsonConverter == null) // TODO: allow customization using attributes " is 158.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMapper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMapper.cs,GetProperties,The length of the statement  "                    Populate = ReflectionUtils.IsComplexType(property.PropertyType) && !ReflectionUtils.IsEnumerable(property.PropertyType) && !ReflectionUtils.IsObject(property.PropertyType) && property.GetMethod != null " is 201.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMapper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMapper.cs,GetProperties,The length of the statement  "                propertyMap.ValidationRules = validationRuleTranslator.TranslateValidationRules(property' validationAttributes).ToList(); " is 121.
Long Statement,DotVVM.Framework.ViewModel.Serialization,ViewModelSerializationMapper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Serialization\ViewModelSerializationMapper.cs,GetJsonConverter,The length of the statement  "                throw new JsonException($"Cannot create an instance of {converterType} converter! Please check that this class have a public parameterless constructor."' ex); " is 158.
Long Statement,DotVVM.Framework.ViewModel.Validation,PropertyPath,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\PropertyPath.cs,BuildPath,The length of the statement  "            var js = configuration.ServiceProvider.GetRequiredService<JavascriptTranslator>().CompileToJavascript(propertyAccessor' context); " is 129.
Long Statement,DotVVM.Framework.ViewModel.Validation,ValidationErrorFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ValidationErrorFactory.cs,AddModelError,The length of the statement  "            if (context.ModelState.ValidationTarget != vm) throw new NotSupportedException($"ValidationTarget ({context.ModelState.ValidationTarget?.GetType().Name ?? "null"}) must be equal to specified view model ({vm.GetType().Name})."); " is 227.
Long Statement,DotVVM.Framework.ViewModel.Validation,ValidationErrorFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ValidationErrorFactory.cs,CreateValidationResult,The length of the statement  "            if (validationContext.Items.TryGetValue(typeof(DotvvmConfiguration)' out var obj) && obj is DotvvmConfiguration dotvvmConfiguration) " is 132.
Long Statement,DotVVM.Framework.ViewModel.Validation,ValidationErrorFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ValidationErrorFactory.cs,CreateValidationResult,The length of the statement  "            return new ValidationResult ( error' expressions.Select(expr => GetPathFromExpression(defaultJavaScriptTranslator' expr)) ); " is 124.
Long Statement,DotVVM.Framework.ViewModel.Validation,ValidationErrorFactory,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ValidationErrorFactory.cs,GetPathFromExpression,The length of the statement  "                var expression = ExpressionUtils.Replace(e.expression' BindingExpressionBuilder.GetParameters(dataContext).First(p => p.Name == "_this")); " is 138.
Long Statement,DotVVM.Framework.ViewModel.Validation,ViewModelValidationRuleTranslator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ViewModelValidationRuleTranslator.cs,TranslateValidationRules,The length of the statement  "                var validationRule = new ViewModelPropertyValidationRule(sourceValidationAttribute: attribute' staticPropertyName: property.Name); " is 130.
Long Statement,DotVVM.Framework.ViewModel.Validation,ViewModelValidationRuleTranslator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ViewModelValidationRuleTranslator.cs,TranslateValidationRules,The length of the statement  "            if (addEnforceClientFormat && (property.PropertyType.IsNullable() && property.PropertyType.UnwrapNullableType().IsNumericType() || property.PropertyType.UnwrapNullableType().IsDateOrTimeType())) " is 194.
Complex Conditional,DotVVM.Framework.Binding,CacheKey,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmBindingCacheHelper.cs,Equals,The conditional expression  "other == null || other.keys.Length != keys.Length || other.type != type || id != other.id"  is complex.
Complex Conditional,DotVVM.Framework.Binding.Expressions,ViewModelAccessReplacer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\Expressions\ValueBindingExpression.cs,Visit,The conditional expression  "node.NodeType == ExpressionType.Convert && node is UnaryExpression unary &&                      unary.Operand.NodeType == ExpressionType.ArrayIndex && unary.Operand is BinaryExpression indexer &&                      indexer.Right is ConstantExpression indexConstant &&                      indexer.Left == vmParameter"  is complex.
Complex Conditional,DotVVM.Framework.Compilation,ParameterReplacementVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\BindingCompiler.cs,VisitParameter,The conditional expression  "AssertAllReplaced && node != CurrentControlParameter && node != ViewModelsParameter && !contextParameters.Contains(node)"  is complex.
Complex Conditional,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The conditional expression  "bindingA != null && !typeof(IStaticValueBinding).IsAssignableFrom(bindingA.BindingType) ||                  bindingB != null && !typeof(IStaticValueBinding).IsAssignableFrom(bindingB.BindingType)"  is complex.
Complex Conditional,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,MergeValues,The conditional expression  "resultExpression == null || valA.NodeType == ExpressionType.Constant && valB.NodeType == ExpressionType.Constant && resultExpression.NodeType != ExpressionType.Constant"  is complex.
Complex Conditional,DotVVM.Framework.Compilation,DefaultAttributeValueMerger,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultAttributeValueMerger.cs,TryOptimizeMethodCall,The conditional expression  "methodCall != null && methodCall.Arguments.All(a => a.NodeType == ExpressionType.Constant) && (methodCall.Object == null || methodCall.Object.NodeType == ExpressionType.Constant)"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Binding,ExpressionBuildingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionBuildingVisitor.cs,ThrowOnErrors,The conditional expression  "currentErrors[0].StackTrace == null                          || (currentErrors[0] is BindingCompilationException && (currentErrors[0] as BindingCompilationException).Tokens == null)                          || (currentErrors[0] is AggregateException && (currentErrors[0] as AggregateException).Message == null)"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetMember,The conditional expression  "!isGeneric && !onlyMemberTypes && typeof(DotvvmBindableObject).IsAssignableFrom(target.Type) &&                  GetDotvvmPropertyMember(target' name) is Expression result"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,UpdateMember,The conditional expression  "(node.NodeType == ExpressionType.MemberAccess                  && node is MemberExpression member                  && member.Member is PropertyInfo property                  && property.CanWrite)                  || node.NodeType == ExpressionType.Parameter                  || node.NodeType == ExpressionType.Index"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,UpdateMember,The conditional expression  "current.NodeType == ExpressionType.Call                  && current is MethodCallExpression call                  && call.Method.DeclaringType == typeof(DotvvmBindableObject)                  && call.Method.Name == nameof(DotvvmBindableObject.GetValue)                  && call.Arguments.Count == 2                  && call.Arguments[0].Type == typeof(DotvvmProperty)                  && call.Arguments[1].Type == typeof(bool)"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Binding,ExpressionNullPropagationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionNullPropagationVisitor.cs,CheckForNull,The conditional expression  "suppress || parameter == null || (parameter.Type.GetTypeInfo().IsValueType && !parameter.Type.IsNullable()) || !checkReferenceTypes && !parameter.Type.GetTypeInfo().IsValueType"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,StartsWithStatementLikeExpression,The conditional expression  "expression == null || !expression.HasChildren ||                  expression is JsParenthesizedExpression ||                  expression is JsUnaryExpression unary && unary.IsPrefix ||                  expression is JsNewExpression ||                  expression is JsArrayExpression"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,ImplicitConstantConversion,The conditional expression  "src.NodeType == ExpressionType.Conditional && src is ConditionalExpression conditional &&                  ImplicitConversion(conditional.IfTrue' destType) is Expression ifTrue &&                  ImplicitConversion(conditional.IfFalse' destType) is Expression ifFalse"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Javascript,JavascriptNullCheckAdder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptNullCheckAdder.cs,ProcessTargetedExpression,The conditional expression  "defaultValue != null &&                      (expression.HasAnnotation<MayBeNullAnnotation>() || expression.IsRootResultExpression()) &&                      target.IsComplexType() &&                      IntroduceVariableFor(target' 1)"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Javascript,JavascriptNullCheckAdder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptNullCheckAdder.cs,IntroduceVariableFor,The conditional expression  "limit > 0 && (expression is JsMemberAccessExpression memberAccess ||                                expression is JsInvocationExpression invocation && invocation.Arguments.Count == 0 && invocation.HasAnnotation<ObservableUnwrapInvocationAnnotation>())"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,TranslateBinary,The conditional expression  "mayInduceDecimals && ReflectionUtils.IsNumericType(expression.Type) && expression.Type != typeof(float) && expression.Type != typeof(double) && expression.Type != typeof(decimal)"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Javascript,JsFormattingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsFormattingVisitor.cs,SpaceBeforeOp,The conditional expression  "result.Length > 0 && op.Length > 0 && parameters?.LastOrDefault().index != result.Length && IsDangerousTuple(result[result.Length - 1]' op.First())"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Javascript,JsTemporaryVariableResolver,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsTemporaryVariableResolver.cs,ResolveVariables,The conditional expression  "groups.Count > 0 && groups.First() is var first && first.Key < k.Value.from && k.Key.Initializer == null"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Javascript,KnockoutObservableHandlingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\KnockoutObservableHandlingVisitor.cs,HandleNode,The conditional expression  "node is JsExpression expression && IsObservableResult(node) && !node.Parent.HasAnnotation<ObservableUnwrapInvocationAnnotation>() && !(node.Role == JsAssignmentExpression.LeftRole && node.Parent is JsAssignmentExpression) && node.Parent != null"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Parser,TokenizerBase<TToken;TTokenType>,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\TokenizerBase.cs,SkipWhitespace,The conditional expression  "char.IsWhiteSpace(Peek()) && (allowEndLine || (Peek() != '\r' && Peek() != '\n'))"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ReadComparisonExpression,The conditional expression  "@operator == BindingTokenType.LessThanEqualsOperator || @operator == BindingTokenType.LessThanOperator                      || @operator == BindingTokenType.GreaterThanEqualsOperator || @operator == BindingTokenType.GreaterThanOperator"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ParseNumberLiteral,The conditional expression  "text.All(char.IsDigit) ||                  (text.StartsWith("0x"' StringComparison.Ordinal) && text.Skip(2).All(c => char.IsDigit(c) || (c >= 'a' && c <= 'f')))"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ParseNumberLiteralDoubleFloat,The conditional expression  "text.Contains(".") || text.Contains("e") || type == NumberLiteralSuffix.Float ||                  type == NumberLiteralSuffix.Double"  is complex.
Complex Conditional,DotVVM.Framework.Compilation.Parser.Dothtml.Parser,DothtmlParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Dothtml\Parser\DothtmlParser.cs,Parse,The conditional expression  "!doNotAppend                          && CurrentElementContent.Count > 0                          && CurrentElementContent[CurrentElementContent.Count - 1].GetType() == typeof(DothtmlLiteralNode)                          && !(CurrentElementContent[CurrentElementContent.Count - 1] is DotHtmlCommentNode)"  is complex.
Complex Conditional,DotVVM.Framework.Configuration,RestApiRegistrationHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\RestApiRegistrationHelpers.cs,RegisterApiDtoProperties,The conditional expression  "obj.GetTypeInfo().Assembly != typeof(string).GetTypeInfo().Assembly &&                      !obj.IsGenericParameter &&                      !ReflectionUtils.IsEnumerable(obj) && ReflectionUtils.IsComplexType(obj) && !ReflectionUtils.IsTuple(obj)"  is complex.
Complex Conditional,DotVVM.Framework.Controls,CheckBox,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\CheckBox.cs,ValidateUsage,The conditional expression  "to != null && from != null                  && !to.IsAssignableFrom(from) && !nonNullableTo!.IsAssignableFrom(from)"  is complex.
Complex Conditional,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,EnsureNoAttributesSet,The conditional expression  "Attributes.Count > 0 || r.HasClass || r.HasStyle || (r.Visible != null && !true.Equals(r.Visible)) || r.HasPostbackUpdate"  is complex.
Complex Conditional,DotVVM.Framework.Controls,HtmlWriter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlWriter.cs,AssertIsValidHtmlName,The conditional expression  "ch == '=' || ch == '"' || ch == '\'' || ch == '<' || ch == '>' || ch == '/' || ch == '&'"  is complex.
Complex Conditional,DotVVM.Framework.Controls,RadioButton,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\RadioButton.cs,ValidateUsage,The conditional expression  "to != null && from != null                  && !to.IsAssignableFrom(from) && !nonNullableTo!.IsAssignableFrom(from)"  is complex.
Complex Conditional,DotVVM.Framework.Controls,Repeater,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Repeater.cs,GetItem,The conditional expression  "allowMemoizationRetrive && item != null && childrenCache.TryGetValue(item' out var container2) && container2.Parent == null"  is complex.
Complex Conditional,DotVVM.Framework.Controls,Selector,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Selector.cs,ValidateUsage,The conditional expression  "to != null && from != null                      && !to.IsAssignableFrom(from) && !nonNullableTo!.IsAssignableFrom(from)"  is complex.
Complex Conditional,DotVVM.Framework.Controls,Selector,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Selector.cs,ValidateUsage,The conditional expression  "to != null && from != null                      && !to.IsAssignableFrom(from) && !nonNullableTo!.IsAssignableFrom(from)                      && !(to.IsEnum && from == typeof(string)) && !(to.UnwrapNullableType().IsEnum && from == typeof(string))"  is complex.
Complex Conditional,DotVVM.Framework.Routing,UrlHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\UrlHelper.cs,ContainsOnlyValidUrlChars,The conditional expression  "(url[i] < 'A' || url[i] > 'Z') && (url[i] < 'a' || url[i] > 'z') && (url[i] < '0' || url[i] > '9')                      && url[i] != '-' && url[i] != '.' && url[i] != '_' && url[i] != '~' && url[i] != '%'                      && url[i] != '!' && url[i] != '$' && url[i] != '&' && url[i] != '\'' && url[i] != '(' && url[i] != ')' && url[i] != '*' && url[i] != '+' && url[i] != ''' && url[i] != ';' && url[i] != '='                      && url[i] != ':' && url[i] != '@' && url[i] != '/' && url[i] != '?'"  is complex.
Complex Conditional,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,Equals,The conditional expression  "HashCache != null && HashCache.TryGetValue(x' out var hashx) && HashCache.TryGetValue(x' out var hashy) && hashy.Item1 != hashx.Item1"  is complex.
Complex Conditional,DotVVM.Framework.Utils,JsonUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\JsonUtils.cs,Diff,The conditional expression  "sourceItem.Type == JTokenType.Object || sourceItem.Type == JTokenType.Array                          || item.Value.Type == JTokenType.Object || item.Value.Type == JTokenType.Array                          || item.Value.ToString() != sourceItem.ToString()"  is complex.
Complex Conditional,DotVVM.Framework.ViewModel.Validation,ViewModelValidationRuleTranslator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\Validation\ViewModelValidationRuleTranslator.cs,TranslateValidationRules,The conditional expression  "addEnforceClientFormat && (property.PropertyType.IsNullable() && property.PropertyType.UnwrapNullableType().IsNumericType() || property.PropertyType.UnwrapNullableType().IsDateOrTimeType())"  is complex.
Virtual Method Call from Constructor,DotVVM.Framework.Binding.Expressions,BindingExpression,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\Expressions\BindingExpression.cs,BindingExpression,The constructor "BindingExpression" calls a virtual method "InitializeBinding".
Virtual Method Call from Constructor,DotVVM.Framework.Compilation.ControlTree,ControlResolverMetadataBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlResolverMetadataBase.cs,ControlResolverMetadataBase,The constructor "ControlResolverMetadataBase" calls a virtual method "LoadProperties".
Virtual Method Call from Constructor,DotVVM.Framework.Compilation.ControlTree,ControlResolverMetadataBase,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\ControlResolverMetadataBase.cs,ControlResolverMetadataBase,The constructor "ControlResolverMetadataBase" calls a virtual method "LoadPropertyGroups".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,ContentPlaceHolder,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\ContentPlaceHolder.cs,ContentPlaceHolder,The constructor "ContentPlaceHolder" calls a virtual method "SetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,DataItemContainer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataItemContainer.cs,DataItemContainer,The constructor "DataItemContainer" calls a virtual method "SetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,DataItemContainer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DataItemContainer.cs,DataItemContainer,The constructor "DataItemContainer" calls a virtual method "SetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,DotvvmControlException,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlException.cs,DotvvmControlException,The constructor "DotvvmControlException" calls a virtual method "GetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,DotvvmControlException,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlException.cs,DotvvmControlException,The constructor "DotvvmControlException" calls a virtual method "GetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,DotvvmMarkupControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmMarkupControl.cs,DotvvmMarkupControl,The constructor "DotvvmMarkupControl" calls a virtual method "SetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,DotvvmMarkupControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmMarkupControl.cs,DotvvmMarkupControl,The constructor "DotvvmMarkupControl" calls a virtual method "SetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,GridView,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\GridView.cs,GridView,The constructor "GridView" calls a virtual method "SetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,HtmlGenericControl,The constructor "HtmlGenericControl" calls a virtual method "SetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,Repeater,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Repeater.cs,Repeater,The constructor "Repeater" calls a virtual method "SetValue".
Virtual Method Call from Constructor,DotVVM.Framework.Controls,Validator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\Validator.cs,Validator,The constructor "Validator" calls a virtual method "SetValue".
Empty Catch Block,DotVVM.Framework.Compilation,DefaultViewCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\DefaultViewCompiler.cs,BuildReferencedAssembliesCache,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,ImplicitConstantConversion,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,AddCssClassesToRender,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Controls,HtmlGenericControl,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\HtmlGenericControl.cs,AddCssStylesToRender,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Diagnostics,DiagnosticsInformationSender,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Diagnostics\DiagnosticsInformationSender.cs,SendInformationAsync,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Diagnostics,DotvvmDiagnosticsConfiguration,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Diagnostics\DotvvmDiagnosticsConfiguration.cs,RefreshConfiguration,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Hosting,VisualStudioHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\VisualStudioHelper.cs,DumpConfiguration,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Hosting.Middlewares,DotvvmRoutingMiddleware,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\Middlewares\DotvvmRoutingMiddleware.cs,Handle,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Storage,FileSystemReturnedFileStorage,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Storage\FileSystemReturnedFileStorage.cs,DeleteFile,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Storage,FileSystemReturnedFileStorage,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Storage\FileSystemReturnedFileStorage.cs,DeleteFile,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Storage,FileSystemReturnedFileStorage,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Storage\FileSystemReturnedFileStorage.cs,DeleteOldFiles,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Storage,FileSystemUploadedFileStorage,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Storage\FileSystemUploadedFileStorage.cs,DeleteFile,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.Storage,FileSystemUploadedFileStorage,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Storage\FileSystemUploadedFileStorage.cs,DeleteOldFiles,The method has an empty catch block.
Empty Catch Block,DotVVM.Framework.ViewModel,ParameterBindingAttribute,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ViewModel\ParameterBindingAttribute.cs,TryGetValue,The method has an empty catch block.
Magic Number,DotVVM.Framework.Binding,CacheKey,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmBindingCacheHelper.cs,GetHashCode,The following statement contains a magic number: var hash = 234567643 ^ keys.Length ^ id.GetHashCode() ^ type.GetHashCode();
Magic Number,DotVVM.Framework.Binding,CacheKey,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\DotvvmBindingCacheHelper.cs,GetHashCode,The following statement contains a magic number: hash *= 17;
Magic Number,DotVVM.Framework.Binding.HelperNamespace,BindingApi,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\HelperNamespace\BindingApi.cs,RegisterJavascriptTranslations,The following statement contains a magic number: methods.AddMethodTranslator(typeof(BindingApi)' nameof(RefreshOnChange)'                  new GenericMethodCompiler(a =>                      new JsIdentifierExpression("dotvvm").Member("apiRefreshOn").Invoke(                              a[1].WithAnnotation(ShouldBeObservableAnnotation.Instance)'                              a[2].WithAnnotation(ObservableTransformationAnnotation.EnsureWrapped))                          .WithAnnotation(a[1].Annotation<ResultIsObservableAnnotation>())                          .WithAnnotation(a[1].Annotation<ViewModelInfoAnnotation>())                          .WithAnnotation(a[1].Annotation<MayBeNullAnnotation>())                  ));
Magic Number,DotVVM.Framework.Binding.HelperNamespace,BindingApi,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Binding\HelperNamespace\BindingApi.cs,RegisterJavascriptTranslations,The following statement contains a magic number: methods.AddMethodTranslator(typeof(BindingApi)' nameof(RefreshOnEvent)'                  new GenericMethodCompiler(a =>                      new JsIdentifierExpression("dotvvm").Member("apiRefreshOn").Invoke(                              a[1].WithAnnotation(ShouldBeObservableAnnotation.Instance)'                              new JsIdentifierExpression("dotvvm").Member("eventHub").Member("get").Invoke(a[2]))                          .WithAnnotation(a[1].Annotation<ResultIsObservableAnnotation>())                          .WithAnnotation(a[1].Annotation<ViewModelInfoAnnotation>())                          .WithAnnotation(a[1].Annotation<MayBeNullAnnotation>())                  ));
Magic Number,DotVVM.Framework.Compilation,ControlType,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlType.cs,GetHashCode,The following statement contains a magic number: return ((Type != null ? Type.GetHashCode() : 53515466) * 397) ^ (VirtualPath != null ? VirtualPath.GetHashCode() : 145132);
Magic Number,DotVVM.Framework.Compilation,ControlType,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlType.cs,GetHashCode,The following statement contains a magic number: return ((Type != null ? Type.GetHashCode() : 53515466) * 397) ^ (VirtualPath != null ? VirtualPath.GetHashCode() : 145132);
Magic Number,DotVVM.Framework.Compilation,ControlType,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlType.cs,GetHashCode,The following statement contains a magic number: return ((Type != null ? Type.GetHashCode() : 53515466) * 397) ^ (VirtualPath != null ? VirtualPath.GetHashCode() : 145132);
Magic Number,DotVVM.Framework.Compilation,RoslynValueEmitter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\RoslynValueEmitter.cs,AddObject,The following statement contains a magic number: var newArray = new T[storage.Length * 2];
Magic Number,DotVVM.Framework.Compilation,EqCmp,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\RoslynValueEmitter.cs,GetHashCode,The following statement contains a magic number: return 5642635;
Magic Number,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,UpdateMember,The following statement contains a magic number: current.NodeType == ExpressionType.Call                  && current is MethodCallExpression call                  && call.Method.DeclaringType == typeof(DotvvmBindableObject)                  && call.Method.Name == nameof(DotvvmBindableObject.GetValue)                  && call.Arguments.Count == 2                  && call.Arguments[0].Type == typeof(DotvvmProperty)                  && call.Arguments[1].Type == typeof(bool)
Magic Number,DotVVM.Framework.Compilation.Binding,ExpressionHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\ExpressionHelper.cs,GetBinaryOperator,The following statement contains a magic number: var binder = (DynamicMetaObjectBinder)Microsoft.CSharp.RuntimeBinder.Binder.BinaryOperation(                  CSharpBinderFlags.None' operation' typeof(object)' GetBinderArguments(2));
Magic Number,DotVVM.Framework.Compilation.Binding,BindingPropertyResolvers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\GeneralBindingPropertyResolvers.cs,CreateBindingId,The following statement contains a magic number: return new IdBindingProperty(Convert.ToBase64String(hash' 0' 12));
Magic Number,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,CompileToJavascript,The following statement contains a magic number: var invocationExpressions =                      methodInvocation is JsInvocationExpression invocation && invocation.Target.ToString() == "dotvvm.staticCommandPostback" ?                      (JsArrayExpression)invocation.Arguments.ElementAt(3) :                      methodInvocation;
Magic Number,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,DeserializePlan,The following statement contains a magic number: var genericArgumentTypes = jarray[2].Value<JArray>();
Magic Number,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,DeserializePlan,The following statement contains a magic number: var argTypes = jarray[3].ToObject<byte[]>().Select(a => (StaticCommandParameterType)a).ToArray();
Magic Number,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,DeserializePlan,The following statement contains a magic number: var args = argTypes                  .Select((a' i) => (type: a' arg: jarray.Count <= i + 4 ? JValue.CreateNull() : jarray[i + 4]' parameter: (methodFound.IsStatic ? methodParameters[i] : (i == 0 ? null : methodParameters[i - 1]))))                  .Select((a) => {                      switch (a.type)                      {                          case StaticCommandParameterType.Argument:                          case StaticCommandParameterType.Inject:                              if (a.arg.Type == JTokenType.Null)                                  return new StaticCommandParameterPlan(a.type' a.parameter?.ParameterType ?? methodFound.DeclaringType);                              else                                  return new StaticCommandParameterPlan(a.type' a.arg.Value<string>().Apply(Type.GetType));                          case StaticCommandParameterType.Constant:                              return new StaticCommandParameterPlan(a.type' a.arg.ToObject(a.parameter?.ParameterType ?? methodFound.DeclaringType));                          case StaticCommandParameterType.DefaultValue:                              return new StaticCommandParameterPlan(a.type' a.parameter.DefaultValue);                          case StaticCommandParameterType.Invocation:                              return new StaticCommandParameterPlan(a.type' DeserializePlan(a.arg));                          default:                              throw new NotSupportedException($"{a.type}");                      }                  }).ToArray();
Magic Number,DotVVM.Framework.Compilation.Binding,StaticCommandBindingCompiler,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\StaticCommandBindingCompiler.cs,DeserializePlan,The following statement contains a magic number: var args = argTypes                  .Select((a' i) => (type: a' arg: jarray.Count <= i + 4 ? JValue.CreateNull() : jarray[i + 4]' parameter: (methodFound.IsStatic ? methodParameters[i] : (i == 0 ? null : methodParameters[i - 1]))))                  .Select((a) => {                      switch (a.type)                      {                          case StaticCommandParameterType.Argument:                          case StaticCommandParameterType.Inject:                              if (a.arg.Type == JTokenType.Null)                                  return new StaticCommandParameterPlan(a.type' a.parameter?.ParameterType ?? methodFound.DeclaringType);                              else                                  return new StaticCommandParameterPlan(a.type' a.arg.Value<string>().Apply(Type.GetType));                          case StaticCommandParameterType.Constant:                              return new StaticCommandParameterPlan(a.type' a.arg.ToObject(a.parameter?.ParameterType ?? methodFound.DeclaringType));                          case StaticCommandParameterType.DefaultValue:                              return new StaticCommandParameterPlan(a.type' a.parameter.DefaultValue);                          case StaticCommandParameterType.Invocation:                              return new StaticCommandParameterPlan(a.type' DeserializePlan(a.arg));                          default:                              throw new NotSupportedException($"{a.type}");                      }                  }).ToArray();
Magic Number,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,TypeConversion,The following statement contains a magic number: typePrecedence = new Dictionary<Type' int>              {                      {typeof (object)' 0}'                      {typeof (bool)' 1}'                      {typeof (byte)' 2}'                      {typeof (int)' 3}'                      {typeof (short)' 4}'                      {typeof (long)' 5}'                      {typeof (float)' 6}'                      {typeof (double)' 7}                  };
Magic Number,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,TypeConversion,The following statement contains a magic number: typePrecedence = new Dictionary<Type' int>              {                      {typeof (object)' 0}'                      {typeof (bool)' 1}'                      {typeof (byte)' 2}'                      {typeof (int)' 3}'                      {typeof (short)' 4}'                      {typeof (long)' 5}'                      {typeof (float)' 6}'                      {typeof (double)' 7}                  };
Magic Number,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,TypeConversion,The following statement contains a magic number: typePrecedence = new Dictionary<Type' int>              {                      {typeof (object)' 0}'                      {typeof (bool)' 1}'                      {typeof (byte)' 2}'                      {typeof (int)' 3}'                      {typeof (short)' 4}'                      {typeof (long)' 5}'                      {typeof (float)' 6}'                      {typeof (double)' 7}                  };
Magic Number,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,TypeConversion,The following statement contains a magic number: typePrecedence = new Dictionary<Type' int>              {                      {typeof (object)' 0}'                      {typeof (bool)' 1}'                      {typeof (byte)' 2}'                      {typeof (int)' 3}'                      {typeof (short)' 4}'                      {typeof (long)' 5}'                      {typeof (float)' 6}'                      {typeof (double)' 7}                  };
Magic Number,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,TypeConversion,The following statement contains a magic number: typePrecedence = new Dictionary<Type' int>              {                      {typeof (object)' 0}'                      {typeof (bool)' 1}'                      {typeof (byte)' 2}'                      {typeof (int)' 3}'                      {typeof (short)' 4}'                      {typeof (long)' 5}'                      {typeof (float)' 6}'                      {typeof (double)' 7}                  };
Magic Number,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,TypeConversion,The following statement contains a magic number: typePrecedence = new Dictionary<Type' int>              {                      {typeof (object)' 0}'                      {typeof (bool)' 1}'                      {typeof (byte)' 2}'                      {typeof (int)' 3}'                      {typeof (short)' 4}'                      {typeof (long)' 5}'                      {typeof (float)' 6}'                      {typeof (double)' 7}                  };
Magic Number,DotVVM.Framework.Compilation.ControlTree,BindingCollectionInfoExtensionParameter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\BindingExtensionParameter.cs,GetJsTranslation,The following statement contains a magic number: return new JsObjectExpression(                  new JsObjectProperty(nameof(BindingCollectionInfo.Index)' index())'                  new JsObjectProperty(nameof(BindingCollectionInfo.IsFirst)' new JsBinaryExpression(index()' BinaryOperatorType.Equal' new JsLiteral(0)))'                  new JsObjectProperty(nameof(BindingCollectionInfo.IsOdd)' new JsBinaryExpression(new JsBinaryExpression(index()' BinaryOperatorType.Modulo' new JsLiteral(2))' BinaryOperatorType.Equal' new JsLiteral(1)))'                  new JsObjectProperty(nameof(BindingCollectionInfo.IsEven)' new JsBinaryExpression(new JsBinaryExpression(index()' BinaryOperatorType.Modulo' new JsLiteral(2))' BinaryOperatorType.Equal' new JsLiteral(0)))              );
Magic Number,DotVVM.Framework.Compilation.ControlTree,BindingCollectionInfoExtensionParameter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\BindingExtensionParameter.cs,GetJsTranslation,The following statement contains a magic number: return new JsObjectExpression(                  new JsObjectProperty(nameof(BindingCollectionInfo.Index)' index())'                  new JsObjectProperty(nameof(BindingCollectionInfo.IsFirst)' new JsBinaryExpression(index()' BinaryOperatorType.Equal' new JsLiteral(0)))'                  new JsObjectProperty(nameof(BindingCollectionInfo.IsOdd)' new JsBinaryExpression(new JsBinaryExpression(index()' BinaryOperatorType.Modulo' new JsLiteral(2))' BinaryOperatorType.Equal' new JsLiteral(1)))'                  new JsObjectProperty(nameof(BindingCollectionInfo.IsEven)' new JsBinaryExpression(new JsBinaryExpression(index()' BinaryOperatorType.Modulo' new JsLiteral(2))' BinaryOperatorType.Equal' new JsLiteral(0)))              );
Magic Number,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,ComputeHashCode,The following statement contains a magic number: hashCode += (hashCode * 47) ^ import.GetHashCode();
Magic Number,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,ComputeHashCode,The following statement contains a magic number: hashCode *= 17;
Magic Number,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,ComputeHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ (Parent?.GetHashCode() ?? 0);
Magic Number,DotVVM.Framework.Compilation.ControlTree,DataContextStack,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\ControlTree\DataContextStack.cs,ComputeHashCode,The following statement contains a magic number: hashCode = (hashCode * 13) ^ (DataContextType?.FullName?.GetHashCode() ?? 0);
Magic Number,DotVVM.Framework.Compilation.Javascript.Ast,AbstractAnnotatable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\Ast\IAnnotatable.cs,AddAnnotation,The following statement contains a magic number: list = new AnnotationList(4);
Magic Number,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The following statement contains a magic number: AddMethodTranslator(typeof(Enumerable).GetMethod("ElementAt"' BindingFlags.Static | BindingFlags.Public)' new GenericMethodCompiler((args' method) =>                  BuildIndexer(args[1]' args[2]' method)));
Magic Number,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The following statement contains a magic number: var stringFormatTranslator = new GenericMethodCompiler(                  args => new JsIdentifierExpression("dotvvm").Member("globalize").Member("format").Invoke(args[1]' new JsArrayExpression(args.Skip(2)))              );
Magic Number,DotVVM.Framework.Compilation.Javascript,JavascriptTranslatableMethodCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslatableMethodCollection.cs,AddDefaultMethodTranslators,The following statement contains a magic number: AddMethodTranslator(typeof(string).GetMethod("Format"' new[] { typeof(string)' typeof(object[]) })' new GenericMethodCompiler(                  args => new JsIdentifierExpression("dotvvm").Member("globalize").Member("format").Invoke(args[1]' args[2])              ));
Magic Number,DotVVM.Framework.Compilation.Javascript,ViewModelInfoAnnotation,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslator.cs,GetHashCode,The following statement contains a magic number: var hash = 69848087;
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Javascript,JsParensFixingVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JsParensFixingVisitor.cs,OperatorLevel,The following statement contains a magic number: switch (expression) {                  case JsParenthesizedExpression _:                  case JsMemberAccessExpression _:                  case JsInvocationExpression _:                  case JsIndexerExpression _:                  case JsIdentifierExpression _:                  case JsLiteral _:                  case JsSymbolicParameter _:                  case JsFunctionExpression _:                  case JsObjectExpression _:                  case JsArrayExpression _:                  case JsNewExpression _:                      return 20;                  case JsBinaryExpression be:                      switch (be.Operator) {                          case BinaryOperatorType.Times:                          case BinaryOperatorType.Divide:                          case BinaryOperatorType.Modulo:                              return 14;                          case BinaryOperatorType.Plus:                          case BinaryOperatorType.Minus:                              return 13;                          case BinaryOperatorType.LeftShift:                          case BinaryOperatorType.RightShift:                          case BinaryOperatorType.UnsignedRightShift:                              return 12;                          case BinaryOperatorType.In:                          case BinaryOperatorType.InstanceOf:                          case BinaryOperatorType.Greater:                          case BinaryOperatorType.GreaterOrEqual:                          case BinaryOperatorType.Less:                          case BinaryOperatorType.LessOrEqual:                              return 11;                          case BinaryOperatorType.Equal:                          case BinaryOperatorType.NotEqual:                          case BinaryOperatorType.StrictlyEqual:                          case BinaryOperatorType.StricltyNotEqual:                              return 10;                          case BinaryOperatorType.BitwiseAnd:                              return 9;                          case BinaryOperatorType.BitwiseXOr:                              return 8;                          case BinaryOperatorType.BitwiseOr:                              return 7;                          case BinaryOperatorType.ConditionalAnd:                              return 6;                          case BinaryOperatorType.ConditionalOr:                              return 5;                          case BinaryOperatorType.Sequence:                              return 0;                          default: throw new NotSupportedException();                      }                  case JsUnaryExpression ue:                      if (!ue.IsPrefix) return 17;                      else return 16;                  case JsConditionalExpression ce:                      return 4;                  case JsAssignmentExpression ae:                      return 3;                  case null:                      return 0;                  default: throw new NotSupportedException();              }
Magic Number,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ParseNumberLiteral,The following statement contains a magic number: text.All(char.IsDigit) ||                  (text.StartsWith("0x"' StringComparison.Ordinal) && text.Skip(2).All(c => char.IsDigit(c) || (c >= 'a' && c <= 'f')))
Magic Number,DotVVM.Framework.Compilation.Parser.Binding.Parser,BindingParser,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Parser\Binding\Parser\BindingParser.cs,ParseNumberLiteralSuffix,The following statement contains a magic number: text = text.Remove(text.Length - 2);
Magic Number,DotVVM.Framework.Compilation.Styles,StyleMatchContext,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Styles\StyleMatchContext.cs,HasViewInDirectory,The following statement contains a magic number: directoryPath = directoryPath.Substring(2);
Magic Number,DotVVM.Framework.Configuration,HtmlTagAttributePair,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\HtmlTagAttributePair.cs,GetHashCode,The following statement contains a magic number: return ((TagName != null ? StringComparer.OrdinalIgnoreCase.GetHashCode(TagName) : 0) * 397) ^ (AttributeName != null ? StringComparer.OrdinalIgnoreCase.GetHashCode(AttributeName) : 0);
Magic Number,DotVVM.Framework.Configuration,HtmlTagAttributePairToStringConverter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Configuration\HtmlTagAttributePair.cs,ReadJson,The following statement contains a magic number: pair.AttributeName = match.Groups[2].Value;
Magic Number,DotVVM.Framework.Controls,DotvvmBindableObjectHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObjectHelper.cs,DebugString,The following statement contains a magic number: var properties = (from kvp in control.Properties                                let p = kvp.Key                                let rawValue = kvp.Value                                where p.DeclaringType != typeof(Internal)                                let isAttached = !p.DeclaringType.IsAssignableFrom(type)                                orderby !isAttached' p.Name                                let name = isAttached ? p.DeclaringType.Name + "." + p.Name : p.Name                                let value = rawValue == null ? "<null>" :                                            rawValue is ITemplate ? "<a template>" :                                            rawValue is DotvvmBindableObject ? $"<control {rawValue.GetType()}>" :                                            rawValue is IEnumerable<DotvvmBindableObject> controlCollection ? $"<{controlCollection.Count()} controls>" :                                            rawValue is IEnumerable<object> collection ? string.Join("' "' collection) :                                            rawValue.ToString()                                let croppedValue = value.Length > 41 ? value.Substring(0' 40) + "" : value                                select new { p' name' croppedValue' value' isAttached }                               ).ToArray();
Magic Number,DotVVM.Framework.Controls,DotvvmBindableObjectHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmBindableObjectHelper.cs,DebugString,The following statement contains a magic number: var properties = (from kvp in control.Properties                                let p = kvp.Key                                let rawValue = kvp.Value                                where p.DeclaringType != typeof(Internal)                                let isAttached = !p.DeclaringType.IsAssignableFrom(type)                                orderby !isAttached' p.Name                                let name = isAttached ? p.DeclaringType.Name + "." + p.Name : p.Name                                let value = rawValue == null ? "<null>" :                                            rawValue is ITemplate ? "<a template>" :                                            rawValue is DotvvmBindableObject ? $"<control {rawValue.GetType()}>" :                                            rawValue is IEnumerable<DotvvmBindableObject> controlCollection ? $"<{controlCollection.Count()} controls>" :                                            rawValue is IEnumerable<object> collection ? string.Join("' "' collection) :                                            rawValue.ToString()                                let croppedValue = value.Length > 41 ? value.Substring(0' 40) + "" : value                                select new { p' name' croppedValue' value' isAttached }                               ).ToArray();
Magic Number,DotVVM.Framework.Controls,RenderState,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControl.cs,RenderOnServer,The following statement contains a magic number: _renderOnServer = @this.RenderOnServer ? (byte)1 : (byte)2;
Magic Number,DotVVM.Framework.Controls,DotvvmControlCollection,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\DotvvmControlCollection.cs,InvokeMissedPageLifeCycleEvent,The following statement contains a magic number: reqflag = reqflag << 5;
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,ContainsKey,The following statement contains a magic number: return keys[0] == p | keys[1] == p | keys[2] == p | keys[3] == p;
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,ContainsKey,The following statement contains a magic number: return keys[0] == p | keys[1] == p | keys[2] == p | keys[3] == p;
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,ContainsKey,The following statement contains a magic number: l == 4
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,ContainsKey,The following statement contains a magic number: var i1 = hash & -2;
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,FindSlot,The following statement contains a magic number: i < 4
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,FindSlot,The following statement contains a magic number: l == 4
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,FindSlot,The following statement contains a magic number: var i1 = hash & -2;
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,BuildTable,The following statement contains a magic number: return tableCache.GetOrAdd(a' keys => {                  if (keys.Length < 4)                  {                      // just pad them to make things regular                      var result = new DotvvmProperty[4];                      Array.Copy(keys' result' keys.Length);                      return (0' result);                  }                  else                  {                      // first try closest size of power two                      var size = 1 << (int)Math.Log(keys.Length + 1' 2);                        while(true)                      {                          Debug.Assert((size & (size - 1)) == 0);                          foreach (var hashSeed in hashSeeds)                          {                              var result = TryBuildTable(keys' size' hashSeed);                              if (result != null)                              {                                  Debug.Assert(TestTableCorrectness(keys' hashSeed' result));                                  return (hashSeed' result);                              }                          }                            size *= 2;                            if (size <= 4) throw new InvalidOperationException("Could not build hash table");                      }                    }              });
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,BuildTable,The following statement contains a magic number: return tableCache.GetOrAdd(a' keys => {                  if (keys.Length < 4)                  {                      // just pad them to make things regular                      var result = new DotvvmProperty[4];                      Array.Copy(keys' result' keys.Length);                      return (0' result);                  }                  else                  {                      // first try closest size of power two                      var size = 1 << (int)Math.Log(keys.Length + 1' 2);                        while(true)                      {                          Debug.Assert((size & (size - 1)) == 0);                          foreach (var hashSeed in hashSeeds)                          {                              var result = TryBuildTable(keys' size' hashSeed);                              if (result != null)                              {                                  Debug.Assert(TestTableCorrectness(keys' hashSeed' result));                                  return (hashSeed' result);                              }                          }                            size *= 2;                            if (size <= 4) throw new InvalidOperationException("Could not build hash table");                      }                    }              });
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,BuildTable,The following statement contains a magic number: return tableCache.GetOrAdd(a' keys => {                  if (keys.Length < 4)                  {                      // just pad them to make things regular                      var result = new DotvvmProperty[4];                      Array.Copy(keys' result' keys.Length);                      return (0' result);                  }                  else                  {                      // first try closest size of power two                      var size = 1 << (int)Math.Log(keys.Length + 1' 2);                        while(true)                      {                          Debug.Assert((size & (size - 1)) == 0);                          foreach (var hashSeed in hashSeeds)                          {                              var result = TryBuildTable(keys' size' hashSeed);                              if (result != null)                              {                                  Debug.Assert(TestTableCorrectness(keys' hashSeed' result));                                  return (hashSeed' result);                              }                          }                            size *= 2;                            if (size <= 4) throw new InvalidOperationException("Could not build hash table");                      }                    }              });
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,BuildTable,The following statement contains a magic number: return tableCache.GetOrAdd(a' keys => {                  if (keys.Length < 4)                  {                      // just pad them to make things regular                      var result = new DotvvmProperty[4];                      Array.Copy(keys' result' keys.Length);                      return (0' result);                  }                  else                  {                      // first try closest size of power two                      var size = 1 << (int)Math.Log(keys.Length + 1' 2);                        while(true)                      {                          Debug.Assert((size & (size - 1)) == 0);                          foreach (var hashSeed in hashSeeds)                          {                              var result = TryBuildTable(keys' size' hashSeed);                              if (result != null)                              {                                  Debug.Assert(TestTableCorrectness(keys' hashSeed' result));                                  return (hashSeed' result);                              }                          }                            size *= 2;                            if (size <= 4) throw new InvalidOperationException("Could not build hash table");                      }                    }              });
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,BuildTable,The following statement contains a magic number: return tableCache.GetOrAdd(a' keys => {                  if (keys.Length < 4)                  {                      // just pad them to make things regular                      var result = new DotvvmProperty[4];                      Array.Copy(keys' result' keys.Length);                      return (0' result);                  }                  else                  {                      // first try closest size of power two                      var size = 1 << (int)Math.Log(keys.Length + 1' 2);                        while(true)                      {                          Debug.Assert((size & (size - 1)) == 0);                          foreach (var hashSeed in hashSeeds)                          {                              var result = TryBuildTable(keys' size' hashSeed);                              if (result != null)                              {                                  Debug.Assert(TestTableCorrectness(keys' hashSeed' result));                                  return (hashSeed' result);                              }                          }                            size *= 2;                            if (size <= 4) throw new InvalidOperationException("Could not build hash table");                      }                    }              });
Magic Number,DotVVM.Framework.Controls,PropertyImmutableHashtable,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\PropertyImmutableHashtable.cs,TryBuildTable,The following statement contains a magic number: var i1 = hash & -2;
Magic Number,DotVVM.Framework.Controls,RouteLinkHelpers,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Controls\RouteLinkHelpers.cs,EvaluateRouteUrl,The following statement contains a magic number: return "#!/" + (coreUrl.StartsWith("~/"' StringComparison.Ordinal) ? coreUrl.Substring(2) : coreUrl);
Magic Number,DotVVM.Framework.Diagnostics,DiagnosticsRequestTracer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Diagnostics\DiagnosticsRequestTracer.cs,EndRequest,The following statement contains a magic number: diagnosticsData.ResponseDiagnostics.StatusCode = 500;
Magic Number,DotVVM.Framework.Hosting,MarkupFile,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\MarkupFile.cs,GetHashCode,The following statement contains a magic number: return ((FullPath != null ? FullPath.ToLower().GetHashCode() : 0) * 397) ^ LastWriteDateTimeUtc.GetHashCode();
Magic Number,DotVVM.Framework.Hosting.ErrorPages,ErrorFormatter,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\ErrorPages\ErrorFormatter.cs,ErrorHtml,The following statement contains a magic number: var template = new ErrorPageTemplate {                  Formatters = Formatters                      .Select(f => f(exception' context))                      .Concat(context.GetEnvironmentTabs().Select(o => DictionarySection.Create(o.Item1' "env_" + o.Item1.GetHashCode()' o.Item2)))                      .Where(t => t != null)                      .ToArray()'                  ErrorCode = context.Response.StatusCode'                  ErrorDescription = "Unhandled exception occurred"'                  Summary = exception.GetType().FullName + ": " + exception.Message.LimitLength(600)              };
Magic Number,DotVVM.Framework.Hosting.Middlewares,DotvvmFileUploadMiddleware,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\Middlewares\DotvvmFileUploadMiddleware.cs,IsMaxSizeExceeded,The following statement contains a magic number: var maxFileSizeInBytes = maxFileSize * 1024 * 1024;
Magic Number,DotVVM.Framework.Hosting.Middlewares,DotvvmFileUploadMiddleware,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Hosting\Middlewares\DotvvmFileUploadMiddleware.cs,IsMaxSizeExceeded,The following statement contains a magic number: var maxFileSizeInBytes = maxFileSize * 1024 * 1024;
Magic Number,DotVVM.Framework.ResourceManagement,DotvvmResourceRepository,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\DotvvmResourceRepository.cs,FindResource,The following statement contains a magic number: var split = name.Split(new[] { ':' }' 2);
Magic Number,DotVVM.Framework.ResourceManagement,FileResourceLocation,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\FileResourceLocation.cs,FileResourceLocation,The following statement contains a magic number: filePath = filePath.Substring(2);
Magic Number,DotVVM.Framework.ResourceManagement,ResourceManager,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\ResourceManagement\ResourceManager.cs,CreateRelativeResourceLocation,The following statement contains a magic number: return url.StartsWith("~/"' StringComparison.Ordinal) ?                     new FileResourceLocation(url.Substring(2)) :                     (IResourceLocation)new UrlResourceLocation(url);
Magic Number,DotVVM.Framework.Routing,UrlHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\UrlHelper.cs,IsLocalUrl,The following statement contains a magic number: url.Length == 2
Magic Number,DotVVM.Framework.Routing,UrlHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\UrlHelper.cs,IsLocalUrl,The following statement contains a magic number: url[2] != '/' && url[2] != '\\'
Magic Number,DotVVM.Framework.Routing,UrlHelper,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Routing\UrlHelper.cs,IsLocalUrl,The following statement contains a magic number: url[2] != '/' && url[2] != '\\'
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: return mi.MetadataToken * 17 + (mi.DeclaringType?.GetTypeInfo()?.MetadataToken ?? 0);
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: int hash = 368814364;
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: hash *= 17;
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: hash += (int)type * 23;
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: switch (type)                  {                      case ExpressionType.Add:                      case ExpressionType.AddChecked:                      case ExpressionType.And:                      case ExpressionType.Divide:                      case ExpressionType.Equal:                      case ExpressionType.ExclusiveOr:                      case ExpressionType.GreaterThan:                      case ExpressionType.GreaterThanOrEqual:                      case ExpressionType.AndAlso:                      case ExpressionType.Power:                      case ExpressionType.RightShift:                      case ExpressionType.Subtract:                      case ExpressionType.SubtractChecked:                      case ExpressionType.ArrayIndex:                      case ExpressionType.Modulo:                      case ExpressionType.Multiply:                      case ExpressionType.MultiplyChecked:                      case ExpressionType.LeftShift:                      case ExpressionType.OnesComplement:                      case ExpressionType.Assign:                      case ExpressionType.AddAssign:                      case ExpressionType.AndAssign:                      case ExpressionType.DivideAssign:                      case ExpressionType.ExclusiveOrAssign:                      case ExpressionType.LeftShiftAssign:                      case ExpressionType.ModuloAssign:                      case ExpressionType.MultiplyAssign:                      case ExpressionType.OrAssign:                      case ExpressionType.PowerAssign:                      case ExpressionType.RightShiftAssign:                      case ExpressionType.SubtractAssign:                      case ExpressionType.AddAssignChecked:                      case ExpressionType.MultiplyAssignChecked:                      case ExpressionType.SubtractAssignChecked:                      case ExpressionType.PreIncrementAssign:                      case ExpressionType.PreDecrementAssign:                      case ExpressionType.PostIncrementAssign:                      case ExpressionType.PostDecrementAssign:                      case ExpressionType.IsTrue:                      case ExpressionType.IsFalse:                      case ExpressionType.NotEqual:                      case ExpressionType.Or:                      case ExpressionType.OrElse:                      case ExpressionType.LessThan:                      case ExpressionType.LessThanOrEqual:                      case ExpressionType.Coalesce:                          var bin = (BinaryExpression)obj;                          hash *= 17;                          hash += GetHashCode(bin.Left);                          hash *= 19;                          hash += GetHashCode(bin.Right);                          break;                      case ExpressionType.Call:                          var call = (MethodCallExpression)obj;                          hash *= 19;                          hash += GetHashCode(call.Method);                          hash *= 23;                          hash += GetHashCode(call.Object);                          foreach (var arg in call.Arguments)                          {                              hash *= 17;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.ConvertChecked:                      case ExpressionType.Negate:                      case ExpressionType.UnaryPlus:                      case ExpressionType.Quote:                      case ExpressionType.Not:                      case ExpressionType.TypeAs:                      case ExpressionType.NegateChecked:                      case ExpressionType.Unbox:                      case ExpressionType.Convert:                      case ExpressionType.ArrayLength:                          var un = (UnaryExpression)obj;                          hash *= 29;                          hash += GetHashCode(un.Operand);                          if (un.Method != null)                          {                              hash *= 17;                              hash += GetHashCode(un.Method);                          }                          break;                      case ExpressionType.Conditional:                          var cond = (ConditionalExpression)obj;                          hash *= 17;                          hash += GetHashCode(cond.IfFalse);                          hash *= 23;                          hash += GetHashCode(cond.IfTrue);                          hash *= 19;                          hash += GetHashCode(cond.Test);                          break;                      case ExpressionType.Constant:                          var conste = (ConstantExpression)obj;                          hash *= 17;                          hash += conste.Value?.GetHashCode() ?? 6446;                          break;                      case ExpressionType.Invoke:                          var inv = (InvocationExpression)obj;                          hash *= 17;                          hash += GetHashCode(inv.Expression);                          foreach (var arg in inv.Arguments)                          {                              hash *= 19;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Lambda:                          var lam = (LambdaExpression)obj;                          foreach (var p in lam.Parameters)                          {                              hash *= 17;                              hash += GetHashCode(p);                          }                          hash *= 23;                          hash += lam.Name?.GetHashCode() ?? 3215;                          hash *= 19;                          hash += GetHashCode(lam.Body);                          break;                      case ExpressionType.ListInit:                          var linit = (ListInitExpression)obj;                          hash *= 17;                          hash += GetHashCode(linit.NewExpression);                          foreach (var ini in linit.Initializers)                          {                              hash *= 23;                              hash += GetHashCode(ini.AddMethod);                              hash *= 29;                              hash += GetHashCode(ini.Arguments);                          }                          break;                      case ExpressionType.MemberAccess:                          var mem = (MemberExpression)obj;                          hash *= 23;                          hash += GetHashCode(mem.Member);                          hash *= 19;                          hash += GetHashCode(mem.Expression);                          break;                      case ExpressionType.MemberInit:                          var minit = (MemberInitExpression)obj;                          throw new NotImplementedException();                      //return Equals(minitX' minitY) && minitX.Bindings.Zip(minitY.Bindings' (a' b) => a.BindingType == b.BindingType && a.Member == b.Member).All(f => f);                      case ExpressionType.New:                          var newe = (NewExpression)obj;                          hash *= 31;                          hash += GetHashCode(newe.Constructor);                          foreach (var arg in newe.Arguments)                          {                              hash *= 29;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.NewArrayInit:                      case ExpressionType.NewArrayBounds:                          var newArr = (NewArrayExpression)obj;                          foreach (var arg in newArr.Expressions)                          {                              hash *= 37;                              hash += GetHashCode(arg);                          }                          break;                      case ExpressionType.Parameter:                          var param = (ParameterExpression)obj;                          hash *= 17;                          if (param.Name != null && !param.Name.StartsWith("__"))                          {                              hash += param.Name.GetHashCode();                          }                          else                          {                              hash += param.GetHashCode();                          }                          if (param.IsByRef) hash++;                          break;                      case ExpressionType.TypeEqual:                      case ExpressionType.TypeIs:                          var typeBin = (TypeBinaryExpression)obj;                          hash *= 29;                          hash += typeBin.TypeOperand.GetHashCode();                          hash *= 17;                          hash += GetHashCode(typeBin.Expression);                          break;                      case ExpressionType.Default:                          hash += 6546546546;                          break;                      case ExpressionType.Block:                          var blockExpression = (BlockExpression)obj;                          hash *= 31;                          hash += GetHashCode(blockExpression.Variables);                          hash *= 3;                          hash += GetHashCode(blockExpression.Expressions);                          break;                      case ExpressionType.Switch:                          var switchExpr = (SwitchExpression)obj;                          hash += GetHashCode(switchExpr.DefaultBody);                          hash *= 31;                          hash += GetHashCode(switchExpr.SwitchValue);                          foreach (var expr in switchExpr.Cases)                          {                              hash *= 7;                              hash += GetHashCode(expr.Body);                              hash += 11;                              hash += GetHashCode(expr.TestValues);                          }                          break;                      case ExpressionType.Extension:                          hash += obj.ToString().GetHashCode(); break;                      case ExpressionType.Index:                          var indexExpr = (IndexExpression)obj;                          hash += GetHashCode(indexExpr.Arguments);                          hash += indexExpr.Indexer?.GetHashCode() ?? 6453124768463154687;                          hash *= 47;                          hash += GetHashCode(indexExpr.Object);                          break;                      default:                          throw new NotImplementedException($"GetHasCode of expression type { type } is not supported.");                  }
Magic Number,DotVVM.Framework.Utils,ExpressionComparer,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\ExpressionComparer.cs,GetHashCode,The following statement contains a magic number: hash *= 4611686018427387847;
Magic Number,DotVVM.Framework.Utils,SecureGuidGenerator,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\SecureGuidGenerator.cs,GenerateGuid,The following statement contains a magic number: byte[] bytes = new byte[16];
Magic Number,DotVVM.Framework.Utils,TextUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\TextUtils.cs,FormatSize,The following statement contains a magic number: size = size / 1024;
Magic Number,DotVVM.Framework.Utils,TextUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\TextUtils.cs,FormatSize,The following statement contains a magic number: size >= 1024 && order < sizeUnits.Length - 1
Magic Number,DotVVM.Framework.Utils,TextUtils,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\TextUtils.cs,FormatSize,The following statement contains a magic number: return order <= 2                  ? $"{size:0.##} {sizeUnits[order]}"                  : $"{size:0.#} {sizeUnits[order]}";
Magic Number,Microsoft.AspNet.WebUtilities,BufferedReadStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\BufferedReadStream.cs,ReadLine,The following statement contains a magic number: var builder = new MemoryStream(200);
Magic Number,Microsoft.AspNet.WebUtilities,BufferedReadStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\BufferedReadStream.cs,ReadLineAsync,The following statement contains a magic number: var builder = new MemoryStream(200);
Magic Number,Microsoft.AspNet.WebUtilities,BufferedReadStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\BufferedReadStream.cs,DecodeLine,The following statement contains a magic number: var length = foundCRLF ? builder.Length - 2 : builder.Length;
Magic Number,Microsoft.AspNet.WebUtilities,MultipartReader,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReader.cs,MultipartReader,The following statement contains a magic number: bufferSize < boundary.Length + 8
Magic Number,Microsoft.AspNet.WebUtilities,MultipartReader,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReader.cs,MultipartReader,The following statement contains a magic number: HeaderLengthLimit = 1024 * 4;
Magic Number,Microsoft.AspNet.WebUtilities,MultipartReader,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReader.cs,MultipartReader,The following statement contains a magic number: HeaderLengthLimit = 1024 * 4;
Magic Number,Microsoft.AspNet.WebUtilities,MultipartReader,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReader.cs,MultipartReader,The following statement contains a magic number: TotalHeaderSizeLimit = 1024 * 16;
Magic Number,Microsoft.AspNet.WebUtilities,MultipartReader,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReader.cs,MultipartReader,The following statement contains a magic number: TotalHeaderSizeLimit = 1024 * 16;
Magic Number,Microsoft.AspNet.WebUtilities,MultipartReaderStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReaderStream.cs,MultipartReaderStream,The following statement contains a magic number: _finalBoundaryLength = _boundaryBytes.Length + 2;
Magic Number,Microsoft.AspNet.WebUtilities,MultipartReaderStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReaderStream.cs,Read,The following statement contains a magic number: var remainder = _innerStream.ReadLine(lengthLimit: 100);
Magic Number,Microsoft.AspNet.WebUtilities,MultipartReaderStream,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\MultipartReaderStream.cs,ReadAsync,The following statement contains a magic number: var remainder = await _innerStream.ReadLineAsync(lengthLimit: 100' cancellationToken: cancellationToken);
Magic Number,Microsoft.AspNet.WebUtilities,StreamHelperExtensions,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Utils\HttpAbstractions\StreamHelperExtensions.cs,DrainAsync,The following statement contains a magic number: byte[] buffer = new byte[1024];
Missing Default,DotVVM.Framework.Compilation.Binding,TypeConversion,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Binding\TypeConversions.cs,GetBaseCommonType,The following switch statement is missing a default case: switch (CanConvert(expression.Type' baseType))                      {                          case 1:                              baseType = expression.Type;                              break;                            case -1:                              throw new Exception(string.Format("Cannot convert between types {0} and {1}"' baseType.Name' expression.Type.Name));                      }
Missing Default,DotVVM.Framework.Compilation.Javascript,JavascriptTranslationVisitor,C:\research\architectureSmells\repos\riganti_redwood\src\DotVVM.Framework\Compilation\Javascript\JavascriptTranslationVisitor.cs,Translate,The following switch statement is missing a default case: switch (expression.NodeType)              {                  case ExpressionType.Constant:                      return TranslateConstant((ConstantExpression)expression);                    case ExpressionType.Call:                      return TranslateMethodCall((MethodCallExpression)expression);                    case ExpressionType.MemberAccess:                      return TranslateMemberAccess((MemberExpression)expression);                    case ExpressionType.Parameter:                      return TranslateParameter((ParameterExpression)expression);                    case ExpressionType.Conditional:                      return TranslateConditional((ConditionalExpression)expression);                    case ExpressionType.Index:                      return TranslateIndex((IndexExpression)expression);                    case ExpressionType.Assign:                      return TranslateAssign((BinaryExpression)expression);                    case ExpressionType.Lambda:                      return TranslateLambda((LambdaExpression)expression);                    case ExpressionType.Block:                      return TranslateBlock((BlockExpression)expression);                    case ExpressionType.Default:                      return TranslateDefault((DefaultExpression)expression);                    case ExpressionType.Invoke:                      return TranslateInvoke((InvocationExpression)expression);              }
