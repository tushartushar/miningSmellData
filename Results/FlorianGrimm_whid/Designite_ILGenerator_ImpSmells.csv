Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,Cyclomatic complexity of the method is 63
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,LongVersionOf,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,ShortVersionOf,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,SizeOfOffset,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci,ILRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILRewriter.cs,EmitMethodBody,Cyclomatic complexity of the method is 47
Complex Method,Microsoft.Cci,ILRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILRewriter.cs,EmitDebugInformationFor,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci,ILRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILRewriter.cs,EmitOperation,Cyclomatic complexity of the method is 58
Long Parameter List,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AddExceptionHandlerInformation,The method has 7 parameters.
Long Parameter List,Microsoft.Cci,ILGeneratorMethodBody,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\MethodBody.cs,ILGeneratorMethodBody,The method has 6 parameters.
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The length of the statement  "				// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes " is 121.
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The length of the statement  "					//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one. " is 140.
Long Statement,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,GetSynchronizationInformation,The length of the statement  "		synchronizationPoints = this.synchronizationPoints == null ? Enumerable<ISynchronizationPoint>.Empty : this.synchronizationPoints.AsReadOnly () " is 143.
Long Statement,Microsoft.Cci,ILRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILRewriter.cs,Rewrite,The length of the statement  "	return new ILGeneratorMethodBody (this.Generator' methodBody.LocalsAreZeroed' this.maxStack' methodBody.MethodDefinition' this.localVariables.ToArray ()' Enumerable<ITypeDefinition>.Empty); " is 189.
Long Statement,Microsoft.Cci,ILRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILRewriter.cs,EmitMethodBody,The length of the statement  "		this.Generator.AddExceptionHandlerInformation (exceptionInfo.HandlerKind' exceptionInfo.ExceptionType' this.GetLabelFor (exceptionInfo.TryStartOffset)' this.GetLabelFor (exceptionInfo.TryEndOffset)' this.GetLabelFor (exceptionInfo.HandlerStartOffset)' this.GetLabelFor (exceptionInfo.HandlerEndOffset)' exceptionInfo.HandlerKind == HandlerKind.Filter ? this.GetLabelFor (exceptionInfo.FilterDecisionStartOffset) : null); " is 420.
Long Statement,Microsoft.Cci,ILRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILRewriter.cs,EmitDebugInformationFor,The length of the statement  "					if (iteratorScope.Offset >= currentScope.Offset && iteratorScope.Offset + iteratorScope.Length <= currentScope.Offset + currentScope.Length) { " is 142.
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: do {  	adjustment = 0;  	numberOfAdjustments = 0;  	for (int i = 0' n = this.operations.Count; i < n; i++) {  		Operation operation = this.operations [i];  		Contract.Assume (operation != null);  		uint oldOffset = operation.offset;  		uint newOffset = (uint)(((int)oldOffset) + adjustment);  		operation.offset = newOffset;  		ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  		if (label != null) {  			if (operation.OperationCode == OperationCode.Invalid) {  				//Dummy operation that serves as label definition.  				label.Offset = operation.offset;  				continue;  			}  			//For backward branches' this test will compare the new offset of the label with the old offset of the current  			//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  			bool isForwardBranch = label.Offset >= oldOffset;  			// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  			// (1 for the opcode and 1 for the signed byte).  			bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  			OperationCode oldOpCode = operation.OperationCode;  			if (shortOffsetOk) {  				operation.operationCode = ShortVersionOf (operation.OperationCode);  				if (operation.operationCode != oldOpCode) {  					numberOfAdjustments++;  					adjustment -= 3;  				}  			}  			else {  				if (operation.operationCode != LongVersionOf (operation.operationCode))  					throw new InvalidOperationException ();  				//A short branch was specified for an offset that is long.  				//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  			}  			if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  				//eliminate branch to the next instruction  				operation.operationCode = OperationCode.Invalid;  				numberOfAdjustments++;  				adjustment -= 2;  			}  		}  	}  }  while (numberOfAdjustments > 0);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: for (int i = 0' n = this.operations.Count; i < n; i++) {  	Operation operation = this.operations [i];  	Contract.Assume (operation != null);  	uint oldOffset = operation.offset;  	uint newOffset = (uint)(((int)oldOffset) + adjustment);  	operation.offset = newOffset;  	ILGeneratorLabel /*?*/label = operation.value as ILGeneratorLabel;  	if (label != null) {  		if (operation.OperationCode == OperationCode.Invalid) {  			//Dummy operation that serves as label definition.  			label.Offset = operation.offset;  			continue;  		}  		//For backward branches' this test will compare the new offset of the label with the old offset of the current  		//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  		bool isForwardBranch = label.Offset >= oldOffset;  		// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  		// (1 for the opcode and 1 for the signed byte).  		bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  		OperationCode oldOpCode = operation.OperationCode;  		if (shortOffsetOk) {  			operation.operationCode = ShortVersionOf (operation.OperationCode);  			if (operation.operationCode != oldOpCode) {  				numberOfAdjustments++;  				adjustment -= 3;  			}  		}  		else {  			if (operation.operationCode != LongVersionOf (operation.operationCode))  				throw new InvalidOperationException ();  			//A short branch was specified for an offset that is long.  			//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  		}  		if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  			//eliminate branch to the next instruction  			operation.operationCode = OperationCode.Invalid;  			numberOfAdjustments++;  			adjustment -= 2;  		}  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (label != null) {  	if (operation.OperationCode == OperationCode.Invalid) {  		//Dummy operation that serves as label definition.  		label.Offset = operation.offset;  		continue;  	}  	//For backward branches' this test will compare the new offset of the label with the old offset of the current  	//instruction. This is OK' because the new offset of the label will be less than or equal to its old offset.  	bool isForwardBranch = label.Offset >= oldOffset;  	// Short offsets are calculated from the start of the instruction *after* the current instruction' which takes up 2 bytes  	// (1 for the opcode and 1 for the signed byte).  	bool shortOffsetOk = isForwardBranch ? label.Offset - oldOffset <= 129 : newOffset - label.Offset <= 126;  	OperationCode oldOpCode = operation.OperationCode;  	if (shortOffsetOk) {  		operation.operationCode = ShortVersionOf (operation.OperationCode);  		if (operation.operationCode != oldOpCode) {  			numberOfAdjustments++;  			adjustment -= 3;  		}  	}  	else {  		if (operation.operationCode != LongVersionOf (operation.operationCode))  			throw new InvalidOperationException ();  		//A short branch was specified for an offset that is long.  		//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  	}  	if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  		//eliminate branch to the next instruction  		operation.operationCode = OperationCode.Invalid;  		numberOfAdjustments++;  		adjustment -= 2;  	}  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (shortOffsetOk) {  	operation.operationCode = ShortVersionOf (operation.OperationCode);  	if (operation.operationCode != oldOpCode) {  		numberOfAdjustments++;  		adjustment -= 3;  	}  }  else {  	if (operation.operationCode != LongVersionOf (operation.operationCode))  		throw new InvalidOperationException ();  	//A short branch was specified for an offset that is long.  	//The test for isForwardBranch depends on label offsets only decreasing' so it is not an option to replace the short branch with a long one.  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (operation.operationCode != oldOpCode) {  	numberOfAdjustments++;  	adjustment -= 3;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: adjustment -= 3;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  	//eliminate branch to the next instruction  	operation.operationCode = OperationCode.Invalid;  	numberOfAdjustments++;  	adjustment -= 2;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: if (eliminateBranchesToNext && operation.OperationCode == OperationCode.Br_S && operation.offset + 2 == label.Offset) {  	//eliminate branch to the next instruction  	operation.operationCode = OperationCode.Invalid;  	numberOfAdjustments++;  	adjustment -= 2;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,AdjustBranchSizesToBestFit,The following statement contains a magic number: adjustment -= 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 8;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4 * ((uint)labels.Length + 1);  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldloc_S || opcode == OperationCode.Ldloca_S || opcode == OperationCode.Stloc_S)  	this.offset += 1;  else if (opcode == OperationCode.Ldloc || opcode == OperationCode.Ldloca || opcode == OperationCode.Stloc)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldloc || opcode == OperationCode.Ldloca || opcode == OperationCode.Stloc)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 8;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldarg_S || opcode == OperationCode.Ldarga_S || opcode == OperationCode.Starg_S)  	this.offset += 1;  else if (opcode == OperationCode.Ldarg || opcode == OperationCode.Ldarga || opcode == OperationCode.Starg)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: if (opcode == OperationCode.Ldarg || opcode == OperationCode.Ldarga || opcode == OperationCode.Starg)  	this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following statement contains a magic number: this.offset += SizeOfOperationCode (opcode) + 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,SizeOfOffset,The following statement contains a magic number: switch (opcode) {  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	return 1;  default:  	return 4;  }  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,SizeOfOffset,The following statement contains a magic number: return 4;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,SizeOfOperationCode,The following statement contains a magic number: if (((int)opcode) > 0xff && (opcode < OperationCode.Array_Create))  	return 2;  
Magic Number,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,SizeOfOperationCode,The following statement contains a magic number: return 2;  
Magic Number,Microsoft.Cci.ILGeneratorImplementation,Stack,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Push,The following statement contains a magic number: if (this.Count == this.elements.Length)  	Array.Resize (ref this.elements' this.elements.Length * 2);  
Magic Number,Microsoft.Cci.ILGeneratorImplementation,Stack,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Push,The following statement contains a magic number: Array.Resize (ref this.elements' this.elements.Length * 2);  
Missing Default,Microsoft.Cci,ILGenerator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILGenerator.cs,Emit,The following switch statement is missing a default case: switch (opcode) {  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  	this.Emit (opcode);  	return;  }  
Missing Default,Microsoft.Cci,ILRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILRewriter.cs,EmitMethodBody,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bge_Un:  case OperationCode.Bgt:  case OperationCode.Bgt_Un:  case OperationCode.Ble:  case OperationCode.Ble_Un:  case OperationCode.Blt:  case OperationCode.Blt_Un:  case OperationCode.Bne_Un:  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Leave:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	Contract.Assume (operation.Value is uint);  	this.GetLabelFor ((uint)operation.Value);  	break;  case OperationCode.Switch:  	uint[] offsets = operation.Value as uint[];  	Contract.Assume (offsets != null);  	foreach (var offset in offsets) {  		this.GetLabelFor (offset);  	}  	break;  }  
Missing Default,Microsoft.Cci,ILRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ILGenerator\ILRewriter.cs,EmitOperation,The following switch statement is missing a default case: switch (operationCode) {  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bge_Un:  case OperationCode.Bgt:  case OperationCode.Bgt_Un:  case OperationCode.Ble:  case OperationCode.Ble_Un:  case OperationCode.Blt:  case OperationCode.Blt_Un:  case OperationCode.Bne_Un:  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Leave:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Leave_S:  	operationCode = ILGenerator.LongVersionOf (operationCode);  	Contract.Assume (operation.Value is uint);  	value = this.GetLabelFor (+(uint)operation.Value);  	break;  case OperationCode.Switch:  	uint[] offsets = operation.Value as uint[];  	Contract.Assume (offsets != null);  	var n = offsets.Length;  	ILGeneratorLabel[] labels = new ILGeneratorLabel[n];  	for (int i = 0; i < n; i++) {  		var offset = offsets [i];  		labels [i] = this.GetLabelFor (offset);  	}  	value = labels;  	break;  //Avoid the short forms because the locals can get reordered.  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	operationCode = OperationCode.Ldloc;  	break;  case OperationCode.Ldloca_S:  	operationCode = OperationCode.Ldloca;  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	operationCode = OperationCode.Stloc;  	break;  }  
