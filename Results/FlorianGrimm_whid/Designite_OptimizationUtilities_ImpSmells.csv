Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The method has 309 lines of code.
Long Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,NormalizeExpressions,The method has 134 lines of code.
Complex Method,Microsoft.Cci.Optimization,ModuleMerger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Merger.cs,ReparentMembersAndDealWithDuplicates,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,PopulateILGenerator,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitScopeInformationFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,Cyclomatic complexity of the method is 288
Complex Method,Microsoft.Cci.Optimization,Inliner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Inlining.cs,EmitOperation,Cyclomatic complexity of the method is 30
Complex Method,Microsoft.Cci.Optimization,Inliner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Inlining.cs,Inline,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,AddTransferInstructions,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,AddTransferInstructions,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,ReplaceSSALocalsInBlocks,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,ReplaceSSALocal,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,ReplaceSSAParameter,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,ReplaceSSALocalsInTransferInstructions,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,NormalizeExpressions,Cyclomatic complexity of the method is 110
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,TryToUseBinaryBranch,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,TryToUseInvertedBinaryBranch,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,WorthCaching,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,NormalizeExpressions,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,FactorOutCommonSubexpressions,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,EnsureTempIsDefinedBeforeControlReachesBlockFrom,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,RemoveUselessBranches,Cyclomatic complexity of the method is 44
Complex Method,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,HasSameBranchTarget,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci.Optimization,PeILConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PopulateLocals,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.Optimization,PeILConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,GenerateILFor,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.Optimization,PeILConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,EmitOperandsFor,Cyclomatic complexity of the method is 9
Long Parameter List,Microsoft.Cci.Optimization,AssemblyMerger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Merger.cs,Merge,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Optimization,LocalMinimizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\LocalMinimizer.cs,LocalMinimizer,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,AddTransferInstruction,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Optimization,StackEliminator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\StackEliminator.cs,AddTransferInstruction,The method has 6 parameters.
Long Statement,Microsoft.Cci.Optimization,ModuleMerger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Merger.cs,ReparentMembersAndDealWithDuplicates,The length of the statement  "				if (laterAlias == null || laterAlias.Name != alias.Name || laterAlias.GenericParameterCount != alias.GenericParameterCount) " is 123.
Long Statement,Microsoft.Cci.Optimization,ModuleMerger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Merger.cs,ReportNameCollisionAndRename,The length of the statement  "		MessageParameter = MemberHelper.GetMethodSignature (globalMethod' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature)' " is 134.
Long Statement,Microsoft.Cci.Optimization,ModuleMerger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Merger.cs,ReparentModuleReferencesAndDealWithDuplicates,The length of the statement  "		moduleRef.ModuleIdentity = new ModuleIdentity (modId.Name' modId.Location' this.result.ModuleIdentity as AssemblyIdentity); " is 123.
Long Statement,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,PopulateILGenerator,The length of the statement  "		this.ILGenerator.AddExceptionHandlerInformation (exceptionInfo.HandlerKind' exceptionInfo.ExceptionType' this.GetLabelFor (exceptionInfo.TryStartOffset)' this.GetLabelFor (exceptionInfo.TryEndOffset)' this.GetLabelFor (exceptionInfo.HandlerStartOffset)' this.GetLabelFor (exceptionInfo.HandlerEndOffset)' exceptionInfo.HandlerKind == HandlerKind.Filter ? this.GetLabelFor (exceptionInfo.FilterDecisionStartOffset) : null); " is 422.
Long Statement,Microsoft.Cci.Optimization,LocalMinimizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\LocalMinimizer.cs,MinimizeLocals,The length of the statement  "	//now run a post order traversal of blocks' and a reverse traversal of instructions in each block. Once a write to an SSA local is processed' return its " is 152.
Long Statement,Microsoft.Cci.Optimization,LocalMinimizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\LocalMinimizer.cs,MinimizeLocals,The length of the statement  "	return new ILGeneratorMethodBody (ilGenerator' methodBody.LocalsAreZeroed' converter.MaxStack' methodBody.MethodDefinition' converter.Locals.AsReadOnly ()' Enumerable<ITypeDefinition>.Empty); " is 191.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	//First analyze the method body to find out what is known at compile time about the values of variables and expressions. " is 120.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	this.cdfg = ControlAndDataFlowGraph<PeBasicBlock<PeInstruction>' PeInstruction>.GetControlAndDataFlowGraphFor (host' methodBody' this.localScopeProvider); " is 154.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	SingleAssigner<PeBasicBlock<PeInstruction>' PeInstruction>.GetInSingleAssignmentForm (host.NameTable' this.cdfg' this.cfgQueries' this.sourceLocationProvider); " is 159.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	AbstractInterpreter<PeBasicBlock<PeInstruction>' PeInstruction>.InterpretUsingAbstractValues (this.Cdfg' this.CfgQueries' this.ValueMappings); " is 142.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	//TODO: if it turns out that a local or parameter can be aliased in a method body because its address was taken and then used " is 125.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	//First rewrite the graph to eliminate instructions that push things on to the stack or store things into temporary variables. " is 126.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	//After this rewrite' only "sinks" (writes to memory' method calls' conditional branches' etc.) will remain and they will " is 121.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	//use operands that are canonicalized full expressions. Canonicalized expressions already have had constant folding done on them. " is 129.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PartiallyEvaluate,The length of the statement  "	var ssaUndoer = new MultipleAssigner<PeBasicBlock<PeInstruction>' PeInstruction> (this.host' this.Cdfg' this.CfgQueries); " is 121.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,NormalizeExpressions,The length of the statement  "			block.Instructions [i] = this.TryToUseBinaryBranch (instruction' opCode == OperationCode.Brfalse_S || opCode == OperationCode.Brtrue_S); " is 136.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,NormalizeExpressions,The length of the statement  "			//The instruction itself is an operand for another instruction and will be emitted as part of emitting its containing instruction. " is 130.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,TryToUseInvertedBinaryBranch,The length of the statement  "	var floatComparison = comparisonOperandType.TypeCode == PrimitiveTypeCode.Float32 || comparisonOperandType.TypeCode == PrimitiveTypeCode.Float64; " is 145.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,FactorOutCommonSubexpressions,The length of the statement  "		//Then this instruction computes a value. That value may already live in a temporary variable computed by a previous instruction. " is 129.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,FactorOutCommonSubexpressions,The length of the statement  "			//If one or more of our predecessors defines temp' we can save work by not defining it on control paths from those predecessors. " is 128.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,FactorOutCommonSubexpressions,The length of the statement  "	//We are going to do some work for this occurrence of instruction' but perhaps we can get lucky with some of its subexpressions' if any. " is 136.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,EnsureTempIsDefinedBeforeControlReachesBlockFrom,The length of the statement  "	//If one or more of predecessor's predecessors defines temp' we can save work by not defining it on control paths from those predecessors. " is 138.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,EnsureTempIsDefinedBeforeControlReachesBlockFrom,The length of the statement  "	//TODO: But.... if block is not the only successor to predecessor and predecessor has a predecessor that does not define temp " is 125.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,EnsureTempIsDefinedBeforeControlReachesBlockFrom,The length of the statement  "	//Either avoid this altogether by not recursing in such cases' or minimize the impact by looking at path profiles and doing it  " is 126.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,RemoveUselessBranches,The length of the statement  "			//If this branch were not present' control would end up in the same place as the branch is going to' so the branch is useless and we remove it. " is 143.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,RemoveUselessBranches,The length of the statement  "			//But' if the branch has a source location' we can only do so if the next instruction cannot be reached any other way' otherwise debugging gets weird. " is 150.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,GenerateNewBody,The length of the statement  "	var converter = new PeILConverter<PeBasicBlock<PeInstruction>' PeInstruction> (this.Cdfg' ilGenerator' this.localScopeProvider' this.sourceLocationProvider); " is 157.
Long Statement,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,GenerateNewBody,The length of the statement  "	return new ILGeneratorMethodBody (ilGenerator' methodBody.LocalsAreZeroed' converter.MaxStack' methodBody.MethodDefinition' converter.Locals.AsReadOnly ()' Enumerable<ITypeDefinition>.Empty); " is 191.
Long Statement,Microsoft.Cci.Optimization,PeILConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,PopulateLocals,The length of the statement  "	counts.Sort ((KeyValuePair<ILocalDefinition' int> pair1' KeyValuePair<ILocalDefinition' int> pair2) => pair2.Value - pair1.Value); " is 130.
Long Statement,Microsoft.Cci.Optimization,StackEliminator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\StackEliminator.cs,GetNewBody,The length of the statement  "	var converter = new PeILConverter<BasicBlock' Instruction> (this.cdfg' ilGenerator' this.localScopeProvider' this.sourceLocationProvider); " is 138.
Long Statement,Microsoft.Cci.Optimization,StackEliminator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\StackEliminator.cs,GetNewBody,The length of the statement  "	return new ILGeneratorMethodBody (ilGenerator' methodBody.LocalsAreZeroed' converter.MaxStack' methodBody.MethodDefinition' converter.Locals.AsReadOnly ()' Enumerable<ITypeDefinition>.Empty); " is 191.
Long Statement,Microsoft.Cci.Optimization,StackEliminator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\StackEliminator.cs,AddTransferInstructions,The length of the statement  "			this.AddTransferInstruction (block' succ' successorIndex' stackLoad.temporaryForResult' join.temporaryForResult' stackLoad.Type); " is 129.
Magic Number,Microsoft.Cci.Optimization,ModuleMerger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Merger.cs,ReportNameCollisionAndRename,The following statement contains a magic number: this.host.ReportError (new ErrorMessage () {  	Code = 2'  	ErrorReporter = this'  	Error = MergeError.DuplicateGlobalField'  	MessageParameter = MemberHelper.GetMemberSignature (globalField' NameFormattingOptions.Signature)'  });  
Magic Number,Microsoft.Cci.Optimization,ModuleMerger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Merger.cs,ReportNameCollisionAndRename,The following statement contains a magic number: this.host.ReportError (new ErrorMessage () {  	Code = 3'  	ErrorReporter = this'  	Error = MergeError.DuplicateGlobalMethod'  	MessageParameter = MemberHelper.GetMethodSignature (globalMethod' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature)'  });  
Magic Number,Microsoft.Cci.Optimization,ModuleMerger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Merger.cs,ReportNameCollisionAndRename,The following statement contains a magic number: this.host.ReportError (new ErrorMessage () {  	Code = 4'  	ErrorReporter = this'  	Error = MergeError.DuplicateGlobalField'  	MessageParameter = TypeHelper.GetTypeName (nsType)'  });  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Arglist:  case OperationCode.Dup:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldftn:  case OperationCode.Ldnull:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  	this.StackHeight += 1;  	break;  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Initobj:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelema:  case OperationCode.Mkrefany:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Pop:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Stsfld:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Switch:  case OperationCode.Throw:  case OperationCode.Xor:  	this.StackHeight -= 1;  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (operation.Value is IArrayTypeReference);  	var arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank;  	break;  case OperationCode.Array_Set:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank + 1;  	break;  case OperationCode.Array_Create:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank - 1;  	break;  case OperationCode.Array_Create_WithLowerBound:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank * 2 - 1;  	break;  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	this.StackHeight -= 2;  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	this.StackHeight -= 1;  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Callvirt:  case OperationCode.Newobj:  	Contract.Assume (operation.Value is ISignature);  	var signature = (ISignature)operation.Value;  	var adjustment = IteratorHelper.EnumerableCount (signature.Parameters);  	if (operation.OperationCode == OperationCode.Newobj)  		adjustment--;  	else {  		if (operation.OperationCode == OperationCode.Calli)  			adjustment++;  		if (!signature.IsStatic)  			adjustment++;  		if (signature.Type.TypeCode != PrimitiveTypeCode.Void)  			adjustment--;  	}  	this.StackHeight -= adjustment;  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	this.StackHeight -= 2;  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	this.StackHeight -= 3;  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	this.StackHeight += 1;  	this.LoadParameter (operation.Value as IParameterDefinition);  	return;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	this.StackHeight += 1;  	this.LoadParameterAddress (operation.Value as IParameterDefinition);  	return;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	this.StackHeight += 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	this.LoadLocal ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	this.StackHeight += 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	LoadLocalAddress ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Starg:  case OperationCode.Starg_S:  	this.StackHeight -= 1;  	this.StoreParameter (operation.Value as IParameterDefinition);  	return;  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	this.StackHeight -= 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	this.StoreLocal ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Box:  case OperationCode.Break:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Constrained_:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Endfilter:  case OperationCode.Endfinally:  case OperationCode.Isinst:  case OperationCode.Jmp:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldlen:  case OperationCode.Ldobj:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Neg:  case OperationCode.Newarr:  case OperationCode.No_:  case OperationCode.Nop:  case OperationCode.Not:  case OperationCode.Readonly_:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Rethrow:  case OperationCode.Sizeof:  case OperationCode.Tail_:  case OperationCode.Unaligned_:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  case OperationCode.Volatile_:  	break;  case OperationCode.Ret:  	if (this.Cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		this.StackHeight -= 1;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Arglist:  case OperationCode.Dup:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldftn:  case OperationCode.Ldnull:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  	this.StackHeight += 1;  	break;  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Initobj:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelema:  case OperationCode.Mkrefany:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Pop:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Stsfld:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Switch:  case OperationCode.Throw:  case OperationCode.Xor:  	this.StackHeight -= 1;  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (operation.Value is IArrayTypeReference);  	var arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank;  	break;  case OperationCode.Array_Set:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank + 1;  	break;  case OperationCode.Array_Create:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank - 1;  	break;  case OperationCode.Array_Create_WithLowerBound:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank * 2 - 1;  	break;  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	this.StackHeight -= 2;  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	this.StackHeight -= 1;  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Callvirt:  case OperationCode.Newobj:  	Contract.Assume (operation.Value is ISignature);  	var signature = (ISignature)operation.Value;  	var adjustment = IteratorHelper.EnumerableCount (signature.Parameters);  	if (operation.OperationCode == OperationCode.Newobj)  		adjustment--;  	else {  		if (operation.OperationCode == OperationCode.Calli)  			adjustment++;  		if (!signature.IsStatic)  			adjustment++;  		if (signature.Type.TypeCode != PrimitiveTypeCode.Void)  			adjustment--;  	}  	this.StackHeight -= adjustment;  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	this.StackHeight -= 2;  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	this.StackHeight -= 3;  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	this.StackHeight += 1;  	this.LoadParameter (operation.Value as IParameterDefinition);  	return;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	this.StackHeight += 1;  	this.LoadParameterAddress (operation.Value as IParameterDefinition);  	return;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	this.StackHeight += 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	this.LoadLocal ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	this.StackHeight += 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	LoadLocalAddress ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Starg:  case OperationCode.Starg_S:  	this.StackHeight -= 1;  	this.StoreParameter (operation.Value as IParameterDefinition);  	return;  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	this.StackHeight -= 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	this.StoreLocal ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Box:  case OperationCode.Break:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Constrained_:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Endfilter:  case OperationCode.Endfinally:  case OperationCode.Isinst:  case OperationCode.Jmp:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldlen:  case OperationCode.Ldobj:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Neg:  case OperationCode.Newarr:  case OperationCode.No_:  case OperationCode.Nop:  case OperationCode.Not:  case OperationCode.Readonly_:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Rethrow:  case OperationCode.Sizeof:  case OperationCode.Tail_:  case OperationCode.Unaligned_:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  case OperationCode.Volatile_:  	break;  case OperationCode.Ret:  	if (this.Cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		this.StackHeight -= 1;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Arglist:  case OperationCode.Dup:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldftn:  case OperationCode.Ldnull:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  	this.StackHeight += 1;  	break;  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Initobj:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelema:  case OperationCode.Mkrefany:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Pop:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Stsfld:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Switch:  case OperationCode.Throw:  case OperationCode.Xor:  	this.StackHeight -= 1;  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (operation.Value is IArrayTypeReference);  	var arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank;  	break;  case OperationCode.Array_Set:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank + 1;  	break;  case OperationCode.Array_Create:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank - 1;  	break;  case OperationCode.Array_Create_WithLowerBound:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank * 2 - 1;  	break;  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	this.StackHeight -= 2;  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	this.StackHeight -= 1;  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Callvirt:  case OperationCode.Newobj:  	Contract.Assume (operation.Value is ISignature);  	var signature = (ISignature)operation.Value;  	var adjustment = IteratorHelper.EnumerableCount (signature.Parameters);  	if (operation.OperationCode == OperationCode.Newobj)  		adjustment--;  	else {  		if (operation.OperationCode == OperationCode.Calli)  			adjustment++;  		if (!signature.IsStatic)  			adjustment++;  		if (signature.Type.TypeCode != PrimitiveTypeCode.Void)  			adjustment--;  	}  	this.StackHeight -= adjustment;  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	this.StackHeight -= 2;  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	this.StackHeight -= 3;  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	this.StackHeight += 1;  	this.LoadParameter (operation.Value as IParameterDefinition);  	return;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	this.StackHeight += 1;  	this.LoadParameterAddress (operation.Value as IParameterDefinition);  	return;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	this.StackHeight += 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	this.LoadLocal ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	this.StackHeight += 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	LoadLocalAddress ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Starg:  case OperationCode.Starg_S:  	this.StackHeight -= 1;  	this.StoreParameter (operation.Value as IParameterDefinition);  	return;  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	this.StackHeight -= 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	this.StoreLocal ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Box:  case OperationCode.Break:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Constrained_:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Endfilter:  case OperationCode.Endfinally:  case OperationCode.Isinst:  case OperationCode.Jmp:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldlen:  case OperationCode.Ldobj:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Neg:  case OperationCode.Newarr:  case OperationCode.No_:  case OperationCode.Nop:  case OperationCode.Not:  case OperationCode.Readonly_:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Rethrow:  case OperationCode.Sizeof:  case OperationCode.Tail_:  case OperationCode.Unaligned_:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  case OperationCode.Volatile_:  	break;  case OperationCode.Ret:  	if (this.Cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		this.StackHeight -= 1;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Arglist:  case OperationCode.Dup:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldftn:  case OperationCode.Ldnull:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  	this.StackHeight += 1;  	break;  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Initobj:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelema:  case OperationCode.Mkrefany:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Pop:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Stsfld:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Switch:  case OperationCode.Throw:  case OperationCode.Xor:  	this.StackHeight -= 1;  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (operation.Value is IArrayTypeReference);  	var arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank;  	break;  case OperationCode.Array_Set:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank + 1;  	break;  case OperationCode.Array_Create:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank - 1;  	break;  case OperationCode.Array_Create_WithLowerBound:  	Contract.Assume (operation.Value is IArrayTypeReference);  	arrayType = (IArrayTypeReference)operation.Value;  	this.StackHeight -= arrayType.Rank * 2 - 1;  	break;  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	this.StackHeight -= 2;  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	this.StackHeight -= 1;  	Contract.Assume (operation.Value is uint);  	this.ilGenerator.Emit (operation.OperationCode' this.GetLabelFor ((uint)operation.Value));  	return;  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Callvirt:  case OperationCode.Newobj:  	Contract.Assume (operation.Value is ISignature);  	var signature = (ISignature)operation.Value;  	var adjustment = IteratorHelper.EnumerableCount (signature.Parameters);  	if (operation.OperationCode == OperationCode.Newobj)  		adjustment--;  	else {  		if (operation.OperationCode == OperationCode.Calli)  			adjustment++;  		if (!signature.IsStatic)  			adjustment++;  		if (signature.Type.TypeCode != PrimitiveTypeCode.Void)  			adjustment--;  	}  	this.StackHeight -= adjustment;  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	this.StackHeight -= 2;  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	this.StackHeight -= 3;  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	this.StackHeight += 1;  	this.LoadParameter (operation.Value as IParameterDefinition);  	return;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	this.StackHeight += 1;  	this.LoadParameterAddress (operation.Value as IParameterDefinition);  	return;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	this.StackHeight += 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	this.LoadLocal ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	this.StackHeight += 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	LoadLocalAddress ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Starg:  case OperationCode.Starg_S:  	this.StackHeight -= 1;  	this.StoreParameter (operation.Value as IParameterDefinition);  	return;  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	this.StackHeight -= 1;  	Contract.Assume (operation.Value is ILocalDefinition);  	this.StoreLocal ((ILocalDefinition)operation.Value);  	return;  case OperationCode.Box:  case OperationCode.Break:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Constrained_:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Endfilter:  case OperationCode.Endfinally:  case OperationCode.Isinst:  case OperationCode.Jmp:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldlen:  case OperationCode.Ldobj:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Neg:  case OperationCode.Newarr:  case OperationCode.No_:  case OperationCode.Nop:  case OperationCode.Not:  case OperationCode.Readonly_:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Rethrow:  case OperationCode.Sizeof:  case OperationCode.Tail_:  case OperationCode.Unaligned_:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  case OperationCode.Volatile_:  	break;  case OperationCode.Ret:  	if (this.Cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		this.StackHeight -= 1;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The following statement contains a magic number: this.StackHeight -= arrayType.Rank * 2 - 1;  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The following statement contains a magic number: this.StackHeight -= 2;  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The following statement contains a magic number: this.StackHeight -= 2;  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,EmitOperationFor,The following statement contains a magic number: this.StackHeight -= 3;  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadLocal,The following statement contains a magic number: if (localIndex == 0)  	this.ilGenerator.Emit (OperationCode.Ldloc_0' local);  else if (localIndex == 1)  	this.ilGenerator.Emit (OperationCode.Ldloc_1' local);  else if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Ldloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadLocal,The following statement contains a magic number: if (localIndex == 0)  	this.ilGenerator.Emit (OperationCode.Ldloc_0' local);  else if (localIndex == 1)  	this.ilGenerator.Emit (OperationCode.Ldloc_1' local);  else if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Ldloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadLocal,The following statement contains a magic number: if (localIndex == 1)  	this.ilGenerator.Emit (OperationCode.Ldloc_1' local);  else if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Ldloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadLocal,The following statement contains a magic number: if (localIndex == 1)  	this.ilGenerator.Emit (OperationCode.Ldloc_1' local);  else if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Ldloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadLocal,The following statement contains a magic number: if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Ldloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadLocal,The following statement contains a magic number: if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Ldloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadLocal,The following statement contains a magic number: if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Ldloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadParameter,The following statement contains a magic number: if (parIndex == 0)  	this.ilGenerator.Emit (OperationCode.Ldarg_0' parameter);  else if (parIndex == 1)  	this.ilGenerator.Emit (OperationCode.Ldarg_1' parameter);  else if (parIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldarg_2' parameter);  else if (parIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldarg_3' parameter);  else if (parIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldarg_S' parameter);  else  	this.ilGenerator.Emit (OperationCode.Ldarg' parameter);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadParameter,The following statement contains a magic number: if (parIndex == 0)  	this.ilGenerator.Emit (OperationCode.Ldarg_0' parameter);  else if (parIndex == 1)  	this.ilGenerator.Emit (OperationCode.Ldarg_1' parameter);  else if (parIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldarg_2' parameter);  else if (parIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldarg_3' parameter);  else if (parIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldarg_S' parameter);  else  	this.ilGenerator.Emit (OperationCode.Ldarg' parameter);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadParameter,The following statement contains a magic number: if (parIndex == 1)  	this.ilGenerator.Emit (OperationCode.Ldarg_1' parameter);  else if (parIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldarg_2' parameter);  else if (parIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldarg_3' parameter);  else if (parIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldarg_S' parameter);  else  	this.ilGenerator.Emit (OperationCode.Ldarg' parameter);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadParameter,The following statement contains a magic number: if (parIndex == 1)  	this.ilGenerator.Emit (OperationCode.Ldarg_1' parameter);  else if (parIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldarg_2' parameter);  else if (parIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldarg_3' parameter);  else if (parIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldarg_S' parameter);  else  	this.ilGenerator.Emit (OperationCode.Ldarg' parameter);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadParameter,The following statement contains a magic number: if (parIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldarg_2' parameter);  else if (parIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldarg_3' parameter);  else if (parIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldarg_S' parameter);  else  	this.ilGenerator.Emit (OperationCode.Ldarg' parameter);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadParameter,The following statement contains a magic number: if (parIndex == 2)  	this.ilGenerator.Emit (OperationCode.Ldarg_2' parameter);  else if (parIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldarg_3' parameter);  else if (parIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldarg_S' parameter);  else  	this.ilGenerator.Emit (OperationCode.Ldarg' parameter);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,LoadParameter,The following statement contains a magic number: if (parIndex == 3)  	this.ilGenerator.Emit (OperationCode.Ldarg_3' parameter);  else if (parIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Ldarg_S' parameter);  else  	this.ilGenerator.Emit (OperationCode.Ldarg' parameter);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,StoreLocal,The following statement contains a magic number: if (localIndex == 0)  	this.ilGenerator.Emit (OperationCode.Stloc_0' local);  else if (localIndex == 1)  	this.ilGenerator.Emit (OperationCode.Stloc_1' local);  else if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Stloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Stloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Stloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Stloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,StoreLocal,The following statement contains a magic number: if (localIndex == 0)  	this.ilGenerator.Emit (OperationCode.Stloc_0' local);  else if (localIndex == 1)  	this.ilGenerator.Emit (OperationCode.Stloc_1' local);  else if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Stloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Stloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Stloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Stloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,StoreLocal,The following statement contains a magic number: if (localIndex == 1)  	this.ilGenerator.Emit (OperationCode.Stloc_1' local);  else if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Stloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Stloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Stloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Stloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,StoreLocal,The following statement contains a magic number: if (localIndex == 1)  	this.ilGenerator.Emit (OperationCode.Stloc_1' local);  else if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Stloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Stloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Stloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Stloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,StoreLocal,The following statement contains a magic number: if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Stloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Stloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Stloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Stloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,StoreLocal,The following statement contains a magic number: if (localIndex == 2)  	this.ilGenerator.Emit (OperationCode.Stloc_2' local);  else if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Stloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Stloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Stloc' local);  
Magic Number,Microsoft.Cci.Optimization,ControlFlowToMethodBodyConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\ILGeneration.cs,StoreLocal,The following statement contains a magic number: if (localIndex == 3)  	this.ilGenerator.Emit (OperationCode.Stloc_3' local);  else if (localIndex <= byte.MaxValue)  	this.ilGenerator.Emit (OperationCode.Stloc_S' local);  else  	this.ilGenerator.Emit (OperationCode.Stloc' local);  
Missing Default,Microsoft.Cci.Optimization,Inliner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\Inlining.cs,EmitOperation,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Call:  	Contract.Assume (operation.Value is IMethodReference);  	var methodsToInline = this.inlineSelector (this.method' operation.Offset' (IMethodReference)operation.Value);  	Contract.Assume (methodsToInline != null);  	if (methodsToInline.Count == 1) {  		var methodToInline = methodsToInline [0];  		Contract.Assume (methodToInline != null && !methodToInline.IsAbstract && !methodToInline.IsExternal);  		this.Inline (methodToInline.Body);  		return;  	}  	break;  //TODO: virtual calls  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	if (this.returnLabel == null)  		break;  	this.EmitMappedLocalInsteadOfArgument (OperationCode.Ldloc' operation.Value);  	return;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	if (this.returnLabel == null)  		break;  	this.EmitMappedLocalInsteadOfArgument (OperationCode.Ldloca' operation.Value);  	return;  case OperationCode.Starg:  case OperationCode.Starg_S:  	if (this.returnLabel == null)  		break;  	this.EmitMappedLocalInsteadOfArgument (OperationCode.Stloc' operation.Value);  	return;  case OperationCode.Ret:  	if (this.returnLabel != null) {  		this.Generator.Emit (OperationCode.Br' this.returnLabel);  		return;  	}  	break;  }  
Missing Default,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,ReplaceSSALocal,The following switch statement is missing a default case: switch (oldOperation.OperationCode) {  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	newOp = OperationCode.Ldloca;  	goto freeUnifiedLocal;  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	newOp = OperationCode.Stloc;  	freeUnifiedLocal:  	this.availableLocalsFor.Add (ssaLocal.Type.InternedKey' unifiedLocal);  	break;  }  
Missing Default,Microsoft.Cci.Optimization,MultipleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\MultipleAssignment.cs,ReplaceSSAParameter,The following switch statement is missing a default case: switch (oldOperation.OperationCode) {  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	newOp = OperationCode.Ldloca;  	goto freeUnifiedLocal;  case OperationCode.Starg:  case OperationCode.Starg_S:  	newOp = OperationCode.Stloc;  	freeUnifiedLocal:  	this.availableLocalsFor.Add (ssaParameter.Type.InternedKey' unifiedLocal);  	break;  }  
Missing Default,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,TryToUseBinaryBranch,The following switch statement is missing a default case: switch (operand1.Operation.OperationCode) {  case OperationCode.Ceq:  	newOpCode = shortBranch ? OperationCode.Beq_S : OperationCode.Beq;  	break;  case OperationCode.Cgt:  	newOpCode = shortBranch ? OperationCode.Bgt_S : OperationCode.Bgt;  	break;  case OperationCode.Cgt_Un:  	newOpCode = shortBranch ? OperationCode.Bgt_Un_S : OperationCode.Bgt_Un;  	break;  case OperationCode.Clt:  	newOpCode = shortBranch ? OperationCode.Blt_S : OperationCode.Blt;  	break;  case OperationCode.Clt_Un:  	newOpCode = shortBranch ? OperationCode.Blt_Un_S : OperationCode.Blt_Un_S;  	break;  }  
Missing Default,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,TryToUseInvertedBinaryBranch,The following switch statement is missing a default case: switch (operand.Operation.OperationCode) {  case OperationCode.Ceq:  	opCode = shortBranch ? OperationCode.Bne_Un_S : OperationCode.Bne_Un;  	break;  case OperationCode.Cgt:  	if (floatComparison)  		opCode = shortBranch ? OperationCode.Blt_Un_S : OperationCode.Bgt_Un;  	else  		opCode = shortBranch ? OperationCode.Blt_S : OperationCode.Blt;  	break;  case OperationCode.Cgt_Un:  	if (floatComparison)  		opCode = shortBranch ? OperationCode.Blt_S : OperationCode.Blt;  	else  		opCode = shortBranch ? OperationCode.Blt_Un_S : OperationCode.Bgt_Un;  	break;  case OperationCode.Clt:  	if (floatComparison)  		opCode = shortBranch ? OperationCode.Bgt_Un_S : OperationCode.Bgt_Un;  	else  		opCode = shortBranch ? OperationCode.Bgt_S : OperationCode.Bgt;  	break;  case OperationCode.Clt_Un:  	if (floatComparison)  		opCode = shortBranch ? OperationCode.Bgt_S : OperationCode.Bgt;  	else  		opCode = shortBranch ? OperationCode.Bgt_Un_S : OperationCode.Bgt_Un;  	break;  }  
Missing Default,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,WorthCaching,The following switch statement is missing a default case: switch (instruction.Operation.OperationCode) {  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	return false;  }  
Missing Default,Microsoft.Cci.Optimization,PartialEvaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\OptimizationUtilities\PartialEvaluation.cs,RemoveUselessBranches,The following switch statement is missing a default case: switch (instruction.Operation.OperationCode) {  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	Contract.Assume (instruction.Operation.Value is uint);  	var targetOffset = (uint)instruction.Operation.Value;  	//If the branch targets a successor block which is associated with a transfer block' then  	//redirect the branch to the transfer block. Obviously' the branch cannot be useless' so we keep it.  	if (block.transferBlocks != null) {  		var transferBlockOffset = uint.MaxValue - targetOffset;  		for (int i = 0' m = block.transferBlocks.Length; i < m; i++) {  			var tb = block.transferBlocks [i];  			if (tb == null)  				continue;  			if (tb.Offset == transferBlockOffset)  				continue;  			var copy = this.copier.Copy (instruction.Operation);  			copy.Value = transferBlockOffset;  			return;  		}  	}  	var fallThroughBlock = (PeBasicBlock<PeInstruction>)block.FallThroughBlock;  	var fallthroughInstruction = GetFallThroughInstruction (ref fallThroughBlock' targetOffset);  	bool branchIsUseless = fallThroughBlock != null && fallThroughBlock.Offset == targetOffset;  	if (!branchIsUseless && fallthroughInstruction != null)  		branchIsUseless = HasSameBranchTarget (fallthroughInstruction' targetOffset);  	if (branchIsUseless) {  		//If this branch were not present' control would end up in the same place as the branch is going to' so the branch is useless and we remove it.  		//But' if the branch has a source location' we can only do so if the next instruction cannot be reached any other way' otherwise debugging gets weird.  		if (instruction.Operation.Location is IPrimarySourceLocation) {  			if (fallthroughInstruction == null || fallThroughBlock == null)  				break;  			if (!this.CfgQueries.Dominates (block' fallThroughBlock))  				break;  			var copy = this.copier.Copy (fallthroughInstruction.Operation);  			copy.Location = instruction.Operation.Location;  			fallthroughInstruction.Operation = copy;  		}  		block.Instructions [n - 1].OmitInstruction = true;  	}  	break;  }  
