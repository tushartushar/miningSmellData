Implementation smell,Namespace,Class,File,Method,Description
Long Method,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,The method has 361 lines of code.
Complex Method,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,Implements,Cyclomatic complexity of the method is 12
Complex Method,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputWholeProgramReports,Cyclomatic complexity of the method is 16
Complex Method,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputAnalysisReasons,Cyclomatic complexity of the method is 21
Complex Method,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,GetStubMethodBodyEmitterForProfile,Cyclomatic complexity of the method is 9
Complex Method,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,RewriteBinary,Cyclomatic complexity of the method is 10
Complex Method,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,Run,Cyclomatic complexity of the method is 9
Complex Method,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ProcessSummary,Cyclomatic complexity of the method is 8
Complex Method,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NoteFirstTypeVariableConstructed,Cyclomatic complexity of the method is 8
Complex Method,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RewriteBranch,Cyclomatic complexity of the method is 39
Complex Method,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RewriteOpertation,Cyclomatic complexity of the method is 47
Complex Method,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,HandleException,Cyclomatic complexity of the method is 18
Complex Method,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RewriteAny,Cyclomatic complexity of the method is 75
Complex Method,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RecordBranchTargets,Cyclomatic complexity of the method is 45
Complex Method,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RecordExceptionHandlerOffsets,Cyclomatic complexity of the method is 8
Complex Method,ILGarbageCollect.Instrumentation,FinalizeMethodRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,GetOrCreateFinalizer,Cyclomatic complexity of the method is 8
Complex Method,ILGarbageCollect.Instrumentation,ZombieFieldInstrumentor,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,Main,Cyclomatic complexity of the method is 16
Complex Method,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,Cyclomatic complexity of the method is 272
Complex Method,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,CreateAssemblyReportFromRTA,Cyclomatic complexity of the method is 9
Complex Method,ILGarbageCollect.Mark,WholeProgram,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,FindDefinitionWithIdentifierInAssembly,Cyclomatic complexity of the method is 10
Complex Method,ILGarbageCollect.Mark,WholeProgram,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,FindDefinitionsMatchingRegularExpressionInAssembly,Cyclomatic complexity of the method is 10
Complex Method,ILGarbageCollect.Summaries,CompleteBytecodeMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\SimpleBytecodeMethodSummarizer.cs,SummarizeMethod,Cyclomatic complexity of the method is 19
Complex Method,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,CreateSummarizerFromPath,Cyclomatic complexity of the method is 32
Complex Method,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,ParseCommand,Cyclomatic complexity of the method is 10
Complex Method,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,ConsumeOperation,Cyclomatic complexity of the method is 21
Long Parameter List,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,Implements,The method has 5 parameters.
Long Parameter List,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,RunRTA,The method has 5 parameters.
Long Parameter List,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,TransformProgram,The method has 5 parameters.
Long Parameter List,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,RewriteBinary,The method has 6 parameters.
Long Parameter List,ILGarbageCollect.Sweep,TreeShakingRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,TreeShakingRewriter,The method has 6 parameters.
Long Identifier,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,InstantiatedTypeIfPossible,The length of the parameter fullyInstantiatedSpecializedTypeReference is 41.
Long Identifier,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,Implements,The length of the parameter versionsOfMSpecializedForDerived is 32.
Long Identifier,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputWholeProgramReports,The length of the parameter methodsRequiringReflectionSummary is 33.
Long Identifier,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NoteVirtualDispatch,The length of the parameter implementationsOfMethodDefinitionForSubType is 43.
Long Identifier,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RecordExceptionHandlerOffsets,The length of the parameter offsetsUsedInExceptionInformation is 33.
Long Identifier,ILGarbageCollect.Instrumentation,AddGCWaitForFinalization,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,RewriteReturn,The length of the parameter systemGCWaitForPendingFinalizers is 32.
Long Identifier,ILGarbageCollect.Instrumentation,ZombieFieldInstrumentor,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,Main,The length of the parameter shadowFieldsAndMethodsAddedAssembly is 35.
Long Identifier,ILGarbageCollect.Summaries,CompleteBytecodeMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\SimpleBytecodeMethodSummarizer.cs,SummarizeMethod,The length of the parameter implementationsOfMethodDefinitionForSubType is 43.
Long Statement,ILGarbageCollect.Reasons,MethodReachedBecauseDispatchedVirtuallyReason,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\AnalysisReasons.cs,ToString,The length of the statement  "	return "Because of virtual dispatch against " + DispatchAgainstMethod + " with " + AndTypeWasConstructed + " constructed"; " is 122.
Long Statement,ILGarbageCollect.Reasons,AnalysisReasons,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\AnalysisReasons.cs,AllMethodsVirtuallyDispatchedAgainst,The length of the statement  "	return new HashSet<IMethodDefinition> (reasonSetsByVirtualDispatchReached.Keys' new MethodDefinitionEqualityComparer ()); " is 121.
Long Statement,ILGarbageCollect.Reasons,AnalysisReasons,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\AnalysisReasons.cs,AllMethodsNonVirtuallyDispatchedAgainst,The length of the statement  "	return new HashSet<IMethodDefinition> (reasonSetsByNonVirtualDispatchReached.Keys' new MethodDefinitionEqualityComparer ()); " is 124.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,Implements,The length of the statement  "	Contract.Ensures (Contract.ForAll (Contract.Result<ICollection<IMethodDefinition>> ()' resultM => GarbageCollectHelper.MethodDefinitionIsUnspecialized (resultM))); " is 163.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,Implements,The length of the statement  "	Contract.Ensures (Contract.ForAll (Contract.Result<ICollection<IMethodDefinition>> ()' resultM => resultM != null && !(resultM is Dummy))); " is 139.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,Implements,The length of the statement  "	IEnumerable<IMethodDefinition> versionsOfMSpecializedForDerived = SearchSpecializedHierarchyForVersionOfMethod (derived' m); " is 124.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,Implements,The length of the statement  "		// Do we really expect to find an implementation for EACH mSpecializedForDerived; or do we expect to find at least one overall all? " is 131.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,SearchSpecializedHierarchyForVersionOfMethod,The length of the statement  "	Contract.Ensures (Contract.ForAll<IMethodDefinition> (Contract.Result<IEnumerable<IMethodDefinition>> ()' m => UnspecializeAndResolveMethodReference (m) == unspecializedMethod)); " is 178.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,UnspecializeAndResolveMethodReference,The length of the statement  "		unspecializedDefinition = UnspecializeAndResolveMethodReference (((IGenericMethodInstance)resolvedDefinition).GenericMethod); " is 125.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,UnspecializeAndResolveTypeReference,The length of the statement  "			return UnspecializeAndResolveTypeReference (((ISpecializedNestedTypeDefinition)resolvedTypeDefinition).UnspecializedVersion); " is 125.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,MethodDefinitionHasName,The length of the statement  "	IMethodDefinition unspecializedMethodDefinition = GarbageCollectHelper.UnspecializeAndResolveMethodReference (methodDefinition); " is 128.
Long Statement,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,CreateTypeReference,The length of the statement  "	return new Microsoft.Cci.Immutable.NamespaceTypeReference (host' ns' host.NameTable.GetNameFor (names [names.Length - 1])' genericParameterCount' false' false' true' PrimitiveTypeCode.NotPrimitive); " is 198.
Long Statement,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,GetRootAssemblyParentDirectoriesFromOptions,The length of the statement  "	return new HashSet<string> (GetRootAssemblyPathsFromOptions (options).Select (assemblyPath => Path.GetDirectoryName (assemblyPath))); " is 133.
Long Statement,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,GetReflectionSummarizersFromOptions,The length of the statement  "		TextFileMethodSummarizer textFileSummarizer = TextFileMethodSummarizer.CreateSummarizerFromPath (textSummariesPath' wholeProgram); " is 130.
Long Statement,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputWholeProgramReports,The length of the statement  "				outfile.WriteLine ("{0} from type {1}"' constructedParameter' ((IGenericTypeParameter)constructedParameter).DefiningType); " is 122.
Long Statement,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputWholeProgramReports,The length of the statement  "				outfile.WriteLine ("{0} from method {1}"' constructedParameter' ((IGenericMethodParameter)constructedParameter).DefiningMethod); " is 128.
Long Statement,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputWholeProgramReports,The length of the statement  "		Console.WriteLine ("Found {0} methods requiring a reflection summary. List written in report directory to {1}"' methodsRequiringReflectionSummary.Count ()' ReflectionSummaryRequiredFileName); " is 191.
Long Statement,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputWholeProgramReports,The length of the statement  "		Console.WriteLine ("Found {0} unresolved references. List written in report directory to {1}"' unresolvedReferences.Count ()' UnresolvedReferencesFileName); " is 156.
Long Statement,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputAnalysisReasons,The length of the statement  "	using (StreamWriter outfile = new StreamWriter (reportingDirectory + @"\" + ReachedNonVirtualDispatchReasonsFileName)) { " is 120.
Long Statement,ILGarbageCollect,Program,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Program.cs,OutputAnalysisReasons,The length of the statement  "			HashSet<DispatchReachedReason> dispatchReasons = reasons.GetReasonsNonVirtualDispatchWasReached (methodDispatchedAgainst); " is 122.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ConstructionFound,The length of the statement  "	ICollection<IMethodDefinition> implementationsOfFinalizeForT = GarbageCollectHelper.Implements (t' systemObjectType' systemObjectFinalizeMethod); " is 145.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ConstructionFound,The length of the statement  "	this.AddToWorklist (GarbageCollectHelper.UnspecializeAndResolveMethodReference (implementationsOfFinalizeForT.First ())); " is 121.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NoteVirtualDispatch,The length of the statement  "	//Console.WriteLine("{0} has {1} derived methods"' methodDefinition' this.callgraph.GetAllDerivedMethods(methodDefinition).ToArray().Length); " is 141.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NoteVirtualDispatch,The length of the statement  "			ICollection<IMethodDefinition> implementationsOfMethodDefinitionForSubType = GarbageCollectHelper.Implements (subType' typeDefiningM' methodDispatchedUpon); " is 156.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NoteVirtualDispatch,The length of the statement  "				NoteDispatch (methodDispatchedUpon' GarbageCollectHelper.UnspecializeAndResolveMethodReference (implementationOfM)' subType); " is 125.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NoteDispatch,The length of the statement  "		analysisReasons.NoteMethodReachableForReason (runtimeMethod' analysisReasons.MethodReachedByDispatchAgainstVirtualMethodWithTypeConstructed (compileTimeMethod' runtimeType)); " is 174.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NotePotentialNonVirtualMethodReachedForReason,The length of the statement  "	this.TypeUseFound (GarbageCollectHelper.UnspecializeAndResolveTypeReference (targetMethodDefinition.ContainingTypeDefinition)); " is 127.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,Run,The length of the statement  "	//Console.WriteLine("Used flow-based summarizer for {0}/{1} methods"' countUsedFlowBasedSummarizer' ReachableMethods().Count()); " is 128.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ProcessSummary,The length of the statement  "		IMethodDefinition unspecializedMethod = GarbageCollectHelper.UnspecializeAndResolveMethodReference (nonvirtuallyCalledMethod); " is 126.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ProcessSummary,The length of the statement  "		analysisReasons.NoteNonVirtualDispatchReachableForReason (nonvirtuallyCalledMethod' analysisReasons.DispatchReachedBecauseContainingMethodWasReached (summarizedMethod)); " is 169.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ProcessSummary,The length of the statement  "		IMethodDefinition unspecializedMethod = GarbageCollectHelper.UnspecializeAndResolveMethodReference (virtuallyCalledMethod); " is 123.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ProcessSummary,The length of the statement  "		analysisReasons.NoteVirtualDispatchReachableForReason (unspecializedMethod' analysisReasons.DispatchReachedBecauseContainingMethodWasReached (summarizedMethod)); " is 161.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ProcessSummary,The length of the statement  "		ITypeDefinition unspecializedConstructedType = GarbageCollectHelper.UnspecializeAndResolveTypeReference (constructedType); " is 122.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,ProcessSummary,The length of the statement  "		ConstructionFoundWithReason (unspecializedConstructedType' analysisReasons.TypeConstructedBecauseAllocatingMethodReached (summarizedMethod)); " is 141.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NoteGenericParameterFlowForMethod,The length of the statement  "	if (calledMethod.ContainingTypeDefinition is IGenericTypeInstance && (calledMethod.IsStatic || calledMethod.IsConstructor)) { " is 125.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,NoteGenericParameterFlow,The length of the statement  "				IMethodDefinition defaultConstructor = TypeHelper.GetMethod (unspecializedConcreteType' wholeProgram.Host ().NameTable.GetNameFor (".ctor")); " is 141.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,IsReflectionSummaryProbablyNeeded,The length of the statement  "		foreach (IMethodDefinition calledMethod in bytecodeSummary.NonvirtuallyCalledMethods.Concat (bytecodeSummary.VirtuallyCalledMethods)) { " is 135.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,IsReflectionSummaryProbablyNeeded,The length of the statement  "			if (calledMethod.ContainingType.ToString ().Contains ("System.Reflection") || calledMethod.ContainingType.ToString ().Contains ("System.Activator") || calledMethod.ContainingType.ToString ().Contains ("System.Xml.Serialization.XmlSerializer")) { " is 245.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,GetMethodCallees,The length of the statement  "			if (this.ReachableMethods ().Contains (GarbageCollectHelper.UnspecializeAndResolveMethodReference (method as IMethodReference))) " is 128.
Long Statement,ILGarbageCollect,RapidTypeAnalysis,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\RapidTypeAnalysis.cs,GetMethodCallees,The length of the statement  "			if (this.ReachableMethods ().Contains (GarbageCollectHelper.UnspecializeAndResolveMethodReference (method as IMethodReference))) " is 128.
Long Statement,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,CreateTypeReference,The length of the statement  "	return new Microsoft.Cci.Immutable.NamespaceTypeReference (host' ns' host.NameTable.GetNameFor (names [names.Length - 1])' 0' false' false' true' PrimitiveTypeCode.NotPrimitive); " is 178.
Long Statement,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RewriteOpertation,The length of the statement  "		//case TypeCode.Empty: // this would be the value for null' but the case when op.Value is null is handled before the switch statement " is 133.
Long Statement,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,Rewrite,The length of the statement  "	this.methodBody.OperationExceptionInformation = new List<IOperationExceptionInformation> (this.generator.GetOperationExceptionInformation ()); " is 142.
Long Statement,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RecordBranchTargets,The length of the statement  "			if (op.OperationCode != OperationCode.Br || op.OperationCode != OperationCode.Br_S || op.OperationCode != OperationCode.Leave || op.OperationCode != OperationCode.Leave_S) { " is 173.
Long Statement,ILGarbageCollect.Instrumentation,AddGCWaitForFinalization,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,RewriteReturn,The length of the statement  "	var systemGC = UnitHelper.FindType (base.host.NameTable' base.host.FindAssembly (host.CoreAssemblySymbolicIdentity)' "System.GC"); " is 130.
Long Statement,ILGarbageCollect.Instrumentation,AddGCWaitForFinalization,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,RewriteReturn,The length of the statement  "	var systemGCWaitForPendingFinalizers = TypeHelper.GetMethod (systemGC' base.host.NameTable.GetNameFor ("WaitForPendingFinalizers")); " is 132.
Long Statement,ILGarbageCollect.Instrumentation,ShadowFieldRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,Rewrite,The length of the statement  "					Name = this.host.NameTable.GetNameFor (MemberHelper.GetMemberSignature (field' NameFormattingOptions.None) + "$$storeCount")' " is 125.
Long Statement,ILGarbageCollect.Instrumentation,ShadowFieldRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,Rewrite,The length of the statement  "					Name = this.host.NameTable.GetNameFor (MemberHelper.GetMemberSignature (field' NameFormattingOptions.None) + "$$loadCount")' " is 124.
Long Statement,ILGarbageCollect.Instrumentation,FinalizeMethodRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ZombieFieldInstrumentor.cs,GetOrCreateFinalizer,The length of the statement  "		var baseClassFinalize = new Microsoft.Cci.MethodReference (base.host' baseClass' CallingConvention.HasThis' base.host.PlatformType.SystemVoid' base.host.NameTable.GetNameFor ("Finalize")' 0); " is 191.
Long Statement,ILGarbageCollect.LocalFlow,LocalsAndOperandsStateAbstraction,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,LessThanOrEqual,The length of the statement  "	return ValueListLessThanOrEqual (lhs.Locals' rhs.Locals) && ValueListLessThanOrEqual (lhs.OperandStack' lhs.OperandStack); " is 122.
Long Statement,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,The length of the statement  "          Contract.Assume(instruction.Operation.Value is IArrayTypeReference); //This is an informally specified property of the Metadata model." is 134.
Long Statement,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,The length of the statement  "          Contract.Assume(instruction.Operation.Value is ISignature); //This is an informally specified property of the Metadata model." is 125.
Long Statement,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,The length of the statement  "          Contract.Assume(instruction.Operation.Value is ISignature); //This is an informally specified property of the Metadata model." is 125.
Long Statement,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,The length of the statement  "          Contract.Assume(instruction.Operation.Value is ISignature); //This is an informally specified property of the Metadata model." is 125.
Long Statement,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,The length of the statement  "          InitializeArgumentsAndPushReturnResult(instruction' stack' (ISignature)instruction.Operation.Value); //won't push anything" is 122.
Long Statement,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,The length of the statement  "		currentState.Push (ValueAbstraction.GetAbstractValueForType (FixupTypeForFlow (((IMethodReference)instruction.Operation.Value).ResolvedMethod.ContainingTypeDefinition))); " is 170.
Long Statement,ILGarbageCollect.LocalFlow,WorkListAlgorithm,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,RunOnMethod,The length of the statement  "	ControlAndDataFlowGraph<BasicBlock<Instruction>' Instruction> cfg = ControlAndDataFlowGraph<BasicBlock<Instruction>' Instruction>.GetControlAndDataFlowGraphFor (host' methodDefinition.Body); " is 190.
Long Statement,ILGarbageCollect.LocalFlow,WorkListAlgorithm,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,ProcessBlock,The length of the statement  "	if (ControlFlowGraph.MethodBody.MethodDefinition.ToString ().Contains ("Microsoft.Cci.IModule Microsoft.Cci.MutableCodeModel.MetadataRewriter.Rewrite(Microsoft.Cci.IModule)")) { " is 177.
Long Statement,ILGarbageCollect.LocalFlow,WorkListAlgorithm,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,ProcessBlock,The length of the statement  "	//Console.WriteLine("Processing block {0} preState is {1} new post state {2} old post state {3}"' block.GetHashCode()' preState' newPostState' oldPostState); " is 157.
Long Statement,ILGarbageCollect.LocalFlow,TypesValueAbstraction,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,LessThanOrEqual,The length of the statement  "	return TypeHelper.Type1DerivesFromOrIsTheSameAsType2 (lhs' rhs) || (rhs.IsInterface && TypeHelper.Type1ImplementsType2 (lhs' rhs)) || (lhs.IsInterface && rhs == host.PlatformType.SystemObject.ResolvedType); " is 206.
Long Statement,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,GetAssemblyReportDirectory,The length of the statement  "	string assemblyReportDirectory = allReportsDirectory + @"\" + assemblyFileName + "-" + assembly.AssemblyIdentity.Version + ".report"; " is 133.
Long Statement,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,CreateAssemblyReportFromPath,The length of the statement  "	report.reachableTypes.UnionWith (ReadDefinitionsFromIdentifierFile<ITypeDefinition> (assemblyReportDirectory + @"\" + ReachableTypesFileName' idMap)); " is 150.
Long Statement,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,CreateAssemblyReportFromPath,The length of the statement  "	report.unreachableTypes.UnionWith (ReadDefinitionsFromIdentifierFile<ITypeDefinition> (assemblyReportDirectory + @"\" + UnusedTypesFileName' idMap)); " is 149.
Long Statement,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,CreateAssemblyReportFromPath,The length of the statement  "	report.reachableMethods.UnionWith (ReadDefinitionsFromIdentifierFile<IMethodDefinition> (assemblyReportDirectory + @"\" + ReachableMethodsFileName' idMap)); " is 156.
Long Statement,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,CreateAssemblyReportFromPath,The length of the statement  "	report.unreachableMethods.UnionWith (ReadDefinitionsFromIdentifierFile<IMethodDefinition> (assemblyReportDirectory + @"\" + UnusedMethodsFileName' idMap)); " is 155.
Long Statement,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,CreateAssemblyReportFromPath,The length of the statement  "	report.reachableFields.UnionWith (ReadDefinitionsFromIdentifierFile<IFieldDefinition> (assemblyReportDirectory + @"\" + ReachableFieldsFileName' idMap)); " is 153.
Long Statement,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,CreateAssemblyReportFromPath,The length of the statement  "	report.unreachableFields.UnionWith (ReadDefinitionsFromIdentifierFile<IFieldDefinition> (assemblyReportDirectory + @"\" + UnusedFieldsFileName' idMap)); " is 152.
Long Statement,ILGarbageCollect.Mark,AssemblyReport,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,ReadDefinitionsFromIdentifierFile,The length of the statement  "						throw new System.Exception ("Found " + definitionsWithIdentifier.Count () + " definitions with identifier " + identifier); " is 122.
Long Statement,ILGarbageCollect.Mark,DocumentationCommentDefinitionIdStringMap,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,CreateEntryPointListFromString,The length of the statement  "				Console.WriteLine ("Warning: found multiple methods with ID string {0}. Treating both as possible entry points."' entryPointString); " is 132.
Long Statement,ILGarbageCollect.Mark,WholeProgram,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,FindTypeWithName,The length of the statement  "		INamedTypeDefinition foundType = UnitHelper.FindType (host.NameTable' assembly' fullyQualifiedName' genericParameterCount); " is 123.
Long Statement,ILGarbageCollect.Mark,WholeProgram,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,SearchWholeProgram,The length of the statement  "			throw new Exception ("Found " + foundAssemblyCount + " assemblies with name " + assemblyName + ". Unfortunately we don't support unification at this time."); " is 157.
Long Statement,ILGarbageCollect.Mark,WholeProgram,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,FindDefinitionWithIdentifierInAssembly,The length of the statement  "		throw new Exception ("Un recognized doc comment definition identifier prefix in: " + docCommentIdentifier + " (expected T:' M:' or F:)"); " is 137.
Long Statement,ILGarbageCollect.Mark,WholeProgram,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,FindDefinitionsMatchingRegularExpressionInAssembly,The length of the statement  "		throw new Exception ("Un recognized doc comment definition identifier prefix in: " + regexPattern + " (expected T:' M:' or F:)"); " is 129.
Long Statement,ILGarbageCollect.Mark,ClassHierarchy,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,DirectSubClassesOfClass,The length of the statement  "        typeDefinition == host.PlatformType.SystemObject.ResolvedType || GarbageCollectHelper.BaseClasses(t).Contains(typeDefinition)));*/if (subclassSetsBySuperClass.ContainsKey (typeDefinition)) { " is 190.
Long Statement,ILGarbageCollect.Mark,DocCommentFileEntryPointDetector,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,GetEntryPoints,The length of the statement  "	DocumentationCommentDefinitionIdStringMap idMap = new DocumentationCommentDefinitionIdStringMap (wholeProgram.AllAssemblies ()); " is 128.
Long Statement,ILGarbageCollect.Mark,WholeProgramSearchQuery,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,Validate,The length of the statement  "		if (DefinitionSpecifier.StartsWith ("M:") || DefinitionSpecifier.StartsWith ("T:") || DefinitionSpecifier.StartsWith ("F:")) { " is 126.
Long Statement,ILGarbageCollect.Summaries,ReachabilityBasedLocalFlowMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,SummarizeMethod,The length of the statement  "	var algorithm = new WorkListAlgorithm<ReachabilityStateInterpreter' ReachabilityStateAbstraction' bool> (stateInterpreter); " is 123.
Long Statement,ILGarbageCollect.Summaries,TypesLocalFlowMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,SummarizeMethod,The length of the statement  "      if (TypeHelper.TryGetFullyInstantiatedSpecializedTypeReference(methodDefinition.ContainingTypeDefinition' out fullyInstantiatedSpecializedTypeReference)) {" is 155.
Long Statement,ILGarbageCollect.Summaries,TypesLocalFlowMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,SummarizeMethod,The length of the statement  "          if (GarbageCollectHelper.UnspecializeAndResolveMethodReference(instantiatedMethod).InternedKey == methodDefinition.InternedKey) {" is 129.
Long Statement,ILGarbageCollect.Summaries,TypesLocalFlowMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,SummarizeMethod,The length of the statement  "	var stateInterpreter = new VirtualCallRecordingStateInterpreter<TypesValueAbstraction' ITypeDefinition> (valueAbstraction); " is 123.
Long Statement,ILGarbageCollect.Summaries,TypesLocalFlowMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,SummarizeMethod,The length of the statement  "	var algorithm = new WorkListAlgorithm<VirtualCallRecordingStateInterpreter<TypesValueAbstraction' ITypeDefinition>' LocalsAndOperandsStateAbstraction<TypesValueAbstraction' ITypeDefinition>' LocalsAndOperands<ITypeDefinition>> (stateInterpreter); " is 246.
Long Statement,ILGarbageCollect.Summaries,TypesLocalFlowMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,SummarizeMethod,The length of the statement  "				ITypeDefinition valueAtReceiver = algorithm.StateInterpreter.ReceiverValueForVirtualCallInstruction (instruction.Operation); " is 124.
Long Statement,ILGarbageCollect.Summaries,TypesLocalFlowMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,SummarizeMethod,The length of the statement  "				Contract.Assert (valueAtReceiver == wholeProgram.Host ().PlatformType.SystemObject.ResolvedType || TypeHelper.Type1DerivesFromOrIsTheSameAsType2 (valueAtReceiver' compileTimeType) || (compileTimeType.IsInterface && TypeHelper.Type1ImplementsType2 (valueAtReceiver' compileTimeType)) || (valueAtReceiver.IsInterface && compileTimeType == wholeProgram.Host ().PlatformType.SystemObject.ResolvedType)); " is 399.
Long Statement,ILGarbageCollect.Summaries,LocalFlowEnhancedBytecodeVisitor,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,Visit,The length of the statement  "				if (!tightenedReceiverType.IsInterface && TypeHelper.Type1DerivesFromOrIsTheSameAsType2 (tightenedReceiverType' compileTimeTargetMethod.ContainingType)) { " is 154.
Long Statement,ILGarbageCollect.Summaries,LocalFlowEnhancedBytecodeVisitor,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\LocalFlowMethodSummarizer.cs,Visit,The length of the statement  "					IMethodDefinition tightenedMethod = GarbageCollectHelper.ImplementsInstantiated (tightenedReceiverType' compileTimeTargetMethod); " is 129.
Long Statement,ILGarbageCollect.Summaries,CompleteBytecodeMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\SimpleBytecodeMethodSummarizer.cs,SummarizeMethod,The length of the statement  "					IMethodDefinition targetUnspecialized = GarbageCollectHelper.UnspecializeAndResolveMethodReference (op.Value as IMethodReference); " is 130.
Long Statement,ILGarbageCollect.Summaries,CompleteBytecodeMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\SimpleBytecodeMethodSummarizer.cs,SummarizeMethod,The length of the statement  "							ICollection<IMethodDefinition> implementationsOfMethodDefinitionForSubType = GarbageCollectHelper.Implements (subType' typeDefiningTarget' targetUnspecialized); " is 160.
Long Statement,ILGarbageCollect.Summaries,SummariesHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\Summaries.cs,COMSummary,The length of the statement  "	IEnumerable<ITypeDefinition> comInterfaces = wholeProgram.AllDefinedTypes ().Where (type => type.IsComObject && type.IsInterface && type.ToString ().StartsWith ("Microsoft.Cci")); " is 179.
Long Statement,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,CreateSummarizerFromPath,The length of the statement  "			summarizer.summariesByMethod [LookupMethodWithIdentifier ((string)command.Argument' wholeProgram)] = summaryForCurrentMethod; " is 125.
Long Statement,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,InterpretConstructAttributes,The length of the statement  "			IMethodDefinition constructorDefinition = GarbageCollectHelper.UnspecializeAndResolveMethodReference (customAttribute.Constructor); " is 131.
Long Statement,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,InterpretConstructAttributes,The length of the statement  "					throw new Exception ("Couldn't find setter " + setterName + " for type " + namedArgument.ArgumentValue.Type + " in " + constructorType); " is 136.
Long Statement,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,LookupMethodWithIdentifier,The length of the statement  "		throw new Exception ("Couldn't find unique method with identifier " + identifier + " (found " + methods.Count () + ")"); " is 120.
Long Statement,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,LookupTypesMatchingQuery,The length of the statement  "		throw new Exception ("Couldn't find any types matching query: " + query.AssemblySpecifier + "!" + query.DefinitionSpecifier); " is 125.
Long Statement,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,LookupTypesWithSpecifier,The length of the statement  "		result.UnionWith (wholeProgram.ClassHierarchy ().AllSubClassesOfClass (LookupExactTypeWithIdentifier (typeIdentifier' wholeProgram))); " is 134.
Long Statement,ILGarbageCollect.Sweep,StubMethodBodyEmitter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,AppendEmitExceptionThrow,The length of the statement  "	var systemExceptionTypeReference = GarbageCollectHelper.CreateTypeReference (host' coreAssemblyReference' "System.Exception"); " is 126.
Long Statement,ILGarbageCollect.Sweep,StubMethodBodyEmitter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,AppendEmitExceptionThrow,The length of the statement  "	IMethodReference exceptionConstructor = new Microsoft.Cci.MethodReference (host' systemExceptionTypeReference' CallingConvention.HasThis' host.PlatformType.SystemVoid' host.NameTable.Ctor' 0); " is 192.
Long Statement,ILGarbageCollect.Sweep,WindowsPhoneStubMethodBodyEmitter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,DebugReplacementGeneratorForBody,The length of the statement  "	string warningText = "\n\n!!!!!!!!!!\nAttempt to execute garbage collected method: " + methodBody.MethodDefinition.ToString () + "\n\n"; " is 136.
Long Statement,ILGarbageCollect.Sweep,TreeShakingRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,RewriteChildren,The length of the statement  "	Contract.Assert (analysisReport.ReachableMethods.Contains (methodDefinition) || analysisReport.UnreachableMethods.Contains (methodDefinition)); " is 143.
Long Statement,ILGarbageCollect.Sweep,TreeShakingRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,RewriteChildren,The length of the statement  "		methodBody.OperationExceptionInformation = new List<IOperationExceptionInformation> (generator.GetOperationExceptionInformation ()); " is 132.
Long Statement,ILGarbageCollect.Sweep,TreeShakingRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,MethodImplementsInterface,The length of the statement  "	foreach (IMethodImplementation methodImplementation in method.ContainingTypeDefinition.ExplicitImplementationOverrides) { " is 121.
Long Statement,ILGarbageCollect.Sweep,TreeShakingRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,MethodIsCustomAttributeConstructor,The length of the statement  "		foreach (ITypeDefinition superClass in GarbageCollectHelper.AllSuperClasses (methodDefinition.ContainingTypeDefinition)) { " is 122.
Long Statement,ILGarbageCollect.Sweep,TreeShakingRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Sweep.cs,IsSafeToRemoveMethod,The length of the statement  "	return !method.IsVirtual && /* This is quite conservative -- could check RTA's virtual methods in demand here. */!method.IsAbstract && !method.IsExternal && !MethodIsPropertyAccessor (method) && !MethodIsEventAccessor (method) && !MethodImplementsInterface (method) && !MethodOverridesAbstractMethod (method) && !MethodIsCustomAttributeConstructor (method); " is 357.
Complex Conditional,ILGarbageCollect,GarbageCollectHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\GarbageCollectHelper.cs,TypeIsConstructable,The conditional expression  "!type.IsAbstract && (type.IsClass || type.IsStruct || type.IsDelegate)"  is complex.
Complex Conditional,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,RecordBranchTargets,The conditional expression  "op.OperationCode != OperationCode.Br || op.OperationCode != OperationCode.Br_S || op.OperationCode != OperationCode.Leave || op.OperationCode != OperationCode.Leave_S"  is complex.
Magic Number,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InitializeArrayCreateInstruction,The following statement contains a magic number: if (currentOperation.OperationCode == OperationCode.Array_Create_WithLowerBound)  	rank *= 2;  
Magic Number,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InitializeArrayCreateInstruction,The following statement contains a magic number: rank *= 2;  
Magic Number,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,CreateQueryForIdentifier,The following statement contains a magic number: if (components.Count () == 2) {  	query = new WholeProgramSearchQuery () {  		AssemblySpecifier = components [0]'  		DefinitionSpecifier = components [1]  	};  }  else if (components.Count () == 1) {  	query = new WholeProgramSearchQuery () {  		DefinitionSpecifier = components [0]  	};  }  else {  	throw new Exception ("Malformed type identifier: " + identifier);  }  
Magic Number,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,ParseCommand,The following statement contains a magic number: if (tokens.Count () >= 2) {  	SummarizeOperation operation = ConsumeOperation (tokens);  	object argument;  	switch (operation) {  	case SummarizeOperation.Construct:  	case SummarizeOperation.CallAny:  	case SummarizeOperation.CallAnyPublic:  		argument = ConsumeTypeSpecifier (tokens);  		break;  	default:  		argument = argument = tokens.ConsumeToken ();  		// string argument  		break;  	}  	if (tokens.Count == 0) {  		return new SummarizeCommand () {  			Operation = operation'  			Argument = argument  		};  	}  }  
Missing Default,ILGarbageCollect.Instrumentation,ILMethodBodyRewriter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Instrumentation\ILMethodBodyRewriter.cs,HandleException,The following switch statement is missing a default case: switch (exceptionInfo.HandlerKind) {  case HandlerKind.Catch:  	generator.BeginCatchBlock (exceptionInfo.ExceptionType);  	break;  case HandlerKind.Fault:  	generator.BeginFaultBlock ();  	break;  case HandlerKind.Filter:  	generator.BeginFilterBody ();  	break;  case HandlerKind.Finally:  	generator.BeginFinallyBlock ();  	break;  }  
Missing Default,ILGarbageCollect.LocalFlow,LocalsAndOperandStackStateInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\LocalFlow.cs,InterpretInstructionInState,The following switch statement is missing a default case: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	//instruction.Operand2 = stack.Pop();  	//instruction.Operand1 = stack.Pop();  	//stack.Push(instruction);  	currentState.Pop ();  	currentState.Pop ();  	//currentState.Push(ValueAbstraction.Top); // Not right  	currentState.Push (ValueAbstraction.GetAbstractValueForType (FixupTypeForFlow (instruction.Type.ResolvedType)));  	// still not right  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	{  		int argumentIndex = GetArgumentIndexFromParameterOperation (instruction.Operation' method);  		V argumentValue = currentState.Arguments.ElementAt (argumentIndex);  		currentState.Push (argumentValue);  	}  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	{  		Contract.Assume (instruction.Operation.Value is ILocalDefinition);  		ILocalDefinition local = instruction.Operation.Value as ILocalDefinition;  		int localIndex = GetLocalIndexFromLocalOperation (instruction.Operation' method);  		V localValue = currentState.Locals.ElementAt (localIndex);  		currentState.Push (localValue);  	}  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldsflda:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldftn:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  case OperationCode.Sizeof:  case OperationCode.Arglist:  	//stack.Push(instruction);  	//currentState.Push(ValueAbstraction.Top); // not right  	currentState.Push (ValueAbstraction.GetAbstractValueForType (FixupTypeForFlow (instruction.Type.ResolvedType)));  	// Still not right  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	//InitializeArrayIndexerInstruction(instruction' stack' (IArrayTypeReference)instruction.Operation.Value);  	InitializeArrayIndexerInstruction (instruction' currentState' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Array_Create:  case OperationCode.Array_Create_WithLowerBound:  case OperationCode.Newarr:  	InitializeArrayCreateInstruction (instruction' currentState' instruction.Operation);  	break;  case OperationCode.Array_Set:  	/*stack.Pop();           Contract.Assume(instruction.Operation.Value is IArrayTypeReference); //This is an informally specified property of the Metadata model.           InitializeArrayIndexerInstruction(instruction' stack' (IArrayTypeReference)instruction.Operation.Value);           */currentState.Pop ();  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArrayIndexerInstruction (instruction' currentState' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	/*instruction.Operand2 = stack.Pop();           instruction.Operand1 = stack.Pop();            */currentState.Pop ();  	currentState.Pop ();  	break;  case OperationCode.Box:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Isinst:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldobj:  case OperationCode.Ldflda:  case OperationCode.Ldfld:  case OperationCode.Ldlen:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Mkrefany:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  	/*instruction.Operand1 = stack.Pop();           stack.Push(instruction);            */currentState.Pop ();  	//currentState.Push(ValueAbstraction.Top); // Could be smarter than Top  	currentState.Push (ValueAbstraction.GetAbstractValueForType (FixupTypeForFlow (instruction.Type.ResolvedType)));  	// Still not right  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	//instruction.Operand1 = stack.Pop();  	currentState.Pop ();  	break;  case OperationCode.Call:  	/*var signature = instruction.Operation.Value as ISignature;           Contract.Assume(signature != null); //This is an informally specified property of the Metadata model.           if (!signature.IsStatic) instruction.Operand1 = stack.Pop();           InitializeArgumentsAndPushReturnResult(instruction' stack' signature);           */var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	InterpretCallWithSignature (currentState' signature' !signature.IsStatic);  	break;  case OperationCode.Callvirt:  	/*           instruction.Operand1 = stack.Pop();           Contract.Assume(instruction.Operation.Value is ISignature); //This is an informally specified property of the Metadata model.           InitializeArgumentsAndPushReturnResult(instruction' stack' (ISignature)instruction.Operation.Value);           */Contract.Assume (instruction.Operation.Value is ISignature);  	//This is an informally specified property of the Metadata model.  	InterpretCallWithSignature (currentState' (ISignature)instruction.Operation.Value' true);  	break;  case OperationCode.Calli:  	/*           Contract.Assume(instruction.Operation.Value is ISignature); //This is an informally specified property of the Metadata model.           InitializeArgumentsAndPushReturnResult(instruction' stack' (ISignature)instruction.Operation.Value);           instruction.Operand1 = stack.Pop();           */currentState.Pop ();  	// the method pointer  	signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	InterpretCallWithSignature (currentState' (ISignature)instruction.Operation.Value' !signature.IsStatic);  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	/*           instruction.Operand2 = stack.Pop();           instruction.Operand1 = stack.Pop();           */currentState.Pop ();  	currentState.Pop ();  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	/*var indexAndValue = new Instruction[2];           indexAndValue[1] = stack.Pop();           indexAndValue[0] = stack.Pop();           instruction.Operand2 = indexAndValue;           instruction.Operand1 = stack.Pop();           */currentState.Pop ();  	currentState.Pop ();  	currentState.Pop ();  	break;  case OperationCode.Dup:  	/*           var dupop = stack.Pop();           instruction.Operand1 = dupop;           stack.Push(dupop);           stack.Push(instruction);           */// Pop the top and push it twice  	var dupValue = currentState.Pop ();  	currentState.Push (dupValue);  	currentState.Push (dupValue);  	break;  case OperationCode.Starg:  case OperationCode.Starg_S:  	{  		int argumentIndex = GetArgumentIndexFromParameterOperation (instruction.Operation' method);  		V newArgumentValue = currentState.Pop ();  		currentState.Arguments [argumentIndex] = newArgumentValue;  	}  	break;  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	{  		Contract.Assume (instruction.Operation.Value is ILocalDefinition);  		ILocalDefinition local = instruction.Operation.Value as ILocalDefinition;  		int localIndex = GetLocalIndexFromLocalOperation (instruction.Operation' method);  		V newLocalValue = currentState.Pop ();  		currentState.Locals [localIndex] = newLocalValue;  	}  	break;  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	//instruction.Operand1 = stack.Pop();  	currentState.Pop ();  	break;  case OperationCode.Newobj:  	/*           Contract.Assume(instruction.Operation.Value is ISignature); //This is an informally specified property of the Metadata model.           InitializeArgumentsAndPushReturnResult(instruction' stack' (ISignature)instruction.Operation.Value); //won't push anything           stack.Push(instruction);           */Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	InterpretCallWithSignature (currentState' (ISignature)instruction.Operation.Value' false);  	//won't push anything' since return type is void  	currentState.Push (ValueAbstraction.GetAbstractValueForType (FixupTypeForFlow (((IMethodReference)instruction.Operation.Value).ResolvedMethod.ContainingTypeDefinition)));  	break;  case OperationCode.Ret:  	/*if (this.cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)             instruction.Operand1 = stack.Pop();            */if (method.Type.TypeCode != PrimitiveTypeCode.Void) {  		currentState.Pop ();  	}  	break;  }  
Missing Default,ILGarbageCollect.Mark,WholeProgram,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Mark.cs,HeuristicFindCoreAssemblyForProfile,The following switch statement is missing a default case: switch (profile) {  case TargetProfile.Desktop:  case TargetProfile.Phone:  	foreach (IAssembly assembly in allAssemblies) {  		if (assembly.AssemblyIdentity.Equals (host.CoreAssemblySymbolicIdentity)) {  			coreAssembly = assembly;  			break;  		}  	}  	break;  }  
Missing Default,ILGarbageCollect.Summaries,TextFileMethodSummarizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\ILGarbageCollect\Summaries\TextFileMethodSummarizer.cs,LookupTypesWithSpecifier,The following switch statement is missing a default case: switch (specifier.Kind) {  case TypeSpecifierKind.Exactly:  	result.Add (LookupExactTypeWithIdentifier (typeIdentifier' wholeProgram));  	break;  case TypeSpecifierKind.Subtypes:  	// t-devinc: We really out to change this to include the type itself' not just all of its proper subtypes  	result.UnionWith (wholeProgram.ClassHierarchy ().AllSubClassesOfClass (LookupExactTypeWithIdentifier (typeIdentifier' wholeProgram)));  	break;  case TypeSpecifierKind.Matches:  	return LookupTypesMatchingRegexpIdentifier (typeIdentifier' wholeProgram);  }  
