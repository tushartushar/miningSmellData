Implementation smell,Namespace,Class,File,Method,Description
Long Method,Jurassic.Compiler,BinderUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderUtilities.cs,ResolveOverloads,The method has 104 lines of code.
Long Method,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,GenerateCode,The method has 109 lines of code.
Long Method,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The method has 106 lines of code.
Long Method,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateGet,The method has 171 lines of code.
Long Method,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateSet,The method has 218 lines of code.
Long Method,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,GenerateCode,The method has 128 lines of code.
Long Method,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,EmitConversionToType,The method has 106 lines of code.
Long Method,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The method has 122 lines of code.
Long Method,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateCode,The method has 148 lines of code.
Long Method,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateRelational,The method has 116 lines of code.
Long Method,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,GenerateCode,The method has 135 lines of code.
Long Method,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,GenerateGet,The method has 102 lines of code.
Long Method,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,GenerateSet,The method has 118 lines of code.
Long Method,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFor,The method has 126 lines of code.
Long Method,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The method has 209 lines of code.
Long Method,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The method has 318 lines of code.
Long Method,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The method has 160 lines of code.
Long Method,Jurassic,ReflectionHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ReflectionHelpers.cs,ReflectionHelpers,The method has 153 lines of code.
Long Method,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The method has 149 lines of code.
Complex Method,Jurassic.Compiler,BinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderMethod.cs,GetArguments,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,BinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderMethod.cs,GenerateArguments,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Compiler,BinderUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderUtilities.cs,ResolveOverloads,Cyclomatic complexity of the method is 59
Complex Method,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,Validate,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,GenerateCode,Cyclomatic complexity of the method is 12
Complex Method,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadArgument,Cyclomatic complexity of the method is 17
Complex Method,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,Cyclomatic complexity of the method is 32
Complex Method,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadArrayElement,Cyclomatic complexity of the method is 26
Complex Method,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,StoreArrayElement,Cyclomatic complexity of the method is 26
Complex Method,Jurassic.Compiler,OptimizationInfo,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\OptimizationInfo.cs,PushBreakOrContinueInfo,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Compiler,EmitHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitHelpers.cs,EmitValue,Cyclomatic complexity of the method is 46
Complex Method,Jurassic.Compiler,PrimitiveTypeUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\PrimitiveTypeUtilities.cs,ToType,Cyclomatic complexity of the method is 12
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,Cyclomatic complexity of the method is 20
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,Cyclomatic complexity of the method is 30
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,Cyclomatic complexity of the method is 25
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,DefineLabelPosition,Cyclomatic complexity of the method is 12
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitCall,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,ToVESType,Cyclomatic complexity of the method is 19
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,Cyclomatic complexity of the method is 35
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,Cyclomatic complexity of the method is 27
Complex Method,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EndCurrentClause,Cyclomatic complexity of the method is 12
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,Convert,Cyclomatic complexity of the method is 34
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToBool,Cyclomatic complexity of the method is 40
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToInteger,Cyclomatic complexity of the method is 33
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToInt32,Cyclomatic complexity of the method is 16
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToNumber,Cyclomatic complexity of the method is 25
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToString,Cyclomatic complexity of the method is 32
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToConcatenatedString,Cyclomatic complexity of the method is 18
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToObject,Cyclomatic complexity of the method is 23
Complex Method,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToPrimitive,Cyclomatic complexity of the method is 18
Complex Method,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateGet,Cyclomatic complexity of the method is 19
Complex Method,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateSet,Cyclomatic complexity of the method is 27
Complex Method,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateDelete,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateThis,Cyclomatic complexity of the method is 11
Complex Method,Jurassic.Compiler,TryCatchFinallyStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\TryCatchFinallyStatement.cs,GenerateCode,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,GenerateCode,Cyclomatic complexity of the method is 14
Complex Method,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,GenerateStub,Cyclomatic complexity of the method is 20
Complex Method,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,EmitConversionToType,Cyclomatic complexity of the method is 72
Complex Method,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,EmitConversionToObject,Cyclomatic complexity of the method is 67
Complex Method,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,NextToken,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadNumericLiteral,Cyclomatic complexity of the method is 11
Complex Method,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,Cyclomatic complexity of the method is 50
Complex Method,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadDivideCommentOrRegularExpression,Cyclomatic complexity of the method is 12
Complex Method,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadRegularExpression,Cyclomatic complexity of the method is 13
Complex Method,Jurassic.Compiler,JSBinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinderMethod.cs,Init,Cyclomatic complexity of the method is 12
Complex Method,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,JSBinder,Cyclomatic complexity of the method is 15
Complex Method,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,Cyclomatic complexity of the method is 22
Complex Method,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,Evaluate,Cyclomatic complexity of the method is 28
Complex Method,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateCode,Cyclomatic complexity of the method is 96
Complex Method,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateRelational,Cyclomatic complexity of the method is 60
Complex Method,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GetCompoundBaseOperator,Cyclomatic complexity of the method is 11
Complex Method,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GenerateCode,Cyclomatic complexity of the method is 36
Complex Method,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,GenerateCode,Cyclomatic complexity of the method is 18
Complex Method,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,Cyclomatic complexity of the method is 12
Complex Method,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,GenerateGet,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,GenerateSet,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Compiler,UnaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\UnaryExpression.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,UnaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\UnaryExpression.cs,GenerateCode,Cyclomatic complexity of the method is 29
Complex Method,Jurassic.Compiler,OperatorExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\OperatorExpression.cs,FromOperator,Cyclomatic complexity of the method is 24
Complex Method,Jurassic.Compiler,OperatorExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\OperatorExpression.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,Operator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Operator.cs,Operator,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,Parse,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFor,Cyclomatic complexity of the method is 14
Complex Method,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseSwitch,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFunction,Cyclomatic complexity of the method is 15
Complex Method,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,Cyclomatic complexity of the method is 43
Complex Method,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,Cyclomatic complexity of the method is 15
Complex Method,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Multiply,Cyclomatic complexity of the method is 8
Complex Method,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Subtract,Cyclomatic complexity of the method is 12
Complex Method,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,Cyclomatic complexity of the method is 11
Complex Method,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,InPlaceDecrement,Cyclomatic complexity of the method is 9
Complex Method,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,Cyclomatic complexity of the method is 9
Complex Method,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,Cyclomatic complexity of the method is 66
Complex Method,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,Cyclomatic complexity of the method is 9
Complex Method,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseFloat,Cyclomatic complexity of the method is 9
Complex Method,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,CoerceToNumber,Cyclomatic complexity of the method is 16
Complex Method,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,Cyclomatic complexity of the method is 31
Complex Method,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,Cyclomatic complexity of the method is 17
Complex Method,Jurassic,ScriptEngine,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ScriptEngine.cs,SetGlobalValue,Cyclomatic complexity of the method is 47
Complex Method,Jurassic,ScriptSource,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ScriptSource\ScriptSource.cs,ReadSpan,Cyclomatic complexity of the method is 11
Complex Method,Jurassic,TypeComparer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeComparer.cs,Equals,Cyclomatic complexity of the method is 8
Complex Method,Jurassic,TypeComparer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeComparer.cs,SameValue,Cyclomatic complexity of the method is 10
Complex Method,Jurassic,JavaScriptException,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\JavaScriptException.cs,CreateError,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,PopulateMembers,Cyclomatic complexity of the method is 31
Complex Method,Jurassic.Library,StandardConsoleOutput,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\FirebugConsole\StandardConsoleOutput.cs,Log,Cyclomatic complexity of the method is 11
Complex Method,Jurassic.Library,FirebugConsole,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\FirebugConsole\FirebugConsole.cs,FormatObjects,Cyclomatic complexity of the method is 30
Complex Method,Jurassic.Library,JSONParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONParser.cs,ParseObjectLiteral,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Library,JSONSerializer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONSerializer.cs,SerializePropertyValue,Cyclomatic complexity of the method is 13
Complex Method,Jurassic.Library,JSONSerializer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONSerializer.cs,QuoteString,Cyclomatic complexity of the method is 28
Complex Method,Jurassic.Library,JSONSerializer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONSerializer.cs,SerializeObject,Cyclomatic complexity of the method is 11
Complex Method,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,NextToken,Cyclomatic complexity of the method is 13
Complex Method,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadNumericLiteral,Cyclomatic complexity of the method is 13
Complex Method,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadStringLiteral,Cyclomatic complexity of the method is 34
Complex Method,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Concat,Cyclomatic complexity of the method is 24
Complex Method,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Splice,Cyclomatic complexity of the method is 14
Complex Method,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,Cyclomatic complexity of the method is 15
Complex Method,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Reduce,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ReduceRight,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Library,ArrayConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayConstructor.cs,Construct,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,Cyclomatic complexity of the method is 21
Complex Method,Jurassic.Library,ArgumentsInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\ArgumentsInstance.cs,ArgumentsInstance,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Library,ClrFunction,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\ClrFunction.cs,ClrFunction,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Library,PropertyDescriptor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\PropertyDescriptor.cs,FromObject,Cyclomatic complexity of the method is 19
Complex Method,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,Cyclomatic complexity of the method is 14
Complex Method,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,ParseFlags,Cyclomatic complexity of the method is 9
Complex Method,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,GetDateComponent,Cyclomatic complexity of the method is 17
Complex Method,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,Cyclomatic complexity of the method is 10
Complex Method,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,Cyclomatic complexity of the method is 8
Complex Method,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,SetPropertyValueIfExists,Cyclomatic complexity of the method is 11
Complex Method,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,PopulateFunctions,Cyclomatic complexity of the method is 22
Long Parameter List,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,MarkSequencePoint,The method has 5 parameters.
Long Parameter List,Jurassic.Compiler,EvalMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\EvalMethodGenerator.cs,EvalMethodGenerator,The method has 5 parameters.
Long Parameter List,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,FunctionMethodGenerator,The method has 8 parameters.
Long Parameter List,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,FunctionMethodGenerator,The method has 6 parameters.
Long Parameter List,Jurassic.Compiler,ILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ILGenerator.cs,MarkSequencePoint,The method has 5 parameters.
Long Parameter List,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,MarkSequencePoint,The method has 5 parameters.
Long Parameter List,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Emit2ByteOpCodeInt16,The method has 5 parameters.
Long Parameter List,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Emit2ByteOpCodeInt32,The method has 5 parameters.
Long Parameter List,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,MarkSequencePoint,The method has 5 parameters.
Long Parameter List,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GenerateIncrementOrDecrement,The method has 5 parameters.
Long Parameter List,Jurassic.Compiler,Operator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Operator.cs,Operator,The method has 7 parameters.
Long Parameter List,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,Parser,The method has 5 parameters.
Long Parameter List,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The method has 5 parameters.
Long Parameter List,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The method has 5 parameters.
Long Parameter List,Jurassic,JavaScriptException,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\JavaScriptException.cs,JavaScriptException,The method has 5 parameters.
Long Parameter List,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Sort,The method has 6 parameters.
Long Parameter List,Jurassic.Library,SparseArray,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\SparseArray.cs,DeleteRange,The method has 6 parameters.
Long Parameter List,Jurassic.Library,ArgumentsInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\ArgumentsInstance.cs,ArgumentGetter,The method has 5 parameters.
Long Parameter List,Jurassic.Library,ArgumentsInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\ArgumentsInstance.cs,ArgumentSetter,The method has 5 parameters.
Long Parameter List,Jurassic.Library,UserDefinedFunction,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\UserDefinedFunction.cs,UserDefinedFunction,The method has 7 parameters.
Long Parameter List,Jurassic.Library,UserDefinedFunction,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\UserDefinedFunction.cs,UserDefinedFunction,The method has 7 parameters.
Long Parameter List,Jurassic.Library,UserDefinedFunction,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\UserDefinedFunction.cs,UserDefinedFunction,The method has 6 parameters.
Long Parameter List,Jurassic.Library,UserDefinedFunction,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\UserDefinedFunction.cs,Init,The method has 7 parameters.
Long Parameter List,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Eval,The method has 5 parameters.
Long Parameter List,Jurassic.Library,DateConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateConstructor.cs,Construct,The method has 7 parameters.
Long Parameter List,Jurassic.Library,DateConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateConstructor.cs,UTC,The method has 7 parameters.
Long Parameter List,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,DateInstance,The method has 8 parameters.
Long Parameter List,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,UTC,The method has 7 parameters.
Long Parameter List,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The method has 8 parameters.
Long Parameter List,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,InlineSetPropertyValue,The method has 5 parameters.
Long Parameter List,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,InlineSetPropertyValueIfExists,The method has 5 parameters.
Long Identifier,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the parameter debuggableAttributeConstructor is 30.
Long Identifier,Jurassic.Compiler,TryCatchFinallyStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\TryCatchFinallyStatement.cs,GenerateCode,The length of the parameter previousInsideTryCatchOrFinally is 31.
Long Identifier,Jurassic.Compiler,WithStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\WithStatement.cs,GenerateCode,The length of the parameter previousInsideTryCatchOrFinally is 31.
Long Identifier,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,GenerateCode,The length of the parameter previousInsideTryCatchOrFinally is 31.
Long Statement,Jurassic.Compiler,Binder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\Binder.cs,CreateDelegateCore,The length of the statement  "		dm = new System.Reflection.Emit.DynamicMethod (string.Format ("binder_for_{0}"' this.FullName)' // Name of the generated method. " is 128.
Long Statement,Jurassic.Compiler,Binder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\Binder.cs,CreateDelegateCore,The length of the statement  "		dm = new System.Reflection.Emit.DynamicMethod (string.Format ("binder_for_{0}"' this.FullName)' // Name of the generated method. " is 128.
Long Statement,Jurassic.Compiler,BinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderMethod.cs,IsArgumentCountCompatible,The length of the statement  "	return argumentCount >= this.RequiredParameterCount && argumentCount <= this.RequiredParameterCount + this.OptionalParameterCount; " is 130.
Long Statement,Jurassic.Compiler,BinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderMethod.cs,GetArguments,The length of the statement  "		yield return new BinderArgument (BinderArgumentSource.InputParameter' parameters [paramIndex].ParameterType.GetElementType ()' index++); " is 136.
Long Statement,Jurassic.Compiler,BinderUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderUtilities.cs,ResolveOverloads,The length of the statement  "		throw new JavaScriptException (engine' "TypeError"' "The method call is ambiguous between the following methods: " + StringHelpers.Join ("' "' ambiguousMethods)); " is 162.
Long Statement,Jurassic.Compiler,BinderUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderUtilities.cs,ResolveOverloads,The length of the statement  "		throw new JavaScriptException (engine' "TypeError"' string.Format ("The best method overload {0} has some invalid arguments"' methods [lowestIndices [0]])); " is 156.
Long Statement,Jurassic.Compiler,EvalMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\EvalMethodGenerator.cs,Execute,The length of the statement  "	object result = ((Func<ScriptEngine' Scope' object' object>)this.GeneratedMethod.GeneratedDelegate) (this.Engine' scope' this.ThisObject); " is 138.
Long Statement,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,Validate,The length of the statement  "			throw new JavaScriptException (this.Engine' "SyntaxError"' string.Format ("Functions cannot be named '{0}' in strict mode."' this.Name)); " is 137.
Long Statement,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,Validate,The length of the statement  "				throw new JavaScriptException (this.Engine' "SyntaxError"' string.Format ("Arguments cannot be named '{0}' in strict mode."' argumentName)); " is 140.
Long Statement,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,Validate,The length of the statement  "				throw new JavaScriptException (this.Engine' "SyntaxError"' string.Format ("Duplicate argument name '{0}' is not allowed in strict mode."' argumentName)); " is 153.
Long Statement,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,GenerateCode,The length of the statement  "	// Method signature: object FunctionDelegate(Compiler.Scope scope' object thisObject' Library.FunctionInstance functionObject' object[] arguments) " is 146.
Long Statement,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,GenerateCode,The length of the statement  "	if (string.IsNullOrEmpty (this.Name) == false && this.ArgumentNames.Contains (this.Name) == false && optimizationInfo.MethodOptimizationHints.HasVariable (this.Name)) { " is 168.
Long Statement,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,ToString,The length of the statement  "		return string.Format ("function {0}({1}) {2}"' this.Name' StringHelpers.Join ("' "' this.ArgumentNames)' this.BodyRoot); " is 120.
Long Statement,Jurassic.Compiler,FunctionMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\FunctionMethodGenerator.cs,ToString,The length of the statement  "	return string.Format ("function {0}({1}) {{\n{2}\n}}"' this.Name' StringHelpers.Join ("' "' this.ArgumentNames)' this.BodyText); " is 128.
Long Statement,Jurassic.Compiler,GeneratedMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\GeneratedMethod.cs,Load,The length of the statement  "			throw new InvalidOperationException (string.Format ("Internal error: generated method {0} was garbage collected."' id)); " is 120.
Long Statement,Jurassic.Compiler,GeneratedMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\GeneratedMethod.cs,Load,The length of the statement  "			throw new InvalidOperationException (string.Format ("Internal error: generated method {0} was garbage collected."' id)); " is 120.
Long Statement,Jurassic.Compiler,GlobalMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\GlobalMethodGenerator.cs,Execute,The length of the statement  "	object result = ((Func<ScriptEngine' Scope' object' object>)this.GeneratedMethod.GeneratedDelegate) (this.Engine' this.InitialScope' this.Engine.Global); " is 153.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "		this.GeneratedMethod = new GeneratedMethod (dynamicMethod.CreateDelegate (GetDelegate ())' optimizationInfo.NestedFunctions); " is 125.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "			reflectionEmitInfo.AssemblyBuilder = System.Threading.Thread.GetDomain ().DefineDynamicAssembly (new System.Reflection.AssemblyName ("Jurassic Dynamic Assembly")' System.Reflection.Emit.AssemblyBuilderAccess.Run); " is 213.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "			reflectionEmitInfo.AssemblyBuilder.SetCustomAttribute (new System.Reflection.Emit.CustomAttributeBuilder (debuggableAttributeConstructor' new object[] { " is 152.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "				System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations | System.Diagnostics.DebuggableAttribute.DebuggingModes.Default " is 138.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "			reflectionEmitInfo.ModuleBuilder = reflectionEmitInfo.AssemblyBuilder.DefineDynamicModule ("Module"' this.Options.EnableDebugging); " is 131.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "		var typeBuilder = reflectionEmitInfo.ModuleBuilder.DefineType ("JavaScriptClass" + reflectionEmitInfo.TypeCount.ToString ()' System.Reflection.TypeAttributes.Public | System.Reflection.TypeAttributes.Class); " is 207.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "		var methodBuilder = typeBuilder.DefineMethod (this.GetMethodName ()' System.Reflection.MethodAttributes.HideBySig | System.Reflection.MethodAttributes.Static | System.Reflection.MethodAttributes.Public' typeof(object)' GetParameterTypes ()); " is 241.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "			optimizationInfo.DebugDocument = reflectionEmitInfo.ModuleBuilder.DefineDocument (this.Source.Path' COMHelpers.LanguageType' COMHelpers.LanguageVendor' COMHelpers.DocumentType); " is 177.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The length of the statement  "		this.GeneratedMethod = new GeneratedMethod (Delegate.CreateDelegate (GetDelegate ()' methodInfo)' optimizationInfo.NestedFunctions); " is 132.
Long Statement,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,VerifyScope,The length of the statement  "	//    EmitHelpers.EmitThrow(generator' "Error"' string.Format("Internal error: incorrect runtime scope type (expected {0})"' scope.GetType().Name)); " is 148.
Long Statement,Jurassic.Compiler,OptimizationInfo,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\OptimizationInfo.cs,PushBreakOrContinueInfo,The length of the statement  "					throw new JavaScriptException (this.Engine' "SyntaxError"' string.Format ("Label '{0}' has already been declared"' labelName)); " is 127.
Long Statement,Jurassic.Compiler,OptimizationInfo,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\OptimizationInfo.cs,GetContinueTarget,The length of the statement  "					throw new JavaScriptException (this.Engine' "SyntaxError"' string.Format ("The statement with label '{0}' is not a loop"' labelName)); " is 134.
Long Statement,Jurassic.Compiler,FunctionExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\FunctionExpression.cs,GenerateCode,The length of the statement  "	// new UserDefinedFunction(ObjectInstance prototype' string name' IList<string> argumentNames' DeclarativeScope scope' Func<Scope' object' object[]' object> body' bool strictMode) " is 179.
Long Statement,Jurassic.Compiler,FunctionExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\FunctionExpression.cs,ToString,The length of the statement  "	return string.Format ("function {0}({1}) {{\n{2}\n}}"' this.FunctionName' StringHelpers.Join ("' "' this.ArgumentNames)' this.BodyText); " is 136.
Long Statement,Jurassic.Compiler,DeclarativeScope,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Scope\DeclarativeScope.cs,GetValue,The length of the statement  "		throw new InvalidOperationException ("This method can only be used when the DeclarativeScope is created using CreateRuntimeScope()."); " is 134.
Long Statement,Jurassic.Compiler,DeclarativeScope,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Scope\DeclarativeScope.cs,SetValue,The length of the statement  "		throw new InvalidOperationException ("This method can only be used when the DeclarativeScope is created using CreateRuntimeScope()."); " is 134.
Long Statement,Jurassic.Compiler,DeclarativeScope,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Scope\DeclarativeScope.cs,Delete,The length of the statement  "		throw new InvalidOperationException ("This method can only be used when the DeclarativeScope is created using CreateRuntimeScope()."); " is 134.
Long Statement,Jurassic.Compiler,PrimitiveTypeUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\PrimitiveTypeUtilities.cs,IsValueType,The length of the statement  "	return type == PrimitiveType.Bool || type == PrimitiveType.Number || type == PrimitiveType.Int32 || type == PrimitiveType.UInt32; " is 129.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,GetToken,The length of the statement  "		throw new ArgumentException ("The provided method cannot be that of an RTDynamicMethod. Use the DynamicMethod instead."); " is 121.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Pop,The length of the statement  "	PopStackOperands (VESType.Int32 | VESType.Int64 | VESType.Float | VESType.NativeInt | VESType.Object | VESType.ManagedPointer); " is 127.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,PopStackOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Expected argument #{0} to be: {1} but was: {2}"' i + 1' expectedTypes [i]' actualTypes [i])); " is 146.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "		if (right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || @operator != ArithmeticOperator.Add)) " is 133.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "		if (right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || @operator != ArithmeticOperator.Add)) " is 133.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "				throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "				throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The length of the statement  "		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "		if (right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual))) " is 181.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "		if (right != VESType.ManagedPointer && (right != VESType.NativeInt || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual))) " is 155.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "		if (right != VESType.Object || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual && @operator != ComparisonOperator.GreaterThanUnsigned)) " is 170.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The length of the statement  "			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right)); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,DefineLabelPosition,The length of the statement  "				throw new InvalidOperationException (string.Format ("Stack mismatch from a previous branch.  Expected: '{0}' but was: '{1}'"' StringHelpers.Join ("' "' previousStack)' StringHelpers.Join ("' "' currentStack))); " is 210.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,DefineLabelPosition,The length of the statement  "					throw new InvalidOperationException (string.Format ("Stack mismatch from a previous branch.  Expected: '{0}' but was: '{1}'"' StringHelpers.Join ("' "' previousStack)' StringHelpers.Join ("' "' currentStack))); " is 210.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,DefineLabelPosition,The length of the statement  "                        throw new InvalidOperationException(string.Format("Stack size mismatch from a previous branch.  Expected {0} items but found {1} items."'" is 137.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The length of the statement  "			throw new InvalidOperationException (string.Format ("Stack mismatch from a previous branch.  Expected: '{0}' but was: '{1}'"' StringHelpers.Join ("' "' previousStack)' StringHelpers.Join ("' "' currentStack))); " is 210.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The length of the statement  "				throw new InvalidOperationException (string.Format ("Stack mismatch from a previous branch.  Expected: '{0}' but was: '{1}'"' StringHelpers.Join ("' "' previousStack)' StringHelpers.Join ("' "' currentStack))); " is 210.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The length of the statement  "                    throw new InvalidOperationException(string.Format("Stack size mismatch from a previous branch.  Expected {0} items but was {1} items."'" is 135.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BranchIfZero,The length of the statement  "	BranchCore (label' 0x39' VESType.Int32 | VESType.Int64 | VESType.Float | VESType.ManagedPointer | VESType.NativeInt | VESType.Object); " is 134.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BranchIfNotZero,The length of the statement  "	BranchCore (label' 0x3A' VESType.Int32 | VESType.Int64 | VESType.Float | VESType.ManagedPointer | VESType.NativeInt | VESType.Object); " is 134.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Return,The length of the statement  "			throw new InvalidOperationException (string.Format ("The evaluation stack should be empty.  Types still on stack: {0}."' StringHelpers.Join ("' "' this.operands))); " is 164.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitCall,The length of the statement  "	Emit1ByteOpCodeInt32 (opcode' parameters.Length + (method.IsStatic ? 0 : 1)' returnType == typeof(void) ? 0 : 1' token); " is 120.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CastClass,The length of the statement  "	//    this.Call(typeof(DynamicILGenerator).GetMethod("OnFailedCast"' System.Reflection.BindingFlags.Static | System.Reflection.BindingFlags.NonPublic)); " is 152.
Long Statement,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BeginExceptionBlock,The length of the statement  "				throw new InvalidOperationException (string.Format ("Multiple {0} clauses are not allowed."' type.ToString ().ToLowerInvariant ())); " is 132.
Long Statement,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateSet,The length of the statement  "				//     object.InlineSetPropertyValueIfExists("property"' value' strictMode' out __object_property_cachedIndex' out __object_cacheKey) " is 133.
Long Statement,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateSet,The length of the statement  "				// xxx = object.InlineSetPropertyValueIfExists("property"' value' strictMode' out __object_property_cachedIndex' out __object_cacheKey) " is 135.
Long Statement,Jurassic.Compiler,NameExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\NameExpression.cs,GenerateDelete,The length of the statement  "		throw new JavaScriptException (optimizationInfo.Engine' "SyntaxError"' string.Format ("Cannot delete {0} because deleting a variable or argument is not allowed in strict mode"' this.Name)); " is 189.
Long Statement,Jurassic.Compiler,ReturnStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\ReturnStatement.cs,GenerateCode,The length of the statement  "	bool lastStatement = optimizationInfo.AbstractSyntaxTree is BlockStatement && ((BlockStatement)optimizationInfo.AbstractSyntaxTree).Statements.Count > 0 && ((BlockStatement)optimizationInfo.AbstractSyntaxTree).Statements [((BlockStatement)optimizationInfo.AbstractSyntaxTree).Statements.Count - 1] == this; " is 306.
Long Statement,Jurassic.Compiler,VarStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\VarStatement.cs,GenerateCode,The length of the statement  "			var initializationStatement = new ExpressionStatement (new AssignmentExpression (this.Scope' declaration.VariableName' declaration.InitExpression)); " is 148.
Long Statement,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The length of the statement  "	if (this.InitVarStatement != null && this.InitVarStatement.Declarations.Count == 1 && this.InitVarStatement.Declarations [0].InitExpression != null && this.InitVarStatement.Declarations [0].InitExpression.ResultType == PrimitiveType.Int32) { " is 241.
Long Statement,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The length of the statement  "	else if (this.InitExpression != null && this.InitExpression is AssignmentExpression && ((AssignmentExpression)this.InitExpression).ResultType == PrimitiveType.Int32 && ((AssignmentExpression)this.InitExpression).Target is NameExpression) { " is 239.
Long Statement,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The length of the statement  "	if (initIsOkay == true && this.ConditionStatement != null && this.Condition is BinaryExpression && (((BinaryExpression)this.Condition).OperatorType == OperatorType.LessThan || ((BinaryExpression)this.Condition).OperatorType == OperatorType.GreaterThan) && ((BinaryExpression)this.Condition).Left is NameExpression && ((NameExpression)((BinaryExpression)this.Condition).Left).Name == loopVariableName && ((BinaryExpression)this.Condition).Right.ResultType == PrimitiveType.Int32) { " is 480.
Long Statement,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The length of the statement  "		if (lessThan == true && this.IncrementStatement != null && this.Increment is AssignmentExpression && (((AssignmentExpression)this.Increment).OperatorType == OperatorType.PostIncrement || ((AssignmentExpression)this.Increment).OperatorType == OperatorType.PreIncrement) && ((NameExpression)((AssignmentExpression)this.Increment).Target).Name == loopVariableName) { " is 363.
Long Statement,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The length of the statement  "		else if (lessThan == false && this.IncrementStatement != null && this.Increment is AssignmentExpression && (((AssignmentExpression)this.Increment).OperatorType == OperatorType.PostDecrement || ((AssignmentExpression)this.Increment).OperatorType == OperatorType.PreDecrement) && ((NameExpression)((AssignmentExpression)this.Increment).Target).Name == loopVariableName) { " is 369.
Long Statement,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The length of the statement  "	conditional = conditional == true || continueEncountered == true || root is IfStatement || root is TernaryExpression || root is TryCatchFinallyStatement || (root is BinaryExpression && ((BinaryExpression)root).OperatorType == OperatorType.LogicalAnd) || (root is BinaryExpression && ((BinaryExpression)root).OperatorType == OperatorType.LogicalOr); " is 348.
Long Statement,Jurassic.Compiler,ForStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\ForStatement.cs,ToString,The length of the statement  "	result.AppendFormat ("for ({0} {1} {2})"' this.InitStatement == null ? ";" : this.InitStatement.ToString (0)' this.ConditionStatement == null ? ";" : this.ConditionStatement.ToString ()' this.IncrementStatement == null ? string.Empty : this.Increment.ToString ()); " is 264.
Long Statement,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,GenerateStub,The length of the statement  "		EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("No overload for method '{0}' takes {1} arguments"' this.Name' argumentCount)); " is 141.
Long Statement,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,EmitConversionToType,The length of the statement  "		EmitHelpers.EmitThrow (generator' "TypeError"' "Cannot convert string to char - the string must be exactly one character long"); " is 128.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,NextToken,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Unexpected character '{0}'."' (char)c1)' this.lineNumber' this.Source.Path); " is 151.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid escape sequence in identifier."' this.lineNumber' this.Source.Path); " is 136.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid character in identifier."' this.lineNumber' this.Source.Path); " is 130.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid escape sequence in identifier."' this.lineNumber' this.Source.Path); " is 136.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid character in identifier."' this.lineNumber' this.Source.Path); " is 130.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadNumericLiteral,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid hexidecimal constant."' this.lineNumber' this.Source.Path); " is 127.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadNumericLiteral,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Octal numbers are not supported."' this.lineNumber' this.Source.Path); " is 130.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadNumericLiteral,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal constant."' this.lineNumber' this.Source.Path); " is 121.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected end of input in string literal."' this.lineNumber' this.Source.Path); " is 140.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected line terminator in string literal."' this.lineNumber' this.Source.Path); " is 143.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The length of the statement  "					throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path); " is 128.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadHexEscapeSequence,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Invalid hex digit '{0}' in escape sequence."' (char)c)' this.lineNumber' this.Source.Path); " is 166.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Octal escape sequences are only supported in ECMAScript 3 compatibility mode."' this.lineNumber' this.Source.Path); " is 175.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path); " is 128.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadMultiLineComment,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected end of input in multi-line comment."' this.lineNumber' this.Source.Path); " is 144.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadMultiLineComment,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected end of input in multi-line comment."' this.lineNumber' this.Source.Path); " is 144.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadDivideCommentOrRegularExpression,The length of the statement  "			isDivisionOperator = this.lastSignificantToken is IdentifierToken || this.lastSignificantToken is LiteralToken || this.lastSignificantToken == PunctuatorToken.RightParenthesis || this.lastSignificantToken == PunctuatorToken.Increment || this.lastSignificantToken == PunctuatorToken.Decrement || this.lastSignificantToken == PunctuatorToken.RightBracket || this.lastSignificantToken == PunctuatorToken.RightBrace; " is 412.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadRegularExpression,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected line terminator in regular expression literal."' this.lineNumber' this.Source.Path); " is 155.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadRegularExpression,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected end of input in regular expression literal."' this.lineNumber' this.Source.Path); " is 152.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadRegularExpression,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid escape sequence in identifier."' this.lineNumber' this.Source.Path); " is 136.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadRegularExpression,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid character in identifier."' this.lineNumber' this.Source.Path); " is 130.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,IsWhiteSpace,The length of the statement  "	return c == 0x09 || c == 0x0B || c == 0x0C || c == 0x20 || c == 0xA0 || c == 0x1680 || c == 0x180E || (c >= 8192 && c <= 8202) || c == 0x202F || c == 0x205F || c == 0x3000 || c == 0xFEFF; " is 187.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,IsIdentifierStartChar,The length of the statement  "	return c == '$' || c == '_' || c == '\\' || cat == UnicodeCategory.UppercaseLetter || cat == UnicodeCategory.LowercaseLetter || cat == UnicodeCategory.TitlecaseLetter || cat == UnicodeCategory.ModifierLetter || cat == UnicodeCategory.OtherLetter || cat == UnicodeCategory.LetterNumber; " is 285.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,IsIdentifierChar,The length of the statement  "	return c == '$' || c == '\\' || cat == UnicodeCategory.UppercaseLetter || cat == UnicodeCategory.LowercaseLetter || cat == UnicodeCategory.TitlecaseLetter || cat == UnicodeCategory.ModifierLetter || cat == UnicodeCategory.OtherLetter || cat == UnicodeCategory.LetterNumber || cat == UnicodeCategory.NonSpacingMark || cat == UnicodeCategory.SpacingCombiningMark || cat == UnicodeCategory.DecimalDigitNumber || cat == UnicodeCategory.ConnectorPunctuation || c == 0x200C || // Zero-width non-joiner. " is 496.
Long Statement,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,IsPunctuatorStartChar,The length of the statement  "	return c == '{' || c == '}' || c == '(' || c == ')' || c == '[' || c == ']' || c == ';' || c == ''' || c == '<' || c == '>' || c == '=' || c == '!' || c == '+' || c == '-' || c == '*' || c == '%' || c == '&' || c == '|' || c == '^' || c == '~' || c == '?' || c == ':'; " is 268.
Long Statement,Jurassic.Compiler,JSBinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinderMethod.cs,Init,The length of the statement  "		throw new InvalidOperationException (string.Format ("The {0} flag cannot be used on the instance method '{1}'."' JSFunctionFlags.HasEngineParameter' this.Name)); " is 161.
Long Statement,Jurassic.Compiler,JSBinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinderMethod.cs,Init,The length of the statement  "		throw new InvalidOperationException (string.Format ("The {0} flag cannot be used on the instance method '{1}'."' JSFunctionFlags.HasThisObject' this.Name)); " is 156.
Long Statement,Jurassic.Compiler,JSBinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinderMethod.cs,Init,The length of the statement  "			throw new InvalidOperationException (string.Format ("The first parameter of the method '{0}' must be of type ScriptEngine."' this.Name)); " is 137.
Long Statement,Jurassic.Compiler,JSBinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinderMethod.cs,Init,The length of the statement  "		if (type != typeof(bool) && type != typeof(int) && type != typeof(double) && type != typeof(string) && type != typeof(object) && typeof(ObjectInstance).IsAssignableFrom (type) == false) " is 185.
Long Statement,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The length of the statement  "	foreach (var argument in binderMethod.GenerateArguments (generator' Math.Min (Math.Max (argumentCount' minArgumentCount)' maxArgumentCount))) { " is 143.
Long Statement,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The length of the statement  "			if (argument.Type.IsClass == true && inheritsFromObjectInstance == false && argument.Type != typeof(string) && argument.Type != typeof(object)) { " is 145.
Long Statement,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The length of the statement  "					EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("Parameter {1} parameter of '{0}' must be an object"' binderMethod.Name' argument.InputParameterIndex)); " is 166.
Long Statement,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,EmitTypeConversion,The length of the statement  "		EmitConversion.Convert (il' PrimitiveTypeUtilities.ToPrimitiveType (fromType)' PrimitiveTypeUtilities.ToPrimitiveType (toType)); " is 128.
Long Statement,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateCode,The length of the statement  "	if (this.OperatorType == OperatorType.LessThan || this.OperatorType == OperatorType.LessThanOrEqual || this.OperatorType == OperatorType.GreaterThan || this.OperatorType == OperatorType.GreaterThanOrEqual) { " is 207.
Long Statement,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateAdd,The length of the statement  "	else if (leftType != PrimitiveType.Any && leftType != PrimitiveType.Object && rightType != PrimitiveType.Any && rightType != PrimitiveType.Object) { " is 148.
Long Statement,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GenerateCode,The length of the statement  "			throw new JavaScriptException (optimizationInfo.Engine' "SyntaxError"' "The variable 'eval' cannot be modified in strict mode."); " is 129.
Long Statement,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GenerateCode,The length of the statement  "			throw new JavaScriptException (optimizationInfo.Engine' "SyntaxError"' "The variable 'arguments' cannot be modified in strict mode."); " is 134.
Long Statement,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GenerateIncrementOrDecrement,The length of the statement  "	target.GenerateSet (generator' optimizationInfo' target.Type == PrimitiveType.Int32 ? PrimitiveType.Int32 : PrimitiveType.Number' optimizationInfo.StrictMode); " is 159.
Long Statement,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GenerateCompoundAddAssignment,The length of the statement  "	//        target.GenerateSet(generator' optimizationInfo' PrimitiveType.ConcatenatedString' optimizationInfo.StrictMode); " is 121.
Long Statement,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GenerateCompoundAssignment,The length of the statement  "	var compoundOperator = new BinaryExpression (GetCompoundBaseOperator (this.OperatorType)' this.GetOperand (0)' this.GetOperand (1)); " is 132.
Long Statement,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,GenerateGet,The length of the statement  "			if (rhs.ResultType == PrimitiveType.Int32 || (propertyName != null && Library.ArrayInstance.ParseArrayIndex (propertyName) != uint.MaxValue)) " is 141.
Long Statement,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,GenerateSet,The length of the statement  "			if (rhs.ResultType == PrimitiveType.Int32 || (propertyName != null && Library.ArrayInstance.ParseArrayIndex (propertyName) != uint.MaxValue)) " is 141.
Long Statement,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,GenerateSet,The length of the statement  "		//     object.InlineSetPropertyValue("property"' value' strictMode' out __object_property_cachedIndex' out __object_cacheKey) " is 125.
Long Statement,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,GenerateSet,The length of the statement  "		// xxx = object.InlineSetPropertyValue("property"' value' strictMode' out __object_property_cachedIndex' out __object_cacheKey) " is 127.
Long Statement,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,ToString,The length of the statement  "		return string.Format ("{0}.{1}"' this.GetRawOperand (0)' this.OperandCount >= 2 ? this.GetRawOperand (1).ToString () : "?"); " is 124.
Long Statement,Jurassic.Compiler,Operator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Operator.cs,IsValidNumberOfOperands,The length of the statement  "		return operandCount == ((this.HasLHSOperand ? 1 : 0) + 0 + (this.HasSecondaryRHSOperand ? 1 : 0)) || operandCount == ((this.HasLHSOperand ? 1 : 0) + 1 + (this.HasSecondaryRHSOperand ? 1 : 0)); " is 192.
Long Statement,Jurassic.Compiler,Operator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Operator.cs,IsValidNumberOfOperands,The length of the statement  "	return operandCount == (this.HasLHSOperand ? 1 : 0) + (this.HasRHSOperand ? 1 : 0) + (this.HasSecondaryRHSOperand ? 1 : 0); " is 123.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ValidateVariableName,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("The variable name cannot be '{0}' in strict mode."' name)' this.LineNumber' this.SourcePath); " is 168.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,Expect,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Expected '{0}' but found {1}"' token.Text' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 184.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ExpectIdentifier,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Expected identifier but found {0}"' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 177.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,AtValidEndOfStatement,The length of the statement  "	return this.nextToken == PunctuatorToken.Semicolon || this.nextToken == PunctuatorToken.RightBrace || this.consumedLineTerminator == true || this.nextToken == null; " is 164.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ExpectEndOfStatement,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Expected ';' but found {0}"' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 170.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseStatementNoNewContext,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected end of input"' this.LineNumber' this.SourcePath); " is 120.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseVar,The length of the statement  "		this.currentScope.DeclareVariable (declaration.VariableName' this.context == CodeContext.Function ? null : new LiteralExpression (Undefined.Value)' writable: true' deletable: this.context == CodeContext.Eval); " is 209.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFor,The length of the statement  "			this.currentScope.DeclareVariable (declaration.VariableName' this.context == CodeContext.Function ? null : new LiteralExpression (Undefined.Value)' writable: true' deletable: this.context == CodeContext.Eval); " is 209.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFor,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Unexpected token {0}"' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 164.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFor,The length of the statement  "					throw new JavaScriptException (this.engine' "ReferenceError"' "Invalid left-hand side in for-in"' this.LineNumber' this.SourcePath); " is 132.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseReturn,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Return statements are only allowed inside functions"' this.LineNumber' this.SourcePath); " is 148.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseWith,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "The with statement is not supported in strict mode"' this.LineNumber' this.SourcePath); " is 147.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseSwitch,The length of the statement  "			while (this.nextToken != KeywordToken.Case && this.nextToken != KeywordToken.Default && this.nextToken != PunctuatorToken.RightBrace) " is 133.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseSwitch,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' "Only one default clause is allowed."' this.LineNumber' this.SourcePath); " is 132.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseSwitch,The length of the statement  "			while (this.nextToken != KeywordToken.Case && this.nextToken != KeywordToken.Default && this.nextToken != PunctuatorToken.RightBrace) " is 133.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseSwitch,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Expected 'case' or 'default'."' this.LineNumber' this.SourcePath); " is 126.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseThrow,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Illegal newline after throw"' this.LineNumber' this.SourcePath); " is 124.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseTry,The length of the statement  "		this.currentScope = result.CatchScope = DeclarativeScope.CreateCatchScope (this.currentScope' result.CatchVariableName); " is 120.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseTry,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Missing catch or finally after try"' this.LineNumber' this.SourcePath); " is 131.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFunctionDeclaration,The length of the statement  "	this.initialScope.DeclareVariable (expression.FunctionName' expression' writable: true' deletable: this.context == CodeContext.Eval); " is 133.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFunction,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Getters cannot have arguments"' this.LineNumber' this.SourcePath); " is 126.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFunction,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' "Setters must have a single argument"' this.LineNumber' this.SourcePath); " is 132.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseFunction,The length of the statement  "	var context = new FunctionMethodGenerator (this.engine' scope' functionName' argumentNames' bodyTextBuilder.ToString (0' bodyTextBuilder.Length - 1)' body' this.SourcePath' options); " is 182.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "		if (this.nextToken is LiteralToken || this.nextToken is IdentifierToken || this.nextToken == KeywordToken.Function || this.nextToken == KeywordToken.This || this.nextToken == PunctuatorToken.LeftBrace || (this.nextToken == PunctuatorToken.LeftBracket && this.expressionState == ParserExpressionState.Literal) || (this.nextToken is KeywordToken && unboundOperator != null && unboundOperator.OperatorType == OperatorType.MemberAccess && this.expressionState == ParserExpressionState.Literal)) { " is 492.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Expected operator but found {0}"' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 175.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "			if ((this.nextToken is KeywordToken || (this.nextToken is LiteralToken && ((LiteralToken)this.nextToken).IsKeyword == true)) && unboundOperator != null && unboundOperator.OperatorType == OperatorType.MemberAccess && this.expressionState == ParserExpressionState.Literal) { " is 272.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "			Operator newOperator = OperatorFromToken (this.nextToken' postfixOrInfix: this.expressionState == ParserExpressionState.Operator); " is 130.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "				if (Array.IndexOf (endTokens' PunctuatorToken.Semicolon) >= 0 && (this.consumedLineTerminator == true || this.nextToken == PunctuatorToken.RightBrace)) " is 151.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Unexpected token {0} in expression."' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 179.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "			if (this.consumedLineTerminator == true && (newOperator == Operator.PostIncrement || newOperator == Operator.PostDecrement)) " is 124.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "					throw new JavaScriptException (this.engine' "SyntaxError"' "Mismatched closing token in expression."' this.LineNumber' this.SourcePath); " is 136.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "						throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid use of prefix operator."' this.LineNumber' this.SourcePath); " is 128.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "					if (unboundOperator == null || (newOperator.Associativity == OperatorAssociativity.LeftToRight && unboundOperator.Precedence < newOperator.Precedence) || (newOperator.Associativity == OperatorAssociativity.RightToLeft && unboundOperator.Precedence <= newOperator.Precedence)) { " is 277.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "							if ((newOperator.Associativity == OperatorAssociativity.LeftToRight && node.Precedence < newOperator.Precedence) || (newOperator.Associativity == OperatorAssociativity.RightToLeft && node.Precedence <= newOperator.Precedence)) " is 226.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "							throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid use of prefix operator."' this.LineNumber' this.SourcePath); " is 128.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Unexpected token {0} in expression"' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 178.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "		this.Consume (root != null && (unboundOperator == null || unboundOperator.AcceptingOperands == false) ? ParserExpressionState.Operator : ParserExpressionState.Literal); " is 168.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Expected an expression but found {0} instead"' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 188.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,CheckASTValidity,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' "Wrong number of operands"' this.LineNumber' this.SourcePath); " is 121.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,CheckASTValidity,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Missing closing token '{0}'"' expression.Operator.SecondaryToken.Text)' this.LineNumber' this.SourcePath); " is 181.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,The length of the statement  "		if (this.nextToken != PunctuatorToken.Colon && mightBeGetOrSet == true && (propertyName == "get" || propertyName == "set")) { " is 125.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,The length of the statement  "						throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("The property '{0}' cannot have both a data property and a getter"' propertyName)' this.LineNumber' this.SourcePath); " is 191.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,The length of the statement  "						throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("The property '{0}' cannot have multiple getters"' propertyName)' this.LineNumber' this.SourcePath); " is 174.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,The length of the statement  "						throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("The property '{0}' cannot have both a data property and a setter"' propertyName)' this.LineNumber' this.SourcePath); " is 191.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,The length of the statement  "						throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("The property '{0}' cannot have multiple setters"' propertyName)' this.LineNumber' this.SourcePath); " is 174.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,The length of the statement  "					throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("The property '{0}' cannot have both a data property and a getter/setter"' propertyName)' this.LineNumber' this.SourcePath); " is 198.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,The length of the statement  "					throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("The property '{0}' already has a value"' propertyName)' this.LineNumber' this.SourcePath); " is 165.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ReadPropertyName,The length of the statement  "				throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Expected property name but found {0}"' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 180.
Long Statement,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ReadPropertyName,The length of the statement  "		throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Expected property name but found {0}"' Token.ToText (this.nextToken))' this.LineNumber' this.SourcePath); " is 180.
Long Statement,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The length of the statement  "			return "0" + numberFormatInfo.NumberDecimalSeparator + new string ('0'' precision) + exponentSymbol + numberFormatInfo.PositiveSign + "0"; " is 138.
Long Statement,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The length of the statement  "	int powerOfTwoScaleFactor = (radix == 10 ? 74 : (int)Math.Ceiling (maxDigitsToOutput * bitsPerDigit)) - divisor.BitCount; " is 121.
Long Statement,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,IsWhiteSpaceOrLineTerminator,The length of the statement  "	return c == 9 || c == 0x0b || c == 0x0c || c == ' ' || c == 0xa0 || c == 0xfeff || c == 0x1680 || c == 0x180e || (c >= 0x2000 && c <= 0x200a) || c == 0x202f || c == 0x205f || c == 0x3000 || c == 0x0a || c == 0x0d || c == 0x2028 || c == 0x2029; " is 243.
Long Statement,Jurassic,ScriptEngine,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ScriptEngine.cs,VerifyGeneratedCode,The length of the statement  "            System.IO.File.Copy(assemblyPath' System.IO.Path.Combine(System.IO.Path.GetDirectoryName(filePath)' System.IO.Path.GetFileName(assemblyPath))' true);" is 149.
Long Statement,Jurassic,ScriptEngine,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ScriptEngine.cs,VerifyGeneratedCode,The length of the statement  "            //    System.Diagnostics.Process.Start(@"C:\Program Files\Reflector\Reflector.exe"' string.Format("\"{0}\" /select:JavaScriptClass"' filePath));" is 144.
Long Statement,Jurassic,TypeUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeUtilities.cs,IsPrimitive,The length of the statement  "	return type == typeof(bool) || type == typeof(int) || type == typeof(uint) || type == typeof(double) || type == typeof(string) || type == typeof(ConcatenatedString) || type == typeof(Null) || type == typeof(Undefined); " is 218.
Long Statement,Jurassic,TypeUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeUtilities.cs,IsPrimitiveOrObject,The length of the statement  "	return type == typeof(bool) || type == typeof(int) || type == typeof(uint) || type == typeof(double) || type == typeof(string) || type == typeof(ConcatenatedString) || type == typeof(Null) || type == typeof(Undefined) || typeof(ObjectInstance).IsAssignableFrom (type); " is 268.
Long Statement,Jurassic,TypeUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeUtilities.cs,VerifyThisObject,The length of the statement  "		throw new JavaScriptException (engine' "TypeError"' string.Format ("The function '{0}' does not allow the value of 'this' to be undefined"' functionName)); " is 155.
Long Statement,Jurassic,TypeUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeUtilities.cs,VerifyThisObject,The length of the statement  "		throw new JavaScriptException (engine' "TypeError"' string.Format ("The function '{0}' does not allow the value of 'this' to be null"' functionName)); " is 150.
Long Statement,Jurassic,ReflectionHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ReflectionHelpers.cs,GetMembers,The length of the statement  "		if (field.FieldType != typeof(MethodInfo) && field.FieldType != typeof(ConstructorInfo) && field.FieldType != typeof(FieldInfo)) " is 128.
Long Statement,Jurassic,ReflectionHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ReflectionHelpers.cs,GetConstructor,The length of the statement  "		throw new InvalidOperationException (string.Format ("The constructor {0}({1}) does not exist."' type.FullName' StringHelpers.Join<Type> ("' "' parameterTypes))); " is 161.
Long Statement,Jurassic,ReflectionHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ReflectionHelpers.cs,GetInstanceMethod,The length of the statement  "	var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly | BindingFlags.ExactBinding; " is 137.
Long Statement,Jurassic,ReflectionHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ReflectionHelpers.cs,GetInstanceMethod,The length of the statement  "		throw new InvalidOperationException (string.Format ("The instance method {0}.{1}({2}) does not exist."' type.FullName' name' StringHelpers.Join<Type> ("' "' parameterTypes))); " is 175.
Long Statement,Jurassic,ReflectionHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ReflectionHelpers.cs,GetStaticMethod,The length of the statement  "	var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly | BindingFlags.ExactBinding; " is 135.
Long Statement,Jurassic,ReflectionHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ReflectionHelpers.cs,GetStaticMethod,The length of the statement  "		throw new InvalidOperationException (string.Format ("The static method {0}.{1}({2}) does not exist."' type.FullName' name' StringHelpers.Join<Type> ("' "' parameterTypes))); " is 173.
Long Statement,Jurassic,ReflectionHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\ReflectionHelpers.cs,GetGenericInstanceMethod,The length of the statement  "		throw new InvalidOperationException (string.Format ("The instance method {0}.{1}(...) does not exist."' type.FullName' name)); " is 126.
Long Statement,Jurassic,TypeConverter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeConverter.cs,ToBoolean,The length of the statement  "	throw new ArgumentException (string.Format ("Cannot convert object of type '{0}' to a boolean."' value.GetType ())' "value"); " is 125.
Long Statement,Jurassic,TypeConverter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeConverter.cs,ToNumber,The length of the statement  "	throw new ArgumentException (string.Format ("Cannot convert object of type '{0}' to a number."' value.GetType ())' "value"); " is 124.
Long Statement,Jurassic,TypeConverter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeConverter.cs,ToString,The length of the statement  "	throw new ArgumentException (string.Format ("Cannot convert object of type '{0}' to a string."' value.GetType ())' "value"); " is 124.
Long Statement,Jurassic,TypeConverter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeConverter.cs,ToObject,The length of the statement  "	throw new ArgumentException (string.Format ("Cannot convert object of type '{0}' to an object."' value.GetType ())' "value"); " is 125.
Long Statement,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,FromCache,The length of the statement  "		throw new JavaScriptException (engine' "TypeError"' "Unsupported type: CLR types are not supported.  Enable CLR types by setting the ScriptEngine's EnableExposedClrTypes property to true."); " is 190.
Long Statement,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,ConstructLateBound,The length of the statement  "		throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("The type '{0}' has no public constructors"' this.WrappedType)); " is 136.
Long Statement,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,PopulateMembers,The length of the statement  "			ClrFunction getter = getMethod == null ? null : new ClrFunction (target.Engine.Function.InstancePrototype' new ClrBinder (getMethod)); " is 134.
Long Statement,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,PopulateMembers,The length of the statement  "			ClrFunction setter = setMethod == null ? null : new ClrFunction (target.Engine.Function.InstancePrototype' new ClrBinder (setMethod)); " is 134.
Long Statement,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,PopulateMembers,The length of the statement  "			target.DefineProperty (property.Name' new PropertyDescriptor (getter' setter' PropertyAttributes.NonEnumerable)' false); " is 120.
Long Statement,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,PopulateMembers,The length of the statement  "			target.DefineProperty (field.Name' new PropertyDescriptor (fieldGetter' fieldSetter' PropertyAttributes.NonEnumerable)' false); " is 127.
Long Statement,Jurassic.Library,ClrInstanceTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrInstanceTypeWrapper.cs,FromCache,The length of the statement  "		throw new JavaScriptException (engine' "TypeError"' "Unsupported type: CLR types are not supported.  Enable CLR types by setting the ScriptEngine's EnableExposedClrTypes property to true."); " is 190.
Long Statement,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadHexNumber,The length of the statement  "			throw new JavaScriptException (this.engine' "SyntaxError"' string.Format ("Invalid hex digit '{0}' in escape sequence."' (char)c)); " is 131.
Long Statement,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,DefineProperty,The length of the statement  "				throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("Accessors are not supported for array elements."' propertyName)); " is 138.
Long Statement,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,DefineProperty,The length of the statement  "				throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("Non-accessible array elements are not supported."' propertyName)); " is 139.
Long Statement,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The length of the statement  "                      (?<zone> Z | (?<zoneHours> [+-][0-9]{2} ) : (?<zoneMinutes> [0-9]{2} ) )?)?$"' RegexOptions.ExplicitCapture | RegexOptions.Singleline | RegexOptions.IgnorePatternWhitespace); " is 174.
Long Statement,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The length of the statement  "		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) { " is 231.
Long Statement,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The length of the statement  "			if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase)) " is 127.
Long Statement,Jurassic.Library,UserDefinedFunction,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\UserDefinedFunction.cs,Compile,The length of the statement  "		var functionGenerator = new FunctionMethodGenerator (this.Engine' scope' this.Name' this.ArgumentNames' this.BodyText' new CompilerOptions ()); " is 143.
Long Statement,Jurassic.Library,UserDefinedFunction,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\UserDefinedFunction.cs,ToString,The length of the statement  "	return string.Format ("function {0}({1}) {{\n{2}\n}}"' this.Name' StringHelpers.Join ("' "' this.ArgumentNames)' this.BodyText); " is 128.
Long Statement,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The length of the statement  "			if (elementValue is string || elementValue is int || elementValue is double || elementValue is StringInstance || elementValue is NumberInstance) " is 144.
Long Statement,Jurassic.Library,HiddenClassSchema,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\HiddenClassSchema.cs,EnumeratePropertyNamesAndValues,The length of the statement  "		yield return new PropertyNameAndValue (pair.Key' new PropertyDescriptor (values [pair.Value.Index]' pair.Value.Attributes)); " is 124.
Long Statement,Jurassic.Library,HiddenClassSchema,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\HiddenClassSchema.cs,DeleteProperty,The length of the statement  "		var properties = this.properties == null ? CreatePropertiesDictionary () : new Dictionary<string' SchemaProperty> (this.properties); " is 132.
Long Statement,Jurassic.Library,HiddenClassSchema,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\HiddenClassSchema.cs,CreatePropertiesDictionary,The length of the statement  "			addTransitions.Push (new KeyValuePair<string' SchemaProperty> (node.addPropertyTransitionInfo.Name' new SchemaProperty (node.NextValueIndex - 1' node.addPropertyTransitionInfo.Attributes))); " is 190.
Long Statement,Jurassic.Library,PropertyDescriptor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\PropertyDescriptor.cs,FromObject,The length of the statement  "			throw new JavaScriptException (obj.Engine' "TypeError"' "Property descriptors with 'get' or 'set' defined must not have 'writable' set"); " is 137.
Long Statement,Jurassic.Library,PropertyDescriptor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\PropertyDescriptor.cs,FromObject,The length of the statement  "			throw new JavaScriptException (obj.Engine' "TypeError"' "Property descriptors with 'get' or 'set' defined must not have 'writable' set"); " is 137.
Long Statement,Jurassic.Library,FunctionConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\FunctionConstructor.cs,Construct,The length of the statement  "	return new UserDefinedFunction (this.InstancePrototype' "anonymous"' argumentNames' argumentsAndBody [argumentsAndBody.Length - 1]); " is 132.
Long Statement,Jurassic.Library,ObjectConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectConstructor.cs,Seal,The length of the statement  "		obj.FastSetProperty (property.Name' property.Value' property.Attributes & ~PropertyAttributes.Configurable' overwriteAttributes: true); " is 135.
Long Statement,Jurassic.Library,ObjectConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectConstructor.cs,Freeze,The length of the statement  "		obj.FastSetProperty (property.Name' property.Value' property.Attributes & ~(PropertyAttributes.NonEnumerable)' overwriteAttributes: true); " is 138.
Long Statement,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,EncodeURI,The length of the statement  "		var lookupTable = CreateCharacterSetLookupTable (";/?:@&=+$'-_.!~*'()#ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"); " is 135.
Long Statement,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,EncodeURIComponent,The length of the statement  "		var lookupTable = CreateCharacterSetLookupTable ("-_.!~*'()ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"); " is 124.
Long Statement,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Escape,The length of the statement  "		if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '@' || c == '*' || c == '_' || c == '+' || c == '-' || c == '.' || c == '/') " is 163.
Long Statement,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,IsWhiteSpaceOrLineTerminator,The length of the statement  "	return c == 9 || c == 0x0b || c == 0x0c || c == ' ' || c == 0xa0 || c == 0xfeff || c == 0x1680 || c == 0x180e || (c >= 0x2000 && c <= 0x200a) || c == 0x202f || c == 0x205f || c == 0x3000 || c == 0x0a || c == 0x0d || c == 0x2028 || c == 0x2029; " is 243.
Long Statement,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,InitializeDeprecatedProperty,The length of the statement  "	this.DefineProperty (propertyName' new PropertyDescriptor (new PropertyAccessorValue (new ClrFunction (this.Engine.Function.InstancePrototype' getter)' null)' attributes)' false); " is 179.
Long Statement,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,Call,The length of the statement  "			throw new JavaScriptException (this.Engine' "TypeError"' "Cannot supply flags when constructing one RegExp from another"); " is 122.
Long Statement,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,Construct,The length of the statement  "			throw new JavaScriptException (this.Engine' "TypeError"' "Cannot supply flags when constructing one RegExp from another"); " is 122.
Long Statement,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The length of the statement  "		// $n or $nn	Where n or nn are decimal digits' inserts the nth parenthesized submatch string' provided the first argument was a RegExp object. " is 142.
Long Statement,Jurassic.Library,FunctionInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\FunctionInstance.cs,Apply,The length of the statement  "			throw new JavaScriptException (this.Engine' "TypeError"' "The second parameter of apply() must be an array or an array-like object."); " is 134.
Long Statement,Jurassic.Library,FunctionInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\FunctionInstance.cs,Apply,The length of the statement  "			throw new JavaScriptException (this.Engine' "TypeError"' "The second parameter of apply() must be an array or an array-like object."); " is 134.
Long Statement,Jurassic.Library,FunctionInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Function\FunctionInstance.cs,Apply,The length of the statement  "			throw new JavaScriptException (this.Engine' "TypeError"' "The second parameter of apply() must be an array or an array-like object."); " is 134.
Long Statement,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToGMTString,The length of the statement  "	return this.value.ToUniversalTime ().ToString ("ddd' dd MMM yyyy HH:mm:ss 'GMT'"' System.Globalization.DateTimeFormatInfo.InvariantInfo); " is 137.
Long Statement,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToISOString,The length of the statement  "	return this.value.ToUniversalTime ().ToString ("yyyy-MM-dd'T'HH:mm:ss.fff'Z'"' System.Globalization.DateTimeFormatInfo.InvariantInfo); " is 134.
Long Statement,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToStringJS,The length of the statement  "	return dateTime.ToString ("ddd MMM dd yyyy HH:mm:ss "' System.Globalization.DateTimeFormatInfo.InvariantInfo) + ToTimeZoneString (dateTime); " is 140.
Long Statement,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToTimeString,The length of the statement  "	return dateTime.ToString ("HH:mm:ss "' System.Globalization.DateTimeFormatInfo.InvariantInfo) + ToTimeZoneString (dateTime); " is 124.
Long Statement,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToUTCString,The length of the statement  "	return this.value.ToUniversalTime ().ToString ("ddd' dd MMM yyyy HH:mm:ss 'GMT'"' System.Globalization.DateTimeFormatInfo.InvariantInfo); " is 137.
Long Statement,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The length of the statement  "	this.value = ToDateTime (allComponentValues [0]' allComponentValues [1]' allComponentValues [2]' allComponentValues [3]' allComponentValues [4]' allComponentValues [5]' allComponentValues [6]' localOrUniversal); " is 211.
Long Statement,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The length of the statement  "	if (month >= 0 && month < 12 && day >= 1 && day <= DateTime.DaysInMonth (year' month + 1) && hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000) { " is 220.
Long Statement,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToLocaleString,The length of the statement  "	return NumberFormatter.ToString (this.value' 10' CultureInfo.CurrentCulture.NumberFormat' NumberFormatter.Style.Regular); " is 121.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,OnDeserializationCallback,The length of the statement  "		throw new InvalidOperationException ("Set the ScriptEngine.DeserializationEnvironment property before deserializing any objects."); " is 131.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,InlineSetPropertyValue,The length of the statement  "		if ((propertyInfo.Attributes & (PropertyAttributes.Writable | PropertyAttributes.IsAccessorProperty | PropertyAttributes.IsLengthProperty)) != PropertyAttributes.Writable) { " is 173.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,InlineSetPropertyValueIfExists,The length of the statement  "		if ((propertyInfo.Attributes & (PropertyAttributes.Writable | PropertyAttributes.IsAccessorProperty | PropertyAttributes.IsLengthProperty)) != PropertyAttributes.Writable) { " is 173.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,SetPropertyValueIfExists,The length of the statement  "				throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("The property '{0}' is read-only."' propertyName)); " is 123.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,Delete,The length of the statement  "			throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("The property '{0}' cannot be deleted."' propertyName)); " is 128.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,DefineProperty,The length of the statement  "		if (descriptor.Attributes != current.Attributes || (descriptor.IsAccessor == true && (getter != descriptor.Getter || setter != descriptor.Setter)) || (descriptor.IsAccessor == false && current.IsWritable == false && TypeComparer.SameValue (currentValue' descriptor.Value) == false)) { " is 284.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,DefineProperty,The length of the statement  "				throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("The property '{0}' is non-configurable."' propertyName)); " is 130.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,AddProperty,The length of the statement  "			throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("The property '{0}' cannot be created as the object is not extensible."' propertyName)); " is 160.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,GetPrimitiveValue,The length of the statement  "	throw new JavaScriptException (this.Engine' "TypeError"' "Attempted conversion of the object to a primitive value failed.  Check the toString() and valueOf() functions."); " is 171.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,CallMemberFunction,The length of the statement  "		throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("Object {0} has no method '{1}'"' this.ToString ()' functionName)); " is 139.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,CallMemberFunction,The length of the statement  "		throw new JavaScriptException (this.Engine' "TypeError"' string.Format ("Property '{1}' of object {0} is not a function"' this.ToString ()' functionName)); " is 155.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,PopulateFunctions,The length of the statement  "	PopulateFunctions (type' BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static | BindingFlags.DeclaredOnly); " is 120.
Long Statement,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,PopulateFunctions,The length of the statement  "		this.FastSetProperty (name' new ClrFunction (this.Engine.Function.InstancePrototype' methodGroup.Methods' name' methodGroup.Length)' methodGroup.PropertyAttributes); " is 165.
Complex Conditional,Jurassic.Compiler,GlobalMethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\GlobalMethodGenerator.cs,GetMethodName,The conditional expression  "(c < '0' || c > '9') && (c < 'a' || c > 'z') && (c < 'A' || c > 'Z')"  is complex.
Complex Conditional,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The conditional expression  "right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || @operator != ArithmeticOperator.Add)"  is complex.
Complex Conditional,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The conditional expression  "right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || @operator != ArithmeticOperator.Add)"  is complex.
Complex Conditional,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The conditional expression  "right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual))"  is complex.
Complex Conditional,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The conditional expression  "right != VESType.ManagedPointer && (right != VESType.NativeInt || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual))"  is complex.
Complex Conditional,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The conditional expression  "right != VESType.Object || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual && @operator != ComparisonOperator.GreaterThanUnsigned)"  is complex.
Complex Conditional,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The conditional expression  "this.InitVarStatement != null && this.InitVarStatement.Declarations.Count == 1 && this.InitVarStatement.Declarations [0].InitExpression != null && this.InitVarStatement.Declarations [0].InitExpression.ResultType == PrimitiveType.Int32"  is complex.
Complex Conditional,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The conditional expression  "this.InitExpression != null && this.InitExpression is AssignmentExpression && ((AssignmentExpression)this.InitExpression).ResultType == PrimitiveType.Int32 && ((AssignmentExpression)this.InitExpression).Target is NameExpression"  is complex.
Complex Conditional,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The conditional expression  "initIsOkay == true && this.ConditionStatement != null && this.Condition is BinaryExpression && (((BinaryExpression)this.Condition).OperatorType == OperatorType.LessThan || ((BinaryExpression)this.Condition).OperatorType == OperatorType.GreaterThan) && ((BinaryExpression)this.Condition).Left is NameExpression && ((NameExpression)((BinaryExpression)this.Condition).Left).Name == loopVariableName && ((BinaryExpression)this.Condition).Right.ResultType == PrimitiveType.Int32"  is complex.
Complex Conditional,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The conditional expression  "lessThan == true && this.IncrementStatement != null && this.Increment is AssignmentExpression && (((AssignmentExpression)this.Increment).OperatorType == OperatorType.PostIncrement || ((AssignmentExpression)this.Increment).OperatorType == OperatorType.PreIncrement) && ((NameExpression)((AssignmentExpression)this.Increment).Target).Name == loopVariableName"  is complex.
Complex Conditional,Jurassic.Compiler,LoopStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\LoopStatement.cs,FindTypedVariables,The conditional expression  "lessThan == false && this.IncrementStatement != null && this.Increment is AssignmentExpression && (((AssignmentExpression)this.Increment).OperatorType == OperatorType.PostDecrement || ((AssignmentExpression)this.Increment).OperatorType == OperatorType.PreDecrement) && ((NameExpression)((AssignmentExpression)this.Increment).Target).Name == loopVariableName"  is complex.
Complex Conditional,Jurassic.Compiler,JSBinderMethod,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinderMethod.cs,Init,The conditional expression  "type != typeof(bool) && type != typeof(int) && type != typeof(double) && type != typeof(string) && type != typeof(object) && typeof(ObjectInstance).IsAssignableFrom (type) == false"  is complex.
Complex Conditional,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The conditional expression  "argument.Type.IsClass == true && inheritsFromObjectInstance == false && argument.Type != typeof(string) && argument.Type != typeof(object)"  is complex.
Complex Conditional,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateCode,The conditional expression  "this.OperatorType == OperatorType.LessThan || this.OperatorType == OperatorType.LessThanOrEqual || this.OperatorType == OperatorType.GreaterThan || this.OperatorType == OperatorType.GreaterThanOrEqual"  is complex.
Complex Conditional,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateAdd,The conditional expression  "leftType != PrimitiveType.Any && leftType != PrimitiveType.Object && rightType != PrimitiveType.Any && rightType != PrimitiveType.Object"  is complex.
Complex Conditional,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The conditional expression  "this.nextToken is LiteralToken || this.nextToken is IdentifierToken || this.nextToken == KeywordToken.Function || this.nextToken == KeywordToken.This || this.nextToken == PunctuatorToken.LeftBrace || (this.nextToken == PunctuatorToken.LeftBracket && this.expressionState == ParserExpressionState.Literal) || (this.nextToken is KeywordToken && unboundOperator != null && unboundOperator.OperatorType == OperatorType.MemberAccess && this.expressionState == ParserExpressionState.Literal)"  is complex.
Complex Conditional,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The conditional expression  "(this.nextToken is KeywordToken || (this.nextToken is LiteralToken && ((LiteralToken)this.nextToken).IsKeyword == true)) && unboundOperator != null && unboundOperator.OperatorType == OperatorType.MemberAccess && this.expressionState == ParserExpressionState.Literal"  is complex.
Complex Conditional,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The conditional expression  "unboundOperator == null || (newOperator.Associativity == OperatorAssociativity.LeftToRight && unboundOperator.Precedence < newOperator.Precedence) || (newOperator.Associativity == OperatorAssociativity.RightToLeft && unboundOperator.Precedence <= newOperator.Precedence)"  is complex.
Complex Conditional,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseExpression,The conditional expression  "(newOperator.Associativity == OperatorAssociativity.LeftToRight && node.Precedence < newOperator.Precedence) || (newOperator.Associativity == OperatorAssociativity.RightToLeft && node.Precedence <= newOperator.Precedence)"  is complex.
Complex Conditional,Jurassic.Compiler,Parser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Parser\Parser.cs,ParseObjectLiteral,The conditional expression  "this.nextToken != PunctuatorToken.Colon && mightBeGetOrSet == true && (propertyName == "get" || propertyName == "set")"  is complex.
Complex Conditional,Jurassic,TypeComparer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeComparer.cs,Equals,The conditional expression  "(x == Undefined.Value && y == Null.Value) || (x == Null.Value && y == Undefined.Value)"  is complex.
Complex Conditional,Jurassic,TypeComparer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeComparer.cs,SameValue,The conditional expression  "x is double && (double)x == 0.0 && y is double && (double)y == 0.0"  is complex.
Complex Conditional,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The conditional expression  "hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0))"  is complex.
Complex Conditional,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The conditional expression  "word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)"  is complex.
Complex Conditional,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The conditional expression  "elementValue is string || elementValue is int || elementValue is double || elementValue is StringInstance || elementValue is NumberInstance"  is complex.
Complex Conditional,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Escape,The conditional expression  "(c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '@' || c == '*' || c == '_' || c == '+' || c == '-' || c == '.' || c == '/'"  is complex.
Complex Conditional,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Split,The conditional expression  "match.Length == 0 && (match.Index == 0 || match.Index == input.Length || match.Index == startIndex)"  is complex.
Complex Conditional,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The conditional expression  "month >= 0 && month < 12 && day >= 1 && day <= DateTime.DaysInMonth (year' month + 1) && hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000"  is complex.
Complex Conditional,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,DefineProperty,The conditional expression  "descriptor.Attributes != current.Attributes || (descriptor.IsAccessor == true && (getter != descriptor.Getter || setter != descriptor.Setter)) || (descriptor.IsAccessor == false && current.IsWritable == false && TypeComparer.SameValue (currentValue' descriptor.Value) == false)"  is complex.
Virtual Method Call from Constructor,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,Lexer,The constructor "Lexer" calls a virtual method "GetReader".
Magic Number,Jurassic.Compiler,FieldSetterBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\FieldBinders.cs,GenerateStub,The following statement contains a magic number: generator.LoadArgument (2);  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,AppendLabel,The following statement contains a magic number: this.log.Append (' '' 4);  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,LogInstruction,The following statement contains a magic number: if (this.indent > 0)  	this.log.Append (' '' this.indent * 4);  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,LogInstruction,The following statement contains a magic number: this.log.Append (' '' this.indent * 4);  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,LogInstruction,The following statement contains a magic number: if (this.nextInstructionHasLabel == true) {  	this.log.AppendFormat ("L{0:D3}: "' this.nextLabelNumber);  	this.nextInstructionHasLabel = false;  	this.nextLabelNumber++;  }  else  	this.log.Append (' '' 6);  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,LogInstruction,The following statement contains a magic number: this.log.Append (' '' 6);  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,LogInstruction,The following statement contains a magic number: if (suffix != null) {  	// Pad the instruction to eleven characters long.  	this.log.Append (' '' 11 - instruction.Length);  	// Output the suffix.  	if (suffix != string.Empty)  		this.log.Append (suffix);  }  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,LogInstruction,The following statement contains a magic number: this.log.Append (' '' 11 - instruction.Length);  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,LogCore,The following statement contains a magic number: if (this.indent > 0)  	this.log.Append (' '' this.indent * 4);  
Magic Number,Jurassic.Compiler,LoggingILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\LoggingILGenerator.cs,LogCore,The following statement contains a magic number: this.log.Append (' '' this.indent * 4);  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: if (this.Options.EnableDebugging == false) {  	// DynamicMethod requires full trust because of generator.LoadMethodPointer in the  	// FunctionExpression class.  	// Create a new dynamic method.  	System.Reflection.Emit.DynamicMethod dynamicMethod;  	#if !SILVERLIGHT  	if (ScriptEngine.LowPrivilegeEnvironment == false) {  		// High privilege path.  		dynamicMethod = new System.Reflection.Emit.DynamicMethod (GetMethodName ()' // Name of the generated method.  		typeof(object)' // Return type of the generated method.  		GetParameterTypes ()' // Parameter types of the generated method.  		typeof(MethodGenerator)' // Owner type.  		true);  		// Skip visibility checks.  		// TODO: Figure out why long methods give BadImageFormatException in .NET 3.5 when generated using DynamicILInfo.  		if (Environment.Version.Major >= 4)  			generator = new DynamicILGenerator (dynamicMethod);  		else  			generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  	}  	else {  		#endif  		// Low privilege path.  		dynamicMethod = new System.Reflection.Emit.DynamicMethod (GetMethodName ()' // Name of the generated method.  		typeof(object)' // Return type of the generated method.  		GetParameterTypes ());  		// Parameter types of the generated method.  		generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  		#if !SILVERLIGHT  	}  	#endif  	if (this.Engine.EnableILAnalysis == true) {  		// Replace the generator with one that logs.  		generator = new LoggingILGenerator (generator);  	}  	// Generate the IL.  	GenerateCode (generator' optimizationInfo);  	generator.Complete ();  	// Create a delegate from the method.  	this.GeneratedMethod = new GeneratedMethod (dynamicMethod.CreateDelegate (GetDelegate ())' optimizationInfo.NestedFunctions);  }  else {  	#if WINDOWS_PHONE  	                throw new NotImplementedException(); #else  	// Debugging or low trust path.  	ScriptEngine.ReflectionEmitModuleInfo reflectionEmitInfo = this.Engine.ReflectionEmitInfo;  	if (reflectionEmitInfo == null) {  		reflectionEmitInfo = new ScriptEngine.ReflectionEmitModuleInfo ();  		// Create a dynamic assembly and module.  		reflectionEmitInfo.AssemblyBuilder = System.Threading.Thread.GetDomain ().DefineDynamicAssembly (new System.Reflection.AssemblyName ("Jurassic Dynamic Assembly")' System.Reflection.Emit.AssemblyBuilderAccess.Run);  		// Mark the assembly as debuggable.  This must be done before the module is created.  		var debuggableAttributeConstructor = typeof(System.Diagnostics.DebuggableAttribute).GetConstructor (new Type[] {  			typeof(System.Diagnostics.DebuggableAttribute.DebuggingModes)  		});  		reflectionEmitInfo.AssemblyBuilder.SetCustomAttribute (new System.Reflection.Emit.CustomAttributeBuilder (debuggableAttributeConstructor' new object[] {  			System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations | System.Diagnostics.DebuggableAttribute.DebuggingModes.Default  		}));  		// Create a dynamic module.  		reflectionEmitInfo.ModuleBuilder = reflectionEmitInfo.AssemblyBuilder.DefineDynamicModule ("Module"' this.Options.EnableDebugging);  		this.Engine.ReflectionEmitInfo = reflectionEmitInfo;  	}  	// Create a new type to hold our method.  	var typeBuilder = reflectionEmitInfo.ModuleBuilder.DefineType ("JavaScriptClass" + reflectionEmitInfo.TypeCount.ToString ()' System.Reflection.TypeAttributes.Public | System.Reflection.TypeAttributes.Class);  	reflectionEmitInfo.TypeCount++;  	// Create a method.  	var methodBuilder = typeBuilder.DefineMethod (this.GetMethodName ()' System.Reflection.MethodAttributes.HideBySig | System.Reflection.MethodAttributes.Static | System.Reflection.MethodAttributes.Public' typeof(object)' GetParameterTypes ());  	// Generate the IL for the method.  	generator = new ReflectionEmitILGenerator (methodBuilder.GetILGenerator ());  	if (this.Engine.EnableILAnalysis == true) {  		// Replace the generator with one that logs.  		generator = new LoggingILGenerator (generator);  	}  	if (this.Source.Path != null && this.Options.EnableDebugging == true) {  		// Initialize the debugging information.  		optimizationInfo.DebugDocument = reflectionEmitInfo.ModuleBuilder.DefineDocument (this.Source.Path' COMHelpers.LanguageType' COMHelpers.LanguageVendor' COMHelpers.DocumentType);  		methodBuilder.DefineParameter (1' System.Reflection.ParameterAttributes.None' "scriptEngine");  		methodBuilder.DefineParameter (2' System.Reflection.ParameterAttributes.None' "scope");  		methodBuilder.DefineParameter (3' System.Reflection.ParameterAttributes.None' "thisValue");  		generator.MarkSequencePoint (optimizationInfo.DebugDocument' new SourceCodeSpan (1' 1' 1' 1));  	}  	GenerateCode (generator' optimizationInfo);  	generator.Complete ();  	// Bake it.  	var type = typeBuilder.CreateType ();  	var methodInfo = type.GetMethod (this.GetMethodName ());  	this.GeneratedMethod = new GeneratedMethod (Delegate.CreateDelegate (GetDelegate ()' methodInfo)' optimizationInfo.NestedFunctions);  	#endif  }  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: if (this.Options.EnableDebugging == false) {  	// DynamicMethod requires full trust because of generator.LoadMethodPointer in the  	// FunctionExpression class.  	// Create a new dynamic method.  	System.Reflection.Emit.DynamicMethod dynamicMethod;  	#if !SILVERLIGHT  	if (ScriptEngine.LowPrivilegeEnvironment == false) {  		// High privilege path.  		dynamicMethod = new System.Reflection.Emit.DynamicMethod (GetMethodName ()' // Name of the generated method.  		typeof(object)' // Return type of the generated method.  		GetParameterTypes ()' // Parameter types of the generated method.  		typeof(MethodGenerator)' // Owner type.  		true);  		// Skip visibility checks.  		// TODO: Figure out why long methods give BadImageFormatException in .NET 3.5 when generated using DynamicILInfo.  		if (Environment.Version.Major >= 4)  			generator = new DynamicILGenerator (dynamicMethod);  		else  			generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  	}  	else {  		#endif  		// Low privilege path.  		dynamicMethod = new System.Reflection.Emit.DynamicMethod (GetMethodName ()' // Name of the generated method.  		typeof(object)' // Return type of the generated method.  		GetParameterTypes ());  		// Parameter types of the generated method.  		generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  		#if !SILVERLIGHT  	}  	#endif  	if (this.Engine.EnableILAnalysis == true) {  		// Replace the generator with one that logs.  		generator = new LoggingILGenerator (generator);  	}  	// Generate the IL.  	GenerateCode (generator' optimizationInfo);  	generator.Complete ();  	// Create a delegate from the method.  	this.GeneratedMethod = new GeneratedMethod (dynamicMethod.CreateDelegate (GetDelegate ())' optimizationInfo.NestedFunctions);  }  else {  	#if WINDOWS_PHONE  	                throw new NotImplementedException(); #else  	// Debugging or low trust path.  	ScriptEngine.ReflectionEmitModuleInfo reflectionEmitInfo = this.Engine.ReflectionEmitInfo;  	if (reflectionEmitInfo == null) {  		reflectionEmitInfo = new ScriptEngine.ReflectionEmitModuleInfo ();  		// Create a dynamic assembly and module.  		reflectionEmitInfo.AssemblyBuilder = System.Threading.Thread.GetDomain ().DefineDynamicAssembly (new System.Reflection.AssemblyName ("Jurassic Dynamic Assembly")' System.Reflection.Emit.AssemblyBuilderAccess.Run);  		// Mark the assembly as debuggable.  This must be done before the module is created.  		var debuggableAttributeConstructor = typeof(System.Diagnostics.DebuggableAttribute).GetConstructor (new Type[] {  			typeof(System.Diagnostics.DebuggableAttribute.DebuggingModes)  		});  		reflectionEmitInfo.AssemblyBuilder.SetCustomAttribute (new System.Reflection.Emit.CustomAttributeBuilder (debuggableAttributeConstructor' new object[] {  			System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations | System.Diagnostics.DebuggableAttribute.DebuggingModes.Default  		}));  		// Create a dynamic module.  		reflectionEmitInfo.ModuleBuilder = reflectionEmitInfo.AssemblyBuilder.DefineDynamicModule ("Module"' this.Options.EnableDebugging);  		this.Engine.ReflectionEmitInfo = reflectionEmitInfo;  	}  	// Create a new type to hold our method.  	var typeBuilder = reflectionEmitInfo.ModuleBuilder.DefineType ("JavaScriptClass" + reflectionEmitInfo.TypeCount.ToString ()' System.Reflection.TypeAttributes.Public | System.Reflection.TypeAttributes.Class);  	reflectionEmitInfo.TypeCount++;  	// Create a method.  	var methodBuilder = typeBuilder.DefineMethod (this.GetMethodName ()' System.Reflection.MethodAttributes.HideBySig | System.Reflection.MethodAttributes.Static | System.Reflection.MethodAttributes.Public' typeof(object)' GetParameterTypes ());  	// Generate the IL for the method.  	generator = new ReflectionEmitILGenerator (methodBuilder.GetILGenerator ());  	if (this.Engine.EnableILAnalysis == true) {  		// Replace the generator with one that logs.  		generator = new LoggingILGenerator (generator);  	}  	if (this.Source.Path != null && this.Options.EnableDebugging == true) {  		// Initialize the debugging information.  		optimizationInfo.DebugDocument = reflectionEmitInfo.ModuleBuilder.DefineDocument (this.Source.Path' COMHelpers.LanguageType' COMHelpers.LanguageVendor' COMHelpers.DocumentType);  		methodBuilder.DefineParameter (1' System.Reflection.ParameterAttributes.None' "scriptEngine");  		methodBuilder.DefineParameter (2' System.Reflection.ParameterAttributes.None' "scope");  		methodBuilder.DefineParameter (3' System.Reflection.ParameterAttributes.None' "thisValue");  		generator.MarkSequencePoint (optimizationInfo.DebugDocument' new SourceCodeSpan (1' 1' 1' 1));  	}  	GenerateCode (generator' optimizationInfo);  	generator.Complete ();  	// Bake it.  	var type = typeBuilder.CreateType ();  	var methodInfo = type.GetMethod (this.GetMethodName ());  	this.GeneratedMethod = new GeneratedMethod (Delegate.CreateDelegate (GetDelegate ()' methodInfo)' optimizationInfo.NestedFunctions);  	#endif  }  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: if (this.Options.EnableDebugging == false) {  	// DynamicMethod requires full trust because of generator.LoadMethodPointer in the  	// FunctionExpression class.  	// Create a new dynamic method.  	System.Reflection.Emit.DynamicMethod dynamicMethod;  	#if !SILVERLIGHT  	if (ScriptEngine.LowPrivilegeEnvironment == false) {  		// High privilege path.  		dynamicMethod = new System.Reflection.Emit.DynamicMethod (GetMethodName ()' // Name of the generated method.  		typeof(object)' // Return type of the generated method.  		GetParameterTypes ()' // Parameter types of the generated method.  		typeof(MethodGenerator)' // Owner type.  		true);  		// Skip visibility checks.  		// TODO: Figure out why long methods give BadImageFormatException in .NET 3.5 when generated using DynamicILInfo.  		if (Environment.Version.Major >= 4)  			generator = new DynamicILGenerator (dynamicMethod);  		else  			generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  	}  	else {  		#endif  		// Low privilege path.  		dynamicMethod = new System.Reflection.Emit.DynamicMethod (GetMethodName ()' // Name of the generated method.  		typeof(object)' // Return type of the generated method.  		GetParameterTypes ());  		// Parameter types of the generated method.  		generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  		#if !SILVERLIGHT  	}  	#endif  	if (this.Engine.EnableILAnalysis == true) {  		// Replace the generator with one that logs.  		generator = new LoggingILGenerator (generator);  	}  	// Generate the IL.  	GenerateCode (generator' optimizationInfo);  	generator.Complete ();  	// Create a delegate from the method.  	this.GeneratedMethod = new GeneratedMethod (dynamicMethod.CreateDelegate (GetDelegate ())' optimizationInfo.NestedFunctions);  }  else {  	#if WINDOWS_PHONE  	                throw new NotImplementedException(); #else  	// Debugging or low trust path.  	ScriptEngine.ReflectionEmitModuleInfo reflectionEmitInfo = this.Engine.ReflectionEmitInfo;  	if (reflectionEmitInfo == null) {  		reflectionEmitInfo = new ScriptEngine.ReflectionEmitModuleInfo ();  		// Create a dynamic assembly and module.  		reflectionEmitInfo.AssemblyBuilder = System.Threading.Thread.GetDomain ().DefineDynamicAssembly (new System.Reflection.AssemblyName ("Jurassic Dynamic Assembly")' System.Reflection.Emit.AssemblyBuilderAccess.Run);  		// Mark the assembly as debuggable.  This must be done before the module is created.  		var debuggableAttributeConstructor = typeof(System.Diagnostics.DebuggableAttribute).GetConstructor (new Type[] {  			typeof(System.Diagnostics.DebuggableAttribute.DebuggingModes)  		});  		reflectionEmitInfo.AssemblyBuilder.SetCustomAttribute (new System.Reflection.Emit.CustomAttributeBuilder (debuggableAttributeConstructor' new object[] {  			System.Diagnostics.DebuggableAttribute.DebuggingModes.DisableOptimizations | System.Diagnostics.DebuggableAttribute.DebuggingModes.Default  		}));  		// Create a dynamic module.  		reflectionEmitInfo.ModuleBuilder = reflectionEmitInfo.AssemblyBuilder.DefineDynamicModule ("Module"' this.Options.EnableDebugging);  		this.Engine.ReflectionEmitInfo = reflectionEmitInfo;  	}  	// Create a new type to hold our method.  	var typeBuilder = reflectionEmitInfo.ModuleBuilder.DefineType ("JavaScriptClass" + reflectionEmitInfo.TypeCount.ToString ()' System.Reflection.TypeAttributes.Public | System.Reflection.TypeAttributes.Class);  	reflectionEmitInfo.TypeCount++;  	// Create a method.  	var methodBuilder = typeBuilder.DefineMethod (this.GetMethodName ()' System.Reflection.MethodAttributes.HideBySig | System.Reflection.MethodAttributes.Static | System.Reflection.MethodAttributes.Public' typeof(object)' GetParameterTypes ());  	// Generate the IL for the method.  	generator = new ReflectionEmitILGenerator (methodBuilder.GetILGenerator ());  	if (this.Engine.EnableILAnalysis == true) {  		// Replace the generator with one that logs.  		generator = new LoggingILGenerator (generator);  	}  	if (this.Source.Path != null && this.Options.EnableDebugging == true) {  		// Initialize the debugging information.  		optimizationInfo.DebugDocument = reflectionEmitInfo.ModuleBuilder.DefineDocument (this.Source.Path' COMHelpers.LanguageType' COMHelpers.LanguageVendor' COMHelpers.DocumentType);  		methodBuilder.DefineParameter (1' System.Reflection.ParameterAttributes.None' "scriptEngine");  		methodBuilder.DefineParameter (2' System.Reflection.ParameterAttributes.None' "scope");  		methodBuilder.DefineParameter (3' System.Reflection.ParameterAttributes.None' "thisValue");  		generator.MarkSequencePoint (optimizationInfo.DebugDocument' new SourceCodeSpan (1' 1' 1' 1));  	}  	GenerateCode (generator' optimizationInfo);  	generator.Complete ();  	// Bake it.  	var type = typeBuilder.CreateType ();  	var methodInfo = type.GetMethod (this.GetMethodName ());  	this.GeneratedMethod = new GeneratedMethod (Delegate.CreateDelegate (GetDelegate ()' methodInfo)' optimizationInfo.NestedFunctions);  	#endif  }  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: if (ScriptEngine.LowPrivilegeEnvironment == false) {  	// High privilege path.  	dynamicMethod = new System.Reflection.Emit.DynamicMethod (GetMethodName ()' // Name of the generated method.  	typeof(object)' // Return type of the generated method.  	GetParameterTypes ()' // Parameter types of the generated method.  	typeof(MethodGenerator)' // Owner type.  	true);  	// Skip visibility checks.  	// TODO: Figure out why long methods give BadImageFormatException in .NET 3.5 when generated using DynamicILInfo.  	if (Environment.Version.Major >= 4)  		generator = new DynamicILGenerator (dynamicMethod);  	else  		generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  }  else {  	#endif  	// Low privilege path.  	dynamicMethod = new System.Reflection.Emit.DynamicMethod (GetMethodName ()' // Name of the generated method.  	typeof(object)' // Return type of the generated method.  	GetParameterTypes ());  	// Parameter types of the generated method.  	generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  	#if !SILVERLIGHT  }  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: if (Environment.Version.Major >= 4)  	generator = new DynamicILGenerator (dynamicMethod);  else  	generator = new ReflectionEmitILGenerator (dynamicMethod.GetILGenerator ());  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: if (this.Source.Path != null && this.Options.EnableDebugging == true) {  	// Initialize the debugging information.  	optimizationInfo.DebugDocument = reflectionEmitInfo.ModuleBuilder.DefineDocument (this.Source.Path' COMHelpers.LanguageType' COMHelpers.LanguageVendor' COMHelpers.DocumentType);  	methodBuilder.DefineParameter (1' System.Reflection.ParameterAttributes.None' "scriptEngine");  	methodBuilder.DefineParameter (2' System.Reflection.ParameterAttributes.None' "scope");  	methodBuilder.DefineParameter (3' System.Reflection.ParameterAttributes.None' "thisValue");  	generator.MarkSequencePoint (optimizationInfo.DebugDocument' new SourceCodeSpan (1' 1' 1' 1));  }  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: if (this.Source.Path != null && this.Options.EnableDebugging == true) {  	// Initialize the debugging information.  	optimizationInfo.DebugDocument = reflectionEmitInfo.ModuleBuilder.DefineDocument (this.Source.Path' COMHelpers.LanguageType' COMHelpers.LanguageVendor' COMHelpers.DocumentType);  	methodBuilder.DefineParameter (1' System.Reflection.ParameterAttributes.None' "scriptEngine");  	methodBuilder.DefineParameter (2' System.Reflection.ParameterAttributes.None' "scope");  	methodBuilder.DefineParameter (3' System.Reflection.ParameterAttributes.None' "thisValue");  	generator.MarkSequencePoint (optimizationInfo.DebugDocument' new SourceCodeSpan (1' 1' 1' 1));  }  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: methodBuilder.DefineParameter (2' System.Reflection.ParameterAttributes.None' "scope");  
Magic Number,Jurassic.Compiler,MethodGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\MethodGenerator\MethodGenerator.cs,GenerateCode,The following statement contains a magic number: methodBuilder.DefineParameter (3' System.Reflection.ParameterAttributes.None' "thisValue");  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadArgument,The following statement contains a magic number: switch (argumentIndex) {  case 0:  	this.generator.Emit (OpCodes.Ldarg_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldarg_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldarg_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldarg_3);  	break;  default:  	if (argumentIndex < 256)  		this.generator.Emit (OpCodes.Ldarg_S' (byte)argumentIndex);  	else  		this.generator.Emit (OpCodes.Ldarg' (short)argumentIndex);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadArgument,The following statement contains a magic number: switch (argumentIndex) {  case 0:  	this.generator.Emit (OpCodes.Ldarg_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldarg_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldarg_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldarg_3);  	break;  default:  	if (argumentIndex < 256)  		this.generator.Emit (OpCodes.Ldarg_S' (byte)argumentIndex);  	else  		this.generator.Emit (OpCodes.Ldarg' (short)argumentIndex);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadArgument,The following statement contains a magic number: switch (argumentIndex) {  case 0:  	this.generator.Emit (OpCodes.Ldarg_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldarg_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldarg_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldarg_3);  	break;  default:  	if (argumentIndex < 256)  		this.generator.Emit (OpCodes.Ldarg_S' (byte)argumentIndex);  	else  		this.generator.Emit (OpCodes.Ldarg' (short)argumentIndex);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadArgument,The following statement contains a magic number: if (argumentIndex < 256)  	this.generator.Emit (OpCodes.Ldarg_S' (byte)argumentIndex);  else  	this.generator.Emit (OpCodes.Ldarg' (short)argumentIndex);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,StoreArgument,The following statement contains a magic number: if (argumentIndex < 256)  	this.generator.Emit (OpCodes.Starg_S' (byte)argumentIndex);  else  	this.generator.Emit (OpCodes.Starg' (short)argumentIndex);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	switch (value) {  	case -1:  		this.generator.Emit (OpCodes.Ldc_I4_M1);  		break;  	case 0:  		this.generator.Emit (OpCodes.Ldc_I4_0);  		break;  	case 1:  		this.generator.Emit (OpCodes.Ldc_I4_1);  		break;  	case 2:  		this.generator.Emit (OpCodes.Ldc_I4_2);  		break;  	case 3:  		this.generator.Emit (OpCodes.Ldc_I4_3);  		break;  	case 4:  		this.generator.Emit (OpCodes.Ldc_I4_4);  		break;  	case 5:  		this.generator.Emit (OpCodes.Ldc_I4_5);  		break;  	case 6:  		this.generator.Emit (OpCodes.Ldc_I4_6);  		break;  	case 7:  		this.generator.Emit (OpCodes.Ldc_I4_7);  		break;  	case 8:  		this.generator.Emit (OpCodes.Ldc_I4_8);  		break;  	}  }  else if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: switch (value) {  case -1:  	this.generator.Emit (OpCodes.Ldc_I4_M1);  	break;  case 0:  	this.generator.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	this.generator.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	this.generator.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	this.generator.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	this.generator.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	this.generator.Emit (OpCodes.Ldc_I4_8);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: switch (value) {  case -1:  	this.generator.Emit (OpCodes.Ldc_I4_M1);  	break;  case 0:  	this.generator.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	this.generator.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	this.generator.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	this.generator.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	this.generator.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	this.generator.Emit (OpCodes.Ldc_I4_8);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: switch (value) {  case -1:  	this.generator.Emit (OpCodes.Ldc_I4_M1);  	break;  case 0:  	this.generator.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	this.generator.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	this.generator.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	this.generator.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	this.generator.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	this.generator.Emit (OpCodes.Ldc_I4_8);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: switch (value) {  case -1:  	this.generator.Emit (OpCodes.Ldc_I4_M1);  	break;  case 0:  	this.generator.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	this.generator.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	this.generator.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	this.generator.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	this.generator.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	this.generator.Emit (OpCodes.Ldc_I4_8);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: switch (value) {  case -1:  	this.generator.Emit (OpCodes.Ldc_I4_M1);  	break;  case 0:  	this.generator.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	this.generator.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	this.generator.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	this.generator.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	this.generator.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	this.generator.Emit (OpCodes.Ldc_I4_8);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: switch (value) {  case -1:  	this.generator.Emit (OpCodes.Ldc_I4_M1);  	break;  case 0:  	this.generator.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	this.generator.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	this.generator.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	this.generator.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	this.generator.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	this.generator.Emit (OpCodes.Ldc_I4_8);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: switch (value) {  case -1:  	this.generator.Emit (OpCodes.Ldc_I4_M1);  	break;  case 0:  	this.generator.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	this.generator.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	this.generator.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	this.generator.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	this.generator.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	this.generator.Emit (OpCodes.Ldc_I4_8);  	break;  }  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -128 && value < 128)  	this.generator.Emit (OpCodes.Ldc_I4_S' (byte)value);  else  	this.generator.Emit (OpCodes.Ldc_I4' value);  
Magic Number,Jurassic.Compiler,EmitHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitHelpers.cs,LoadThis,The following statement contains a magic number: generator.LoadArgument (2);  
Magic Number,Jurassic.Compiler,EmitHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitHelpers.cs,StoreThis,The following statement contains a magic number: generator.StoreArgument (2);  
Magic Number,Jurassic.Compiler,EmitHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitHelpers.cs,LoadFunction,The following statement contains a magic number: generator.LoadArgument (3);  
Magic Number,Jurassic.Compiler,EmitHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitHelpers.cs,LoadArgumentsArray,The following statement contains a magic number: generator.LoadArgument (4);  
Magic Number,Jurassic.Compiler,DeclarativeScope,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Scope\DeclarativeScope.cs,DeclareVariable,The following statement contains a magic number: if (this.values != null && this.DeclaredVariableCount >= this.Values.Length)  	Array.Resize (ref this.values' this.DeclaredVariableCount + 10);  
Magic Number,Jurassic.Compiler,DeclarativeScope,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Scope\DeclarativeScope.cs,DeclareVariable,The following statement contains a magic number: Array.Resize (ref this.values' this.DeclaredVariableCount + 10);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,DynamicILGenerator,The following statement contains a magic number: this.bytes = new byte[100];  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: if (this.exceptionRegions != null && this.exceptionRegions.Count > 0) {  	// Count the number of exception clauses.  	int clauseCount = 0;  	foreach (var exceptionRegion in this.exceptionRegions)  		clauseCount += exceptionRegion.Clauses.Count;  	var exceptionBytes = new byte[4 + 24 * clauseCount];  	var writer = new System.IO.BinaryWriter (new System.IO.MemoryStream (exceptionBytes));  	// 4-byte header' see Partition II' section 25.4.5.  	writer.Write ((byte)0x41);  	// Flags: CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat  	writer.Write (exceptionBytes.Length);  	// 3-byte data size.  	writer.Flush ();  	writer.BaseStream.Seek (4' System.IO.SeekOrigin.Begin);  	// Exception clauses' see Partition II' section 25.4.6.  	foreach (var exceptionRegion in this.exceptionRegions) {  		foreach (var clause in exceptionRegion.Clauses) {  			switch (clause.Type) {  			case ExceptionClauseType.Catch:  				writer.Write (0);  				// Flags  				break;  			case ExceptionClauseType.Filter:  				writer.Write (1);  				// Flags  				break;  			case ExceptionClauseType.Finally:  				writer.Write (2);  				// Flags  				break;  			case ExceptionClauseType.Fault:  				writer.Write (4);  				// Flags  				break;  			}  			writer.Write (exceptionRegion.Start);  			// TryOffset  			writer.Write (clause.ILStart - exceptionRegion.Start);  			// TryLength  			writer.Write (clause.ILStart);  			// HandlerOffset  			writer.Write (clause.ILLength);  			// HandlerLength  			if (clause.Type == ExceptionClauseType.Catch)  				writer.Write (clause.CatchToken);  			// ClassToken  			else if (clause.Type == ExceptionClauseType.Filter)  				writer.Write (clause.FilterHandlerStart);  			// FilterOffset  			else  				writer.Write (0);  		}  	}  	writer.Flush ();  	this.dynamicILInfo.SetExceptions (exceptionBytes);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: if (this.exceptionRegions != null && this.exceptionRegions.Count > 0) {  	// Count the number of exception clauses.  	int clauseCount = 0;  	foreach (var exceptionRegion in this.exceptionRegions)  		clauseCount += exceptionRegion.Clauses.Count;  	var exceptionBytes = new byte[4 + 24 * clauseCount];  	var writer = new System.IO.BinaryWriter (new System.IO.MemoryStream (exceptionBytes));  	// 4-byte header' see Partition II' section 25.4.5.  	writer.Write ((byte)0x41);  	// Flags: CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat  	writer.Write (exceptionBytes.Length);  	// 3-byte data size.  	writer.Flush ();  	writer.BaseStream.Seek (4' System.IO.SeekOrigin.Begin);  	// Exception clauses' see Partition II' section 25.4.6.  	foreach (var exceptionRegion in this.exceptionRegions) {  		foreach (var clause in exceptionRegion.Clauses) {  			switch (clause.Type) {  			case ExceptionClauseType.Catch:  				writer.Write (0);  				// Flags  				break;  			case ExceptionClauseType.Filter:  				writer.Write (1);  				// Flags  				break;  			case ExceptionClauseType.Finally:  				writer.Write (2);  				// Flags  				break;  			case ExceptionClauseType.Fault:  				writer.Write (4);  				// Flags  				break;  			}  			writer.Write (exceptionRegion.Start);  			// TryOffset  			writer.Write (clause.ILStart - exceptionRegion.Start);  			// TryLength  			writer.Write (clause.ILStart);  			// HandlerOffset  			writer.Write (clause.ILLength);  			// HandlerLength  			if (clause.Type == ExceptionClauseType.Catch)  				writer.Write (clause.CatchToken);  			// ClassToken  			else if (clause.Type == ExceptionClauseType.Filter)  				writer.Write (clause.FilterHandlerStart);  			// FilterOffset  			else  				writer.Write (0);  		}  	}  	writer.Flush ();  	this.dynamicILInfo.SetExceptions (exceptionBytes);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: if (this.exceptionRegions != null && this.exceptionRegions.Count > 0) {  	// Count the number of exception clauses.  	int clauseCount = 0;  	foreach (var exceptionRegion in this.exceptionRegions)  		clauseCount += exceptionRegion.Clauses.Count;  	var exceptionBytes = new byte[4 + 24 * clauseCount];  	var writer = new System.IO.BinaryWriter (new System.IO.MemoryStream (exceptionBytes));  	// 4-byte header' see Partition II' section 25.4.5.  	writer.Write ((byte)0x41);  	// Flags: CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat  	writer.Write (exceptionBytes.Length);  	// 3-byte data size.  	writer.Flush ();  	writer.BaseStream.Seek (4' System.IO.SeekOrigin.Begin);  	// Exception clauses' see Partition II' section 25.4.6.  	foreach (var exceptionRegion in this.exceptionRegions) {  		foreach (var clause in exceptionRegion.Clauses) {  			switch (clause.Type) {  			case ExceptionClauseType.Catch:  				writer.Write (0);  				// Flags  				break;  			case ExceptionClauseType.Filter:  				writer.Write (1);  				// Flags  				break;  			case ExceptionClauseType.Finally:  				writer.Write (2);  				// Flags  				break;  			case ExceptionClauseType.Fault:  				writer.Write (4);  				// Flags  				break;  			}  			writer.Write (exceptionRegion.Start);  			// TryOffset  			writer.Write (clause.ILStart - exceptionRegion.Start);  			// TryLength  			writer.Write (clause.ILStart);  			// HandlerOffset  			writer.Write (clause.ILLength);  			// HandlerLength  			if (clause.Type == ExceptionClauseType.Catch)  				writer.Write (clause.CatchToken);  			// ClassToken  			else if (clause.Type == ExceptionClauseType.Filter)  				writer.Write (clause.FilterHandlerStart);  			// FilterOffset  			else  				writer.Write (0);  		}  	}  	writer.Flush ();  	this.dynamicILInfo.SetExceptions (exceptionBytes);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: if (this.exceptionRegions != null && this.exceptionRegions.Count > 0) {  	// Count the number of exception clauses.  	int clauseCount = 0;  	foreach (var exceptionRegion in this.exceptionRegions)  		clauseCount += exceptionRegion.Clauses.Count;  	var exceptionBytes = new byte[4 + 24 * clauseCount];  	var writer = new System.IO.BinaryWriter (new System.IO.MemoryStream (exceptionBytes));  	// 4-byte header' see Partition II' section 25.4.5.  	writer.Write ((byte)0x41);  	// Flags: CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat  	writer.Write (exceptionBytes.Length);  	// 3-byte data size.  	writer.Flush ();  	writer.BaseStream.Seek (4' System.IO.SeekOrigin.Begin);  	// Exception clauses' see Partition II' section 25.4.6.  	foreach (var exceptionRegion in this.exceptionRegions) {  		foreach (var clause in exceptionRegion.Clauses) {  			switch (clause.Type) {  			case ExceptionClauseType.Catch:  				writer.Write (0);  				// Flags  				break;  			case ExceptionClauseType.Filter:  				writer.Write (1);  				// Flags  				break;  			case ExceptionClauseType.Finally:  				writer.Write (2);  				// Flags  				break;  			case ExceptionClauseType.Fault:  				writer.Write (4);  				// Flags  				break;  			}  			writer.Write (exceptionRegion.Start);  			// TryOffset  			writer.Write (clause.ILStart - exceptionRegion.Start);  			// TryLength  			writer.Write (clause.ILStart);  			// HandlerOffset  			writer.Write (clause.ILLength);  			// HandlerLength  			if (clause.Type == ExceptionClauseType.Catch)  				writer.Write (clause.CatchToken);  			// ClassToken  			else if (clause.Type == ExceptionClauseType.Filter)  				writer.Write (clause.FilterHandlerStart);  			// FilterOffset  			else  				writer.Write (0);  		}  	}  	writer.Flush ();  	this.dynamicILInfo.SetExceptions (exceptionBytes);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: if (this.exceptionRegions != null && this.exceptionRegions.Count > 0) {  	// Count the number of exception clauses.  	int clauseCount = 0;  	foreach (var exceptionRegion in this.exceptionRegions)  		clauseCount += exceptionRegion.Clauses.Count;  	var exceptionBytes = new byte[4 + 24 * clauseCount];  	var writer = new System.IO.BinaryWriter (new System.IO.MemoryStream (exceptionBytes));  	// 4-byte header' see Partition II' section 25.4.5.  	writer.Write ((byte)0x41);  	// Flags: CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat  	writer.Write (exceptionBytes.Length);  	// 3-byte data size.  	writer.Flush ();  	writer.BaseStream.Seek (4' System.IO.SeekOrigin.Begin);  	// Exception clauses' see Partition II' section 25.4.6.  	foreach (var exceptionRegion in this.exceptionRegions) {  		foreach (var clause in exceptionRegion.Clauses) {  			switch (clause.Type) {  			case ExceptionClauseType.Catch:  				writer.Write (0);  				// Flags  				break;  			case ExceptionClauseType.Filter:  				writer.Write (1);  				// Flags  				break;  			case ExceptionClauseType.Finally:  				writer.Write (2);  				// Flags  				break;  			case ExceptionClauseType.Fault:  				writer.Write (4);  				// Flags  				break;  			}  			writer.Write (exceptionRegion.Start);  			// TryOffset  			writer.Write (clause.ILStart - exceptionRegion.Start);  			// TryLength  			writer.Write (clause.ILStart);  			// HandlerOffset  			writer.Write (clause.ILLength);  			// HandlerLength  			if (clause.Type == ExceptionClauseType.Catch)  				writer.Write (clause.CatchToken);  			// ClassToken  			else if (clause.Type == ExceptionClauseType.Filter)  				writer.Write (clause.FilterHandlerStart);  			// FilterOffset  			else  				writer.Write (0);  		}  	}  	writer.Flush ();  	this.dynamicILInfo.SetExceptions (exceptionBytes);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: writer.BaseStream.Seek (4' System.IO.SeekOrigin.Begin);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: foreach (var exceptionRegion in this.exceptionRegions) {  	foreach (var clause in exceptionRegion.Clauses) {  		switch (clause.Type) {  		case ExceptionClauseType.Catch:  			writer.Write (0);  			// Flags  			break;  		case ExceptionClauseType.Filter:  			writer.Write (1);  			// Flags  			break;  		case ExceptionClauseType.Finally:  			writer.Write (2);  			// Flags  			break;  		case ExceptionClauseType.Fault:  			writer.Write (4);  			// Flags  			break;  		}  		writer.Write (exceptionRegion.Start);  		// TryOffset  		writer.Write (clause.ILStart - exceptionRegion.Start);  		// TryLength  		writer.Write (clause.ILStart);  		// HandlerOffset  		writer.Write (clause.ILLength);  		// HandlerLength  		if (clause.Type == ExceptionClauseType.Catch)  			writer.Write (clause.CatchToken);  		// ClassToken  		else if (clause.Type == ExceptionClauseType.Filter)  			writer.Write (clause.FilterHandlerStart);  		// FilterOffset  		else  			writer.Write (0);  	}  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: foreach (var exceptionRegion in this.exceptionRegions) {  	foreach (var clause in exceptionRegion.Clauses) {  		switch (clause.Type) {  		case ExceptionClauseType.Catch:  			writer.Write (0);  			// Flags  			break;  		case ExceptionClauseType.Filter:  			writer.Write (1);  			// Flags  			break;  		case ExceptionClauseType.Finally:  			writer.Write (2);  			// Flags  			break;  		case ExceptionClauseType.Fault:  			writer.Write (4);  			// Flags  			break;  		}  		writer.Write (exceptionRegion.Start);  		// TryOffset  		writer.Write (clause.ILStart - exceptionRegion.Start);  		// TryLength  		writer.Write (clause.ILStart);  		// HandlerOffset  		writer.Write (clause.ILLength);  		// HandlerLength  		if (clause.Type == ExceptionClauseType.Catch)  			writer.Write (clause.CatchToken);  		// ClassToken  		else if (clause.Type == ExceptionClauseType.Filter)  			writer.Write (clause.FilterHandlerStart);  		// FilterOffset  		else  			writer.Write (0);  	}  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: foreach (var clause in exceptionRegion.Clauses) {  	switch (clause.Type) {  	case ExceptionClauseType.Catch:  		writer.Write (0);  		// Flags  		break;  	case ExceptionClauseType.Filter:  		writer.Write (1);  		// Flags  		break;  	case ExceptionClauseType.Finally:  		writer.Write (2);  		// Flags  		break;  	case ExceptionClauseType.Fault:  		writer.Write (4);  		// Flags  		break;  	}  	writer.Write (exceptionRegion.Start);  	// TryOffset  	writer.Write (clause.ILStart - exceptionRegion.Start);  	// TryLength  	writer.Write (clause.ILStart);  	// HandlerOffset  	writer.Write (clause.ILLength);  	// HandlerLength  	if (clause.Type == ExceptionClauseType.Catch)  		writer.Write (clause.CatchToken);  	// ClassToken  	else if (clause.Type == ExceptionClauseType.Filter)  		writer.Write (clause.FilterHandlerStart);  	// FilterOffset  	else  		writer.Write (0);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: foreach (var clause in exceptionRegion.Clauses) {  	switch (clause.Type) {  	case ExceptionClauseType.Catch:  		writer.Write (0);  		// Flags  		break;  	case ExceptionClauseType.Filter:  		writer.Write (1);  		// Flags  		break;  	case ExceptionClauseType.Finally:  		writer.Write (2);  		// Flags  		break;  	case ExceptionClauseType.Fault:  		writer.Write (4);  		// Flags  		break;  	}  	writer.Write (exceptionRegion.Start);  	// TryOffset  	writer.Write (clause.ILStart - exceptionRegion.Start);  	// TryLength  	writer.Write (clause.ILStart);  	// HandlerOffset  	writer.Write (clause.ILLength);  	// HandlerLength  	if (clause.Type == ExceptionClauseType.Catch)  		writer.Write (clause.CatchToken);  	// ClassToken  	else if (clause.Type == ExceptionClauseType.Filter)  		writer.Write (clause.FilterHandlerStart);  	// FilterOffset  	else  		writer.Write (0);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: switch (clause.Type) {  case ExceptionClauseType.Catch:  	writer.Write (0);  	// Flags  	break;  case ExceptionClauseType.Filter:  	writer.Write (1);  	// Flags  	break;  case ExceptionClauseType.Finally:  	writer.Write (2);  	// Flags  	break;  case ExceptionClauseType.Fault:  	writer.Write (4);  	// Flags  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: switch (clause.Type) {  case ExceptionClauseType.Catch:  	writer.Write (0);  	// Flags  	break;  case ExceptionClauseType.Filter:  	writer.Write (1);  	// Flags  	break;  case ExceptionClauseType.Finally:  	writer.Write (2);  	// Flags  	break;  case ExceptionClauseType.Fault:  	writer.Write (4);  	// Flags  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: writer.Write (2);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following statement contains a magic number: writer.Write (4);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EnlargeArray,The following statement contains a magic number: Array.Resize (ref this.bytes' this.bytes.Length * 2);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt16,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 8);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt32,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 8);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt32,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 16);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt32,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 24);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt64,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 8);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt64,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 16);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt64,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 24);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt64,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 32);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt64,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 40);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt64,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 48);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitInt64,The following statement contains a magic number: this.bytes [offset++] = (byte)(value >> 56);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Duplicate,The following statement contains a magic number: Emit1ByteOpCode (0x25' 1' 2);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,FixLabels,The following statement contains a magic number: foreach (var fix in this.fixups) {  	// Get the IL offset of the label.  	int jumpOffset = fix.Label.ILOffset;  	if (jumpOffset < 0)  		throw new InvalidOperationException ("Undefined label.");  	// Jump offsets are relative to the next instruction.  	jumpOffset -= fix.StartOfNextInstruction;  	// Patch the jump offset;  	var position = fix.Position;  	if (fix.Length != 4)  		throw new NotImplementedException ("Short jumps are not supported.");  	this.bytes [position++] = (byte)jumpOffset;  	this.bytes [position++] = (byte)(jumpOffset >> 8);  	this.bytes [position++] = (byte)(jumpOffset >> 16);  	this.bytes [position++] = (byte)(jumpOffset >> 24);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,FixLabels,The following statement contains a magic number: foreach (var fix in this.fixups) {  	// Get the IL offset of the label.  	int jumpOffset = fix.Label.ILOffset;  	if (jumpOffset < 0)  		throw new InvalidOperationException ("Undefined label.");  	// Jump offsets are relative to the next instruction.  	jumpOffset -= fix.StartOfNextInstruction;  	// Patch the jump offset;  	var position = fix.Position;  	if (fix.Length != 4)  		throw new NotImplementedException ("Short jumps are not supported.");  	this.bytes [position++] = (byte)jumpOffset;  	this.bytes [position++] = (byte)(jumpOffset >> 8);  	this.bytes [position++] = (byte)(jumpOffset >> 16);  	this.bytes [position++] = (byte)(jumpOffset >> 24);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,FixLabels,The following statement contains a magic number: foreach (var fix in this.fixups) {  	// Get the IL offset of the label.  	int jumpOffset = fix.Label.ILOffset;  	if (jumpOffset < 0)  		throw new InvalidOperationException ("Undefined label.");  	// Jump offsets are relative to the next instruction.  	jumpOffset -= fix.StartOfNextInstruction;  	// Patch the jump offset;  	var position = fix.Position;  	if (fix.Length != 4)  		throw new NotImplementedException ("Short jumps are not supported.");  	this.bytes [position++] = (byte)jumpOffset;  	this.bytes [position++] = (byte)(jumpOffset >> 8);  	this.bytes [position++] = (byte)(jumpOffset >> 16);  	this.bytes [position++] = (byte)(jumpOffset >> 24);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,FixLabels,The following statement contains a magic number: foreach (var fix in this.fixups) {  	// Get the IL offset of the label.  	int jumpOffset = fix.Label.ILOffset;  	if (jumpOffset < 0)  		throw new InvalidOperationException ("Undefined label.");  	// Jump offsets are relative to the next instruction.  	jumpOffset -= fix.StartOfNextInstruction;  	// Patch the jump offset;  	var position = fix.Position;  	if (fix.Length != 4)  		throw new NotImplementedException ("Short jumps are not supported.");  	this.bytes [position++] = (byte)jumpOffset;  	this.bytes [position++] = (byte)(jumpOffset >> 8);  	this.bytes [position++] = (byte)(jumpOffset >> 16);  	this.bytes [position++] = (byte)(jumpOffset >> 24);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,FixLabels,The following statement contains a magic number: if (fix.Length != 4)  	throw new NotImplementedException ("Short jumps are not supported.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,FixLabels,The following statement contains a magic number: this.bytes [position++] = (byte)(jumpOffset >> 8);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,FixLabels,The following statement contains a magic number: this.bytes [position++] = (byte)(jumpOffset >> 16);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,FixLabels,The following statement contains a magic number: this.bytes [position++] = (byte)(jumpOffset >> 24);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BranchCore,The following statement contains a magic number: EmitLabel (label' this.offset + 4);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BranchCore,The following statement contains a magic number: EmitLabel (label' this.offset + 4);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BranchCore,The following statement contains a magic number: Emit1ByteOpCode (opCode' 2' 0);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BranchCore,The following statement contains a magic number: EmitLabel (label' this.offset + 4);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The following statement contains a magic number: if (this.offset + 4 >= this.bytes.Length)  	EnlargeArray (4);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The following statement contains a magic number: if (this.offset + 4 >= this.bytes.Length)  	EnlargeArray (4);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The following statement contains a magic number: EnlargeArray (4);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The following statement contains a magic number: if (label2.ILOffset >= 0) {  	// The label is defined.  	EmitInt32 (label2.ILOffset - startOfNextInstruction);  }  else {  	// The label is not defined.  Add a fix up.  	EmitInt32 (0);  	this.fixups.Add (new Fixup () {  		Position = this.offset - 4'  		Length = 4'  		StartOfNextInstruction = startOfNextInstruction'  		Label = label2  	});  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The following statement contains a magic number: if (label2.ILOffset >= 0) {  	// The label is defined.  	EmitInt32 (label2.ILOffset - startOfNextInstruction);  }  else {  	// The label is not defined.  Add a fix up.  	EmitInt32 (0);  	this.fixups.Add (new Fixup () {  		Position = this.offset - 4'  		Length = 4'  		StartOfNextInstruction = startOfNextInstruction'  		Label = label2  	});  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The following statement contains a magic number: this.fixups.Add (new Fixup () {  	Position = this.offset - 4'  	Length = 4'  	StartOfNextInstruction = startOfNextInstruction'  	Label = label2  });  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EmitLabel,The following statement contains a magic number: this.fixups.Add (new Fixup () {  	Position = this.offset - 4'  	Length = 4'  	StartOfNextInstruction = startOfNextInstruction'  	Label = label2  });  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadVariable,The following statement contains a magic number: if (variable.Index <= 3) {  	// ldloc.0 = 06  	// ldloc.1 = 07  	// ldloc.2 = 08  	// ldloc.3 = 09  	Emit1ByteOpCode ((byte)(0x06 + variable.Index)' 0' 1);  }  else if (variable.Index < 256) {  	// ldloc.s index = 11 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x11' 0' 1' variable.Index);  }  else if (variable.Index < 65535) {  	// ldloc index = FE 0C <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0C' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadVariable,The following statement contains a magic number: if (variable.Index <= 3) {  	// ldloc.0 = 06  	// ldloc.1 = 07  	// ldloc.2 = 08  	// ldloc.3 = 09  	Emit1ByteOpCode ((byte)(0x06 + variable.Index)' 0' 1);  }  else if (variable.Index < 256) {  	// ldloc.s index = 11 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x11' 0' 1' variable.Index);  }  else if (variable.Index < 65535) {  	// ldloc index = FE 0C <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0C' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadVariable,The following statement contains a magic number: if (variable.Index <= 3) {  	// ldloc.0 = 06  	// ldloc.1 = 07  	// ldloc.2 = 08  	// ldloc.3 = 09  	Emit1ByteOpCode ((byte)(0x06 + variable.Index)' 0' 1);  }  else if (variable.Index < 256) {  	// ldloc.s index = 11 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x11' 0' 1' variable.Index);  }  else if (variable.Index < 65535) {  	// ldloc index = FE 0C <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0C' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadVariable,The following statement contains a magic number: if (variable.Index < 256) {  	// ldloc.s index = 11 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x11' 0' 1' variable.Index);  }  else if (variable.Index < 65535) {  	// ldloc index = FE 0C <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0C' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadVariable,The following statement contains a magic number: if (variable.Index < 256) {  	// ldloc.s index = 11 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x11' 0' 1' variable.Index);  }  else if (variable.Index < 65535) {  	// ldloc index = FE 0C <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0C' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadVariable,The following statement contains a magic number: if (variable.Index < 65535) {  	// ldloc index = FE 0C <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0C' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadAddressOfVariable,The following statement contains a magic number: if (variable.Index < 256) {  	// ldloca.s index = 12 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x12' 0' 1' variable.Index);  }  else if (variable.Index < 65535) {  	// ldloca index = FE 0D <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0D' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadAddressOfVariable,The following statement contains a magic number: if (variable.Index < 256) {  	// ldloca.s index = 12 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x12' 0' 1' variable.Index);  }  else if (variable.Index < 65535) {  	// ldloca index = FE 0D <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0D' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadAddressOfVariable,The following statement contains a magic number: if (variable.Index < 65535) {  	// ldloca index = FE 0D <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0D' 0' 1' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreVariable,The following statement contains a magic number: if (variable.Index <= 3) {  	// stloc.0 = 0A  	// stloc.1 = 0B  	// stloc.2 = 0C  	// stloc.3 = 0D  	Emit1ByteOpCode ((byte)(0x0A + variable.Index)' 1' 0);  }  else if (variable.Index < 256) {  	// stloc.s index = 13 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x13' 1' 0' variable.Index);  }  else if (variable.Index < 65535) {  	// stloc index = FE 0E <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0E' 1' 0' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreVariable,The following statement contains a magic number: if (variable.Index <= 3) {  	// stloc.0 = 0A  	// stloc.1 = 0B  	// stloc.2 = 0C  	// stloc.3 = 0D  	Emit1ByteOpCode ((byte)(0x0A + variable.Index)' 1' 0);  }  else if (variable.Index < 256) {  	// stloc.s index = 13 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x13' 1' 0' variable.Index);  }  else if (variable.Index < 65535) {  	// stloc index = FE 0E <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0E' 1' 0' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreVariable,The following statement contains a magic number: if (variable.Index <= 3) {  	// stloc.0 = 0A  	// stloc.1 = 0B  	// stloc.2 = 0C  	// stloc.3 = 0D  	Emit1ByteOpCode ((byte)(0x0A + variable.Index)' 1' 0);  }  else if (variable.Index < 256) {  	// stloc.s index = 13 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x13' 1' 0' variable.Index);  }  else if (variable.Index < 65535) {  	// stloc index = FE 0E <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0E' 1' 0' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreVariable,The following statement contains a magic number: if (variable.Index < 256) {  	// stloc.s index = 13 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x13' 1' 0' variable.Index);  }  else if (variable.Index < 65535) {  	// stloc index = FE 0E <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0E' 1' 0' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreVariable,The following statement contains a magic number: if (variable.Index < 256) {  	// stloc.s index = 13 <unsigned int8>  	Emit1ByteOpCodeInt8 (0x13' 1' 0' variable.Index);  }  else if (variable.Index < 65535) {  	// stloc index = FE 0E <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0E' 1' 0' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreVariable,The following statement contains a magic number: if (variable.Index < 65535) {  	// stloc index = FE 0E <unsigned int16>  	Emit2ByteOpCodeInt16 (0xFE' 0x0E' 1' 0' variable.Index);  }  else  	throw new InvalidOperationException ("Too many local variables.");  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArgument,The following statement contains a magic number: if (argumentIndex < 4)  	Emit1ByteOpCode ((byte)(argumentIndex + 2)' 0' 1);  else if (argumentIndex < 256)  	Emit1ByteOpCodeInt8 (0x0E' 0' 1' argumentIndex);  else  	Emit2ByteOpCodeInt16 (0xFE' 0x09' 0' 1' argumentIndex);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArgument,The following statement contains a magic number: if (argumentIndex < 4)  	Emit1ByteOpCode ((byte)(argumentIndex + 2)' 0' 1);  else if (argumentIndex < 256)  	Emit1ByteOpCodeInt8 (0x0E' 0' 1' argumentIndex);  else  	Emit2ByteOpCodeInt16 (0xFE' 0x09' 0' 1' argumentIndex);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArgument,The following statement contains a magic number: if (argumentIndex < 4)  	Emit1ByteOpCode ((byte)(argumentIndex + 2)' 0' 1);  else if (argumentIndex < 256)  	Emit1ByteOpCodeInt8 (0x0E' 0' 1' argumentIndex);  else  	Emit2ByteOpCodeInt16 (0xFE' 0x09' 0' 1' argumentIndex);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArgument,The following statement contains a magic number: Emit1ByteOpCode ((byte)(argumentIndex + 2)' 0' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArgument,The following statement contains a magic number: if (argumentIndex < 256)  	Emit1ByteOpCodeInt8 (0x0E' 0' 1' argumentIndex);  else  	Emit2ByteOpCodeInt16 (0xFE' 0x09' 0' 1' argumentIndex);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArgument,The following statement contains a magic number: if (argumentIndex < 256)  	Emit1ByteOpCodeInt8 (0x10' 1' 0' argumentIndex);  else  	Emit2ByteOpCodeInt16 (0xFE' 0x0B' 1' 0' argumentIndex);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	// ldc.i4.m1 = 15  	// ldc.i4.0 = 16  	// ldc.i4.1 = 17  	// ldc.i4.2 = 18  	// ldc.i4.3 = 19  	// ldc.i4.4 = 1A  	// ldc.i4.5 = 1B  	// ldc.i4.6 = 1C  	// ldc.i4.7 = 1D  	// ldc.i4.8 = 1E  	Emit1ByteOpCode ((byte)(0x16 + value)' 0' 1);  }  else if (value >= -128 && value <= 127) {  	// ldc.i4.s value = 1F <unsigned int8>  	Emit1ByteOpCodeInt8 (0x1F' 0' 1' value);  }  else {  	// ldc.i4 value = 20 <int32>  	Emit1ByteOpCodeInt32 (0x20' 0' 1' value);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	// ldc.i4.m1 = 15  	// ldc.i4.0 = 16  	// ldc.i4.1 = 17  	// ldc.i4.2 = 18  	// ldc.i4.3 = 19  	// ldc.i4.4 = 1A  	// ldc.i4.5 = 1B  	// ldc.i4.6 = 1C  	// ldc.i4.7 = 1D  	// ldc.i4.8 = 1E  	Emit1ByteOpCode ((byte)(0x16 + value)' 0' 1);  }  else if (value >= -128 && value <= 127) {  	// ldc.i4.s value = 1F <unsigned int8>  	Emit1ByteOpCodeInt8 (0x1F' 0' 1' value);  }  else {  	// ldc.i4 value = 20 <int32>  	Emit1ByteOpCodeInt32 (0x20' 0' 1' value);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -1 && value <= 8) {  	// ldc.i4.m1 = 15  	// ldc.i4.0 = 16  	// ldc.i4.1 = 17  	// ldc.i4.2 = 18  	// ldc.i4.3 = 19  	// ldc.i4.4 = 1A  	// ldc.i4.5 = 1B  	// ldc.i4.6 = 1C  	// ldc.i4.7 = 1D  	// ldc.i4.8 = 1E  	Emit1ByteOpCode ((byte)(0x16 + value)' 0' 1);  }  else if (value >= -128 && value <= 127) {  	// ldc.i4.s value = 1F <unsigned int8>  	Emit1ByteOpCodeInt8 (0x1F' 0' 1' value);  }  else {  	// ldc.i4 value = 20 <int32>  	Emit1ByteOpCodeInt32 (0x20' 0' 1' value);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -128 && value <= 127) {  	// ldc.i4.s value = 1F <unsigned int8>  	Emit1ByteOpCodeInt8 (0x1F' 0' 1' value);  }  else {  	// ldc.i4 value = 20 <int32>  	Emit1ByteOpCodeInt32 (0x20' 0' 1' value);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadInt32,The following statement contains a magic number: if (value >= -128 && value <= 127) {  	// ldc.i4.s value = 1F <unsigned int8>  	Emit1ByteOpCodeInt8 (0x1F' 0' 1' value);  }  else {  	// ldc.i4 value = 20 <int32>  	Emit1ByteOpCodeInt32 (0x20' 0' 1' value);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CompareEqual,The following statement contains a magic number: Emit2ByteOpCode (0xFE' 0x01' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CompareGreaterThan,The following statement contains a magic number: Emit2ByteOpCode (0xFE' 0x02' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CompareGreaterThanUnsigned,The following statement contains a magic number: Emit2ByteOpCode (0xFE' 0x03' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CompareLessThan,The following statement contains a magic number: Emit2ByteOpCode (0xFE' 0x04' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CompareLessThanUnsigned,The following statement contains a magic number: Emit2ByteOpCode (0xFE' 0x05' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Add,The following statement contains a magic number: Emit1ByteOpCode (0x58' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Subtract,The following statement contains a magic number: Emit1ByteOpCode (0x59' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Multiply,The following statement contains a magic number: Emit1ByteOpCode (0x5A' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Divide,The following statement contains a magic number: Emit1ByteOpCode (0x5B' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Remainder,The following statement contains a magic number: Emit1ByteOpCode (0x5D' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BitwiseAnd,The following statement contains a magic number: Emit1ByteOpCode (0x5F' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BitwiseOr,The following statement contains a magic number: Emit1ByteOpCode (0x60' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BitwiseXor,The following statement contains a magic number: Emit1ByteOpCode (0x61' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,ShiftLeft,The following statement contains a magic number: Emit1ByteOpCode (0x62' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,ShiftRight,The following statement contains a magic number: Emit1ByteOpCode (0x63' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,ShiftRightUnsigned,The following statement contains a magic number: Emit1ByteOpCode (0x64' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreField,The following statement contains a magic number: if (field.IsStatic == true) {  	// stsfld = 80 <token>  	PopStackOperands (ToVESType (field.FieldType));  	Emit1ByteOpCodeInt32 (0x80' 1' 0' token);  }  else {  	// stfld = 7D <token>  	PopStackOperands (VESType.Object | VESType.ManagedPointer | VESType.NativeInt' ToVESType (field.FieldType));  	Emit1ByteOpCodeInt32 (0x7D' 2' 0' token);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreField,The following statement contains a magic number: Emit1ByteOpCodeInt32 (0x7D' 2' 0' token);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.SByte:  	Emit1ByteOpCode (0x90' 2' 1);  	break;  case TypeCode.Int16:  	Emit1ByteOpCode (0x92' 2' 1);  	break;  case TypeCode.Int32:  	Emit1ByteOpCode (0x94' 2' 1);  	break;  case TypeCode.Int64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Byte:  	Emit1ByteOpCode (0x91' 2' 1);  	break;  case TypeCode.UInt16:  	Emit1ByteOpCode (0x93' 2' 1);  	break;  case TypeCode.UInt32:  	Emit1ByteOpCode (0x95' 2' 1);  	break;  case TypeCode.UInt64:  	Emit1ByteOpCode (0x96' 2' 1);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0x98' 2' 1);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0x99' 2' 1);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0x9A' 2' 1);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x90' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x92' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x94' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x96' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x91' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x93' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x95' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x96' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x98' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x99' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: if (type.IsClass == true)  	Emit1ByteOpCode (0x9A' 2' 1);  else {  	int token = this.GetToken (type);  	Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: if (type.IsClass == true)  	Emit1ByteOpCode (0x9A' 2' 1);  else {  	int token = this.GetToken (type);  	Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x9A' 2' 1);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,LoadArrayElement,The following statement contains a magic number: Emit1ByteOpCodeInt32 (0xA3' 2' 1' token);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.Byte:  case TypeCode.SByte:  	Emit1ByteOpCode (0x9C' 3' 0);  	break;  case TypeCode.UInt16:  case TypeCode.Int16:  	Emit1ByteOpCode (0x9D' 3' 0);  	break;  case TypeCode.UInt32:  case TypeCode.Int32:  	Emit1ByteOpCode (0x9E' 3' 0);  	break;  case TypeCode.UInt64:  case TypeCode.Int64:  	Emit1ByteOpCode (0x9F' 3' 0);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0xA0' 3' 0);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0xA1' 3' 0);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0xA2' 3' 0);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.Byte:  case TypeCode.SByte:  	Emit1ByteOpCode (0x9C' 3' 0);  	break;  case TypeCode.UInt16:  case TypeCode.Int16:  	Emit1ByteOpCode (0x9D' 3' 0);  	break;  case TypeCode.UInt32:  case TypeCode.Int32:  	Emit1ByteOpCode (0x9E' 3' 0);  	break;  case TypeCode.UInt64:  case TypeCode.Int64:  	Emit1ByteOpCode (0x9F' 3' 0);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0xA0' 3' 0);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0xA1' 3' 0);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0xA2' 3' 0);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.Byte:  case TypeCode.SByte:  	Emit1ByteOpCode (0x9C' 3' 0);  	break;  case TypeCode.UInt16:  case TypeCode.Int16:  	Emit1ByteOpCode (0x9D' 3' 0);  	break;  case TypeCode.UInt32:  case TypeCode.Int32:  	Emit1ByteOpCode (0x9E' 3' 0);  	break;  case TypeCode.UInt64:  case TypeCode.Int64:  	Emit1ByteOpCode (0x9F' 3' 0);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0xA0' 3' 0);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0xA1' 3' 0);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0xA2' 3' 0);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.Byte:  case TypeCode.SByte:  	Emit1ByteOpCode (0x9C' 3' 0);  	break;  case TypeCode.UInt16:  case TypeCode.Int16:  	Emit1ByteOpCode (0x9D' 3' 0);  	break;  case TypeCode.UInt32:  case TypeCode.Int32:  	Emit1ByteOpCode (0x9E' 3' 0);  	break;  case TypeCode.UInt64:  case TypeCode.Int64:  	Emit1ByteOpCode (0x9F' 3' 0);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0xA0' 3' 0);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0xA1' 3' 0);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0xA2' 3' 0);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.Byte:  case TypeCode.SByte:  	Emit1ByteOpCode (0x9C' 3' 0);  	break;  case TypeCode.UInt16:  case TypeCode.Int16:  	Emit1ByteOpCode (0x9D' 3' 0);  	break;  case TypeCode.UInt32:  case TypeCode.Int32:  	Emit1ByteOpCode (0x9E' 3' 0);  	break;  case TypeCode.UInt64:  case TypeCode.Int64:  	Emit1ByteOpCode (0x9F' 3' 0);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0xA0' 3' 0);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0xA1' 3' 0);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0xA2' 3' 0);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.Byte:  case TypeCode.SByte:  	Emit1ByteOpCode (0x9C' 3' 0);  	break;  case TypeCode.UInt16:  case TypeCode.Int16:  	Emit1ByteOpCode (0x9D' 3' 0);  	break;  case TypeCode.UInt32:  case TypeCode.Int32:  	Emit1ByteOpCode (0x9E' 3' 0);  	break;  case TypeCode.UInt64:  case TypeCode.Int64:  	Emit1ByteOpCode (0x9F' 3' 0);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0xA0' 3' 0);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0xA1' 3' 0);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0xA2' 3' 0);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.Byte:  case TypeCode.SByte:  	Emit1ByteOpCode (0x9C' 3' 0);  	break;  case TypeCode.UInt16:  case TypeCode.Int16:  	Emit1ByteOpCode (0x9D' 3' 0);  	break;  case TypeCode.UInt32:  case TypeCode.Int32:  	Emit1ByteOpCode (0x9E' 3' 0);  	break;  case TypeCode.UInt64:  case TypeCode.Int64:  	Emit1ByteOpCode (0x9F' 3' 0);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0xA0' 3' 0);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0xA1' 3' 0);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0xA2' 3' 0);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: switch (Type.GetTypeCode (type)) {  case TypeCode.Byte:  case TypeCode.SByte:  	Emit1ByteOpCode (0x9C' 3' 0);  	break;  case TypeCode.UInt16:  case TypeCode.Int16:  	Emit1ByteOpCode (0x9D' 3' 0);  	break;  case TypeCode.UInt32:  case TypeCode.Int32:  	Emit1ByteOpCode (0x9E' 3' 0);  	break;  case TypeCode.UInt64:  case TypeCode.Int64:  	Emit1ByteOpCode (0x9F' 3' 0);  	break;  case TypeCode.Single:  	Emit1ByteOpCode (0xA0' 3' 0);  	break;  case TypeCode.Double:  	Emit1ByteOpCode (0xA1' 3' 0);  	break;  default:  	if (type.IsClass == true)  		Emit1ByteOpCode (0xA2' 3' 0);  	else {  		int token = this.GetToken (type);  		Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  	}  	break;  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x9C' 3' 0);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x9D' 3' 0);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x9E' 3' 0);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0x9F' 3' 0);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0xA0' 3' 0);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0xA1' 3' 0);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: if (type.IsClass == true)  	Emit1ByteOpCode (0xA2' 3' 0);  else {  	int token = this.GetToken (type);  	Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: if (type.IsClass == true)  	Emit1ByteOpCode (0xA2' 3' 0);  else {  	int token = this.GetToken (type);  	Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  }  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: Emit1ByteOpCode (0xA2' 3' 0);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,StoreArrayElement,The following statement contains a magic number: Emit1ByteOpCodeInt32 (0xA4' 3' 0' token);  
Magic Number,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,BeginExceptionBlock,The following statement contains a magic number: region.Clauses = new List<ExceptionClause> (3);  
Magic Number,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToInteger,The following statement contains a magic number: switch (fromType) {  case PrimitiveType.Undefined:  case PrimitiveType.Null:  	// Converting from undefined or null produces 0.  	generator.Pop ();  	generator.LoadInt32 (0);  	break;  case PrimitiveType.Number:  	// Converting from a number produces the following:  	// Any number between -2147483648 and +2147483647 -> itself  	// Any number smaller than -2147483648 -> -2147483648  	// Any number larger than +2147483647 -> +2147483647  	// NaN -> 0  	// bool isPositiveInfinity = input > 2147483647.0  	var isPositiveInfinity = generator.CreateTemporaryVariable (typeof(bool));  	generator.Duplicate ();  	generator.LoadDouble (2147483647.0);  	generator.CompareGreaterThan ();  	generator.StoreVariable (isPositiveInfinity);  	// bool notNaN = input == input  	var notNaN = generator.CreateTemporaryVariable (typeof(bool));  	generator.Duplicate ();  	generator.Duplicate ();  	generator.CompareEqual ();  	generator.StoreVariable (notNaN);  	// input = (int)input  	// Infinity -> -2147483648  	// -Infinity -> -2147483648  	// NaN -> -2147483648  	generator.ConvertToInteger ();  	// input = input & -((int)notNaN)  	generator.LoadVariable (notNaN);  	generator.Negate ();  	generator.BitwiseAnd ();  	// input = input - (int)isPositiveInfinity  	generator.LoadVariable (isPositiveInfinity);  	generator.Subtract ();  	// The temporary variables are no longer needed.  	generator.ReleaseTemporaryVariable (notNaN);  	generator.ReleaseTemporaryVariable (isPositiveInfinity);  	break;  case PrimitiveType.String:  case PrimitiveType.ConcatenatedString:  case PrimitiveType.Any:  case PrimitiveType.Object:  	// Otherwise' fall back to calling TypeConverter.ToInteger()  	generator.Call (ReflectionHelpers.TypeConverter_ToInteger);  	break;  default:  	throw new NotImplementedException (string.Format ("Unsupported primitive type: {0}"' fromType));  }  
Magic Number,Jurassic.Compiler,EmitConversion,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitConversion.cs,ToInteger,The following statement contains a magic number: generator.LoadDouble (2147483647.0);  
Magic Number,Jurassic.Compiler,SwitchStatement,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Statements\SwitchStatement.cs,SwitchStatement,The following statement contains a magic number: this.CaseClauses = new List<SwitchCase> (5);  
Magic Number,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,GenerateStub,The following statement contains a magic number: generator.LoadArgument (2);  
Magic Number,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,GenerateStub,The following statement contains a magic number: for (int i = 0; i < candidateMethods.Count; i++) {  	// Check if this is the selected method.  	ILLabel endOfIf = null;  	if (i < candidateMethods.Count - 1) {  		generator.Duplicate ();  		generator.LoadInt32 (i);  		endOfIf = generator.CreateLabel ();  		generator.BranchIfNotEqual (endOfIf);  	}  	generator.Pop ();  	var targetMethod = candidateMethods [i];  	// Convert the arguments.  	foreach (var argument in targetMethod.GenerateArguments (generator' argumentCount)) {  		// Load the input parameter value.  		switch (argument.Source) {  		case BinderArgumentSource.ScriptEngine:  			generator.LoadArgument (0);  			break;  		case BinderArgumentSource.ThisValue:  			generator.LoadArgument (1);  			break;  		case BinderArgumentSource.InputParameter:  			generator.LoadArgument (2);  			generator.LoadInt32 (argument.InputParameterIndex);  			generator.LoadArrayElement (typeof(object));  			break;  		}  		// Convert to the target type.  		EmitConversionToType (generator' argument.Type' convertToAddress: argument.Source == BinderArgumentSource.ThisValue);  	}  	// Call the target method.  	targetMethod.GenerateCall (generator);  	// Convert the return value.  	if (targetMethod.ReturnType == typeof(void))  		EmitHelpers.EmitUndefined (generator);  	else  		EmitConversionToObject (generator' targetMethod.ReturnType);  	// Branch to the end of the method if this was the selected method.  	if (endOfIf != null) {  		generator.Branch (endOfMethod);  		generator.DefineLabelPosition (endOfIf);  	}  }  
Magic Number,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,GenerateStub,The following statement contains a magic number: foreach (var argument in targetMethod.GenerateArguments (generator' argumentCount)) {  	// Load the input parameter value.  	switch (argument.Source) {  	case BinderArgumentSource.ScriptEngine:  		generator.LoadArgument (0);  		break;  	case BinderArgumentSource.ThisValue:  		generator.LoadArgument (1);  		break;  	case BinderArgumentSource.InputParameter:  		generator.LoadArgument (2);  		generator.LoadInt32 (argument.InputParameterIndex);  		generator.LoadArrayElement (typeof(object));  		break;  	}  	// Convert to the target type.  	EmitConversionToType (generator' argument.Type' convertToAddress: argument.Source == BinderArgumentSource.ThisValue);  }  
Magic Number,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,GenerateStub,The following statement contains a magic number: switch (argument.Source) {  case BinderArgumentSource.ScriptEngine:  	generator.LoadArgument (0);  	break;  case BinderArgumentSource.ThisValue:  	generator.LoadArgument (1);  	break;  case BinderArgumentSource.InputParameter:  	generator.LoadArgument (2);  	generator.LoadInt32 (argument.InputParameterIndex);  	generator.LoadArrayElement (typeof(object));  	break;  }  
Magic Number,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,GenerateStub,The following statement contains a magic number: generator.LoadArgument (2);  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The following statement contains a magic number: if (firstChar == '\\') {  	// Unicode escape sequence.  	if (ReadNextChar () != 'u')  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid escape sequence in identifier."' this.lineNumber' this.Source.Path);  	firstChar = ReadHexEscapeSequence (4);  	if (IsIdentifierChar (firstChar) == false)  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid character in identifier."' this.lineNumber' this.Source.Path);  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The following statement contains a magic number: firstChar = ReadHexEscapeSequence (4);  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The following statement contains a magic number: while (true) {  	int c = this.reader.Peek ();  	if (IsIdentifierChar (c) == false || c == -1)  		break;  	if (c == '\\') {  		// Unicode escape sequence.  		ReadNextChar ();  		if (ReadNextChar () != 'u')  			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid escape sequence in identifier."' this.lineNumber' this.Source.Path);  		c = ReadHexEscapeSequence (4);  		if (IsIdentifierChar (c) == false)  			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid character in identifier."' this.lineNumber' this.Source.Path);  		name.Append ((char)c);  	}  	else {  		// Add the character we peeked at to the identifier name.  		name.Append ((char)c);  		// Advance the input stream.  		ReadNextChar ();  	}  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The following statement contains a magic number: if (c == '\\') {  	// Unicode escape sequence.  	ReadNextChar ();  	if (ReadNextChar () != 'u')  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid escape sequence in identifier."' this.lineNumber' this.Source.Path);  	c = ReadHexEscapeSequence (4);  	if (IsIdentifierChar (c) == false)  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid character in identifier."' this.lineNumber' this.Source.Path);  	name.Append ((char)c);  }  else {  	// Add the character we peeked at to the identifier name.  	name.Append ((char)c);  	// Advance the input stream.  	ReadNextChar ();  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadIdentifier,The following statement contains a magic number: c = ReadHexEscapeSequence (4);  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadInteger,The following statement contains a magic number: while (true) {  	int c = this.reader.Peek ();  	if (c < '0' || c > '9')  		break;  	ReadNextChar ();  	digitsRead++;  	result = result * 10 + (c - '0');  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadInteger,The following statement contains a magic number: result = result * 10 + (c - '0');  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: while (true) {  	int c = ReadNextChar ();  	if (c == firstChar)  		break;  	if (c == -1)  		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected end of input in string literal."' this.lineNumber' this.Source.Path);  	if (IsLineTerminator (c))  		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected line terminator in string literal."' this.lineNumber' this.Source.Path);  	if (c == '\\') {  		// Escape sequence or line continuation.  		c = ReadNextChar ();  		if (IsLineTerminator (c)) {  			// Line continuation.  			ReadLineTerminator (c);  			// Keep track of the number of line terminators so the parser can compute  			// line numbers correctly.  			lineTerminatorCount++;  			// Increment the internal line number so errors can be tracked properly.  			this.lineNumber++;  			this.columnNumber = 1;  		}  		else {  			// Escape sequence.  			switch (c) {  			case 'b':  				// Backspace.  				contents.Append ((char)0x08);  				break;  			case 'f':  				// Form feed.  				contents.Append ((char)0x0C);  				break;  			case 'n':  				// Line feed.  				contents.Append ((char)0x0A);  				break;  			case 'r':  				// Carriage return.  				contents.Append ((char)0x0D);  				break;  			case 't':  				// Horizontal tab.  				contents.Append ((char)0x09);  				break;  			case 'v':  				// Vertical tab.  				contents.Append ((char)0x0B);  				break;  			case 'x':  				// ASCII escape.  				contents.Append (ReadHexEscapeSequence (2));  				break;  			case 'u':  				// Unicode escape.  				contents.Append (ReadHexEscapeSequence (4));  				break;  			case '0':  				// Null character or octal escape sequence.  				c = this.reader.Peek ();  				if (c >= '0' && c <= '9')  					contents.Append (ReadOctalEscapeSequence (0));  				else  					contents.Append ((char)0);  				break;  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  				// Octal escape sequence.  				contents.Append (ReadOctalEscapeSequence (c - '0'));  				break;  			case '8':  			case '9':  				throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  			default:  				contents.Append ((char)c);  				break;  			}  			escapeSequenceCount++;  		}  	}  	else {  		contents.Append ((char)c);  	}  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: while (true) {  	int c = ReadNextChar ();  	if (c == firstChar)  		break;  	if (c == -1)  		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected end of input in string literal."' this.lineNumber' this.Source.Path);  	if (IsLineTerminator (c))  		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected line terminator in string literal."' this.lineNumber' this.Source.Path);  	if (c == '\\') {  		// Escape sequence or line continuation.  		c = ReadNextChar ();  		if (IsLineTerminator (c)) {  			// Line continuation.  			ReadLineTerminator (c);  			// Keep track of the number of line terminators so the parser can compute  			// line numbers correctly.  			lineTerminatorCount++;  			// Increment the internal line number so errors can be tracked properly.  			this.lineNumber++;  			this.columnNumber = 1;  		}  		else {  			// Escape sequence.  			switch (c) {  			case 'b':  				// Backspace.  				contents.Append ((char)0x08);  				break;  			case 'f':  				// Form feed.  				contents.Append ((char)0x0C);  				break;  			case 'n':  				// Line feed.  				contents.Append ((char)0x0A);  				break;  			case 'r':  				// Carriage return.  				contents.Append ((char)0x0D);  				break;  			case 't':  				// Horizontal tab.  				contents.Append ((char)0x09);  				break;  			case 'v':  				// Vertical tab.  				contents.Append ((char)0x0B);  				break;  			case 'x':  				// ASCII escape.  				contents.Append (ReadHexEscapeSequence (2));  				break;  			case 'u':  				// Unicode escape.  				contents.Append (ReadHexEscapeSequence (4));  				break;  			case '0':  				// Null character or octal escape sequence.  				c = this.reader.Peek ();  				if (c >= '0' && c <= '9')  					contents.Append (ReadOctalEscapeSequence (0));  				else  					contents.Append ((char)0);  				break;  			case '1':  			case '2':  			case '3':  			case '4':  			case '5':  			case '6':  			case '7':  				// Octal escape sequence.  				contents.Append (ReadOctalEscapeSequence (c - '0'));  				break;  			case '8':  			case '9':  				throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  			default:  				contents.Append ((char)c);  				break;  			}  			escapeSequenceCount++;  		}  	}  	else {  		contents.Append ((char)c);  	}  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: if (c == '\\') {  	// Escape sequence or line continuation.  	c = ReadNextChar ();  	if (IsLineTerminator (c)) {  		// Line continuation.  		ReadLineTerminator (c);  		// Keep track of the number of line terminators so the parser can compute  		// line numbers correctly.  		lineTerminatorCount++;  		// Increment the internal line number so errors can be tracked properly.  		this.lineNumber++;  		this.columnNumber = 1;  	}  	else {  		// Escape sequence.  		switch (c) {  		case 'b':  			// Backspace.  			contents.Append ((char)0x08);  			break;  		case 'f':  			// Form feed.  			contents.Append ((char)0x0C);  			break;  		case 'n':  			// Line feed.  			contents.Append ((char)0x0A);  			break;  		case 'r':  			// Carriage return.  			contents.Append ((char)0x0D);  			break;  		case 't':  			// Horizontal tab.  			contents.Append ((char)0x09);  			break;  		case 'v':  			// Vertical tab.  			contents.Append ((char)0x0B);  			break;  		case 'x':  			// ASCII escape.  			contents.Append (ReadHexEscapeSequence (2));  			break;  		case 'u':  			// Unicode escape.  			contents.Append (ReadHexEscapeSequence (4));  			break;  		case '0':  			// Null character or octal escape sequence.  			c = this.reader.Peek ();  			if (c >= '0' && c <= '9')  				contents.Append (ReadOctalEscapeSequence (0));  			else  				contents.Append ((char)0);  			break;  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  			// Octal escape sequence.  			contents.Append (ReadOctalEscapeSequence (c - '0'));  			break;  		case '8':  		case '9':  			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  		default:  			contents.Append ((char)c);  			break;  		}  		escapeSequenceCount++;  	}  }  else {  	contents.Append ((char)c);  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: if (c == '\\') {  	// Escape sequence or line continuation.  	c = ReadNextChar ();  	if (IsLineTerminator (c)) {  		// Line continuation.  		ReadLineTerminator (c);  		// Keep track of the number of line terminators so the parser can compute  		// line numbers correctly.  		lineTerminatorCount++;  		// Increment the internal line number so errors can be tracked properly.  		this.lineNumber++;  		this.columnNumber = 1;  	}  	else {  		// Escape sequence.  		switch (c) {  		case 'b':  			// Backspace.  			contents.Append ((char)0x08);  			break;  		case 'f':  			// Form feed.  			contents.Append ((char)0x0C);  			break;  		case 'n':  			// Line feed.  			contents.Append ((char)0x0A);  			break;  		case 'r':  			// Carriage return.  			contents.Append ((char)0x0D);  			break;  		case 't':  			// Horizontal tab.  			contents.Append ((char)0x09);  			break;  		case 'v':  			// Vertical tab.  			contents.Append ((char)0x0B);  			break;  		case 'x':  			// ASCII escape.  			contents.Append (ReadHexEscapeSequence (2));  			break;  		case 'u':  			// Unicode escape.  			contents.Append (ReadHexEscapeSequence (4));  			break;  		case '0':  			// Null character or octal escape sequence.  			c = this.reader.Peek ();  			if (c >= '0' && c <= '9')  				contents.Append (ReadOctalEscapeSequence (0));  			else  				contents.Append ((char)0);  			break;  		case '1':  		case '2':  		case '3':  		case '4':  		case '5':  		case '6':  		case '7':  			// Octal escape sequence.  			contents.Append (ReadOctalEscapeSequence (c - '0'));  			break;  		case '8':  		case '9':  			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  		default:  			contents.Append ((char)c);  			break;  		}  		escapeSequenceCount++;  	}  }  else {  	contents.Append ((char)c);  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: if (IsLineTerminator (c)) {  	// Line continuation.  	ReadLineTerminator (c);  	// Keep track of the number of line terminators so the parser can compute  	// line numbers correctly.  	lineTerminatorCount++;  	// Increment the internal line number so errors can be tracked properly.  	this.lineNumber++;  	this.columnNumber = 1;  }  else {  	// Escape sequence.  	switch (c) {  	case 'b':  		// Backspace.  		contents.Append ((char)0x08);  		break;  	case 'f':  		// Form feed.  		contents.Append ((char)0x0C);  		break;  	case 'n':  		// Line feed.  		contents.Append ((char)0x0A);  		break;  	case 'r':  		// Carriage return.  		contents.Append ((char)0x0D);  		break;  	case 't':  		// Horizontal tab.  		contents.Append ((char)0x09);  		break;  	case 'v':  		// Vertical tab.  		contents.Append ((char)0x0B);  		break;  	case 'x':  		// ASCII escape.  		contents.Append (ReadHexEscapeSequence (2));  		break;  	case 'u':  		// Unicode escape.  		contents.Append (ReadHexEscapeSequence (4));  		break;  	case '0':  		// Null character or octal escape sequence.  		c = this.reader.Peek ();  		if (c >= '0' && c <= '9')  			contents.Append (ReadOctalEscapeSequence (0));  		else  			contents.Append ((char)0);  		break;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  		// Octal escape sequence.  		contents.Append (ReadOctalEscapeSequence (c - '0'));  		break;  	case '8':  	case '9':  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  	default:  		contents.Append ((char)c);  		break;  	}  	escapeSequenceCount++;  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: if (IsLineTerminator (c)) {  	// Line continuation.  	ReadLineTerminator (c);  	// Keep track of the number of line terminators so the parser can compute  	// line numbers correctly.  	lineTerminatorCount++;  	// Increment the internal line number so errors can be tracked properly.  	this.lineNumber++;  	this.columnNumber = 1;  }  else {  	// Escape sequence.  	switch (c) {  	case 'b':  		// Backspace.  		contents.Append ((char)0x08);  		break;  	case 'f':  		// Form feed.  		contents.Append ((char)0x0C);  		break;  	case 'n':  		// Line feed.  		contents.Append ((char)0x0A);  		break;  	case 'r':  		// Carriage return.  		contents.Append ((char)0x0D);  		break;  	case 't':  		// Horizontal tab.  		contents.Append ((char)0x09);  		break;  	case 'v':  		// Vertical tab.  		contents.Append ((char)0x0B);  		break;  	case 'x':  		// ASCII escape.  		contents.Append (ReadHexEscapeSequence (2));  		break;  	case 'u':  		// Unicode escape.  		contents.Append (ReadHexEscapeSequence (4));  		break;  	case '0':  		// Null character or octal escape sequence.  		c = this.reader.Peek ();  		if (c >= '0' && c <= '9')  			contents.Append (ReadOctalEscapeSequence (0));  		else  			contents.Append ((char)0);  		break;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  		// Octal escape sequence.  		contents.Append (ReadOctalEscapeSequence (c - '0'));  		break;  	case '8':  	case '9':  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  	default:  		contents.Append ((char)c);  		break;  	}  	escapeSequenceCount++;  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: switch (c) {  case 'b':  	// Backspace.  	contents.Append ((char)0x08);  	break;  case 'f':  	// Form feed.  	contents.Append ((char)0x0C);  	break;  case 'n':  	// Line feed.  	contents.Append ((char)0x0A);  	break;  case 'r':  	// Carriage return.  	contents.Append ((char)0x0D);  	break;  case 't':  	// Horizontal tab.  	contents.Append ((char)0x09);  	break;  case 'v':  	// Vertical tab.  	contents.Append ((char)0x0B);  	break;  case 'x':  	// ASCII escape.  	contents.Append (ReadHexEscapeSequence (2));  	break;  case 'u':  	// Unicode escape.  	contents.Append (ReadHexEscapeSequence (4));  	break;  case '0':  	// Null character or octal escape sequence.  	c = this.reader.Peek ();  	if (c >= '0' && c <= '9')  		contents.Append (ReadOctalEscapeSequence (0));  	else  		contents.Append ((char)0);  	break;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	// Octal escape sequence.  	contents.Append (ReadOctalEscapeSequence (c - '0'));  	break;  case '8':  case '9':  	throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  default:  	contents.Append ((char)c);  	break;  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: switch (c) {  case 'b':  	// Backspace.  	contents.Append ((char)0x08);  	break;  case 'f':  	// Form feed.  	contents.Append ((char)0x0C);  	break;  case 'n':  	// Line feed.  	contents.Append ((char)0x0A);  	break;  case 'r':  	// Carriage return.  	contents.Append ((char)0x0D);  	break;  case 't':  	// Horizontal tab.  	contents.Append ((char)0x09);  	break;  case 'v':  	// Vertical tab.  	contents.Append ((char)0x0B);  	break;  case 'x':  	// ASCII escape.  	contents.Append (ReadHexEscapeSequence (2));  	break;  case 'u':  	// Unicode escape.  	contents.Append (ReadHexEscapeSequence (4));  	break;  case '0':  	// Null character or octal escape sequence.  	c = this.reader.Peek ();  	if (c >= '0' && c <= '9')  		contents.Append (ReadOctalEscapeSequence (0));  	else  		contents.Append ((char)0);  	break;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  	// Octal escape sequence.  	contents.Append (ReadOctalEscapeSequence (c - '0'));  	break;  case '8':  case '9':  	throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  default:  	contents.Append ((char)c);  	break;  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: contents.Append (ReadHexEscapeSequence (2));  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadStringLiteral,The following statement contains a magic number: contents.Append (ReadHexEscapeSequence (4));  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	int c = this.reader.Peek ();  	if (c < '0' || c > '9')  		break;  	if (c == '8' || c == '9')  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  	numericValue = numericValue * 8 + (c - '0');  	ReadNextChar ();  	if (numericValue * 8 > 255)  		break;  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	int c = this.reader.Peek ();  	if (c < '0' || c > '9')  		break;  	if (c == '8' || c == '9')  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  	numericValue = numericValue * 8 + (c - '0');  	ReadNextChar ();  	if (numericValue * 8 > 255)  		break;  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	int c = this.reader.Peek ();  	if (c < '0' || c > '9')  		break;  	if (c == '8' || c == '9')  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  	numericValue = numericValue * 8 + (c - '0');  	ReadNextChar ();  	if (numericValue * 8 > 255)  		break;  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	int c = this.reader.Peek ();  	if (c < '0' || c > '9')  		break;  	if (c == '8' || c == '9')  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal escape sequence."' this.lineNumber' this.Source.Path);  	numericValue = numericValue * 8 + (c - '0');  	ReadNextChar ();  	if (numericValue * 8 > 255)  		break;  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The following statement contains a magic number: numericValue = numericValue * 8 + (c - '0');  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The following statement contains a magic number: if (numericValue * 8 > 255)  	break;  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadOctalEscapeSequence,The following statement contains a magic number: if (numericValue * 8 > 255)  	break;  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadRegularExpression,The following statement contains a magic number: while (true) {  	int c = this.reader.Peek ();  	if (IsIdentifierChar (c) == false || c == -1)  		break;  	if (c == '\\') {  		// Unicode escape sequence.  		ReadNextChar ();  		if (ReadNextChar () != 'u')  			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid escape sequence in identifier."' this.lineNumber' this.Source.Path);  		c = ReadHexEscapeSequence (4);  		if (IsIdentifierChar (c) == false)  			throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid character in identifier."' this.lineNumber' this.Source.Path);  		flags.Append ((char)c);  	}  	else {  		// Add the character we peeked at to the flags.  		flags.Append ((char)c);  		// Advance the input stream.  		ReadNextChar ();  	}  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadRegularExpression,The following statement contains a magic number: if (c == '\\') {  	// Unicode escape sequence.  	ReadNextChar ();  	if (ReadNextChar () != 'u')  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid escape sequence in identifier."' this.lineNumber' this.Source.Path);  	c = ReadHexEscapeSequence (4);  	if (IsIdentifierChar (c) == false)  		throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid character in identifier."' this.lineNumber' this.Source.Path);  	flags.Append ((char)c);  }  else {  	// Add the character we peeked at to the flags.  	flags.Append ((char)c);  	// Advance the input stream.  	ReadNextChar ();  }  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadRegularExpression,The following statement contains a magic number: c = ReadHexEscapeSequence (4);  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,IsWhiteSpace,The following statement contains a magic number: return c == 0x09 || c == 0x0B || c == 0x0C || c == 0x20 || c == 0xA0 || c == 0x1680 || c == 0x180E || (c >= 8192 && c <= 8202) || c == 0x202F || c == 0x205F || c == 0x3000 || c == 0xFEFF;  
Magic Number,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,IsWhiteSpace,The following statement contains a magic number: return c == 0x09 || c == 0x0B || c == 0x0C || c == 0x20 || c == 0xA0 || c == 0x1680 || c == 0x180E || (c >= 8192 && c <= 8202) || c == 0x202F || c == 0x205F || c == 0x3000 || c == 0xFEFF;  
Magic Number,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The following statement contains a magic number: foreach (var argument in binderMethod.GenerateArguments (generator' Math.Min (Math.Max (argumentCount' minArgumentCount)' maxArgumentCount))) {  	switch (argument.Source) {  	case BinderArgumentSource.ScriptEngine:  		// Load the "engine" parameter passed by the client.  		generator.LoadArgument (0);  		break;  	case BinderArgumentSource.ThisValue:  		// Load the "this" parameter passed by the client.  		generator.LoadArgument (1);  		bool inheritsFromObjectInstance = typeof(ObjectInstance).IsAssignableFrom (argument.Type);  		if (argument.Type.IsClass == true && inheritsFromObjectInstance == false && argument.Type != typeof(string) && argument.Type != typeof(object)) {  			// If the "this" object is an unsupported class' pass it through unmodified.  			generator.CastClass (argument.Type);  		}  		else {  			if (argument.Type != typeof(object)) {  				// If the target "this" object type is not of type object' throw an error if  				// the value is undefined or null.  				generator.Duplicate ();  				var temp = generator.CreateTemporaryVariable (typeof(object));  				generator.StoreVariable (temp);  				generator.LoadArgument (0);  				generator.LoadVariable (temp);  				generator.LoadString (binderMethod.Name);  				generator.Call (ReflectionHelpers.TypeUtilities_VerifyThisObject);  				generator.ReleaseTemporaryVariable (temp);  			}  			// Convert to the target type.  			EmitTypeConversion (generator' typeof(object)' argument.Type);  			if (argument.Type != typeof(ObjectInstance) && inheritsFromObjectInstance == true) {  				// EmitConversionToObjectInstance can emit null if the toType is derived from ObjectInstance.  				// Therefore' if the value emitted is null it means that the "thisObject" is a type derived  				// from ObjectInstance (e.g. FunctionInstance) and the value provided is a different type  				// (e.g. ArrayInstance).  In this case' throw an exception explaining that the function is  				// not generic.  				var endOfThrowLabel = generator.CreateLabel ();  				generator.Duplicate ();  				generator.BranchIfNotNull (endOfThrowLabel);  				generator.LoadArgument (0);  				EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("The method '{0}' is not generic"' binderMethod.Name));  				generator.DefineLabelPosition (endOfThrowLabel);  			}  		}  		break;  	case BinderArgumentSource.InputParameter:  		if (argument.InputParameterIndex < argumentCount) {  			// Load the argument onto the stack.  			generator.LoadArgument (2);  			generator.LoadInt32 (argument.InputParameterIndex);  			generator.LoadArrayElement (typeof(object));  			// Get some flags that apply to the parameter.  			var parameterFlags = JSParameterFlags.None;  			var parameterAttribute = argument.GetCustomAttribute<JSParameterAttribute> ();  			if (parameterAttribute != null) {  				if (argument.Type != typeof(ObjectInstance))  					throw new NotImplementedException ("[JSParameter] is only supported for arguments of type ObjectInstance.");  				parameterFlags = parameterAttribute.Flags;  			}  			if ((parameterFlags & JSParameterFlags.DoNotConvert) == 0) {  				// Convert the input parameter to the correct type.  				EmitTypeConversion (generator' typeof(object)' argument);  			}  			else {  				// Don't do argument conversion.  				var endOfThrowLabel = generator.CreateLabel ();  				generator.IsInstance (typeof(ObjectInstance));  				generator.Duplicate ();  				generator.BranchIfNotNull (endOfThrowLabel);  				EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("Parameter {1} parameter of '{0}' must be an object"' binderMethod.Name' argument.InputParameterIndex));  				generator.DefineLabelPosition (endOfThrowLabel);  			}  		}  		else {  			// The target method has more parameters than we have input values.  			EmitUndefined (generator' argument);  		}  		break;  	}  }  
Magic Number,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The following statement contains a magic number: switch (argument.Source) {  case BinderArgumentSource.ScriptEngine:  	// Load the "engine" parameter passed by the client.  	generator.LoadArgument (0);  	break;  case BinderArgumentSource.ThisValue:  	// Load the "this" parameter passed by the client.  	generator.LoadArgument (1);  	bool inheritsFromObjectInstance = typeof(ObjectInstance).IsAssignableFrom (argument.Type);  	if (argument.Type.IsClass == true && inheritsFromObjectInstance == false && argument.Type != typeof(string) && argument.Type != typeof(object)) {  		// If the "this" object is an unsupported class' pass it through unmodified.  		generator.CastClass (argument.Type);  	}  	else {  		if (argument.Type != typeof(object)) {  			// If the target "this" object type is not of type object' throw an error if  			// the value is undefined or null.  			generator.Duplicate ();  			var temp = generator.CreateTemporaryVariable (typeof(object));  			generator.StoreVariable (temp);  			generator.LoadArgument (0);  			generator.LoadVariable (temp);  			generator.LoadString (binderMethod.Name);  			generator.Call (ReflectionHelpers.TypeUtilities_VerifyThisObject);  			generator.ReleaseTemporaryVariable (temp);  		}  		// Convert to the target type.  		EmitTypeConversion (generator' typeof(object)' argument.Type);  		if (argument.Type != typeof(ObjectInstance) && inheritsFromObjectInstance == true) {  			// EmitConversionToObjectInstance can emit null if the toType is derived from ObjectInstance.  			// Therefore' if the value emitted is null it means that the "thisObject" is a type derived  			// from ObjectInstance (e.g. FunctionInstance) and the value provided is a different type  			// (e.g. ArrayInstance).  In this case' throw an exception explaining that the function is  			// not generic.  			var endOfThrowLabel = generator.CreateLabel ();  			generator.Duplicate ();  			generator.BranchIfNotNull (endOfThrowLabel);  			generator.LoadArgument (0);  			EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("The method '{0}' is not generic"' binderMethod.Name));  			generator.DefineLabelPosition (endOfThrowLabel);  		}  	}  	break;  case BinderArgumentSource.InputParameter:  	if (argument.InputParameterIndex < argumentCount) {  		// Load the argument onto the stack.  		generator.LoadArgument (2);  		generator.LoadInt32 (argument.InputParameterIndex);  		generator.LoadArrayElement (typeof(object));  		// Get some flags that apply to the parameter.  		var parameterFlags = JSParameterFlags.None;  		var parameterAttribute = argument.GetCustomAttribute<JSParameterAttribute> ();  		if (parameterAttribute != null) {  			if (argument.Type != typeof(ObjectInstance))  				throw new NotImplementedException ("[JSParameter] is only supported for arguments of type ObjectInstance.");  			parameterFlags = parameterAttribute.Flags;  		}  		if ((parameterFlags & JSParameterFlags.DoNotConvert) == 0) {  			// Convert the input parameter to the correct type.  			EmitTypeConversion (generator' typeof(object)' argument);  		}  		else {  			// Don't do argument conversion.  			var endOfThrowLabel = generator.CreateLabel ();  			generator.IsInstance (typeof(ObjectInstance));  			generator.Duplicate ();  			generator.BranchIfNotNull (endOfThrowLabel);  			EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("Parameter {1} parameter of '{0}' must be an object"' binderMethod.Name' argument.InputParameterIndex));  			generator.DefineLabelPosition (endOfThrowLabel);  		}  	}  	else {  		// The target method has more parameters than we have input values.  		EmitUndefined (generator' argument);  	}  	break;  }  
Magic Number,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The following statement contains a magic number: if (argument.InputParameterIndex < argumentCount) {  	// Load the argument onto the stack.  	generator.LoadArgument (2);  	generator.LoadInt32 (argument.InputParameterIndex);  	generator.LoadArrayElement (typeof(object));  	// Get some flags that apply to the parameter.  	var parameterFlags = JSParameterFlags.None;  	var parameterAttribute = argument.GetCustomAttribute<JSParameterAttribute> ();  	if (parameterAttribute != null) {  		if (argument.Type != typeof(ObjectInstance))  			throw new NotImplementedException ("[JSParameter] is only supported for arguments of type ObjectInstance.");  		parameterFlags = parameterAttribute.Flags;  	}  	if ((parameterFlags & JSParameterFlags.DoNotConvert) == 0) {  		// Convert the input parameter to the correct type.  		EmitTypeConversion (generator' typeof(object)' argument);  	}  	else {  		// Don't do argument conversion.  		var endOfThrowLabel = generator.CreateLabel ();  		generator.IsInstance (typeof(ObjectInstance));  		generator.Duplicate ();  		generator.BranchIfNotNull (endOfThrowLabel);  		EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("Parameter {1} parameter of '{0}' must be an object"' binderMethod.Name' argument.InputParameterIndex));  		generator.DefineLabelPosition (endOfThrowLabel);  	}  }  else {  	// The target method has more parameters than we have input values.  	EmitUndefined (generator' argument);  }  
Magic Number,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The following statement contains a magic number: generator.LoadArgument (2);  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: if (this.Value is Dictionary<string' object>) {  	var result = new System.Text.StringBuilder ("{");  	foreach (var keyValuePair in (Dictionary<string' object>)this.Value) {  		if (result.Length > 1)  			result.Append ("' ");  		if (keyValuePair.Value is Expression) {  			result.Append (keyValuePair.Key);  			result.Append (": ");  			result.Append (keyValuePair.Value);  		}  		else if (keyValuePair.Value is Parser.ObjectLiteralAccessor) {  			var accessor = (Parser.ObjectLiteralAccessor)keyValuePair.Value;  			if (accessor.Getter != null) {  				result.Append ("get ");  				result.Append (accessor.Getter.ToString ().Substring (9));  				if (accessor.Setter != null)  					result.Append ("' ");  			}  			if (accessor.Setter != null) {  				result.Append ("set ");  				result.Append (accessor.Setter.ToString ().Substring (9));  			}  		}  	}  	result.Append ("}");  	return result.ToString ();  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: if (this.Value is Dictionary<string' object>) {  	var result = new System.Text.StringBuilder ("{");  	foreach (var keyValuePair in (Dictionary<string' object>)this.Value) {  		if (result.Length > 1)  			result.Append ("' ");  		if (keyValuePair.Value is Expression) {  			result.Append (keyValuePair.Key);  			result.Append (": ");  			result.Append (keyValuePair.Value);  		}  		else if (keyValuePair.Value is Parser.ObjectLiteralAccessor) {  			var accessor = (Parser.ObjectLiteralAccessor)keyValuePair.Value;  			if (accessor.Getter != null) {  				result.Append ("get ");  				result.Append (accessor.Getter.ToString ().Substring (9));  				if (accessor.Setter != null)  					result.Append ("' ");  			}  			if (accessor.Setter != null) {  				result.Append ("set ");  				result.Append (accessor.Setter.ToString ().Substring (9));  			}  		}  	}  	result.Append ("}");  	return result.ToString ();  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: foreach (var keyValuePair in (Dictionary<string' object>)this.Value) {  	if (result.Length > 1)  		result.Append ("' ");  	if (keyValuePair.Value is Expression) {  		result.Append (keyValuePair.Key);  		result.Append (": ");  		result.Append (keyValuePair.Value);  	}  	else if (keyValuePair.Value is Parser.ObjectLiteralAccessor) {  		var accessor = (Parser.ObjectLiteralAccessor)keyValuePair.Value;  		if (accessor.Getter != null) {  			result.Append ("get ");  			result.Append (accessor.Getter.ToString ().Substring (9));  			if (accessor.Setter != null)  				result.Append ("' ");  		}  		if (accessor.Setter != null) {  			result.Append ("set ");  			result.Append (accessor.Setter.ToString ().Substring (9));  		}  	}  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: foreach (var keyValuePair in (Dictionary<string' object>)this.Value) {  	if (result.Length > 1)  		result.Append ("' ");  	if (keyValuePair.Value is Expression) {  		result.Append (keyValuePair.Key);  		result.Append (": ");  		result.Append (keyValuePair.Value);  	}  	else if (keyValuePair.Value is Parser.ObjectLiteralAccessor) {  		var accessor = (Parser.ObjectLiteralAccessor)keyValuePair.Value;  		if (accessor.Getter != null) {  			result.Append ("get ");  			result.Append (accessor.Getter.ToString ().Substring (9));  			if (accessor.Setter != null)  				result.Append ("' ");  		}  		if (accessor.Setter != null) {  			result.Append ("set ");  			result.Append (accessor.Setter.ToString ().Substring (9));  		}  	}  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: if (keyValuePair.Value is Expression) {  	result.Append (keyValuePair.Key);  	result.Append (": ");  	result.Append (keyValuePair.Value);  }  else if (keyValuePair.Value is Parser.ObjectLiteralAccessor) {  	var accessor = (Parser.ObjectLiteralAccessor)keyValuePair.Value;  	if (accessor.Getter != null) {  		result.Append ("get ");  		result.Append (accessor.Getter.ToString ().Substring (9));  		if (accessor.Setter != null)  			result.Append ("' ");  	}  	if (accessor.Setter != null) {  		result.Append ("set ");  		result.Append (accessor.Setter.ToString ().Substring (9));  	}  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: if (keyValuePair.Value is Expression) {  	result.Append (keyValuePair.Key);  	result.Append (": ");  	result.Append (keyValuePair.Value);  }  else if (keyValuePair.Value is Parser.ObjectLiteralAccessor) {  	var accessor = (Parser.ObjectLiteralAccessor)keyValuePair.Value;  	if (accessor.Getter != null) {  		result.Append ("get ");  		result.Append (accessor.Getter.ToString ().Substring (9));  		if (accessor.Setter != null)  			result.Append ("' ");  	}  	if (accessor.Setter != null) {  		result.Append ("set ");  		result.Append (accessor.Setter.ToString ().Substring (9));  	}  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: if (keyValuePair.Value is Parser.ObjectLiteralAccessor) {  	var accessor = (Parser.ObjectLiteralAccessor)keyValuePair.Value;  	if (accessor.Getter != null) {  		result.Append ("get ");  		result.Append (accessor.Getter.ToString ().Substring (9));  		if (accessor.Setter != null)  			result.Append ("' ");  	}  	if (accessor.Setter != null) {  		result.Append ("set ");  		result.Append (accessor.Setter.ToString ().Substring (9));  	}  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: if (keyValuePair.Value is Parser.ObjectLiteralAccessor) {  	var accessor = (Parser.ObjectLiteralAccessor)keyValuePair.Value;  	if (accessor.Getter != null) {  		result.Append ("get ");  		result.Append (accessor.Getter.ToString ().Substring (9));  		if (accessor.Setter != null)  			result.Append ("' ");  	}  	if (accessor.Setter != null) {  		result.Append ("set ");  		result.Append (accessor.Setter.ToString ().Substring (9));  	}  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: if (accessor.Getter != null) {  	result.Append ("get ");  	result.Append (accessor.Getter.ToString ().Substring (9));  	if (accessor.Setter != null)  		result.Append ("' ");  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: result.Append (accessor.Getter.ToString ().Substring (9));  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: if (accessor.Setter != null) {  	result.Append ("set ");  	result.Append (accessor.Setter.ToString ().Substring (9));  }  
Magic Number,Jurassic.Compiler,LiteralExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\LiteralExpression.cs,ToString,The following statement contains a magic number: result.Append (accessor.Setter.ToString ().Substring (9));  
Magic Number,Jurassic.Compiler,FunctionCallExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\FunctionCallExpression.cs,GenerateArgumentsArray,The following statement contains a magic number: if (this.OperandCount < 2) {  	// No parameters passed.  Create an empty array.  	generator.LoadInt32 (0);  	generator.NewArray (typeof(object));  }  else {  	// One or more arguments.  	IList<Expression> arguments;  	var argumentsOperand = this.GetRawOperand (1);  	if (argumentsOperand is ListExpression) {  		// Multiple parameters were passed to the function.  		arguments = ((ListExpression)argumentsOperand).Items;  	}  	else {  		// A single parameter was passed to the function.  		arguments = new List<Expression> (1) {  			argumentsOperand  		};  	}  	// Generate an array containing the value of each argument.  	generator.LoadInt32 (arguments.Count);  	generator.NewArray (typeof(object));  	for (int i = 0; i < arguments.Count; i++) {  		generator.Duplicate ();  		generator.LoadInt32 (i);  		arguments [i].GenerateCode (generator' optimizationInfo);  		EmitConversion.ToAny (generator' arguments [i].ResultType);  		generator.StoreArrayElement (typeof(object));  	}  }  
Magic Number,Jurassic.Compiler,FunctionCallExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\FunctionCallExpression.cs,GenerateEval,The following statement contains a magic number: if (this.OperandCount < 2) {  	// No arguments were supplied.  	generator.LoadNull ();  }  else {  	// Take the first argument and convert it to a string.  	GenerateArgumentsArray (generator' optimizationInfo);  	generator.LoadInt32 (0);  	generator.LoadArrayElement (typeof(object));  }  
Magic Number,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,ToString,The following statement contains a magic number: if (this.OperatorType == OperatorType.MemberAccess)  	return string.Format ("{0}.{1}"' this.GetRawOperand (0)' this.OperandCount >= 2 ? this.GetRawOperand (1).ToString () : "?");  
Magic Number,Jurassic.Compiler,MemberAccessExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\MemberAccessExpression.cs,ToString,The following statement contains a magic number: return string.Format ("{0}.{1}"' this.GetRawOperand (0)' this.OperandCount >= 2 ? this.GetRawOperand (1).ToString () : "?");  
Magic Number,Jurassic.Compiler,OperatorExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\OperatorExpression.cs,FromOperator,The following statement contains a magic number: if (@operator.Arity == 2)  	return new BinaryExpression (@operator);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,BigInteger,The following statement contains a magic number: this.bits = new uint[2];  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,BigInteger,The following statement contains a magic number: this.bits [1] = (uint)(Math.Abs (value) >> 32);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,BigInteger,The following statement contains a magic number: this.wordCount = this.bits [1] != 0 ? 2 : 1;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: for (; i < Math.Min (left.wordCount' right.wordCount); i++) {  	ulong temp = (ulong)left.bits [i] + right.bits [i] + borrow;  	borrow = (uint)(temp >> 32);  	outputBits [i] = (uint)temp;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: borrow = (uint)(temp >> 32);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: if (left.wordCount > right.wordCount) {  	for (; i < left.wordCount; i++) {  		ulong temp = (ulong)left.bits [i] + borrow;  		borrow = (uint)(temp >> 32);  		outputBits [i] = (uint)temp;  	}  }  else if (left.wordCount < right.wordCount) {  	for (; i < right.wordCount; i++) {  		ulong temp = (ulong)right.bits [i] + borrow;  		borrow = (uint)(temp >> 32);  		outputBits [i] = (uint)temp;  	}  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: if (left.wordCount > right.wordCount) {  	for (; i < left.wordCount; i++) {  		ulong temp = (ulong)left.bits [i] + borrow;  		borrow = (uint)(temp >> 32);  		outputBits [i] = (uint)temp;  	}  }  else if (left.wordCount < right.wordCount) {  	for (; i < right.wordCount; i++) {  		ulong temp = (ulong)right.bits [i] + borrow;  		borrow = (uint)(temp >> 32);  		outputBits [i] = (uint)temp;  	}  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: for (; i < left.wordCount; i++) {  	ulong temp = (ulong)left.bits [i] + borrow;  	borrow = (uint)(temp >> 32);  	outputBits [i] = (uint)temp;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: borrow = (uint)(temp >> 32);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: if (left.wordCount < right.wordCount) {  	for (; i < right.wordCount; i++) {  		ulong temp = (ulong)right.bits [i] + borrow;  		borrow = (uint)(temp >> 32);  		outputBits [i] = (uint)temp;  	}  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: for (; i < right.wordCount; i++) {  	ulong temp = (ulong)right.bits [i] + borrow;  	borrow = (uint)(temp >> 32);  	outputBits [i] = (uint)temp;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Add,The following statement contains a magic number: borrow = (uint)(temp >> 32);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Multiply,The following statement contains a magic number: for (int i = 0; i < left.wordCount; i++) {  	uint carry = 0;  	for (int j = 0; j < right.wordCount; j++) {  		ulong temp = (ulong)left.bits [i] * right.bits [j] + outputBits [i + j] + carry;  		carry = (uint)(temp >> 32);  		outputBits [i + j] = (uint)temp;  	}  	if (carry != 0) {  		outputWordCount = Math.Max (outputWordCount' i + right.wordCount + 1);  		outputBits [i + right.wordCount] = (uint)carry;  	}  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Multiply,The following statement contains a magic number: for (int j = 0; j < right.wordCount; j++) {  	ulong temp = (ulong)left.bits [i] * right.bits [j] + outputBits [i + j] + carry;  	carry = (uint)(temp >> 32);  	outputBits [i + j] = (uint)temp;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Multiply,The following statement contains a magic number: carry = (uint)(temp >> 32);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Subtract,The following statement contains a magic number: for (i = 0; i < right.wordCount; i++) {  	y = (ulong)left.bits [i] - right.bits [i] - borrow;  	borrow = y >> 32 & 1;  	outputBits [i] = (uint)y;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Subtract,The following statement contains a magic number: borrow = y >> 32 & 1;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Subtract,The following statement contains a magic number: for (; i < left.wordCount; i++) {  	y = (ulong)left.bits [i] - borrow;  	borrow = y >> 32 & 1;  	outputBits [i] = (uint)y;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Subtract,The following statement contains a magic number: borrow = y >> 32 & 1;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,LeftShift,The following statement contains a magic number: for (int i = 0; i < value.wordCount; i++) {  	uint word = value.bits [i];  	outputBits [i + wordShift] = (word << bitShift) | carry;  	carry = bitShift == 0 ? 0 : word >> (32 - bitShift);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,LeftShift,The following statement contains a magic number: carry = bitShift == 0 ? 0 : word >> (32 - bitShift);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,RightShift,The following statement contains a magic number: for (int i = value.wordCount - 1; i >= wordShift; i--) {  	uint word = value.bits [i];  	outputBits [i - wordShift] = (word >> bitShift) | (carry << (32 - bitShift));  	carry = word & (((uint)1 << bitShift) - 1);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,RightShift,The following statement contains a magic number: outputBits [i - wordShift] = (word >> bitShift) | (carry << (32 - bitShift));  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,MultiplyAdd,The following statement contains a magic number: for (int i = 0; i < b.wordCount; i++) {  	ulong temp = b.bits [i] * (ulong)m + carry;  	carry = (uint)(temp >> 32);  	outputBits [i] = (uint)temp;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,MultiplyAdd,The following statement contains a magic number: carry = (uint)(temp >> 32);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,MultiplyPow5,The following statement contains a magic number: if ((k & 3) != 0)  	b = MultiplyAdd (b' powersOfFive [(k & 3) - 1]' 0);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,MultiplyPow5,The following statement contains a magic number: if ((k & 3) != 0)  	b = MultiplyAdd (b' powersOfFive [(k & 3) - 1]' 0);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,MultiplyPow5,The following statement contains a magic number: b = MultiplyAdd (b' powersOfFive [(k & 3) - 1]' 0);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,MultiplyPow5,The following statement contains a magic number: if ((k >>= 2) == 0)  	return b;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,MultiplyPow5,The following statement contains a magic number: p5 = new BigInteger (625);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: dividend = BigInteger.LeftShift (dividend' 8);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: divisor = BigInteger.LeftShift (divisor' 8);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  	other = BigInteger.LeftShift (other' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  	other = BigInteger.LeftShift (other' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  	other = BigInteger.LeftShift (other' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  	other = BigInteger.LeftShift (other' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: if (leadingZeroCount < 4 || leadingZeroCount > 28) {  	dividend = BigInteger.LeftShift (dividend' 8);  	divisor = BigInteger.LeftShift (divisor' 8);  	other = BigInteger.LeftShift (other' 8);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: dividend = BigInteger.LeftShift (dividend' 8);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: divisor = BigInteger.LeftShift (divisor' 8);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,SetupQuorum,The following statement contains a magic number: other = BigInteger.LeftShift (other' 8);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: if (q != 0) {  	ulong borrow = 0;  	ulong carry = 0;  	for (int i = 0; i < divisor.wordCount; i++) {  		ulong ys = divisor.bits [i] * (ulong)q + carry;  		carry = ys >> 32;  		ulong y = dividend.bits [i] - (ys & 0xFFFFFFFF) - borrow;  		borrow = y >> 32 & 1;  		dividend.bits [i] = (uint)y;  	}  	while (dividend.wordCount > 1 && dividend.bits [dividend.wordCount - 1] == 0)  		dividend.wordCount--;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: if (q != 0) {  	ulong borrow = 0;  	ulong carry = 0;  	for (int i = 0; i < divisor.wordCount; i++) {  		ulong ys = divisor.bits [i] * (ulong)q + carry;  		carry = ys >> 32;  		ulong y = dividend.bits [i] - (ys & 0xFFFFFFFF) - borrow;  		borrow = y >> 32 & 1;  		dividend.bits [i] = (uint)y;  	}  	while (dividend.wordCount > 1 && dividend.bits [dividend.wordCount - 1] == 0)  		dividend.wordCount--;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: for (int i = 0; i < divisor.wordCount; i++) {  	ulong ys = divisor.bits [i] * (ulong)q + carry;  	carry = ys >> 32;  	ulong y = dividend.bits [i] - (ys & 0xFFFFFFFF) - borrow;  	borrow = y >> 32 & 1;  	dividend.bits [i] = (uint)y;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: for (int i = 0; i < divisor.wordCount; i++) {  	ulong ys = divisor.bits [i] * (ulong)q + carry;  	carry = ys >> 32;  	ulong y = dividend.bits [i] - (ys & 0xFFFFFFFF) - borrow;  	borrow = y >> 32 & 1;  	dividend.bits [i] = (uint)y;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: carry = ys >> 32;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: borrow = y >> 32 & 1;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: if (Compare (dividend' divisor) >= 0) {  	q++;  	ulong borrow = 0;  	ulong carry = 0;  	for (int i = 0; i < divisor.wordCount; i++) {  		ulong ys = divisor.bits [i] + carry;  		carry = ys >> 32;  		ulong y = dividend.bits [i] - (ys & 0xFFFFFFFF) - borrow;  		borrow = y >> 32 & 1;  		dividend.bits [i] = (uint)y;  	}  	while (dividend.wordCount > 1 && dividend.bits [dividend.wordCount - 1] == 0)  		dividend.wordCount--;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: if (Compare (dividend' divisor) >= 0) {  	q++;  	ulong borrow = 0;  	ulong carry = 0;  	for (int i = 0; i < divisor.wordCount; i++) {  		ulong ys = divisor.bits [i] + carry;  		carry = ys >> 32;  		ulong y = dividend.bits [i] - (ys & 0xFFFFFFFF) - borrow;  		borrow = y >> 32 & 1;  		dividend.bits [i] = (uint)y;  	}  	while (dividend.wordCount > 1 && dividend.bits [dividend.wordCount - 1] == 0)  		dividend.wordCount--;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: for (int i = 0; i < divisor.wordCount; i++) {  	ulong ys = divisor.bits [i] + carry;  	carry = ys >> 32;  	ulong y = dividend.bits [i] - (ys & 0xFFFFFFFF) - borrow;  	borrow = y >> 32 & 1;  	dividend.bits [i] = (uint)y;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: for (int i = 0; i < divisor.wordCount; i++) {  	ulong ys = divisor.bits [i] + carry;  	carry = ys >> 32;  	ulong y = dividend.bits [i] - (ys & 0xFFFFFFFF) - borrow;  	borrow = y >> 32 & 1;  	dividend.bits [i] = (uint)y;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: carry = ys >> 32;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Quorem,The following statement contains a magic number: borrow = y >> 32 & 1;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following statement contains a magic number: if (radix < 0 || radix > 36)  	throw new ArgumentOutOfRangeException ("radix");  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following statement contains a magic number: if (radix == 10 && exponent < integerPowersOfTen.Length) {  	// Use a table for quick lookup of powers of 10.  	return new BigInteger (integerPowersOfTen [exponent]);  }  else if (radix == 2) {  	// Power of two is easy.  	return BigInteger.LeftShift (BigInteger.One' exponent);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following statement contains a magic number: if (radix == 10 && exponent < integerPowersOfTen.Length) {  	// Use a table for quick lookup of powers of 10.  	return new BigInteger (integerPowersOfTen [exponent]);  }  else if (radix == 2) {  	// Power of two is easy.  	return BigInteger.LeftShift (BigInteger.One' exponent);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following statement contains a magic number: if (radix == 2) {  	// Power of two is easy.  	return BigInteger.LeftShift (BigInteger.One' exponent);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following statement contains a magic number: switch (exponent) {  case 0:  	return BigInteger.One;  case 1:  	return new BigInteger (radix);  case 2:  	return new BigInteger (radix * radix);  case 3:  	return new BigInteger (radix * radix * radix);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following statement contains a magic number: switch (exponent) {  case 0:  	return BigInteger.One;  case 1:  	return new BigInteger (radix);  case 2:  	return new BigInteger (radix * radix);  case 3:  	return new BigInteger (radix * radix * radix);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following statement contains a magic number: if ((exponent & 1) == 1) {  	// Exponent is odd.  	var temp = Pow (radix' exponent / 2);  	return BigInteger.MultiplyAdd (BigInteger.Multiply (temp' temp)' radix' 0);  }  else {  	// Exponent is even.  	var temp = Pow (radix' exponent / 2);  	return BigInteger.Multiply (temp' temp);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following statement contains a magic number: if ((exponent & 1) == 1) {  	// Exponent is odd.  	var temp = Pow (radix' exponent / 2);  	return BigInteger.MultiplyAdd (BigInteger.Multiply (temp' temp)' radix' 0);  }  else {  	// Exponent is even.  	var temp = Pow (radix' exponent / 2);  	return BigInteger.Multiply (temp' temp);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Log,The following statement contains a magic number: for (int i = value.wordCount - 1; i >= 0; i--) {  	while (highBit != 0) {  		if ((value.bits [i] & highBit) != 0)  			d += residual;  		residual *= 0.5;  		highBit = highBit >> 1;  	}  	highBit = 0x80000000;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Log,The following statement contains a magic number: while (highBit != 0) {  	if ((value.bits [i] & highBit) != 0)  		d += residual;  	residual *= 0.5;  	highBit = highBit >> 1;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Log,The following statement contains a magic number: residual *= 0.5;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Log,The following statement contains a magic number: return ((Math.Log (d) + (0.69314718055994529 * bitCount)) / Math.Log (baseValue));  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Parse,The following statement contains a magic number: for (; i < str.Length; i++) {  	char c = str [i];  	if (c < '0' || c > '9')  		throw new FormatException ("Invalid character in number.");  	result = MultiplyAdd (result' 10' c - '0');  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Parse,The following statement contains a magic number: result = MultiplyAdd (result' 10' c - '0');  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToString,The following statement contains a magic number: if (BigInteger.Compare (divisor' value) > 0) {  	value = BigInteger.MultiplyAdd (value' 10' 0);  	log10--;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToString,The following statement contains a magic number: value = BigInteger.MultiplyAdd (value' 10' 0);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToString,The following statement contains a magic number: for (int i = 0; i <= log10; i++) {  	// value = value / divisor  	int digit = Quorem (ref value' divisor);  	// Append the digit.  	result.Append ((char)(digit + '0'));  	// value = value * 10;  	value = BigInteger.MultiplyAdd (value' 10' 0);  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToString,The following statement contains a magic number: value = BigInteger.MultiplyAdd (value' 10' 0);  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,FromDouble,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,FromDouble,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,FromDouble,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,FromDouble,The following statement contains a magic number: base2Exponent -= 52;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,FromDouble,The following statement contains a magic number: base2Exponent -= 51;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToDouble,The following statement contains a magic number: doubleBits |= (ulong)(bitCount - 53 + 52 + 1023) << 52;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToDouble,The following statement contains a magic number: doubleBits |= (ulong)(bitCount - 53 + 52 + 1023) << 52;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToDouble,The following statement contains a magic number: doubleBits |= (ulong)(bitCount - 53 + 52 + 1023) << 52;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToDouble,The following statement contains a magic number: doubleBits |= (ulong)(bitCount - 53 + 52 + 1023) << 52;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToDouble,The following statement contains a magic number: if (this.sign == -1)  	doubleBits |= (ulong)1 << 63;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,ToDouble,The following statement contains a magic number: doubleBits |= (ulong)1 << 63;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) {  	k = 16;  	value <<= 16;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0) {  	k = 16;  	value <<= 16;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: k = 16;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 16;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFF000000) == 0) {  	k += 8;  	value <<= 8;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFF000000) == 0) {  	k += 8;  	value <<= 8;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: k += 8;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 8;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xF0000000) == 0) {  	k += 4;  	value <<= 4;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xF0000000) == 0) {  	k += 4;  	value <<= 4;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: k += 4;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 4;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xC0000000) == 0) {  	k += 2;  	value <<= 2;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xC0000000) == 0) {  	k += 2;  	value <<= 2;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: k += 2;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 2;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0x80000000) == 0) {  	k++;  	if ((value & 0x40000000) == 0)  		return 32;  }  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0x40000000) == 0)  	return 32;  
Magic Number,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,CountLeadingZeroBits,The following statement contains a magic number: return 32;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (radix == 10) {  	exponent = (int)Math.Floor (Math.Log10 (value));  	// We need to calculate k = floor(log10(x)).  	// log(x)	~=~ log(1.5) + (x-1.5)/1.5 (taylor series approximation)  	// log10(x) ~=~ log(1.5) / log(10) + (x - 1.5) / (1.5 * log(10))  	// d = x * 2^l (1 <= x < 2)  	// log10(d) = l * log10(2) + log10(x)  	// log10(d) ~=~ l * log10(2)           + (x - 1.5) * (1 / (1.5 * log(10)))  + log(1.5) / log(10)  	// log10(d) ~=~ l * 0.301029995663981  + (x - 1.5) * 0.289529654602168      + 0.1760912590558  	// The last term (0.1760912590558) is rounded so that k = floor(log10(x)) or  	// k = floor(log10(x)) + 1 (i.e. it's the exact value or one higher).  	//double log10;  	//if ((int)(bits.LongValue >> MantissaExplicitBits) == 0)  	//{  	//    // The number is denormalized.  	//    int mantissaShift = CountLeadingZeroBits((ulong)mantissa) - (64 - MantissaImplicitBits);  	//    bits.LongValue = (mantissa << mantissaShift) & MantissaMask |  	//        ((long)ExponentBias << MantissaExplicitBits);  	//    // Calculate an overestimate of log-10 of the value.  	//    log10 = (bits.DoubleValue - 1.5) * 0.289529654602168 + 0.1760912590558 +  	//        (base2Exponent - mantissaShift) * 0.301029995663981;  	//}  	//else  	//{  	//    // Set the base-2 exponent to biased zero.  	//    bits.LongValue = (bits.LongValue & ~ExponentMask) | ((long)ExponentBias << MantissaExplicitBits);  	//    // Calculate an overestimate of log-10 of the value.  	//    log10 = (bits.DoubleValue - 1.5) * 0.289529654602168 + 0.1760912590558 + base2Exponent * 0.301029995663981;  	//}  	//// (int)Math.Floor(log10)  	//exponent = (int)log10;  	//if (log10 < 0 && log10 != exponent)  	//    exponent--;  	//if (exponent >= 0 && exponent < tens.Length)  	//{  	//    if (value < tens[exponent])  	//        exponent--;  	//}  }  else  	exponent = (int)Math.Floor (Math.Log (value' radix));  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (radix == 10 && style == Style.Regular) {  	// Do we have a small integer?  	if (base2Exponent >= 0 && exponent <= 14) {  		// Yes.  		for (int i = exponent; i >= 0; i--) {  			double scaleFactor = tens [i];  			int digit = (int)(value / scaleFactor);  			result.Append ((char)(digit + '0'));  			value -= digit * scaleFactor;  		}  		return result.ToString ();  	}  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (radix == 10 && style == Style.Regular) {  	// Do we have a small integer?  	if (base2Exponent >= 0 && exponent <= 14) {  		// Yes.  		for (int i = exponent; i >= 0; i--) {  			double scaleFactor = tens [i];  			int digit = (int)(value / scaleFactor);  			result.Append ((char)(digit + '0'));  			value -= digit * scaleFactor;  		}  		return result.ToString ();  	}  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (base2Exponent >= 0 && exponent <= 14) {  	// Yes.  	for (int i = exponent; i >= 0; i--) {  		double scaleFactor = tens [i];  		int digit = (int)(value / scaleFactor);  		result.Append ((char)(digit + '0'));  		value -= digit * scaleFactor;  	}  	return result.ToString ();  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (style == Style.Fixed && exponent >= 21)  	style = Style.Regular;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (radix == 10 && style != Style.Fixed)  	lowExponentThreshold = -7;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (radix == 10 && style != Style.Fixed)  	lowExponentThreshold = -7;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: lowExponentThreshold = -7;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (radix == 10 && style == Style.Regular)  	highExponentThreshold = 21;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (radix == 10 && style == Style.Regular)  	highExponentThreshold = 21;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: highExponentThreshold = 21;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: for (; digitsOutput < maxDigitsToOutput && rounded == false; digitsOutput++) {  	// Calculate the next digit.  	var digit = (int)BigInteger.Quorem (ref scaledValue' divisor);  	if (BigInteger.Compare (scaledValue' errorDelta) <= 0 && BigInteger.Compare (scaledValue' halfDivisor) < 0) {  		// Round down.  		rounded = true;  	}  	else if (BigInteger.Compare (BigInteger.Subtract (divisor' scaledValue)' errorDelta) <= 0) {  		// Round up.  		rounded = true;  		digit++;  		if (digit == radix) {  			digit = 1;  			exponent++;  			integralDigits++;  		}  	}  	if (digit > 0 || decimalPointOutput == false) {  		// Check if the decimal point should be output.  		if (decimalPointOutput == false && (scientificNotation == true || digitsOutput == integralDigits)) {  			result.Append (numberFormatInfo.NumberDecimalSeparator);  			decimalPointOutput = true;  		}  		// Output any pent-up zeros.  		if (zeroCount > 0) {  			result.Append ('0'' zeroCount);  			zeroCount = 0;  		}  		// Output the next digit.  		if (digit < 10)  			result.Append ((char)(digit + '0'));  		else  			result.Append ((char)(digit - 10 + 'a'));  	}  	else  		zeroCount++;  	// Check whether the number should be displayed in scientific notation (we cannot  	// determine this up front for large exponents because the number might get rounded  	// up to cross the threshold).  	if (digitsOutput == 0 && (exponent <= lowExponentThreshold || exponent >= highExponentThreshold))  		scientificNotation = true;  	scaledValue = BigInteger.MultiplyAdd (scaledValue' radix' 0);  	errorDelta = BigInteger.MultiplyAdd (errorDelta' radix' 0);  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: for (; digitsOutput < maxDigitsToOutput && rounded == false; digitsOutput++) {  	// Calculate the next digit.  	var digit = (int)BigInteger.Quorem (ref scaledValue' divisor);  	if (BigInteger.Compare (scaledValue' errorDelta) <= 0 && BigInteger.Compare (scaledValue' halfDivisor) < 0) {  		// Round down.  		rounded = true;  	}  	else if (BigInteger.Compare (BigInteger.Subtract (divisor' scaledValue)' errorDelta) <= 0) {  		// Round up.  		rounded = true;  		digit++;  		if (digit == radix) {  			digit = 1;  			exponent++;  			integralDigits++;  		}  	}  	if (digit > 0 || decimalPointOutput == false) {  		// Check if the decimal point should be output.  		if (decimalPointOutput == false && (scientificNotation == true || digitsOutput == integralDigits)) {  			result.Append (numberFormatInfo.NumberDecimalSeparator);  			decimalPointOutput = true;  		}  		// Output any pent-up zeros.  		if (zeroCount > 0) {  			result.Append ('0'' zeroCount);  			zeroCount = 0;  		}  		// Output the next digit.  		if (digit < 10)  			result.Append ((char)(digit + '0'));  		else  			result.Append ((char)(digit - 10 + 'a'));  	}  	else  		zeroCount++;  	// Check whether the number should be displayed in scientific notation (we cannot  	// determine this up front for large exponents because the number might get rounded  	// up to cross the threshold).  	if (digitsOutput == 0 && (exponent <= lowExponentThreshold || exponent >= highExponentThreshold))  		scientificNotation = true;  	scaledValue = BigInteger.MultiplyAdd (scaledValue' radix' 0);  	errorDelta = BigInteger.MultiplyAdd (errorDelta' radix' 0);  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (digit > 0 || decimalPointOutput == false) {  	// Check if the decimal point should be output.  	if (decimalPointOutput == false && (scientificNotation == true || digitsOutput == integralDigits)) {  		result.Append (numberFormatInfo.NumberDecimalSeparator);  		decimalPointOutput = true;  	}  	// Output any pent-up zeros.  	if (zeroCount > 0) {  		result.Append ('0'' zeroCount);  		zeroCount = 0;  	}  	// Output the next digit.  	if (digit < 10)  		result.Append ((char)(digit + '0'));  	else  		result.Append ((char)(digit - 10 + 'a'));  }  else  	zeroCount++;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (digit > 0 || decimalPointOutput == false) {  	// Check if the decimal point should be output.  	if (decimalPointOutput == false && (scientificNotation == true || digitsOutput == integralDigits)) {  		result.Append (numberFormatInfo.NumberDecimalSeparator);  		decimalPointOutput = true;  	}  	// Output any pent-up zeros.  	if (zeroCount > 0) {  		result.Append ('0'' zeroCount);  		zeroCount = 0;  	}  	// Output the next digit.  	if (digit < 10)  		result.Append ((char)(digit + '0'));  	else  		result.Append ((char)(digit - 10 + 'a'));  }  else  	zeroCount++;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (digit < 10)  	result.Append ((char)(digit + '0'));  else  	result.Append ((char)(digit - 10 + 'a'));  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: if (digit < 10)  	result.Append ((char)(digit + '0'));  else  	result.Append ((char)(digit - 10 + 'a'));  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following statement contains a magic number: result.Append ((char)(digit - 10 + 'a'));  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CalculateError,The following statement contains a magic number: if (base2Exponent < 53)  	return BitConverter.Int64BitsToDouble (1L << (base2Exponent - 1));  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CalculateError,The following statement contains a magic number: return BitConverter.Int64BitsToDouble ((long)(base2Exponent - 52) << 52);  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CalculateError,The following statement contains a magic number: return BitConverter.Int64BitsToDouble ((long)(base2Exponent - 52) << 52);  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ScaleToInteger,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ScaleToInteger,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ScaleToInteger,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ScaleToInteger,The following statement contains a magic number: base2Exponent -= 52;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ScaleToInteger,The following statement contains a magic number: base2Exponent -= 51;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFFFFFFFF00000000) == 0) {  	k = 32;  	value <<= 32;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFFFFFFFF00000000) == 0) {  	k = 32;  	value <<= 32;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: k = 32;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 32;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFFFF000000000000) == 0) {  	k += 16;  	value <<= 16;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFFFF000000000000) == 0) {  	k += 16;  	value <<= 16;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: k += 16;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 16;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFF00000000000000) == 0) {  	k += 8;  	value <<= 8;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xFF00000000000000) == 0) {  	k += 8;  	value <<= 8;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: k += 8;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 8;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xF000000000000000) == 0) {  	k += 4;  	value <<= 4;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xF000000000000000) == 0) {  	k += 4;  	value <<= 4;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: k += 4;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 4;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xC000000000000000) == 0) {  	k += 2;  	value <<= 2;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0xC000000000000000) == 0) {  	k += 2;  	value <<= 2;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: k += 2;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: value <<= 2;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0x8000000000000000) == 0) {  	k++;  	if ((value & 0x4000000000000000) == 0)  		return 64;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: if ((value & 0x4000000000000000) == 0)  	return 64;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountLeadingZeroBits,The following statement contains a magic number: return 64;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 7) != 0) {  	if ((value & 1) != 0)  		return 0;  	if ((value & 2) != 0) {  		value >>= 1;  		return 1;  	}  	value >>= 2;  	return 2;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 7) != 0) {  	if ((value & 1) != 0)  		return 0;  	if ((value & 2) != 0) {  		value >>= 1;  		return 1;  	}  	value >>= 2;  	return 2;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 7) != 0) {  	if ((value & 1) != 0)  		return 0;  	if ((value & 2) != 0) {  		value >>= 1;  		return 1;  	}  	value >>= 2;  	return 2;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 7) != 0) {  	if ((value & 1) != 0)  		return 0;  	if ((value & 2) != 0) {  		value >>= 1;  		return 1;  	}  	value >>= 2;  	return 2;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 2) != 0) {  	value >>= 1;  	return 1;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: value >>= 2;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: return 2;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0xFFFFFFFF) == 0) {  	k = 32;  	value >>= 32;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0xFFFFFFFF) == 0) {  	k = 32;  	value >>= 32;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: k = 32;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: value >>= 32;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0xFFFF) == 0) {  	k += 16;  	value >>= 16;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0xFFFF) == 0) {  	k += 16;  	value >>= 16;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: k += 16;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: value >>= 16;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0xFF) == 0) {  	k += 8;  	value >>= 8;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0xFF) == 0) {  	k += 8;  	value >>= 8;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: k += 8;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: value >>= 8;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0xF) == 0) {  	k += 4;  	value >>= 4;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0xF) == 0) {  	k += 4;  	value >>= 4;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: k += 4;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: value >>= 4;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0x3) == 0) {  	k += 2;  	value >>= 2;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 0x3) == 0) {  	k += 2;  	value >>= 2;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: k += 2;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: value >>= 2;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if ((value & 1) == 0) {  	k++;  	value >>= 1;  	if (value == 0)  		return 32;  }  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: if (value == 0)  	return 32;  
Magic Number,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,CountTrailingZeroBits,The following statement contains a magic number: return 32;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,CoerceToNumber,The following statement contains a magic number: if (firstChar == 'I') {  	string restOfString1 = reader.ReadToEnd ();  	if (restOfString1.StartsWith ("nfinity"' StringComparison.Ordinal) == true) {  		// Check the end of the string for junk.  		for (int i = 7; i < restOfString1.Length; i++)  			if (IsWhiteSpaceOrLineTerminator (restOfString1 [i]) == false)  				return double.NaN;  		return negative ? double.NegativeInfinity : double.PositiveInfinity;  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,CoerceToNumber,The following statement contains a magic number: if (restOfString1.StartsWith ("nfinity"' StringComparison.Ordinal) == true) {  	// Check the end of the string for junk.  	for (int i = 7; i < restOfString1.Length; i++)  		if (IsWhiteSpaceOrLineTerminator (restOfString1 [i]) == false)  			return double.NaN;  	return negative ? double.NegativeInfinity : double.PositiveInfinity;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,CoerceToNumber,The following statement contains a magic number: for (int i = 7; i < restOfString1.Length; i++)  	if (IsWhiteSpaceOrLineTerminator (restOfString1 [i]) == false)  		return double.NaN;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar >= '0' && firstChar <= '9') {  	desired1 = firstChar - '0';  	totalDigits = 1;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar >= '0' && firstChar <= '9') {  	desired1 = firstChar - '0';  	totalDigits = 1;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar >= '0' && firstChar <= '9') {  	desired1 = firstChar - '0';  	totalDigits = 1;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar >= '0' && firstChar <= '9') {  	desired1 = firstChar - '0';  	totalDigits = 1;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar >= '0' && firstChar <= '9') {  	desired1 = firstChar - '0';  	totalDigits = 1;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired1 = desired1 * 10 + (c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired2 = desired2 * 10 + (c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar == '.' || reader.Peek () == '.') {  	// Skip past the period.  	if (firstChar != '.')  		reader.Read ();  	// Read the fractional component.  	int fractionalDigits = 0;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  		fractionalDigits++;  		exponentBase10--;  	}  	// Check if the number consists solely of a period.  	if (totalDigits == 0) {  		status = ParseCoreStatus.NoDigits;  		return double.NaN;  	}  	// Check if the number has a period but no digits afterwards.  	if (fractionalDigits == 0)  		status = ParseCoreStatus.NoFraction;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar == '.' || reader.Peek () == '.') {  	// Skip past the period.  	if (firstChar != '.')  		reader.Read ();  	// Read the fractional component.  	int fractionalDigits = 0;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  		fractionalDigits++;  		exponentBase10--;  	}  	// Check if the number consists solely of a period.  	if (totalDigits == 0) {  		status = ParseCoreStatus.NoDigits;  		return double.NaN;  	}  	// Check if the number has a period but no digits afterwards.  	if (fractionalDigits == 0)  		status = ParseCoreStatus.NoFraction;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar == '.' || reader.Peek () == '.') {  	// Skip past the period.  	if (firstChar != '.')  		reader.Read ();  	// Read the fractional component.  	int fractionalDigits = 0;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  		fractionalDigits++;  		exponentBase10--;  	}  	// Check if the number consists solely of a period.  	if (totalDigits == 0) {  		status = ParseCoreStatus.NoDigits;  		return double.NaN;  	}  	// Check if the number has a period but no digits afterwards.  	if (fractionalDigits == 0)  		status = ParseCoreStatus.NoFraction;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar == '.' || reader.Peek () == '.') {  	// Skip past the period.  	if (firstChar != '.')  		reader.Read ();  	// Read the fractional component.  	int fractionalDigits = 0;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  		fractionalDigits++;  		exponentBase10--;  	}  	// Check if the number consists solely of a period.  	if (totalDigits == 0) {  		status = ParseCoreStatus.NoDigits;  		return double.NaN;  	}  	// Check if the number has a period but no digits afterwards.  	if (fractionalDigits == 0)  		status = ParseCoreStatus.NoFraction;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstChar == '.' || reader.Peek () == '.') {  	// Skip past the period.  	if (firstChar != '.')  		reader.Read ();  	// Read the fractional component.  	int fractionalDigits = 0;  	while (true) {  		int c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		if (totalDigits < 9)  			desired1 = desired1 * 10 + (c - '0');  		else if (totalDigits < 18)  			desired2 = desired2 * 10 + (c - '0');  		else  			desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  		totalDigits++;  		fractionalDigits++;  		exponentBase10--;  	}  	// Check if the number consists solely of a period.  	if (totalDigits == 0) {  		status = ParseCoreStatus.NoDigits;  		return double.NaN;  	}  	// Check if the number has a period but no digits afterwards.  	if (fractionalDigits == 0)  		status = ParseCoreStatus.NoFraction;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  	fractionalDigits++;  	exponentBase10--;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  	fractionalDigits++;  	exponentBase10--;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  	fractionalDigits++;  	exponentBase10--;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  	fractionalDigits++;  	exponentBase10--;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	if (totalDigits < 9)  		desired1 = desired1 * 10 + (c - '0');  	else if (totalDigits < 18)  		desired2 = desired2 * 10 + (c - '0');  	else  		desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  	totalDigits++;  	fractionalDigits++;  	exponentBase10--;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 9)  	desired1 = desired1 * 10 + (c - '0');  else if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired1 = desired1 * 10 + (c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 18)  	desired2 = desired2 * 10 + (c - '0');  else  	desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired2 = desired2 * 10 + (c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired3 = BigInteger.MultiplyAdd (desired3' 10' c - '0');  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (reader.Peek () == 'e' || reader.Peek () == 'E') {  	// Skip past the 'e'.  	reader.Read ();  	// Read the sign of the exponent.  	bool exponentNegative = false;  	int c = reader.Peek ();  	if (c == '+')  		reader.Read ();  	else if (c == '-') {  		reader.Read ();  		exponentNegative = true;  	}  	// Read the first character of the exponent.  	int firstExponentChar = reader.Read ();  	// Check there is a number after the 'e'.  	int exponent = 0;  	if (firstExponentChar < '0' || firstExponentChar > '9') {  		status = ParseCoreStatus.NoExponent;  	}  	else {  		// Read the rest of the exponent.  		exponent = firstExponentChar - '0';  		int exponentDigits = 1;  		while (true) {  			c = reader.Peek ();  			if (c < '0' || c > '9')  				break;  			reader.Read ();  			exponent = Math.Min (exponent * 10 + (c - '0')' 9999);  			exponentDigits++;  		}  		// JSON does not allow a leading zero in front of the exponent.  		if (firstExponentChar == '0' && exponentDigits > 1 && status == ParseCoreStatus.Success)  			status = ParseCoreStatus.ExponentHasLeadingZero;  	}  	// Keep track of the overall base-10 exponent.  	exponentBase10 += exponentNegative ? -exponent : exponent;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (reader.Peek () == 'e' || reader.Peek () == 'E') {  	// Skip past the 'e'.  	reader.Read ();  	// Read the sign of the exponent.  	bool exponentNegative = false;  	int c = reader.Peek ();  	if (c == '+')  		reader.Read ();  	else if (c == '-') {  		reader.Read ();  		exponentNegative = true;  	}  	// Read the first character of the exponent.  	int firstExponentChar = reader.Read ();  	// Check there is a number after the 'e'.  	int exponent = 0;  	if (firstExponentChar < '0' || firstExponentChar > '9') {  		status = ParseCoreStatus.NoExponent;  	}  	else {  		// Read the rest of the exponent.  		exponent = firstExponentChar - '0';  		int exponentDigits = 1;  		while (true) {  			c = reader.Peek ();  			if (c < '0' || c > '9')  				break;  			reader.Read ();  			exponent = Math.Min (exponent * 10 + (c - '0')' 9999);  			exponentDigits++;  		}  		// JSON does not allow a leading zero in front of the exponent.  		if (firstExponentChar == '0' && exponentDigits > 1 && status == ParseCoreStatus.Success)  			status = ParseCoreStatus.ExponentHasLeadingZero;  	}  	// Keep track of the overall base-10 exponent.  	exponentBase10 += exponentNegative ? -exponent : exponent;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstExponentChar < '0' || firstExponentChar > '9') {  	status = ParseCoreStatus.NoExponent;  }  else {  	// Read the rest of the exponent.  	exponent = firstExponentChar - '0';  	int exponentDigits = 1;  	while (true) {  		c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		exponent = Math.Min (exponent * 10 + (c - '0')' 9999);  		exponentDigits++;  	}  	// JSON does not allow a leading zero in front of the exponent.  	if (firstExponentChar == '0' && exponentDigits > 1 && status == ParseCoreStatus.Success)  		status = ParseCoreStatus.ExponentHasLeadingZero;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (firstExponentChar < '0' || firstExponentChar > '9') {  	status = ParseCoreStatus.NoExponent;  }  else {  	// Read the rest of the exponent.  	exponent = firstExponentChar - '0';  	int exponentDigits = 1;  	while (true) {  		c = reader.Peek ();  		if (c < '0' || c > '9')  			break;  		reader.Read ();  		exponent = Math.Min (exponent * 10 + (c - '0')' 9999);  		exponentDigits++;  	}  	// JSON does not allow a leading zero in front of the exponent.  	if (firstExponentChar == '0' && exponentDigits > 1 && status == ParseCoreStatus.Success)  		status = ParseCoreStatus.ExponentHasLeadingZero;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	exponent = Math.Min (exponent * 10 + (c - '0')' 9999);  	exponentDigits++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: while (true) {  	c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	exponent = Math.Min (exponent * 10 + (c - '0')' 9999);  	exponentDigits++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: exponent = Math.Min (exponent * 10 + (c - '0')' 9999);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: exponent = Math.Min (exponent * 10 + (c - '0')' 9999);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 16) {  	// Combine desired1 and desired2 to produce an integer representing the final  	// result.  	result = (double)((long)desired1 * integerPowersOfTen [Math.Max (totalDigits - 9' 0)] + desired2);  }  else {  	// Combine desired1' desired2 and desired3 to produce an integer representing the  	// final result.  	var temp = desired3;  	desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  	if (totalDigits > 18) {  		desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  		desired3 = BigInteger.Add (desired3' temp);  	}  	result = desired3.ToDouble ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 16) {  	// Combine desired1 and desired2 to produce an integer representing the final  	// result.  	result = (double)((long)desired1 * integerPowersOfTen [Math.Max (totalDigits - 9' 0)] + desired2);  }  else {  	// Combine desired1' desired2 and desired3 to produce an integer representing the  	// final result.  	var temp = desired3;  	desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  	if (totalDigits > 18) {  		desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  		desired3 = BigInteger.Add (desired3' temp);  	}  	result = desired3.ToDouble ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 16) {  	// Combine desired1 and desired2 to produce an integer representing the final  	// result.  	result = (double)((long)desired1 * integerPowersOfTen [Math.Max (totalDigits - 9' 0)] + desired2);  }  else {  	// Combine desired1' desired2 and desired3 to produce an integer representing the  	// final result.  	var temp = desired3;  	desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  	if (totalDigits > 18) {  		desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  		desired3 = BigInteger.Add (desired3' temp);  	}  	result = desired3.ToDouble ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 16) {  	// Combine desired1 and desired2 to produce an integer representing the final  	// result.  	result = (double)((long)desired1 * integerPowersOfTen [Math.Max (totalDigits - 9' 0)] + desired2);  }  else {  	// Combine desired1' desired2 and desired3 to produce an integer representing the  	// final result.  	var temp = desired3;  	desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  	if (totalDigits > 18) {  		desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  		desired3 = BigInteger.Add (desired3' temp);  	}  	result = desired3.ToDouble ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 16) {  	// Combine desired1 and desired2 to produce an integer representing the final  	// result.  	result = (double)((long)desired1 * integerPowersOfTen [Math.Max (totalDigits - 9' 0)] + desired2);  }  else {  	// Combine desired1' desired2 and desired3 to produce an integer representing the  	// final result.  	var temp = desired3;  	desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  	if (totalDigits > 18) {  		desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  		desired3 = BigInteger.Add (desired3' temp);  	}  	result = desired3.ToDouble ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 16) {  	// Combine desired1 and desired2 to produce an integer representing the final  	// result.  	result = (double)((long)desired1 * integerPowersOfTen [Math.Max (totalDigits - 9' 0)] + desired2);  }  else {  	// Combine desired1' desired2 and desired3 to produce an integer representing the  	// final result.  	var temp = desired3;  	desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  	if (totalDigits > 18) {  		desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  		desired3 = BigInteger.Add (desired3' temp);  	}  	result = desired3.ToDouble ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits < 16) {  	// Combine desired1 and desired2 to produce an integer representing the final  	// result.  	result = (double)((long)desired1 * integerPowersOfTen [Math.Max (totalDigits - 9' 0)] + desired2);  }  else {  	// Combine desired1' desired2 and desired3 to produce an integer representing the  	// final result.  	var temp = desired3;  	desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  	if (totalDigits > 18) {  		desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  		desired3 = BigInteger.Add (desired3' temp);  	}  	result = desired3.ToDouble ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: result = (double)((long)desired1 * integerPowersOfTen [Math.Max (totalDigits - 9' 0)] + desired2);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired3 = new BigInteger ((long)desired1 * integerPowersOfTen [Math.Min (totalDigits - 9' 9)] + desired2);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits > 18) {  	desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  	desired3 = BigInteger.Add (desired3' temp);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits > 18) {  	desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  	desired3 = BigInteger.Add (desired3' temp);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits > 18) {  	desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  	desired3 = BigInteger.Add (desired3' temp);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: desired3 = BigInteger.Multiply (desired3' BigInteger.Pow (10' totalDigits - 18));  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 > 0)  	result *= Math.Pow (10' exponentBase10);  else if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 > 0)  	result *= Math.Pow (10' exponentBase10);  else if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 > 0)  	result *= Math.Pow (10' exponentBase10);  else if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 > 0)  	result *= Math.Pow (10' exponentBase10);  else if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 > 0)  	result *= Math.Pow (10' exponentBase10);  else if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 > 0)  	result *= Math.Pow (10' exponentBase10);  else if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 > 0)  	result *= Math.Pow (10' exponentBase10);  else if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 > 0)  	result *= Math.Pow (10' exponentBase10);  else if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: result *= Math.Pow (10' exponentBase10);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < 0 && exponentBase10 >= -308)  	result /= Math.Pow (10' -exponentBase10);  else if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: result /= Math.Pow (10' -exponentBase10);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (exponentBase10 < -308) {  	// Note: 10^308 is the largest representable power of ten.  	result /= Math.Pow (10' 308);  	result /= Math.Pow (10' -exponentBase10 - 308);  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: result /= Math.Pow (10' 308);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: result /= Math.Pow (10' 308);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: result /= Math.Pow (10' -exponentBase10 - 308);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: result /= Math.Pow (10' -exponentBase10 - 308);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseCore,The following statement contains a magic number: if (totalDigits >= 16)  	return RefineEstimate (result' exponentBase10' desired3);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (radix == 0)  	radix = 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: radix = 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (stripPrefix == true) {  	if (reader.Peek () == '0') {  		reader.Read ();  		digitCount = 1;  		// Note: required for parsing "0z11" correctly (when radix = 0).  		int c = reader.Peek ();  		if (c == 'x' || c == 'X') {  			// Hex number.  			reader.Read ();  			radix = 16;  		}  		if (c >= '0' && c <= '9' && allowOctal == true) {  			// Octal number.  			radix = 8;  		}  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (stripPrefix == true) {  	if (reader.Peek () == '0') {  		reader.Read ();  		digitCount = 1;  		// Note: required for parsing "0z11" correctly (when radix = 0).  		int c = reader.Peek ();  		if (c == 'x' || c == 'X') {  			// Hex number.  			reader.Read ();  			radix = 16;  		}  		if (c >= '0' && c <= '9' && allowOctal == true) {  			// Octal number.  			radix = 8;  		}  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (reader.Peek () == '0') {  	reader.Read ();  	digitCount = 1;  	// Note: required for parsing "0z11" correctly (when radix = 0).  	int c = reader.Peek ();  	if (c == 'x' || c == 'X') {  		// Hex number.  		reader.Read ();  		radix = 16;  	}  	if (c >= '0' && c <= '9' && allowOctal == true) {  		// Octal number.  		radix = 8;  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (reader.Peek () == '0') {  	reader.Read ();  	digitCount = 1;  	// Note: required for parsing "0z11" correctly (when radix = 0).  	int c = reader.Peek ();  	if (c == 'x' || c == 'X') {  		// Hex number.  		reader.Read ();  		radix = 16;  	}  	if (c >= '0' && c <= '9' && allowOctal == true) {  		// Octal number.  		radix = 8;  	}  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (c == 'x' || c == 'X') {  	// Hex number.  	reader.Read ();  	radix = 16;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: radix = 16;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (c >= '0' && c <= '9' && allowOctal == true) {  	// Octal number.  	radix = 8;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: radix = 8;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: while (true) {  	int numericValue = -1;  	int c = reader.Read ();  	if (c >= '0' && c <= '9')  		numericValue = c - '0';  	if (c >= 'a' && c <= 'z')  		numericValue = c - 'a' + 10;  	if (c >= 'A' && c <= 'Z')  		numericValue = c - 'A' + 10;  	if (numericValue == -1 || numericValue >= radix)  		break;  	if (digitCount == maxDigits)  		bigResult = BigInteger.FromDouble (result);  	result = result * radix + numericValue;  	if (digitCount >= maxDigits)  		bigResult = BigInteger.MultiplyAdd (bigResult' radix' numericValue);  	digitCount++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: while (true) {  	int numericValue = -1;  	int c = reader.Read ();  	if (c >= '0' && c <= '9')  		numericValue = c - '0';  	if (c >= 'a' && c <= 'z')  		numericValue = c - 'a' + 10;  	if (c >= 'A' && c <= 'Z')  		numericValue = c - 'A' + 10;  	if (numericValue == -1 || numericValue >= radix)  		break;  	if (digitCount == maxDigits)  		bigResult = BigInteger.FromDouble (result);  	result = result * radix + numericValue;  	if (digitCount >= maxDigits)  		bigResult = BigInteger.MultiplyAdd (bigResult' radix' numericValue);  	digitCount++;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (c >= 'a' && c <= 'z')  	numericValue = c - 'a' + 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: numericValue = c - 'a' + 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: if (c >= 'A' && c <= 'Z')  	numericValue = c - 'A' + 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseInt,The following statement contains a magic number: numericValue = c - 'A' + 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c >= '0' && c <= '9')  		result = result * 16 + c - '0';  	else if (c >= 'a' && c <= 'f')  		result = result * 16 + c - 'a' + 10;  	else if (c >= 'A' && c <= 'F')  		result = result * 16 + c - 'A' + 10;  	else  		break;  	digitsRead++;  	reader.Read ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c >= '0' && c <= '9')  		result = result * 16 + c - '0';  	else if (c >= 'a' && c <= 'f')  		result = result * 16 + c - 'a' + 10;  	else if (c >= 'A' && c <= 'F')  		result = result * 16 + c - 'A' + 10;  	else  		break;  	digitsRead++;  	reader.Read ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c >= '0' && c <= '9')  		result = result * 16 + c - '0';  	else if (c >= 'a' && c <= 'f')  		result = result * 16 + c - 'a' + 10;  	else if (c >= 'A' && c <= 'F')  		result = result * 16 + c - 'A' + 10;  	else  		break;  	digitsRead++;  	reader.Read ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c >= '0' && c <= '9')  		result = result * 16 + c - '0';  	else if (c >= 'a' && c <= 'f')  		result = result * 16 + c - 'a' + 10;  	else if (c >= 'A' && c <= 'F')  		result = result * 16 + c - 'A' + 10;  	else  		break;  	digitsRead++;  	reader.Read ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c >= '0' && c <= '9')  		result = result * 16 + c - '0';  	else if (c >= 'a' && c <= 'f')  		result = result * 16 + c - 'a' + 10;  	else if (c >= 'A' && c <= 'F')  		result = result * 16 + c - 'A' + 10;  	else  		break;  	digitsRead++;  	reader.Read ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= '0' && c <= '9')  	result = result * 16 + c - '0';  else if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= '0' && c <= '9')  	result = result * 16 + c - '0';  else if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= '0' && c <= '9')  	result = result * 16 + c - '0';  else if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= '0' && c <= '9')  	result = result * 16 + c - '0';  else if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= '0' && c <= '9')  	result = result * 16 + c - '0';  else if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: result = result * 16 + c - '0';  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= 'a' && c <= 'f')  	result = result * 16 + c - 'a' + 10;  else if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: result = result * 16 + c - 'a' + 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: result = result * 16 + c - 'a' + 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: if (c >= 'A' && c <= 'F')  	result = result * 16 + c - 'A' + 10;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: result = result * 16 + c - 'A' + 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseHex,The following statement contains a magic number: result = result * 16 + c - 'A' + 10;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseOctal,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c >= '0' && c <= '7')  		result = result * 8 + c - '0';  	else if (c == '8' || c == '9')  		return double.NaN;  	else  		break;  	reader.Read ();  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseOctal,The following statement contains a magic number: if (c >= '0' && c <= '7')  	result = result * 8 + c - '0';  else if (c == '8' || c == '9')  	return double.NaN;  else  	break;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseOctal,The following statement contains a magic number: result = result * 8 + c - '0';  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,IsWhiteSpaceOrLineTerminator,The following statement contains a magic number: return c == 9 || c == 0x0b || c == 0x0c || c == ' ' || c == 0xa0 || c == 0xfeff || c == 0x1680 || c == 0x180e || (c >= 0x2000 && c <= 0x200a) || c == 0x202f || c == 0x205f || c == 0x3000 || c == 0x0a || c == 0x0d || c == 0x2028 || c == 0x2029;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: if (base10Exponent < 0)  	multiplier = BigInteger.Pow (10' -base10Exponent);  else if (base10Exponent > 0)  	desiredValue = BigInteger.Multiply (desiredValue' BigInteger.Pow (10' base10Exponent));  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: if (base10Exponent < 0)  	multiplier = BigInteger.Pow (10' -base10Exponent);  else if (base10Exponent > 0)  	desiredValue = BigInteger.Multiply (desiredValue' BigInteger.Pow (10' base10Exponent));  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: multiplier = BigInteger.Pow (10' -base10Exponent);  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: if (base10Exponent > 0)  	desiredValue = BigInteger.Multiply (desiredValue' BigInteger.Pow (10' base10Exponent));  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: desiredValue = BigInteger.Multiply (desiredValue' BigInteger.Pow (10' base10Exponent));  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: while (precision <= 160) {  	// Scale the candidate values to a big integer.  	var actual1 = ScaleToInteger (result' multiplier' precision);  	var actual2 = ScaleToInteger (result2' multiplier' precision);  	// Calculate the differences between the candidate values and the desired value.  	var baseline = BigInteger.LeftShift (desiredValue' precision);  	var diff1 = BigInteger.Subtract (actual1' baseline);  	var diff2 = BigInteger.Subtract (actual2' baseline);  	if (diff1.Sign == direction && diff2.Sign == direction) {  		// We're going the wrong way!  		direction = -direction;  		result2 = AddUlps (result' direction);  	}  	else if (diff1.Sign == -direction && diff2.Sign == -direction) {  		// Going the right way' but need to go further.  		result = result2;  		result2 = AddUlps (result' direction);  	}  	else {  		// Found two values that bracket the actual value.  		// If one candidate value is closer to the actual value by at least 2 (one  		// doesn't cut it because of the integer division) then use that value.  		diff1 = BigInteger.Abs (diff1);  		diff2 = BigInteger.Abs (diff2);  		if (BigInteger.Compare (diff1' BigInteger.Subtract (diff2' BigInteger.One)) < 0)  			return result;  		if (BigInteger.Compare (diff2' BigInteger.Subtract (diff1' BigInteger.One)) < 0)  			return result2;  		// Not enough precision to determine the correct answer' or it's a halfway case.  		// Increase the precision.  		precision += 32;  	}  	// If result2 is NaN then we have gone too far.  	if (double.IsNaN (result2) == true)  		return result;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: while (precision <= 160) {  	// Scale the candidate values to a big integer.  	var actual1 = ScaleToInteger (result' multiplier' precision);  	var actual2 = ScaleToInteger (result2' multiplier' precision);  	// Calculate the differences between the candidate values and the desired value.  	var baseline = BigInteger.LeftShift (desiredValue' precision);  	var diff1 = BigInteger.Subtract (actual1' baseline);  	var diff2 = BigInteger.Subtract (actual2' baseline);  	if (diff1.Sign == direction && diff2.Sign == direction) {  		// We're going the wrong way!  		direction = -direction;  		result2 = AddUlps (result' direction);  	}  	else if (diff1.Sign == -direction && diff2.Sign == -direction) {  		// Going the right way' but need to go further.  		result = result2;  		result2 = AddUlps (result' direction);  	}  	else {  		// Found two values that bracket the actual value.  		// If one candidate value is closer to the actual value by at least 2 (one  		// doesn't cut it because of the integer division) then use that value.  		diff1 = BigInteger.Abs (diff1);  		diff2 = BigInteger.Abs (diff2);  		if (BigInteger.Compare (diff1' BigInteger.Subtract (diff2' BigInteger.One)) < 0)  			return result;  		if (BigInteger.Compare (diff2' BigInteger.Subtract (diff1' BigInteger.One)) < 0)  			return result2;  		// Not enough precision to determine the correct answer' or it's a halfway case.  		// Increase the precision.  		precision += 32;  	}  	// If result2 is NaN then we have gone too far.  	if (double.IsNaN (result2) == true)  		return result;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: if (diff1.Sign == direction && diff2.Sign == direction) {  	// We're going the wrong way!  	direction = -direction;  	result2 = AddUlps (result' direction);  }  else if (diff1.Sign == -direction && diff2.Sign == -direction) {  	// Going the right way' but need to go further.  	result = result2;  	result2 = AddUlps (result' direction);  }  else {  	// Found two values that bracket the actual value.  	// If one candidate value is closer to the actual value by at least 2 (one  	// doesn't cut it because of the integer division) then use that value.  	diff1 = BigInteger.Abs (diff1);  	diff2 = BigInteger.Abs (diff2);  	if (BigInteger.Compare (diff1' BigInteger.Subtract (diff2' BigInteger.One)) < 0)  		return result;  	if (BigInteger.Compare (diff2' BigInteger.Subtract (diff1' BigInteger.One)) < 0)  		return result2;  	// Not enough precision to determine the correct answer' or it's a halfway case.  	// Increase the precision.  	precision += 32;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: if (diff1.Sign == -direction && diff2.Sign == -direction) {  	// Going the right way' but need to go further.  	result = result2;  	result2 = AddUlps (result' direction);  }  else {  	// Found two values that bracket the actual value.  	// If one candidate value is closer to the actual value by at least 2 (one  	// doesn't cut it because of the integer division) then use that value.  	diff1 = BigInteger.Abs (diff1);  	diff2 = BigInteger.Abs (diff2);  	if (BigInteger.Compare (diff1' BigInteger.Subtract (diff2' BigInteger.One)) < 0)  		return result;  	if (BigInteger.Compare (diff2' BigInteger.Subtract (diff1' BigInteger.One)) < 0)  		return result2;  	// Not enough precision to determine the correct answer' or it's a halfway case.  	// Increase the precision.  	precision += 32;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,RefineEstimate,The following statement contains a magic number: precision += 32;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ScaleToInteger,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ScaleToInteger,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ScaleToInteger,The following statement contains a magic number: if (base2Exponent > -1023) {  	mantissa |= 0x10000000000000;  	base2Exponent -= 52;  }  else {  	// Denormals.  	base2Exponent -= 51;  }  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ScaleToInteger,The following statement contains a magic number: base2Exponent -= 52;  
Magic Number,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ScaleToInteger,The following statement contains a magic number: base2Exponent -= 51;  
Magic Number,Jurassic,TypeConverter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeConverter.cs,ToString,The following statement contains a magic number: if (value is double) {  	// Check if the value is in the cache.  	double doubleValue = (double)value;  	var cache = numberToStringCache;  	if (doubleValue == cache.Value)  		return cache.Result;  	// Convert the number to a string.  	var result = NumberFormatter.ToString ((double)value' 10' NumberFormatter.Style.Regular);  	// Cache the result.  	// This is thread-safe on Intel but not architectures with weak write ordering.  	numberToStringCache = new NumberToStringCache () {  		Value = doubleValue'  		Result = result  	};  	return result;  }  
Magic Number,Jurassic,TypeConverter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeConverter.cs,ToInteger,The following statement contains a magic number: if (num > 2147483647.0)  	return 2147483647;  
Magic Number,Jurassic,TypeConverter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeConverter.cs,ToInteger,The following statement contains a magic number: if (num > 2147483647.0)  	return 2147483647;  
Magic Number,Jurassic,TypeConverter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\TypeConverter.cs,ToInteger,The following statement contains a magic number: return 2147483647;  
Magic Number,Jurassic.Library,StandardConsoleOutput,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\FirebugConsole\StandardConsoleOutput.cs,StartGroup,The following statement contains a magic number: this.CurrentIndentation = Math.Min (this.CurrentIndentation + this.IndentationDelta' 40);  
Magic Number,Jurassic.Library,FirebugConsole,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\FirebugConsole\FirebugConsole.cs,FormatObjects,The following statement contains a magic number: if (items [0] is string) {  	string formatString = (string)items [0];  	int previousPatternIndex = 0' patternIndex;  	while (items.Length > itemsConsumed) {  		// Find a percent sign.  		patternIndex = formatString.IndexOf ('%'' previousPatternIndex);  		if (patternIndex == -1 || patternIndex == formatString.Length - 1)  			break;  		// Append the text that didn't contain a pattern to the result.  		formattedString.Append (formatString' previousPatternIndex' patternIndex - previousPatternIndex);  		// Extract the pattern type.  		char patternType = formatString [patternIndex + 1];  		// Determine the replacement string.  		string replacement;  		switch (patternType) {  		case 's':  			replacement = TypeConverter.ToString (items [itemsConsumed++]);  			break;  		case 'd':  		case 'i':  			var number = TypeConverter.ToNumber (items [itemsConsumed++]);  			replacement = (number >= 0 ? Math.Floor (number) : Math.Ceiling (number)).ToString ();  			break;  		case 'f':  			replacement = TypeConverter.ToNumber (items [itemsConsumed++]).ToString ();  			break;  		case '%':  			replacement = "%";  			break;  		case 'o':  			replacement = string.Empty;  			if (formattedString.Length > 0)  				result.Add (formattedString.ToString ());  			result.Add (items [itemsConsumed++]);  			formattedString.Remove (0' formattedString.Length);  			break;  		default:  			replacement = "%" + patternType;  			break;  		}  		// Replace the pattern with the corresponding argument.  		formattedString.Append (replacement);  		// Start searching just after the end of the pattern.  		previousPatternIndex = patternIndex + 2;  	}  	// Append the text that didn't contain a pattern to the result.  	formattedString.Append (formatString' previousPatternIndex' formatString.Length - previousPatternIndex);  	// Add the formatted string to the resulting array.  	if (formattedString.Length > 0)  		result.Add (formattedString.ToString ());  	// Append the items that weren't consumed to the end of the resulting array.  	for (int i = itemsConsumed; i < items.Length; i++)  		result.Add (items [i]);  	return result.ToArray ();  }  else {  	// The first item is not a string - just return the objects verbatim.  	return items;  }  
Magic Number,Jurassic.Library,FirebugConsole,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\FirebugConsole\FirebugConsole.cs,FormatObjects,The following statement contains a magic number: while (items.Length > itemsConsumed) {  	// Find a percent sign.  	patternIndex = formatString.IndexOf ('%'' previousPatternIndex);  	if (patternIndex == -1 || patternIndex == formatString.Length - 1)  		break;  	// Append the text that didn't contain a pattern to the result.  	formattedString.Append (formatString' previousPatternIndex' patternIndex - previousPatternIndex);  	// Extract the pattern type.  	char patternType = formatString [patternIndex + 1];  	// Determine the replacement string.  	string replacement;  	switch (patternType) {  	case 's':  		replacement = TypeConverter.ToString (items [itemsConsumed++]);  		break;  	case 'd':  	case 'i':  		var number = TypeConverter.ToNumber (items [itemsConsumed++]);  		replacement = (number >= 0 ? Math.Floor (number) : Math.Ceiling (number)).ToString ();  		break;  	case 'f':  		replacement = TypeConverter.ToNumber (items [itemsConsumed++]).ToString ();  		break;  	case '%':  		replacement = "%";  		break;  	case 'o':  		replacement = string.Empty;  		if (formattedString.Length > 0)  			result.Add (formattedString.ToString ());  		result.Add (items [itemsConsumed++]);  		formattedString.Remove (0' formattedString.Length);  		break;  	default:  		replacement = "%" + patternType;  		break;  	}  	// Replace the pattern with the corresponding argument.  	formattedString.Append (replacement);  	// Start searching just after the end of the pattern.  	previousPatternIndex = patternIndex + 2;  }  
Magic Number,Jurassic.Library,FirebugConsole,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\FirebugConsole\FirebugConsole.cs,FormatObjects,The following statement contains a magic number: previousPatternIndex = patternIndex + 2;  
Magic Number,Jurassic.Library,JSONSerializer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONSerializer.cs,SerializePropertyValue,The following statement contains a magic number: if (value is double) {  	if (double.IsInfinity ((double)value) == true || double.IsNaN ((double)value))  		result.Append ("null");  	else  		result.Append (NumberFormatter.ToString ((double)value' 10' NumberFormatter.Style.Regular));  	return;  }  
Magic Number,Jurassic.Library,JSONSerializer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONSerializer.cs,SerializePropertyValue,The following statement contains a magic number: if (double.IsInfinity ((double)value) == true || double.IsNaN ((double)value))  	result.Append ("null");  else  	result.Append (NumberFormatter.ToString ((double)value' 10' NumberFormatter.Style.Regular));  
Magic Number,Jurassic.Library,JSONSerializer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONSerializer.cs,SerializePropertyValue,The following statement contains a magic number: result.Append (NumberFormatter.ToString ((double)value' 10' NumberFormatter.Style.Regular));  
Magic Number,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadInteger,The following statement contains a magic number: while (true) {  	int c = this.reader.Peek ();  	if (c < '0' || c > '9')  		break;  	this.reader.Read ();  	digitsRead++;  	result = result * 10 + (c - '0');  }  
Magic Number,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadInteger,The following statement contains a magic number: result = result * 10 + (c - '0');  
Magic Number,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadStringLiteral,The following statement contains a magic number: while (true) {  	int c = this.reader.Read ();  	if (c == '"')  		break;  	if (c == -1)  		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected end of input in string literal");  	if (c < 0x20)  		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected character in string literal");  	if (c == '\\') {  		// Escape sequence.  		c = this.reader.Read ();  		switch (c) {  		case '\"':  			// Double quote.  			contents.Append ('\"');  			break;  		case '/':  			// Slash.  			contents.Append ('/');  			break;  		case '\\':  			// Backslash.  			contents.Append ('\\');  			break;  		case 'b':  			// Backspace.  			contents.Append ((char)0x08);  			break;  		case 'f':  			// Form feed.  			contents.Append ((char)0x0C);  			break;  		case 'n':  			// Line feed.  			contents.Append ((char)0x0A);  			break;  		case 'r':  			// Carriage return.  			contents.Append ((char)0x0D);  			break;  		case 't':  			// Horizontal tab.  			contents.Append ((char)0x09);  			break;  		case 'u':  			// Unicode escape sequence.  			contents.Append (ReadHexNumber (4));  			break;  		default:  			throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected character in escape sequence.");  		}  	}  	else {  		contents.Append ((char)c);  	}  }  
Magic Number,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadStringLiteral,The following statement contains a magic number: if (c == '\\') {  	// Escape sequence.  	c = this.reader.Read ();  	switch (c) {  	case '\"':  		// Double quote.  		contents.Append ('\"');  		break;  	case '/':  		// Slash.  		contents.Append ('/');  		break;  	case '\\':  		// Backslash.  		contents.Append ('\\');  		break;  	case 'b':  		// Backspace.  		contents.Append ((char)0x08);  		break;  	case 'f':  		// Form feed.  		contents.Append ((char)0x0C);  		break;  	case 'n':  		// Line feed.  		contents.Append ((char)0x0A);  		break;  	case 'r':  		// Carriage return.  		contents.Append ((char)0x0D);  		break;  	case 't':  		// Horizontal tab.  		contents.Append ((char)0x09);  		break;  	case 'u':  		// Unicode escape sequence.  		contents.Append (ReadHexNumber (4));  		break;  	default:  		throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected character in escape sequence.");  	}  }  else {  	contents.Append ((char)c);  }  
Magic Number,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadStringLiteral,The following statement contains a magic number: switch (c) {  case '\"':  	// Double quote.  	contents.Append ('\"');  	break;  case '/':  	// Slash.  	contents.Append ('/');  	break;  case '\\':  	// Backslash.  	contents.Append ('\\');  	break;  case 'b':  	// Backspace.  	contents.Append ((char)0x08);  	break;  case 'f':  	// Form feed.  	contents.Append ((char)0x0C);  	break;  case 'n':  	// Line feed.  	contents.Append ((char)0x0A);  	break;  case 'r':  	// Carriage return.  	contents.Append ((char)0x0D);  	break;  case 't':  	// Horizontal tab.  	contents.Append ((char)0x09);  	break;  case 'u':  	// Unicode escape sequence.  	contents.Append (ReadHexNumber (4));  	break;  default:  	throw new JavaScriptException (this.engine' "SyntaxError"' "Unexpected character in escape sequence.");  }  
Magic Number,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadStringLiteral,The following statement contains a magic number: contents.Append (ReadHexNumber (4));  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ArrayInstance,The following statement contains a magic number: if (length <= 1000) {  	this.dense = new object[(int)capacity];  	this.denseMayContainHoles = length > 0;  }  else {  	this.sparse = new SparseArray ();  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: if (digit < 0 || digit > 9)  	return uint.MaxValue;  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: for (int i = 1; i < propertyName.Length; i++) {  	digit = propertyName [i] - '0';  	if (digit < 0 || digit > 9)  		return uint.MaxValue;  	if (result > 429496728) {  		// Largest number 429496728 * 10 + 9 = 4294967289  		// Largest number 429496729 * 10 + 9 = 4294967299  		// Largest valid array index is 4294967294  		if (result != 429496729 || digit > 4)  			return uint.MaxValue;  	}  	result = result * 10 + (uint)digit;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: for (int i = 1; i < propertyName.Length; i++) {  	digit = propertyName [i] - '0';  	if (digit < 0 || digit > 9)  		return uint.MaxValue;  	if (result > 429496728) {  		// Largest number 429496728 * 10 + 9 = 4294967289  		// Largest number 429496729 * 10 + 9 = 4294967299  		// Largest valid array index is 4294967294  		if (result != 429496729 || digit > 4)  			return uint.MaxValue;  	}  	result = result * 10 + (uint)digit;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: for (int i = 1; i < propertyName.Length; i++) {  	digit = propertyName [i] - '0';  	if (digit < 0 || digit > 9)  		return uint.MaxValue;  	if (result > 429496728) {  		// Largest number 429496728 * 10 + 9 = 4294967289  		// Largest number 429496729 * 10 + 9 = 4294967299  		// Largest valid array index is 4294967294  		if (result != 429496729 || digit > 4)  			return uint.MaxValue;  	}  	result = result * 10 + (uint)digit;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: for (int i = 1; i < propertyName.Length; i++) {  	digit = propertyName [i] - '0';  	if (digit < 0 || digit > 9)  		return uint.MaxValue;  	if (result > 429496728) {  		// Largest number 429496728 * 10 + 9 = 4294967289  		// Largest number 429496729 * 10 + 9 = 4294967299  		// Largest valid array index is 4294967294  		if (result != 429496729 || digit > 4)  			return uint.MaxValue;  	}  	result = result * 10 + (uint)digit;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: for (int i = 1; i < propertyName.Length; i++) {  	digit = propertyName [i] - '0';  	if (digit < 0 || digit > 9)  		return uint.MaxValue;  	if (result > 429496728) {  		// Largest number 429496728 * 10 + 9 = 4294967289  		// Largest number 429496729 * 10 + 9 = 4294967299  		// Largest valid array index is 4294967294  		if (result != 429496729 || digit > 4)  			return uint.MaxValue;  	}  	result = result * 10 + (uint)digit;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: if (digit < 0 || digit > 9)  	return uint.MaxValue;  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: if (result > 429496728) {  	// Largest number 429496728 * 10 + 9 = 4294967289  	// Largest number 429496729 * 10 + 9 = 4294967299  	// Largest valid array index is 4294967294  	if (result != 429496729 || digit > 4)  		return uint.MaxValue;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: if (result > 429496728) {  	// Largest number 429496728 * 10 + 9 = 4294967289  	// Largest number 429496729 * 10 + 9 = 4294967299  	// Largest valid array index is 4294967294  	if (result != 429496729 || digit > 4)  		return uint.MaxValue;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: if (result > 429496728) {  	// Largest number 429496728 * 10 + 9 = 4294967289  	// Largest number 429496729 * 10 + 9 = 4294967299  	// Largest valid array index is 4294967294  	if (result != 429496729 || digit > 4)  		return uint.MaxValue;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: if (result != 429496729 || digit > 4)  	return uint.MaxValue;  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: if (result != 429496729 || digit > 4)  	return uint.MaxValue;  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ParseArrayIndex,The following statement contains a magic number: result = result * 10 + (uint)digit;  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (this.dense != null) {  	if (index < this.length) {  		// The index is inside the existing bounds of the array.  		this.dense [index] = value;  	}  	else if (index < this.dense.Length) {  		// The index is outside the bounds of the array but inside the allocated buffer.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  		this.length = index + 1;  	}  	else {  		// The index is out of range - either enlarge the array or switch to sparse.  		if (index < this.dense.Length + 10) {  			// Enlarge the dense array.  			ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  			// Set the value.  			this.dense [index] = value;  			this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  		}  		else {  			// Switch to a sparse array.  			this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  			this.dense = null;  			this.sparse [index] = value;  		}  		// Update the length.  		this.length = index + 1;  	}  }  else {  	// Set the value and update the length.  	this.sparse [index] = value;  	this.length = Math.Max (this.length' index + 1);  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (this.dense != null) {  	if (index < this.length) {  		// The index is inside the existing bounds of the array.  		this.dense [index] = value;  	}  	else if (index < this.dense.Length) {  		// The index is outside the bounds of the array but inside the allocated buffer.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  		this.length = index + 1;  	}  	else {  		// The index is out of range - either enlarge the array or switch to sparse.  		if (index < this.dense.Length + 10) {  			// Enlarge the dense array.  			ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  			// Set the value.  			this.dense [index] = value;  			this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  		}  		else {  			// Switch to a sparse array.  			this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  			this.dense = null;  			this.sparse [index] = value;  		}  		// Update the length.  		this.length = index + 1;  	}  }  else {  	// Set the value and update the length.  	this.sparse [index] = value;  	this.length = Math.Max (this.length' index + 1);  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (this.dense != null) {  	if (index < this.length) {  		// The index is inside the existing bounds of the array.  		this.dense [index] = value;  	}  	else if (index < this.dense.Length) {  		// The index is outside the bounds of the array but inside the allocated buffer.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  		this.length = index + 1;  	}  	else {  		// The index is out of range - either enlarge the array or switch to sparse.  		if (index < this.dense.Length + 10) {  			// Enlarge the dense array.  			ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  			// Set the value.  			this.dense [index] = value;  			this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  		}  		else {  			// Switch to a sparse array.  			this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  			this.dense = null;  			this.sparse [index] = value;  		}  		// Update the length.  		this.length = index + 1;  	}  }  else {  	// Set the value and update the length.  	this.sparse [index] = value;  	this.length = Math.Max (this.length' index + 1);  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.length) {  	// The index is inside the existing bounds of the array.  	this.dense [index] = value;  }  else if (index < this.dense.Length) {  	// The index is outside the bounds of the array but inside the allocated buffer.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	this.length = index + 1;  }  else {  	// The index is out of range - either enlarge the array or switch to sparse.  	if (index < this.dense.Length + 10) {  		// Enlarge the dense array.  		ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  		// Set the value.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	}  	else {  		// Switch to a sparse array.  		this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  		this.dense = null;  		this.sparse [index] = value;  	}  	// Update the length.  	this.length = index + 1;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.length) {  	// The index is inside the existing bounds of the array.  	this.dense [index] = value;  }  else if (index < this.dense.Length) {  	// The index is outside the bounds of the array but inside the allocated buffer.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	this.length = index + 1;  }  else {  	// The index is out of range - either enlarge the array or switch to sparse.  	if (index < this.dense.Length + 10) {  		// Enlarge the dense array.  		ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  		// Set the value.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	}  	else {  		// Switch to a sparse array.  		this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  		this.dense = null;  		this.sparse [index] = value;  	}  	// Update the length.  	this.length = index + 1;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.length) {  	// The index is inside the existing bounds of the array.  	this.dense [index] = value;  }  else if (index < this.dense.Length) {  	// The index is outside the bounds of the array but inside the allocated buffer.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	this.length = index + 1;  }  else {  	// The index is out of range - either enlarge the array or switch to sparse.  	if (index < this.dense.Length + 10) {  		// Enlarge the dense array.  		ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  		// Set the value.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	}  	else {  		// Switch to a sparse array.  		this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  		this.dense = null;  		this.sparse [index] = value;  	}  	// Update the length.  	this.length = index + 1;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.dense.Length) {  	// The index is outside the bounds of the array but inside the allocated buffer.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	this.length = index + 1;  }  else {  	// The index is out of range - either enlarge the array or switch to sparse.  	if (index < this.dense.Length + 10) {  		// Enlarge the dense array.  		ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  		// Set the value.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	}  	else {  		// Switch to a sparse array.  		this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  		this.dense = null;  		this.sparse [index] = value;  	}  	// Update the length.  	this.length = index + 1;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.dense.Length) {  	// The index is outside the bounds of the array but inside the allocated buffer.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	this.length = index + 1;  }  else {  	// The index is out of range - either enlarge the array or switch to sparse.  	if (index < this.dense.Length + 10) {  		// Enlarge the dense array.  		ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  		// Set the value.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	}  	else {  		// Switch to a sparse array.  		this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  		this.dense = null;  		this.sparse [index] = value;  	}  	// Update the length.  	this.length = index + 1;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.dense.Length) {  	// The index is outside the bounds of the array but inside the allocated buffer.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	this.length = index + 1;  }  else {  	// The index is out of range - either enlarge the array or switch to sparse.  	if (index < this.dense.Length + 10) {  		// Enlarge the dense array.  		ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  		// Set the value.  		this.dense [index] = value;  		this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  	}  	else {  		// Switch to a sparse array.  		this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  		this.dense = null;  		this.sparse [index] = value;  	}  	// Update the length.  	this.length = index + 1;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.dense.Length + 10) {  	// Enlarge the dense array.  	ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  	// Set the value.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  }  else {  	// Switch to a sparse array.  	this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  	this.dense = null;  	this.sparse [index] = value;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.dense.Length + 10) {  	// Enlarge the dense array.  	ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  	// Set the value.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  }  else {  	// Switch to a sparse array.  	this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  	this.dense = null;  	this.sparse [index] = value;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: if (index < this.dense.Length + 10) {  	// Enlarge the dense array.  	ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  	// Set the value.  	this.dense [index] = value;  	this.denseMayContainHoles = this.denseMayContainHoles || index > this.length;  }  else {  	// Switch to a sparse array.  	this.sparse = SparseArray.FromDenseArray (this.dense' (int)this.length);  	this.dense = null;  	this.sparse [index] = value;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,SetPropertyValue,The following statement contains a magic number: ResizeDenseArray ((uint)(this.dense.Length * 2 + 10)' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Join,The following statement contains a magic number: if (arrayLength > int.MaxValue / 2)  	throw new JavaScriptException (thisObj.Engine' "RangeError"' "The array is too long");  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: if (this.dense != null) {  	// Get the last value.  	var result = this.dense [this.length];  	// If the element does not exist in this array' it may exist in the prototype.  	if (result == null && this.Prototype != null)  		result = this.Prototype.GetPropertyValue (this.length);  	// Delete it from the array.  	this.dense [this.length] = null;  	// Check if the array should be shrunk.  	if (this.length < this.dense.Length / 2 && this.length > 10)  		ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  	// Return the last value.  	return result;  }  else {  	// Get the last value.  	var result = this.sparse [this.length];  	// If the element does not exist in this array' it may exist in the prototype.  	if (result == null && this.Prototype != null)  		result = this.Prototype.GetPropertyValue (this.length);  	// Delete it from the array.  	this.sparse.Delete (this.length);  	// Return the last value.  	return result;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: if (this.dense != null) {  	// Get the last value.  	var result = this.dense [this.length];  	// If the element does not exist in this array' it may exist in the prototype.  	if (result == null && this.Prototype != null)  		result = this.Prototype.GetPropertyValue (this.length);  	// Delete it from the array.  	this.dense [this.length] = null;  	// Check if the array should be shrunk.  	if (this.length < this.dense.Length / 2 && this.length > 10)  		ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  	// Return the last value.  	return result;  }  else {  	// Get the last value.  	var result = this.sparse [this.length];  	// If the element does not exist in this array' it may exist in the prototype.  	if (result == null && this.Prototype != null)  		result = this.Prototype.GetPropertyValue (this.length);  	// Delete it from the array.  	this.sparse.Delete (this.length);  	// Return the last value.  	return result;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: if (this.dense != null) {  	// Get the last value.  	var result = this.dense [this.length];  	// If the element does not exist in this array' it may exist in the prototype.  	if (result == null && this.Prototype != null)  		result = this.Prototype.GetPropertyValue (this.length);  	// Delete it from the array.  	this.dense [this.length] = null;  	// Check if the array should be shrunk.  	if (this.length < this.dense.Length / 2 && this.length > 10)  		ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  	// Return the last value.  	return result;  }  else {  	// Get the last value.  	var result = this.sparse [this.length];  	// If the element does not exist in this array' it may exist in the prototype.  	if (result == null && this.Prototype != null)  		result = this.Prototype.GetPropertyValue (this.length);  	// Delete it from the array.  	this.sparse.Delete (this.length);  	// Return the last value.  	return result;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: if (this.dense != null) {  	// Get the last value.  	var result = this.dense [this.length];  	// If the element does not exist in this array' it may exist in the prototype.  	if (result == null && this.Prototype != null)  		result = this.Prototype.GetPropertyValue (this.length);  	// Delete it from the array.  	this.dense [this.length] = null;  	// Check if the array should be shrunk.  	if (this.length < this.dense.Length / 2 && this.length > 10)  		ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  	// Return the last value.  	return result;  }  else {  	// Get the last value.  	var result = this.sparse [this.length];  	// If the element does not exist in this array' it may exist in the prototype.  	if (result == null && this.Prototype != null)  		result = this.Prototype.GetPropertyValue (this.length);  	// Delete it from the array.  	this.sparse.Delete (this.length);  	// Return the last value.  	return result;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: if (this.length < this.dense.Length / 2 && this.length > 10)  	ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: if (this.length < this.dense.Length / 2 && this.length > 10)  	ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: if (this.length < this.dense.Length / 2 && this.length > 10)  	ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: if (this.length < this.dense.Length / 2 && this.length > 10)  	ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Pop,The following statement contains a magic number: ResizeDenseArray ((uint)(this.dense.Length / 2 + 10)' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Push,The following statement contains a magic number: if (this.dense != null) {  	// Check if we need to enlarge the array.  	if (this.length == this.dense.Length)  		ResizeDenseArray (this.length * 2 + 10' this.length);  	// Append the new item to the array.  	this.dense [this.length++] = item;  }  else {  	// Append the new item to the array.  	this.sparse [this.length++] = item;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Push,The following statement contains a magic number: if (this.dense != null) {  	// Check if we need to enlarge the array.  	if (this.length == this.dense.Length)  		ResizeDenseArray (this.length * 2 + 10' this.length);  	// Append the new item to the array.  	this.dense [this.length++] = item;  }  else {  	// Append the new item to the array.  	this.sparse [this.length++] = item;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Push,The following statement contains a magic number: if (this.length == this.dense.Length)  	ResizeDenseArray (this.length * 2 + 10' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Push,The following statement contains a magic number: if (this.length == this.dense.Length)  	ResizeDenseArray (this.length * 2 + 10' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Push,The following statement contains a magic number: ResizeDenseArray (this.length * 2 + 10' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Push,The following statement contains a magic number: ResizeDenseArray (this.length * 2 + 10' this.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Reverse,The following statement contains a magic number: for (uint lowIndex = 0; lowIndex < arrayLength / 2; lowIndex++) {  	uint highIndex = arrayLength - lowIndex - 1;  	// Swap the two values.  	object low = thisObj [lowIndex];  	object high = thisObj [highIndex];  	if (high != null)  		thisObj [lowIndex] = high;  	else  		thisObj.Delete (lowIndex' true);  	if (low != null)  		thisObj [highIndex] = low;  	else  		thisObj.Delete (highIndex' true);  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: if (array != null && array.dense != null) {  	// Dense arrays are supported up to 2^32-1.  	if (array.length + items.Length > int.MaxValue)  		throw new JavaScriptException (thisObj.Engine' "RangeError"' "Invalid array length");  	if (array.denseMayContainHoles == true && array.Prototype != null) {  		// Find all the holes and populate them from the prototype.  		for (uint i = 0; i < array.length; i++)  			if (array.dense [i] == null)  				array.dense [i] = array.Prototype.GetPropertyValue (i);  	}  	// Allocate some more space if required.  	if (array.length + items.Length > array.dense.Length)  		array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  	// Shift all the items up.  	Array.Copy (array.dense' 0' array.dense' items.Length' (int)array.length);  	// Prepend the new items.  	for (int i = 0; i < items.Length; i++)  		array.dense [i] = items [i];  	// Update the length property.  	array.length += (uint)items.Length;  	// Return the new length of the array.  	return array.length;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: if (array != null && array.dense != null) {  	// Dense arrays are supported up to 2^32-1.  	if (array.length + items.Length > int.MaxValue)  		throw new JavaScriptException (thisObj.Engine' "RangeError"' "Invalid array length");  	if (array.denseMayContainHoles == true && array.Prototype != null) {  		// Find all the holes and populate them from the prototype.  		for (uint i = 0; i < array.length; i++)  			if (array.dense [i] == null)  				array.dense [i] = array.Prototype.GetPropertyValue (i);  	}  	// Allocate some more space if required.  	if (array.length + items.Length > array.dense.Length)  		array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  	// Shift all the items up.  	Array.Copy (array.dense' 0' array.dense' items.Length' (int)array.length);  	// Prepend the new items.  	for (int i = 0; i < items.Length; i++)  		array.dense [i] = items [i];  	// Update the length property.  	array.length += (uint)items.Length;  	// Return the new length of the array.  	return array.length;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: if (array != null && array.dense != null) {  	// Dense arrays are supported up to 2^32-1.  	if (array.length + items.Length > int.MaxValue)  		throw new JavaScriptException (thisObj.Engine' "RangeError"' "Invalid array length");  	if (array.denseMayContainHoles == true && array.Prototype != null) {  		// Find all the holes and populate them from the prototype.  		for (uint i = 0; i < array.length; i++)  			if (array.dense [i] == null)  				array.dense [i] = array.Prototype.GetPropertyValue (i);  	}  	// Allocate some more space if required.  	if (array.length + items.Length > array.dense.Length)  		array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  	// Shift all the items up.  	Array.Copy (array.dense' 0' array.dense' items.Length' (int)array.length);  	// Prepend the new items.  	for (int i = 0; i < items.Length; i++)  		array.dense [i] = items [i];  	// Update the length property.  	array.length += (uint)items.Length;  	// Return the new length of the array.  	return array.length;  }  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: if (array.length + items.Length > array.dense.Length)  	array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: if (array.length + items.Length > array.dense.Length)  	array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: if (array.length + items.Length > array.dense.Length)  	array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,Unshift,The following statement contains a magic number: array.ResizeDenseArray ((uint)Math.Max (array.dense.Length * 2 + 10' array.length + items.Length * 10)' array.length);  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,ToLocaleString,The following statement contains a magic number: if (arrayLength > int.MaxValue / 2)  	throw new JavaScriptException (thisObj.Engine' "RangeError"' "The array is too long");  
Magic Number,Jurassic.Library,ArrayInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayInstance.cs,QuickSort,The following statement contains a magic number: if (end - start < 30) {  	// Insertion sort is faster than quick sort for small arrays.  	InsertionSort (array' comparer' start' end);  	return;  }  
Magic Number,Jurassic.Library,SparseArray,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\SparseArray.cs,Delete,The following statement contains a magic number: if (p != 41)  	return;  
Magic Number,Jurassic.Library,SparseArray,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\SparseArray.cs,FindOrCreateArray,The following statement contains a magic number: if ((index & this.mask) != index || this.depth == 0) {  	if (writeAccess == false)  		return null;  	// Create one or more new root nodes.  	do {  		var newRoot = new Node ();  		newRoot.array [0] = this.root;  		this.root = newRoot;  		this.depth++;  		this.mask = NodeShift * this.depth >= 32 ? -1 : (1 << NodeShift * this.depth) - 1;  	}  	while ((index & this.mask) != index);  }  
Magic Number,Jurassic.Library,SparseArray,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\SparseArray.cs,FindOrCreateArray,The following statement contains a magic number: do {  	var newRoot = new Node ();  	newRoot.array [0] = this.root;  	this.root = newRoot;  	this.depth++;  	this.mask = NodeShift * this.depth >= 32 ? -1 : (1 << NodeShift * this.depth) - 1;  }  while ((index & this.mask) != index);  
Magic Number,Jurassic.Library,SparseArray,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\SparseArray.cs,FindOrCreateArray,The following statement contains a magic number: this.mask = NodeShift * this.depth >= 32 ? -1 : (1 << NodeShift * this.depth) - 1;  
Magic Number,Jurassic.Library,ArrayConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Array\ArrayConstructor.cs,New,The following statement contains a magic number: return new ArrayInstance (this.InstancePrototype' 0' 10);  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Success == true) {  	// Get the group values.  	int year' month' day' hour' minute' second' millisecond' offsetInMinutes = 0;  	if (int.TryParse (match.Groups ["year"].Value' out year) == false)  		year = 1970;  	if (int.TryParse (match.Groups ["month"].Value' out month) == false)  		month = 1;  	if (int.TryParse (match.Groups ["day"].Value' out day) == false)  		day = 1;  	int.TryParse (match.Groups ["hour"].Value' out hour);  	int.TryParse (match.Groups ["minute"].Value' out minute);  	int.TryParse (match.Groups ["second"].Value' out second);  	int.TryParse (match.Groups ["millisecond"].Value' out millisecond);  	// Validate the components.  	if (month < 1 || month > 12)  		return DateTime.MinValue;  	if (day < 1 || day > 31)  		return DateTime.MinValue;  	if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  		return DateTime.MinValue;  	if (minute >= 60)  		return DateTime.MinValue;  	if (second >= 60)  		return DateTime.MinValue;  	// 24:00 is valid according to the spec.  	if (hour == 24) {  		hour = 0;  		offsetInMinutes += 24 * 60;  	}  	// Parse the zone information (the default is UTC).  	if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  		// Parse the numeric values.  		int zoneHours' zoneMinutes;  		if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  			return DateTime.MinValue;  		if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  			return DateTime.MinValue;  		// Validate the components.  		if (zoneHours >= 24)  			return DateTime.MinValue;  		if (zoneMinutes >= 60)  			return DateTime.MinValue;  		// Calculate the zone offset' in minutes.  		offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  	}  	// Create a date from the components.  	var result = new DateTime (year' month' day' hour' minute' second' millisecond' DateTimeKind.Utc);  	if (offsetInMinutes != 0)  		result = result.AddMinutes (offsetInMinutes);  	return result;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (int.TryParse (match.Groups ["year"].Value' out year) == false)  	year = 1970;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: year = 1970;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (month < 1 || month > 12)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (day < 1 || day > 31)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (hour > 24 || (hour == 24 && (minute > 0 || second > 0 || millisecond > 0)))  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (minute >= 60)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (second >= 60)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (hour == 24) {  	hour = 0;  	offsetInMinutes += 24 * 60;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (hour == 24) {  	hour = 0;  	offsetInMinutes += 24 * 60;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (hour == 24) {  	hour = 0;  	offsetInMinutes += 24 * 60;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: offsetInMinutes += 24 * 60;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: offsetInMinutes += 24 * 60;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  	// Parse the numeric values.  	int zoneHours' zoneMinutes;  	if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  		return DateTime.MinValue;  	if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  		return DateTime.MinValue;  	// Validate the components.  	if (zoneHours >= 24)  		return DateTime.MinValue;  	if (zoneMinutes >= 60)  		return DateTime.MinValue;  	// Calculate the zone offset' in minutes.  	offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  	// Parse the numeric values.  	int zoneHours' zoneMinutes;  	if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  		return DateTime.MinValue;  	if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  		return DateTime.MinValue;  	// Validate the components.  	if (zoneHours >= 24)  		return DateTime.MinValue;  	if (zoneMinutes >= 60)  		return DateTime.MinValue;  	// Calculate the zone offset' in minutes.  	offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  	// Parse the numeric values.  	int zoneHours' zoneMinutes;  	if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  		return DateTime.MinValue;  	if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  		return DateTime.MinValue;  	// Validate the components.  	if (zoneHours >= 24)  		return DateTime.MinValue;  	if (zoneMinutes >= 60)  		return DateTime.MinValue;  	// Calculate the zone offset' in minutes.  	offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (match.Groups ["zone"].Value != string.Empty && match.Groups ["zone"].Value != "Z") {  	// Parse the numeric values.  	int zoneHours' zoneMinutes;  	if (int.TryParse (match.Groups ["zoneHours"].Value' out zoneHours) == false)  		return DateTime.MinValue;  	if (int.TryParse (match.Groups ["zoneMinutes"].Value' out zoneMinutes) == false)  		return DateTime.MinValue;  	// Validate the components.  	if (zoneHours >= 24)  		return DateTime.MinValue;  	if (zoneMinutes >= 60)  		return DateTime.MinValue;  	// Calculate the zone offset' in minutes.  	offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (zoneHours >= 24)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: if (zoneMinutes >= 60)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,Parse,The following statement contains a magic number: offsetInMinutes -= zoneHours < 0 ? zoneHours * 60 - zoneMinutes : zoneHours * 60 + zoneMinutes;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: for (int i = 0; i < words.Length; i++) {  	string word = words [i];  	// Check if the word is a number.  	int numericValue;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  		// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  		kind = DateTimeKind.Utc;  		if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  			word = word.Substring (3);  		// Time zone offset is [+-]hhmm.  Convert to minutes.  		int timeZoneOffset;  		int.TryParse (word' out timeZoneOffset);  		offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  	}  	else if (monthNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a month name' guess the word is a month.  		month = numericValue;  	}  	else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  		// If the word is a time zone name' the word is a zone.  		kind = DateTimeKind.Utc;  		offsetInMinutes -= numericValue * 60;  	}  	else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  	}  	else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  		// This is a 12-hour time.  		twelveHourTime = true;  		offsetInMinutes = 60 * 12;  	}  	else if (int.TryParse (word' out numericValue) == true) {  		// Guess that a number >= 1000 is the year.  		if (numericValue >= 1000)  			year = numericValue;  		else  			unclassifiedNumbers.Add (numericValue);  	}  	else if (word.IndexOfAny (new char[] {  		'/''  		'-'  	}) >= 0) {  		// If the word contains a slash or a dash' guess the word is a date.  		string[] components = word.Split ('/'' '-');  		if (components.Length != 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out month) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out day) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [2]' out year) == false)  			return DateTime.MinValue;  	}  	else if (word.IndexOf (':') >= 0) {  		// If the word contains a colon' guess the word is a time.  		string[] components = word.Split (':');  		if (components.Length < 2 || components.Length > 3)  			return DateTime.MinValue;  		if (int.TryParse (components [0]' out hour) == false)  			return DateTime.MinValue;  		if (int.TryParse (components [1]' out minute) == false)  			return DateTime.MinValue;  		if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  			return DateTime.MinValue;  	}  	else if (dayOfWeekNames.Contains (word) == true) {  		// Day of week name is ignored.  	}  	else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  		// Extraneous text can start with a parenthesis' this will stop parsing.  		break;  	}  	else {  		// Error.  		return DateTime.MinValue;  	}  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("+"' StringComparison.Ordinal) || word.StartsWith ("-"' StringComparison.Ordinal)) {  	// If the word starts with 'GMT'' 'UTC'' '+'' '-' then guess it is a zone.  	kind = DateTimeKind.Utc;  	if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  		word = word.Substring (3);  	// Time zone offset is [+-]hhmm.  Convert to minutes.  	int timeZoneOffset;  	int.TryParse (word' out timeZoneOffset);  	offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  }  else if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.StartsWith ("GMT"' StringComparison.OrdinalIgnoreCase) || word.StartsWith ("UTC"' StringComparison.OrdinalIgnoreCase))  	word = word.Substring (3);  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: word = word.Substring (3);  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: offsetInMinutes -= (timeZoneOffset / 100) * 60 + (timeZoneOffset % 100);  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (monthNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a month name' guess the word is a month.  	month = numericValue;  }  else if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (timeZoneNames.TryGetValue (word' out numericValue) == true) {  	// If the word is a time zone name' the word is a zone.  	kind = DateTimeKind.Utc;  	offsetInMinutes -= numericValue * 60;  }  else if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: offsetInMinutes -= numericValue * 60;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("AM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  }  else if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.Equals ("PM"' StringComparison.OrdinalIgnoreCase)) {  	// This is a 12-hour time.  	twelveHourTime = true;  	offsetInMinutes = 60 * 12;  }  else if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: offsetInMinutes = 60 * 12;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: offsetInMinutes = 60 * 12;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (int.TryParse (word' out numericValue) == true) {  	// Guess that a number >= 1000 is the year.  	if (numericValue >= 1000)  		year = numericValue;  	else  		unclassifiedNumbers.Add (numericValue);  }  else if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (numericValue >= 1000)  	year = numericValue;  else  	unclassifiedNumbers.Add (numericValue);  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOfAny (new char[] {  	'/''  	'-'  }) >= 0) {  	// If the word contains a slash or a dash' guess the word is a date.  	string[] components = word.Split ('/'' '-');  	if (components.Length != 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out month) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out day) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [2]' out year) == false)  		return DateTime.MinValue;  }  else if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (components.Length != 3)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (int.TryParse (components [2]' out year) == false)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (word.IndexOf (':') >= 0) {  	// If the word contains a colon' guess the word is a time.  	string[] components = word.Split (':');  	if (components.Length < 2 || components.Length > 3)  		return DateTime.MinValue;  	if (int.TryParse (components [0]' out hour) == false)  		return DateTime.MinValue;  	if (int.TryParse (components [1]' out minute) == false)  		return DateTime.MinValue;  	if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  		return DateTime.MinValue;  }  else if (dayOfWeekNames.Contains (word) == true) {  	// Day of week name is ignored.  }  else if (word.StartsWith ("("' StringComparison.Ordinal) == true) {  	// Extraneous text can start with a parenthesis' this will stop parsing.  	break;  }  else {  	// Error.  	return DateTime.MinValue;  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (components.Length < 2 || components.Length > 3)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (components.Length < 2 || components.Length > 3)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (components.Length >= 3 && int.TryParse (components [2]' out second) == false)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (year == -1) {  	if (unclassifiedNumbers.Count == 0)  		return DateTime.MinValue;  	year = unclassifiedNumbers [0];  	if (year >= 70 && year < 100)  		year += 1900;  	// two digit dates are okay from 1970 - 1999.  	unclassifiedNumbers.RemoveAt (0);  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (year == -1) {  	if (unclassifiedNumbers.Count == 0)  		return DateTime.MinValue;  	year = unclassifiedNumbers [0];  	if (year >= 70 && year < 100)  		year += 1900;  	// two digit dates are okay from 1970 - 1999.  	unclassifiedNumbers.RemoveAt (0);  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (year == -1) {  	if (unclassifiedNumbers.Count == 0)  		return DateTime.MinValue;  	year = unclassifiedNumbers [0];  	if (year >= 70 && year < 100)  		year += 1900;  	// two digit dates are okay from 1970 - 1999.  	unclassifiedNumbers.RemoveAt (0);  }  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (year >= 70 && year < 100)  	year += 1900;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (year >= 70 && year < 100)  	year += 1900;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (year >= 70 && year < 100)  	year += 1900;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: year += 1900;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (year < 70)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (month < 1 || month > 12)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (day < 1 || day > 31)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (hour >= 24 || (twelveHourTime && hour >= 13))  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (hour >= 24 || (twelveHourTime && hour >= 13))  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (minute >= 60)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (second >= 60)  	return DateTime.MinValue;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,ParseUnstructured,The following statement contains a magic number: if (twelveHourTime && hour == 12)  	hour = 0;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,PopulateMonthNames,The following statement contains a magic number: for (int i = 0; i < 12; i++)  	monthNames [abbreviatedNames [i]] = i + 1;  
Magic Number,Jurassic.Library,DateParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateParser.cs,PopulateMonthNames,The following statement contains a magic number: for (int i = 0; i < 12; i++)  	monthNames [fullNames [i]] = i + 1;  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: if (spacer is double)  	serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((double)spacer)' 10)' 0));  else if (spacer is int)  	serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((int)spacer)' 10)' 0));  else if (spacer is string)  	serializer.Indentation = ((string)spacer).Substring (0' Math.Min (((string)spacer).Length' 10));  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: if (spacer is double)  	serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((double)spacer)' 10)' 0));  else if (spacer is int)  	serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((int)spacer)' 10)' 0));  else if (spacer is string)  	serializer.Indentation = ((string)spacer).Substring (0' Math.Min (((string)spacer).Length' 10));  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: if (spacer is double)  	serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((double)spacer)' 10)' 0));  else if (spacer is int)  	serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((int)spacer)' 10)' 0));  else if (spacer is string)  	serializer.Indentation = ((string)spacer).Substring (0' Math.Min (((string)spacer).Length' 10));  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((double)spacer)' 10)' 0));  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: if (spacer is int)  	serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((int)spacer)' 10)' 0));  else if (spacer is string)  	serializer.Indentation = ((string)spacer).Substring (0' Math.Min (((string)spacer).Length' 10));  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: if (spacer is int)  	serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((int)spacer)' 10)' 0));  else if (spacer is string)  	serializer.Indentation = ((string)spacer).Substring (0' Math.Min (((string)spacer).Length' 10));  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: serializer.Indentation = new string (' '' Math.Max (Math.Min (TypeConverter.ToInteger ((int)spacer)' 10)' 0));  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: if (spacer is string)  	serializer.Indentation = ((string)spacer).Substring (0' Math.Min (((string)spacer).Length' 10));  
Magic Number,Jurassic.Library,JSONObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONObject.cs,Stringify,The following statement contains a magic number: serializer.Indentation = ((string)spacer).Substring (0' Math.Min (((string)spacer).Length' 10));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Escape,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '@' || c == '*' || c == '_' || c == '+' || c == '-' || c == '.' || c == '/')  		result.Append (c);  	else if (c < 256)  		result.AppendFormat ("%{0:X2}"' (int)c);  	else  		result.AppendFormat ("%u{0:X4}"' (int)c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Escape,The following statement contains a magic number: if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '@' || c == '*' || c == '_' || c == '+' || c == '-' || c == '.' || c == '/')  	result.Append (c);  else if (c < 256)  	result.AppendFormat ("%{0:X2}"' (int)c);  else  	result.AppendFormat ("%u{0:X4}"' (int)c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Escape,The following statement contains a magic number: if (c < 256)  	result.AppendFormat ("%{0:X2}"' (int)c);  else  	result.AppendFormat ("%u{0:X4}"' (int)c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseInt,The following statement contains a magic number: if (radix2 < 0 || radix2 == 1 || radix2 > 36)  	return double.NaN;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// Make sure the string is long enough.  		if (i == input.Length - 1)  			break;  		if (input [i + 1] == 'u') {  			// 4 digit escape sequence %uXXXX.  			int value = ParseHexNumber (input' i + 2' 4);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 5;  		}  		else {  			// 2 digit escape sequence %XX.  			int value = ParseHexNumber (input' i + 1' 2);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 2;  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// Make sure the string is long enough.  		if (i == input.Length - 1)  			break;  		if (input [i + 1] == 'u') {  			// 4 digit escape sequence %uXXXX.  			int value = ParseHexNumber (input' i + 2' 4);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 5;  		}  		else {  			// 2 digit escape sequence %XX.  			int value = ParseHexNumber (input' i + 1' 2);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 2;  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// Make sure the string is long enough.  		if (i == input.Length - 1)  			break;  		if (input [i + 1] == 'u') {  			// 4 digit escape sequence %uXXXX.  			int value = ParseHexNumber (input' i + 2' 4);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 5;  		}  		else {  			// 2 digit escape sequence %XX.  			int value = ParseHexNumber (input' i + 1' 2);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 2;  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// Make sure the string is long enough.  		if (i == input.Length - 1)  			break;  		if (input [i + 1] == 'u') {  			// 4 digit escape sequence %uXXXX.  			int value = ParseHexNumber (input' i + 2' 4);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 5;  		}  		else {  			// 2 digit escape sequence %XX.  			int value = ParseHexNumber (input' i + 1' 2);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 2;  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// Make sure the string is long enough.  		if (i == input.Length - 1)  			break;  		if (input [i + 1] == 'u') {  			// 4 digit escape sequence %uXXXX.  			int value = ParseHexNumber (input' i + 2' 4);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 5;  		}  		else {  			// 2 digit escape sequence %XX.  			int value = ParseHexNumber (input' i + 1' 2);  			if (value < 0) {  				result.Append ('%');  				continue;  			}  			result.Append ((char)value);  			i += 2;  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (c == '%') {  	// Make sure the string is long enough.  	if (i == input.Length - 1)  		break;  	if (input [i + 1] == 'u') {  		// 4 digit escape sequence %uXXXX.  		int value = ParseHexNumber (input' i + 2' 4);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 5;  	}  	else {  		// 2 digit escape sequence %XX.  		int value = ParseHexNumber (input' i + 1' 2);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 2;  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (c == '%') {  	// Make sure the string is long enough.  	if (i == input.Length - 1)  		break;  	if (input [i + 1] == 'u') {  		// 4 digit escape sequence %uXXXX.  		int value = ParseHexNumber (input' i + 2' 4);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 5;  	}  	else {  		// 2 digit escape sequence %XX.  		int value = ParseHexNumber (input' i + 1' 2);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 2;  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (c == '%') {  	// Make sure the string is long enough.  	if (i == input.Length - 1)  		break;  	if (input [i + 1] == 'u') {  		// 4 digit escape sequence %uXXXX.  		int value = ParseHexNumber (input' i + 2' 4);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 5;  	}  	else {  		// 2 digit escape sequence %XX.  		int value = ParseHexNumber (input' i + 1' 2);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 2;  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (c == '%') {  	// Make sure the string is long enough.  	if (i == input.Length - 1)  		break;  	if (input [i + 1] == 'u') {  		// 4 digit escape sequence %uXXXX.  		int value = ParseHexNumber (input' i + 2' 4);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 5;  	}  	else {  		// 2 digit escape sequence %XX.  		int value = ParseHexNumber (input' i + 1' 2);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 2;  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (c == '%') {  	// Make sure the string is long enough.  	if (i == input.Length - 1)  		break;  	if (input [i + 1] == 'u') {  		// 4 digit escape sequence %uXXXX.  		int value = ParseHexNumber (input' i + 2' 4);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 5;  	}  	else {  		// 2 digit escape sequence %XX.  		int value = ParseHexNumber (input' i + 1' 2);  		if (value < 0) {  			result.Append ('%');  			continue;  		}  		result.Append ((char)value);  		i += 2;  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (input [i + 1] == 'u') {  	// 4 digit escape sequence %uXXXX.  	int value = ParseHexNumber (input' i + 2' 4);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 5;  }  else {  	// 2 digit escape sequence %XX.  	int value = ParseHexNumber (input' i + 1' 2);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 2;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (input [i + 1] == 'u') {  	// 4 digit escape sequence %uXXXX.  	int value = ParseHexNumber (input' i + 2' 4);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 5;  }  else {  	// 2 digit escape sequence %XX.  	int value = ParseHexNumber (input' i + 1' 2);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 2;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (input [i + 1] == 'u') {  	// 4 digit escape sequence %uXXXX.  	int value = ParseHexNumber (input' i + 2' 4);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 5;  }  else {  	// 2 digit escape sequence %XX.  	int value = ParseHexNumber (input' i + 1' 2);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 2;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (input [i + 1] == 'u') {  	// 4 digit escape sequence %uXXXX.  	int value = ParseHexNumber (input' i + 2' 4);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 5;  }  else {  	// 2 digit escape sequence %XX.  	int value = ParseHexNumber (input' i + 1' 2);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 2;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: if (input [i + 1] == 'u') {  	// 4 digit escape sequence %uXXXX.  	int value = ParseHexNumber (input' i + 2' 4);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 5;  }  else {  	// 2 digit escape sequence %XX.  	int value = ParseHexNumber (input' i + 1' 2);  	if (value < 0) {  		result.Append ('%');  		continue;  	}  	result.Append ((char)value);  	i += 2;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: i += 5;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Unescape,The following statement contains a magic number: i += 2;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	char c = input [i];  	if (c == '%') {  		// 2 digit escape sequence %XX.  		// Decode the %XX encoding.  		int utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		i += 2;  		// If the high bit is not set' then this is a single byte ASCII character.  		if ((utf8Byte & 0x80) == 0) {  			// Decode only if the character is not reserved.  			if (reservedSet [utf8Byte] == true) {  				// Leave the escape sequence as is.  				result.Append (input.Substring (i - 2' 3));  			}  			else {  				result.Append ((char)utf8Byte);  			}  		}  		else {  			// Otherwise' this character was encoded to multiple bytes.  			// Check for an invalid UTF-8 start value.  			if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Count the number of high bits set (this is the number of bytes required for the character).  			int utf8ByteCount = 1;  			for (int j = 6; j >= 0; j--) {  				if ((utf8Byte & (1 << j)) != 0)  					utf8ByteCount++;  				else  					break;  			}  			if (utf8ByteCount < 2 || utf8ByteCount > 4)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Read the additional bytes.  			byte[] utf8Bytes = new byte[utf8ByteCount];  			utf8Bytes [0] = (byte)utf8Byte;  			for (int j = 1; j < utf8ByteCount; j++) {  				// An additional escape sequence is expected.  				if (i >= input.Length - 1 || input [++i] != '%')  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Decode the %XX encoding.  				utf8Byte = ParseHexNumber (input' i + 1' 2);  				if (utf8Byte < 0)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  				if ((utf8Byte & 0xC0) != 0x80)  					throw new JavaScriptException (engine' "URIError"' "URI malformed");  				// Store the byte.  				utf8Bytes [j] = (byte)utf8Byte;  				// Update the character position.  				i += 2;  			}  			// Decode the UTF-8 sequence.  			result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  		}  	}  	else  		result.Append (c);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (c == '%') {  	// 2 digit escape sequence %XX.  	// Decode the %XX encoding.  	int utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	i += 2;  	// If the high bit is not set' then this is a single byte ASCII character.  	if ((utf8Byte & 0x80) == 0) {  		// Decode only if the character is not reserved.  		if (reservedSet [utf8Byte] == true) {  			// Leave the escape sequence as is.  			result.Append (input.Substring (i - 2' 3));  		}  		else {  			result.Append ((char)utf8Byte);  		}  	}  	else {  		// Otherwise' this character was encoded to multiple bytes.  		// Check for an invalid UTF-8 start value.  		if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Count the number of high bits set (this is the number of bytes required for the character).  		int utf8ByteCount = 1;  		for (int j = 6; j >= 0; j--) {  			if ((utf8Byte & (1 << j)) != 0)  				utf8ByteCount++;  			else  				break;  		}  		if (utf8ByteCount < 2 || utf8ByteCount > 4)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Read the additional bytes.  		byte[] utf8Bytes = new byte[utf8ByteCount];  		utf8Bytes [0] = (byte)utf8Byte;  		for (int j = 1; j < utf8ByteCount; j++) {  			// An additional escape sequence is expected.  			if (i >= input.Length - 1 || input [++i] != '%')  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Decode the %XX encoding.  			utf8Byte = ParseHexNumber (input' i + 1' 2);  			if (utf8Byte < 0)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  			if ((utf8Byte & 0xC0) != 0x80)  				throw new JavaScriptException (engine' "URIError"' "URI malformed");  			// Store the byte.  			utf8Bytes [j] = (byte)utf8Byte;  			// Update the character position.  			i += 2;  		}  		// Decode the UTF-8 sequence.  		result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  	}  }  else  	result.Append (c);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: i += 2;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if ((utf8Byte & 0x80) == 0) {  	// Decode only if the character is not reserved.  	if (reservedSet [utf8Byte] == true) {  		// Leave the escape sequence as is.  		result.Append (input.Substring (i - 2' 3));  	}  	else {  		result.Append ((char)utf8Byte);  	}  }  else {  	// Otherwise' this character was encoded to multiple bytes.  	// Check for an invalid UTF-8 start value.  	if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Count the number of high bits set (this is the number of bytes required for the character).  	int utf8ByteCount = 1;  	for (int j = 6; j >= 0; j--) {  		if ((utf8Byte & (1 << j)) != 0)  			utf8ByteCount++;  		else  			break;  	}  	if (utf8ByteCount < 2 || utf8ByteCount > 4)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Read the additional bytes.  	byte[] utf8Bytes = new byte[utf8ByteCount];  	utf8Bytes [0] = (byte)utf8Byte;  	for (int j = 1; j < utf8ByteCount; j++) {  		// An additional escape sequence is expected.  		if (i >= input.Length - 1 || input [++i] != '%')  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Decode the %XX encoding.  		utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  		if ((utf8Byte & 0xC0) != 0x80)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Store the byte.  		utf8Bytes [j] = (byte)utf8Byte;  		// Update the character position.  		i += 2;  	}  	// Decode the UTF-8 sequence.  	result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if ((utf8Byte & 0x80) == 0) {  	// Decode only if the character is not reserved.  	if (reservedSet [utf8Byte] == true) {  		// Leave the escape sequence as is.  		result.Append (input.Substring (i - 2' 3));  	}  	else {  		result.Append ((char)utf8Byte);  	}  }  else {  	// Otherwise' this character was encoded to multiple bytes.  	// Check for an invalid UTF-8 start value.  	if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Count the number of high bits set (this is the number of bytes required for the character).  	int utf8ByteCount = 1;  	for (int j = 6; j >= 0; j--) {  		if ((utf8Byte & (1 << j)) != 0)  			utf8ByteCount++;  		else  			break;  	}  	if (utf8ByteCount < 2 || utf8ByteCount > 4)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Read the additional bytes.  	byte[] utf8Bytes = new byte[utf8ByteCount];  	utf8Bytes [0] = (byte)utf8Byte;  	for (int j = 1; j < utf8ByteCount; j++) {  		// An additional escape sequence is expected.  		if (i >= input.Length - 1 || input [++i] != '%')  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Decode the %XX encoding.  		utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  		if ((utf8Byte & 0xC0) != 0x80)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Store the byte.  		utf8Bytes [j] = (byte)utf8Byte;  		// Update the character position.  		i += 2;  	}  	// Decode the UTF-8 sequence.  	result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if ((utf8Byte & 0x80) == 0) {  	// Decode only if the character is not reserved.  	if (reservedSet [utf8Byte] == true) {  		// Leave the escape sequence as is.  		result.Append (input.Substring (i - 2' 3));  	}  	else {  		result.Append ((char)utf8Byte);  	}  }  else {  	// Otherwise' this character was encoded to multiple bytes.  	// Check for an invalid UTF-8 start value.  	if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Count the number of high bits set (this is the number of bytes required for the character).  	int utf8ByteCount = 1;  	for (int j = 6; j >= 0; j--) {  		if ((utf8Byte & (1 << j)) != 0)  			utf8ByteCount++;  		else  			break;  	}  	if (utf8ByteCount < 2 || utf8ByteCount > 4)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Read the additional bytes.  	byte[] utf8Bytes = new byte[utf8ByteCount];  	utf8Bytes [0] = (byte)utf8Byte;  	for (int j = 1; j < utf8ByteCount; j++) {  		// An additional escape sequence is expected.  		if (i >= input.Length - 1 || input [++i] != '%')  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Decode the %XX encoding.  		utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  		if ((utf8Byte & 0xC0) != 0x80)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Store the byte.  		utf8Bytes [j] = (byte)utf8Byte;  		// Update the character position.  		i += 2;  	}  	// Decode the UTF-8 sequence.  	result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if ((utf8Byte & 0x80) == 0) {  	// Decode only if the character is not reserved.  	if (reservedSet [utf8Byte] == true) {  		// Leave the escape sequence as is.  		result.Append (input.Substring (i - 2' 3));  	}  	else {  		result.Append ((char)utf8Byte);  	}  }  else {  	// Otherwise' this character was encoded to multiple bytes.  	// Check for an invalid UTF-8 start value.  	if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Count the number of high bits set (this is the number of bytes required for the character).  	int utf8ByteCount = 1;  	for (int j = 6; j >= 0; j--) {  		if ((utf8Byte & (1 << j)) != 0)  			utf8ByteCount++;  		else  			break;  	}  	if (utf8ByteCount < 2 || utf8ByteCount > 4)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Read the additional bytes.  	byte[] utf8Bytes = new byte[utf8ByteCount];  	utf8Bytes [0] = (byte)utf8Byte;  	for (int j = 1; j < utf8ByteCount; j++) {  		// An additional escape sequence is expected.  		if (i >= input.Length - 1 || input [++i] != '%')  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Decode the %XX encoding.  		utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  		if ((utf8Byte & 0xC0) != 0x80)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Store the byte.  		utf8Bytes [j] = (byte)utf8Byte;  		// Update the character position.  		i += 2;  	}  	// Decode the UTF-8 sequence.  	result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if ((utf8Byte & 0x80) == 0) {  	// Decode only if the character is not reserved.  	if (reservedSet [utf8Byte] == true) {  		// Leave the escape sequence as is.  		result.Append (input.Substring (i - 2' 3));  	}  	else {  		result.Append ((char)utf8Byte);  	}  }  else {  	// Otherwise' this character was encoded to multiple bytes.  	// Check for an invalid UTF-8 start value.  	if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Count the number of high bits set (this is the number of bytes required for the character).  	int utf8ByteCount = 1;  	for (int j = 6; j >= 0; j--) {  		if ((utf8Byte & (1 << j)) != 0)  			utf8ByteCount++;  		else  			break;  	}  	if (utf8ByteCount < 2 || utf8ByteCount > 4)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Read the additional bytes.  	byte[] utf8Bytes = new byte[utf8ByteCount];  	utf8Bytes [0] = (byte)utf8Byte;  	for (int j = 1; j < utf8ByteCount; j++) {  		// An additional escape sequence is expected.  		if (i >= input.Length - 1 || input [++i] != '%')  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Decode the %XX encoding.  		utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  		if ((utf8Byte & 0xC0) != 0x80)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Store the byte.  		utf8Bytes [j] = (byte)utf8Byte;  		// Update the character position.  		i += 2;  	}  	// Decode the UTF-8 sequence.  	result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if ((utf8Byte & 0x80) == 0) {  	// Decode only if the character is not reserved.  	if (reservedSet [utf8Byte] == true) {  		// Leave the escape sequence as is.  		result.Append (input.Substring (i - 2' 3));  	}  	else {  		result.Append ((char)utf8Byte);  	}  }  else {  	// Otherwise' this character was encoded to multiple bytes.  	// Check for an invalid UTF-8 start value.  	if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Count the number of high bits set (this is the number of bytes required for the character).  	int utf8ByteCount = 1;  	for (int j = 6; j >= 0; j--) {  		if ((utf8Byte & (1 << j)) != 0)  			utf8ByteCount++;  		else  			break;  	}  	if (utf8ByteCount < 2 || utf8ByteCount > 4)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Read the additional bytes.  	byte[] utf8Bytes = new byte[utf8ByteCount];  	utf8Bytes [0] = (byte)utf8Byte;  	for (int j = 1; j < utf8ByteCount; j++) {  		// An additional escape sequence is expected.  		if (i >= input.Length - 1 || input [++i] != '%')  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Decode the %XX encoding.  		utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  		if ((utf8Byte & 0xC0) != 0x80)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Store the byte.  		utf8Bytes [j] = (byte)utf8Byte;  		// Update the character position.  		i += 2;  	}  	// Decode the UTF-8 sequence.  	result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if ((utf8Byte & 0x80) == 0) {  	// Decode only if the character is not reserved.  	if (reservedSet [utf8Byte] == true) {  		// Leave the escape sequence as is.  		result.Append (input.Substring (i - 2' 3));  	}  	else {  		result.Append ((char)utf8Byte);  	}  }  else {  	// Otherwise' this character was encoded to multiple bytes.  	// Check for an invalid UTF-8 start value.  	if (utf8Byte == 0xc0 || utf8Byte == 0xc1)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Count the number of high bits set (this is the number of bytes required for the character).  	int utf8ByteCount = 1;  	for (int j = 6; j >= 0; j--) {  		if ((utf8Byte & (1 << j)) != 0)  			utf8ByteCount++;  		else  			break;  	}  	if (utf8ByteCount < 2 || utf8ByteCount > 4)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Read the additional bytes.  	byte[] utf8Bytes = new byte[utf8ByteCount];  	utf8Bytes [0] = (byte)utf8Byte;  	for (int j = 1; j < utf8ByteCount; j++) {  		// An additional escape sequence is expected.  		if (i >= input.Length - 1 || input [++i] != '%')  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Decode the %XX encoding.  		utf8Byte = ParseHexNumber (input' i + 1' 2);  		if (utf8Byte < 0)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  		if ((utf8Byte & 0xC0) != 0x80)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		// Store the byte.  		utf8Bytes [j] = (byte)utf8Byte;  		// Update the character position.  		i += 2;  	}  	// Decode the UTF-8 sequence.  	result.Append (System.Text.Encoding.UTF8.GetString (utf8Bytes' 0' utf8Bytes.Length));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (reservedSet [utf8Byte] == true) {  	// Leave the escape sequence as is.  	result.Append (input.Substring (i - 2' 3));  }  else {  	result.Append ((char)utf8Byte);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (reservedSet [utf8Byte] == true) {  	// Leave the escape sequence as is.  	result.Append (input.Substring (i - 2' 3));  }  else {  	result.Append ((char)utf8Byte);  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: result.Append (input.Substring (i - 2' 3));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: result.Append (input.Substring (i - 2' 3));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int j = 6; j >= 0; j--) {  	if ((utf8Byte & (1 << j)) != 0)  		utf8ByteCount++;  	else  		break;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (utf8ByteCount < 2 || utf8ByteCount > 4)  	throw new JavaScriptException (engine' "URIError"' "URI malformed");  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: if (utf8ByteCount < 2 || utf8ByteCount > 4)  	throw new JavaScriptException (engine' "URIError"' "URI malformed");  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int j = 1; j < utf8ByteCount; j++) {  	// An additional escape sequence is expected.  	if (i >= input.Length - 1 || input [++i] != '%')  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Decode the %XX encoding.  	utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  	if ((utf8Byte & 0xC0) != 0x80)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Store the byte.  	utf8Bytes [j] = (byte)utf8Byte;  	// Update the character position.  	i += 2;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: for (int j = 1; j < utf8ByteCount; j++) {  	// An additional escape sequence is expected.  	if (i >= input.Length - 1 || input [++i] != '%')  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Decode the %XX encoding.  	utf8Byte = ParseHexNumber (input' i + 1' 2);  	if (utf8Byte < 0)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Top two bits must be 10 (i.e. byte must be 10XXXXXX in binary).  	if ((utf8Byte & 0xC0) != 0x80)  		throw new JavaScriptException (engine' "URIError"' "URI malformed");  	// Store the byte.  	utf8Bytes [j] = (byte)utf8Byte;  	// Update the character position.  	i += 2;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: utf8Byte = ParseHexNumber (input' i + 1' 2);  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Decode,The following statement contains a magic number: i += 2;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	// Get the next character in the string.  This might be half of a surrogate pair.  	int c = input [i];  	if (c >= 0xD800 && c < 0xE000) {  		// The character is a surrogate pair.  		// Surrogate pairs need to advance an extra character position.  		i++;  		// Compute the code point.  		if (c >= 0xDC00)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		if (i == input.Length)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		int c2 = input [i];  		if (c2 < 0xDC00 || c2 >= 0xE000)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		c = (c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;  	}  	if (c < 128 && unescapedSet [c] == true) {  		// Character should not be escaped.  		result.Append ((char)c);  	}  	else {  		// Character should be escaped.  		if (c < 0x80) {  			// Encodes to a single byte.  			result.AppendFormat ("%{0:X2}"' c);  		}  		else if (c < 0x800) {  			// Encodes to two bytes.  			result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else if (c < 0x10000) {  			// Encodes to three bytes.  			result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else {  			// Encodes to four bytes.  			result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	// Get the next character in the string.  This might be half of a surrogate pair.  	int c = input [i];  	if (c >= 0xD800 && c < 0xE000) {  		// The character is a surrogate pair.  		// Surrogate pairs need to advance an extra character position.  		i++;  		// Compute the code point.  		if (c >= 0xDC00)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		if (i == input.Length)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		int c2 = input [i];  		if (c2 < 0xDC00 || c2 >= 0xE000)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		c = (c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;  	}  	if (c < 128 && unescapedSet [c] == true) {  		// Character should not be escaped.  		result.Append ((char)c);  	}  	else {  		// Character should be escaped.  		if (c < 0x80) {  			// Encodes to a single byte.  			result.AppendFormat ("%{0:X2}"' c);  		}  		else if (c < 0x800) {  			// Encodes to two bytes.  			result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else if (c < 0x10000) {  			// Encodes to three bytes.  			result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else {  			// Encodes to four bytes.  			result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	// Get the next character in the string.  This might be half of a surrogate pair.  	int c = input [i];  	if (c >= 0xD800 && c < 0xE000) {  		// The character is a surrogate pair.  		// Surrogate pairs need to advance an extra character position.  		i++;  		// Compute the code point.  		if (c >= 0xDC00)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		if (i == input.Length)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		int c2 = input [i];  		if (c2 < 0xDC00 || c2 >= 0xE000)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		c = (c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;  	}  	if (c < 128 && unescapedSet [c] == true) {  		// Character should not be escaped.  		result.Append ((char)c);  	}  	else {  		// Character should be escaped.  		if (c < 0x80) {  			// Encodes to a single byte.  			result.AppendFormat ("%{0:X2}"' c);  		}  		else if (c < 0x800) {  			// Encodes to two bytes.  			result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else if (c < 0x10000) {  			// Encodes to three bytes.  			result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else {  			// Encodes to four bytes.  			result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	// Get the next character in the string.  This might be half of a surrogate pair.  	int c = input [i];  	if (c >= 0xD800 && c < 0xE000) {  		// The character is a surrogate pair.  		// Surrogate pairs need to advance an extra character position.  		i++;  		// Compute the code point.  		if (c >= 0xDC00)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		if (i == input.Length)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		int c2 = input [i];  		if (c2 < 0xDC00 || c2 >= 0xE000)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		c = (c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;  	}  	if (c < 128 && unescapedSet [c] == true) {  		// Character should not be escaped.  		result.Append ((char)c);  	}  	else {  		// Character should be escaped.  		if (c < 0x80) {  			// Encodes to a single byte.  			result.AppendFormat ("%{0:X2}"' c);  		}  		else if (c < 0x800) {  			// Encodes to two bytes.  			result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else if (c < 0x10000) {  			// Encodes to three bytes.  			result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else {  			// Encodes to four bytes.  			result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	// Get the next character in the string.  This might be half of a surrogate pair.  	int c = input [i];  	if (c >= 0xD800 && c < 0xE000) {  		// The character is a surrogate pair.  		// Surrogate pairs need to advance an extra character position.  		i++;  		// Compute the code point.  		if (c >= 0xDC00)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		if (i == input.Length)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		int c2 = input [i];  		if (c2 < 0xDC00 || c2 >= 0xE000)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		c = (c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;  	}  	if (c < 128 && unescapedSet [c] == true) {  		// Character should not be escaped.  		result.Append ((char)c);  	}  	else {  		// Character should be escaped.  		if (c < 0x80) {  			// Encodes to a single byte.  			result.AppendFormat ("%{0:X2}"' c);  		}  		else if (c < 0x800) {  			// Encodes to two bytes.  			result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else if (c < 0x10000) {  			// Encodes to three bytes.  			result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else {  			// Encodes to four bytes.  			result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	// Get the next character in the string.  This might be half of a surrogate pair.  	int c = input [i];  	if (c >= 0xD800 && c < 0xE000) {  		// The character is a surrogate pair.  		// Surrogate pairs need to advance an extra character position.  		i++;  		// Compute the code point.  		if (c >= 0xDC00)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		if (i == input.Length)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		int c2 = input [i];  		if (c2 < 0xDC00 || c2 >= 0xE000)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		c = (c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;  	}  	if (c < 128 && unescapedSet [c] == true) {  		// Character should not be escaped.  		result.Append ((char)c);  	}  	else {  		// Character should be escaped.  		if (c < 0x80) {  			// Encodes to a single byte.  			result.AppendFormat ("%{0:X2}"' c);  		}  		else if (c < 0x800) {  			// Encodes to two bytes.  			result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else if (c < 0x10000) {  			// Encodes to three bytes.  			result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else {  			// Encodes to four bytes.  			result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) {  	// Get the next character in the string.  This might be half of a surrogate pair.  	int c = input [i];  	if (c >= 0xD800 && c < 0xE000) {  		// The character is a surrogate pair.  		// Surrogate pairs need to advance an extra character position.  		i++;  		// Compute the code point.  		if (c >= 0xDC00)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		if (i == input.Length)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		int c2 = input [i];  		if (c2 < 0xDC00 || c2 >= 0xE000)  			throw new JavaScriptException (engine' "URIError"' "URI malformed");  		c = (c - 0xD800) * 0x400 + (c2 - 0xDC00) + 0x10000;  	}  	if (c < 128 && unescapedSet [c] == true) {  		// Character should not be escaped.  		result.Append ((char)c);  	}  	else {  		// Character should be escaped.  		if (c < 0x80) {  			// Encodes to a single byte.  			result.AppendFormat ("%{0:X2}"' c);  		}  		else if (c < 0x800) {  			// Encodes to two bytes.  			result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else if (c < 0x10000) {  			// Encodes to three bytes.  			result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  		else {  			// Encodes to four bytes.  			result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  			result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  		}  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 128 && unescapedSet [c] == true) {  	// Character should not be escaped.  	result.Append ((char)c);  }  else {  	// Character should be escaped.  	if (c < 0x80) {  		// Encodes to a single byte.  		result.AppendFormat ("%{0:X2}"' c);  	}  	else if (c < 0x800) {  		// Encodes to two bytes.  		result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else if (c < 0x10000) {  		// Encodes to three bytes.  		result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else {  		// Encodes to four bytes.  		result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 128 && unescapedSet [c] == true) {  	// Character should not be escaped.  	result.Append ((char)c);  }  else {  	// Character should be escaped.  	if (c < 0x80) {  		// Encodes to a single byte.  		result.AppendFormat ("%{0:X2}"' c);  	}  	else if (c < 0x800) {  		// Encodes to two bytes.  		result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else if (c < 0x10000) {  		// Encodes to three bytes.  		result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else {  		// Encodes to four bytes.  		result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 128 && unescapedSet [c] == true) {  	// Character should not be escaped.  	result.Append ((char)c);  }  else {  	// Character should be escaped.  	if (c < 0x80) {  		// Encodes to a single byte.  		result.AppendFormat ("%{0:X2}"' c);  	}  	else if (c < 0x800) {  		// Encodes to two bytes.  		result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else if (c < 0x10000) {  		// Encodes to three bytes.  		result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else {  		// Encodes to four bytes.  		result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 128 && unescapedSet [c] == true) {  	// Character should not be escaped.  	result.Append ((char)c);  }  else {  	// Character should be escaped.  	if (c < 0x80) {  		// Encodes to a single byte.  		result.AppendFormat ("%{0:X2}"' c);  	}  	else if (c < 0x800) {  		// Encodes to two bytes.  		result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else if (c < 0x10000) {  		// Encodes to three bytes.  		result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else {  		// Encodes to four bytes.  		result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 128 && unescapedSet [c] == true) {  	// Character should not be escaped.  	result.Append ((char)c);  }  else {  	// Character should be escaped.  	if (c < 0x80) {  		// Encodes to a single byte.  		result.AppendFormat ("%{0:X2}"' c);  	}  	else if (c < 0x800) {  		// Encodes to two bytes.  		result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else if (c < 0x10000) {  		// Encodes to three bytes.  		result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else {  		// Encodes to four bytes.  		result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 128 && unescapedSet [c] == true) {  	// Character should not be escaped.  	result.Append ((char)c);  }  else {  	// Character should be escaped.  	if (c < 0x80) {  		// Encodes to a single byte.  		result.AppendFormat ("%{0:X2}"' c);  	}  	else if (c < 0x800) {  		// Encodes to two bytes.  		result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else if (c < 0x10000) {  		// Encodes to three bytes.  		result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else {  		// Encodes to four bytes.  		result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 128 && unescapedSet [c] == true) {  	// Character should not be escaped.  	result.Append ((char)c);  }  else {  	// Character should be escaped.  	if (c < 0x80) {  		// Encodes to a single byte.  		result.AppendFormat ("%{0:X2}"' c);  	}  	else if (c < 0x800) {  		// Encodes to two bytes.  		result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else if (c < 0x10000) {  		// Encodes to three bytes.  		result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  	else {  		// Encodes to four bytes.  		result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  		result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  	}  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x80) {  	// Encodes to a single byte.  	result.AppendFormat ("%{0:X2}"' c);  }  else if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x80) {  	// Encodes to a single byte.  	result.AppendFormat ("%{0:X2}"' c);  }  else if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x80) {  	// Encodes to a single byte.  	result.AppendFormat ("%{0:X2}"' c);  }  else if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x80) {  	// Encodes to a single byte.  	result.AppendFormat ("%{0:X2}"' c);  }  else if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x80) {  	// Encodes to a single byte.  	result.AppendFormat ("%{0:X2}"' c);  }  else if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x80) {  	// Encodes to a single byte.  	result.AppendFormat ("%{0:X2}"' c);  }  else if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x800) {  	// Encodes to two bytes.  	result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: result.AppendFormat ("%{0:X2}"' 0xC0 | (c >> 6));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: if (c < 0x10000) {  	// Encodes to three bytes.  	result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  else {  	// Encodes to four bytes.  	result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  	result.AppendFormat ("%{0:X2}"' 0x80 | (c & 0x3F));  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: result.AppendFormat ("%{0:X2}"' 0xE0 | (c >> 12));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: result.AppendFormat ("%{0:X2}"' 0xF0 | (c >> 18));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 12) & 0x3F));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,Encode,The following statement contains a magic number: result.AppendFormat ("%{0:X2}"' 0x80 | ((c >> 6) & 0x3F));  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ReadInteger,The following statement contains a magic number: while (true) {  	int c = reader.Peek ();  	if (c < '0' || c > '9')  		break;  	reader.Read ();  	digitsRead++;  	if (double.IsNaN (result))  		result = c - '0';  	else  		result = result * 10 + (c - '0');  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ReadInteger,The following statement contains a magic number: if (double.IsNaN (result))  	result = c - '0';  else  	result = result * 10 + (c - '0');  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ReadInteger,The following statement contains a magic number: result = result * 10 + (c - '0');  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,IsWhiteSpaceOrLineTerminator,The following statement contains a magic number: return c == 9 || c == 0x0b || c == 0x0c || c == ' ' || c == 0xa0 || c == 0xfeff || c == 0x1680 || c == 0x180e || (c >= 0x2000 && c <= 0x200a) || c == 0x202f || c == 0x205f || c == 0x3000 || c == 0x0a || c == 0x0d || c == 0x2028 || c == 0x2029;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: for (int i = start; i < start + length; i++) {  	result *= 0x10;  	char c = input [i];  	if (c >= '0' && c <= '9')  		result += c - '0';  	else if (c >= 'A' && c <= 'F')  		result += c - 'A' + 10;  	else if (c >= 'a' && c <= 'f')  		result += c - 'a' + 10;  	else  		return -1;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: for (int i = start; i < start + length; i++) {  	result *= 0x10;  	char c = input [i];  	if (c >= '0' && c <= '9')  		result += c - '0';  	else if (c >= 'A' && c <= 'F')  		result += c - 'A' + 10;  	else if (c >= 'a' && c <= 'f')  		result += c - 'a' + 10;  	else  		return -1;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: if (c >= '0' && c <= '9')  	result += c - '0';  else if (c >= 'A' && c <= 'F')  	result += c - 'A' + 10;  else if (c >= 'a' && c <= 'f')  	result += c - 'a' + 10;  else  	return -1;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: if (c >= '0' && c <= '9')  	result += c - '0';  else if (c >= 'A' && c <= 'F')  	result += c - 'A' + 10;  else if (c >= 'a' && c <= 'f')  	result += c - 'a' + 10;  else  	return -1;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: if (c >= 'A' && c <= 'F')  	result += c - 'A' + 10;  else if (c >= 'a' && c <= 'f')  	result += c - 'a' + 10;  else  	return -1;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: if (c >= 'A' && c <= 'F')  	result += c - 'A' + 10;  else if (c >= 'a' && c <= 'f')  	result += c - 'a' + 10;  else  	return -1;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: result += c - 'A' + 10;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: if (c >= 'a' && c <= 'f')  	result += c - 'a' + 10;  else  	return -1;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,ParseHexNumber,The following statement contains a magic number: result += c - 'a' + 10;  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,CreateCharacterSetLookupTable,The following statement contains a magic number: for (int i = 0; i < characters.Length; i++) {  	char c = characters [i];  	if (c >= 128)  		throw new ArgumentException ("Characters must be ASCII."' "characters");  	result [c] = true;  }  
Magic Number,Jurassic.Library,GlobalObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\GlobalObject.cs,CreateCharacterSetLookupTable,The following statement contains a magic number: if (c >= 128)  	throw new ArgumentException ("Characters must be ASCII."' "characters");  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup2,The following statement contains a magic number: if (this.lastMatch == null || this.lastMatch.Groups.Count < 2)  	return string.Empty;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup2,The following statement contains a magic number: return this.lastMatch.Groups [2].Value;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup3,The following statement contains a magic number: if (this.lastMatch == null || this.lastMatch.Groups.Count < 3)  	return string.Empty;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup3,The following statement contains a magic number: return this.lastMatch.Groups [3].Value;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup4,The following statement contains a magic number: if (this.lastMatch == null || this.lastMatch.Groups.Count < 4)  	return string.Empty;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup4,The following statement contains a magic number: return this.lastMatch.Groups [4].Value;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup5,The following statement contains a magic number: if (this.lastMatch == null || this.lastMatch.Groups.Count < 5)  	return string.Empty;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup5,The following statement contains a magic number: return this.lastMatch.Groups [5].Value;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup6,The following statement contains a magic number: if (this.lastMatch == null || this.lastMatch.Groups.Count < 6)  	return string.Empty;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup6,The following statement contains a magic number: return this.lastMatch.Groups [6].Value;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup7,The following statement contains a magic number: if (this.lastMatch == null || this.lastMatch.Groups.Count < 7)  	return string.Empty;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup7,The following statement contains a magic number: return this.lastMatch.Groups [7].Value;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup8,The following statement contains a magic number: if (this.lastMatch == null || this.lastMatch.Groups.Count < 8)  	return string.Empty;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup8,The following statement contains a magic number: return this.lastMatch.Groups [8].Value;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup9,The following statement contains a magic number: if (this.lastMatch == null || this.lastMatch.Groups.Count < 9)  	return string.Empty;  
Magic Number,Jurassic.Library,RegExpConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpConstructor.cs,GetGroup9,The following statement contains a magic number: return this.lastMatch.Groups [9].Value;  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: for (int i = 0; i < replaceText.Length; i++) {  	char c = replaceText [i];  	if (c == '$' && i < replaceText.Length - 1) {  		c = replaceText [++i];  		if (c == '$')  			replacementBuilder.Append ('$');  		else if (c == '&')  			replacementBuilder.Append (match.Value);  		else if (c == '`')  			replacementBuilder.Append (input.Substring (0' match.Index));  		else if (c == '\'')  			replacementBuilder.Append (input.Substring (match.Index + match.Length));  		else if (c >= '0' && c <= '9') {  			int matchNumber1 = c - '0';  			// The match number can be one or two digits long.  			int matchNumber2 = 0;  			if (i < replaceText.Length - 1 && replaceText [i + 1] >= '0' && replaceText [i + 1] <= '9')  				matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  			// Try the two digit capture first.  			if (matchNumber2 > 0 && matchNumber2 < match.Groups.Count) {  				// Two digit capture replacement.  				replacementBuilder.Append (match.Groups [matchNumber2].Value);  				i++;  			}  			else if (matchNumber1 > 0 && matchNumber1 < match.Groups.Count) {  				// Single digit capture replacement.  				replacementBuilder.Append (match.Groups [matchNumber1].Value);  			}  			else {  				// Capture does not exist.  				replacementBuilder.Append ('$');  				i--;  			}  		}  		else {  			// Unknown replacement pattern.  			replacementBuilder.Append ('$');  			replacementBuilder.Append (c);  		}  	}  	else  		replacementBuilder.Append (c);  }  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: if (c == '$' && i < replaceText.Length - 1) {  	c = replaceText [++i];  	if (c == '$')  		replacementBuilder.Append ('$');  	else if (c == '&')  		replacementBuilder.Append (match.Value);  	else if (c == '`')  		replacementBuilder.Append (input.Substring (0' match.Index));  	else if (c == '\'')  		replacementBuilder.Append (input.Substring (match.Index + match.Length));  	else if (c >= '0' && c <= '9') {  		int matchNumber1 = c - '0';  		// The match number can be one or two digits long.  		int matchNumber2 = 0;  		if (i < replaceText.Length - 1 && replaceText [i + 1] >= '0' && replaceText [i + 1] <= '9')  			matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  		// Try the two digit capture first.  		if (matchNumber2 > 0 && matchNumber2 < match.Groups.Count) {  			// Two digit capture replacement.  			replacementBuilder.Append (match.Groups [matchNumber2].Value);  			i++;  		}  		else if (matchNumber1 > 0 && matchNumber1 < match.Groups.Count) {  			// Single digit capture replacement.  			replacementBuilder.Append (match.Groups [matchNumber1].Value);  		}  		else {  			// Capture does not exist.  			replacementBuilder.Append ('$');  			i--;  		}  	}  	else {  		// Unknown replacement pattern.  		replacementBuilder.Append ('$');  		replacementBuilder.Append (c);  	}  }  else  	replacementBuilder.Append (c);  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: if (c == '$')  	replacementBuilder.Append ('$');  else if (c == '&')  	replacementBuilder.Append (match.Value);  else if (c == '`')  	replacementBuilder.Append (input.Substring (0' match.Index));  else if (c == '\'')  	replacementBuilder.Append (input.Substring (match.Index + match.Length));  else if (c >= '0' && c <= '9') {  	int matchNumber1 = c - '0';  	// The match number can be one or two digits long.  	int matchNumber2 = 0;  	if (i < replaceText.Length - 1 && replaceText [i + 1] >= '0' && replaceText [i + 1] <= '9')  		matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  	// Try the two digit capture first.  	if (matchNumber2 > 0 && matchNumber2 < match.Groups.Count) {  		// Two digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber2].Value);  		i++;  	}  	else if (matchNumber1 > 0 && matchNumber1 < match.Groups.Count) {  		// Single digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber1].Value);  	}  	else {  		// Capture does not exist.  		replacementBuilder.Append ('$');  		i--;  	}  }  else {  	// Unknown replacement pattern.  	replacementBuilder.Append ('$');  	replacementBuilder.Append (c);  }  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: if (c == '&')  	replacementBuilder.Append (match.Value);  else if (c == '`')  	replacementBuilder.Append (input.Substring (0' match.Index));  else if (c == '\'')  	replacementBuilder.Append (input.Substring (match.Index + match.Length));  else if (c >= '0' && c <= '9') {  	int matchNumber1 = c - '0';  	// The match number can be one or two digits long.  	int matchNumber2 = 0;  	if (i < replaceText.Length - 1 && replaceText [i + 1] >= '0' && replaceText [i + 1] <= '9')  		matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  	// Try the two digit capture first.  	if (matchNumber2 > 0 && matchNumber2 < match.Groups.Count) {  		// Two digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber2].Value);  		i++;  	}  	else if (matchNumber1 > 0 && matchNumber1 < match.Groups.Count) {  		// Single digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber1].Value);  	}  	else {  		// Capture does not exist.  		replacementBuilder.Append ('$');  		i--;  	}  }  else {  	// Unknown replacement pattern.  	replacementBuilder.Append ('$');  	replacementBuilder.Append (c);  }  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: if (c == '`')  	replacementBuilder.Append (input.Substring (0' match.Index));  else if (c == '\'')  	replacementBuilder.Append (input.Substring (match.Index + match.Length));  else if (c >= '0' && c <= '9') {  	int matchNumber1 = c - '0';  	// The match number can be one or two digits long.  	int matchNumber2 = 0;  	if (i < replaceText.Length - 1 && replaceText [i + 1] >= '0' && replaceText [i + 1] <= '9')  		matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  	// Try the two digit capture first.  	if (matchNumber2 > 0 && matchNumber2 < match.Groups.Count) {  		// Two digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber2].Value);  		i++;  	}  	else if (matchNumber1 > 0 && matchNumber1 < match.Groups.Count) {  		// Single digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber1].Value);  	}  	else {  		// Capture does not exist.  		replacementBuilder.Append ('$');  		i--;  	}  }  else {  	// Unknown replacement pattern.  	replacementBuilder.Append ('$');  	replacementBuilder.Append (c);  }  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: if (c == '\'')  	replacementBuilder.Append (input.Substring (match.Index + match.Length));  else if (c >= '0' && c <= '9') {  	int matchNumber1 = c - '0';  	// The match number can be one or two digits long.  	int matchNumber2 = 0;  	if (i < replaceText.Length - 1 && replaceText [i + 1] >= '0' && replaceText [i + 1] <= '9')  		matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  	// Try the two digit capture first.  	if (matchNumber2 > 0 && matchNumber2 < match.Groups.Count) {  		// Two digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber2].Value);  		i++;  	}  	else if (matchNumber1 > 0 && matchNumber1 < match.Groups.Count) {  		// Single digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber1].Value);  	}  	else {  		// Capture does not exist.  		replacementBuilder.Append ('$');  		i--;  	}  }  else {  	// Unknown replacement pattern.  	replacementBuilder.Append ('$');  	replacementBuilder.Append (c);  }  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: if (c >= '0' && c <= '9') {  	int matchNumber1 = c - '0';  	// The match number can be one or two digits long.  	int matchNumber2 = 0;  	if (i < replaceText.Length - 1 && replaceText [i + 1] >= '0' && replaceText [i + 1] <= '9')  		matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  	// Try the two digit capture first.  	if (matchNumber2 > 0 && matchNumber2 < match.Groups.Count) {  		// Two digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber2].Value);  		i++;  	}  	else if (matchNumber1 > 0 && matchNumber1 < match.Groups.Count) {  		// Single digit capture replacement.  		replacementBuilder.Append (match.Groups [matchNumber1].Value);  	}  	else {  		// Capture does not exist.  		replacementBuilder.Append ('$');  		i--;  	}  }  else {  	// Unknown replacement pattern.  	replacementBuilder.Append ('$');  	replacementBuilder.Append (c);  }  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: if (i < replaceText.Length - 1 && replaceText [i + 1] >= '0' && replaceText [i + 1] <= '9')  	matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: matchNumber2 = matchNumber1 * 10 + (replaceText [i + 1] - '0');  
Magic Number,Jurassic.Library,RegExpInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\RegExp\RegExpInstance.cs,Replace,The following statement contains a magic number: return this.value.Replace (input' match =>  {  	// Set the deprecated RegExp properties.  	this.Engine.RegExp.SetDeprecatedProperties (input' match);  	object[] parameters = new object[match.Groups.Count + 2];  	for (int i = 0; i < match.Groups.Count; i++) {  		if (match.Groups [i].Success == false)  			parameters [i] = Undefined.Value;  		else  			parameters [i] = match.Groups [i].Value;  	}  	parameters [match.Groups.Count] = match.Index;  	parameters [match.Groups.Count + 1] = input;  	return TypeConverter.ToString (replaceFunction.CallLateBound (null' parameters));  }' this.Global == true ? int.MaxValue : 1);  
Magic Number,Jurassic.Library,DateConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateConstructor.cs,DateConstructor,The following statement contains a magic number: this.Length = 7;  
Magic Number,Jurassic.Library,DateConstructor,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateConstructor.cs,Construct,The following statement contains a magic number: for (int i = 0; i < Math.Min (components.Length' 7); i++) {  	double component = TypeConverter.ToNumber (components [i]);  	if (component < int.MinValue || component > int.MaxValue || double.IsNaN (component) == true)  		return Construct (double.NaN);  }  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,GetYear,The following statement contains a magic number: return GetDateComponent (DateComponent.Year' DateTimeKind.Local) - 1900;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetYear,The following statement contains a magic number: return SetDateComponents (DateComponent.Year' DateTimeKind.Local' year >= 0 && year < 100 ? year + 1900 : year);  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetYear,The following statement contains a magic number: return SetDateComponents (DateComponent.Year' DateTimeKind.Local' year >= 0 && year < 100 ? year + 1900 : year);  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: allComponentValues [2] = this.value.Day;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: allComponentValues [3] = this.value.Hour;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: allComponentValues [4] = this.value.Minute;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: allComponentValues [5] = this.value.Second;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: allComponentValues [6] = this.value.Millisecond;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: this.value = ToDateTime (allComponentValues [0]' allComponentValues [1]' allComponentValues [2]' allComponentValues [3]' allComponentValues [4]' allComponentValues [5]' allComponentValues [6]' localOrUniversal);  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: this.value = ToDateTime (allComponentValues [0]' allComponentValues [1]' allComponentValues [2]' allComponentValues [3]' allComponentValues [4]' allComponentValues [5]' allComponentValues [6]' localOrUniversal);  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: this.value = ToDateTime (allComponentValues [0]' allComponentValues [1]' allComponentValues [2]' allComponentValues [3]' allComponentValues [4]' allComponentValues [5]' allComponentValues [6]' localOrUniversal);  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: this.value = ToDateTime (allComponentValues [0]' allComponentValues [1]' allComponentValues [2]' allComponentValues [3]' allComponentValues [4]' allComponentValues [5]' allComponentValues [6]' localOrUniversal);  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,SetDateComponents,The following statement contains a magic number: this.value = ToDateTime (allComponentValues [0]' allComponentValues [1]' allComponentValues [2]' allComponentValues [3]' allComponentValues [4]' allComponentValues [5]' allComponentValues [6]' localOrUniversal);  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToJSDate,The following statement contains a magic number: return dateTime.ToUniversalTime ().Subtract (new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc)).TotalMilliseconds;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The following statement contains a magic number: if (double.IsNaN (milliseconds) || milliseconds < -31557600000000 || milliseconds > 31557600000000)  	return InvalidDate;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The following statement contains a magic number: if (double.IsNaN (milliseconds) || milliseconds < -31557600000000 || milliseconds > 31557600000000)  	return InvalidDate;  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The following statement contains a magic number: return new DateTime (1970' 1' 1' 0' 0' 0' DateTimeKind.Utc).AddMilliseconds (milliseconds);  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The following statement contains a magic number: if (month >= 0 && month < 12 && day >= 1 && day <= DateTime.DaysInMonth (year' month + 1) && hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000) {  	// All parameters are in range.  	return new DateTime (year' month + 1' day' hour' minute' second' millisecond' kind);  }  else {  	// One or more parameters are out of range.  	try {  		DateTime value = new DateTime (year' 1' 1' 0' 0' 0' kind);  		value = value.AddMonths (month);  		if (day != 1)  			value = value.AddDays (day - 1);  		if (hour != 0)  			value = value.AddHours (hour);  		if (minute != 0)  			value = value.AddMinutes (minute);  		if (second != 0)  			value = value.AddSeconds (second);  		if (millisecond != 0)  			value = value.AddMilliseconds (millisecond);  		return value;  	}  	catch (ArgumentOutOfRangeException) {  		// One or more of the parameters was NaN or way too big or way too small.  		// Return a sentinel invalid date.  		return InvalidDate;  	}  }  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The following statement contains a magic number: if (month >= 0 && month < 12 && day >= 1 && day <= DateTime.DaysInMonth (year' month + 1) && hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000) {  	// All parameters are in range.  	return new DateTime (year' month + 1' day' hour' minute' second' millisecond' kind);  }  else {  	// One or more parameters are out of range.  	try {  		DateTime value = new DateTime (year' 1' 1' 0' 0' 0' kind);  		value = value.AddMonths (month);  		if (day != 1)  			value = value.AddDays (day - 1);  		if (hour != 0)  			value = value.AddHours (hour);  		if (minute != 0)  			value = value.AddMinutes (minute);  		if (second != 0)  			value = value.AddSeconds (second);  		if (millisecond != 0)  			value = value.AddMilliseconds (millisecond);  		return value;  	}  	catch (ArgumentOutOfRangeException) {  		// One or more of the parameters was NaN or way too big or way too small.  		// Return a sentinel invalid date.  		return InvalidDate;  	}  }  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The following statement contains a magic number: if (month >= 0 && month < 12 && day >= 1 && day <= DateTime.DaysInMonth (year' month + 1) && hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000) {  	// All parameters are in range.  	return new DateTime (year' month + 1' day' hour' minute' second' millisecond' kind);  }  else {  	// One or more parameters are out of range.  	try {  		DateTime value = new DateTime (year' 1' 1' 0' 0' 0' kind);  		value = value.AddMonths (month);  		if (day != 1)  			value = value.AddDays (day - 1);  		if (hour != 0)  			value = value.AddHours (hour);  		if (minute != 0)  			value = value.AddMinutes (minute);  		if (second != 0)  			value = value.AddSeconds (second);  		if (millisecond != 0)  			value = value.AddMilliseconds (millisecond);  		return value;  	}  	catch (ArgumentOutOfRangeException) {  		// One or more of the parameters was NaN or way too big or way too small.  		// Return a sentinel invalid date.  		return InvalidDate;  	}  }  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The following statement contains a magic number: if (month >= 0 && month < 12 && day >= 1 && day <= DateTime.DaysInMonth (year' month + 1) && hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000) {  	// All parameters are in range.  	return new DateTime (year' month + 1' day' hour' minute' second' millisecond' kind);  }  else {  	// One or more parameters are out of range.  	try {  		DateTime value = new DateTime (year' 1' 1' 0' 0' 0' kind);  		value = value.AddMonths (month);  		if (day != 1)  			value = value.AddDays (day - 1);  		if (hour != 0)  			value = value.AddHours (hour);  		if (minute != 0)  			value = value.AddMinutes (minute);  		if (second != 0)  			value = value.AddSeconds (second);  		if (millisecond != 0)  			value = value.AddMilliseconds (millisecond);  		return value;  	}  	catch (ArgumentOutOfRangeException) {  		// One or more of the parameters was NaN or way too big or way too small.  		// Return a sentinel invalid date.  		return InvalidDate;  	}  }  
Magic Number,Jurassic.Library,DateInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Date\DateInstance.cs,ToDateTime,The following statement contains a magic number: if (month >= 0 && month < 12 && day >= 1 && day <= DateTime.DaysInMonth (year' month + 1) && hour >= 0 && hour < 24 && minute >= 0 && minute < 60 && second >= 0 && second < 60 && millisecond >= 0 && millisecond < 1000) {  	// All parameters are in range.  	return new DateTime (year' month + 1' day' hour' minute' second' millisecond' kind);  }  else {  	// One or more parameters are out of range.  	try {  		DateTime value = new DateTime (year' 1' 1' 0' 0' 0' kind);  		value = value.AddMonths (month);  		if (day != 1)  			value = value.AddDays (day - 1);  		if (hour != 0)  			value = value.AddHours (hour);  		if (minute != 0)  			value = value.AddMinutes (minute);  		if (second != 0)  			value = value.AddSeconds (second);  		if (millisecond != 0)  			value = value.AddMilliseconds (millisecond);  		return value;  	}  	catch (ArgumentOutOfRangeException) {  		// One or more of the parameters was NaN or way too big or way too small.  		// Return a sentinel invalid date.  		return InvalidDate;  	}  }  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToExponential,The following statement contains a magic number: if (TypeUtilities.IsUndefined (fractionDigits))  	return NumberFormatter.ToString (this.value' 10' NumberFormatter.Style.Exponential' -1);  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToExponential,The following statement contains a magic number: return NumberFormatter.ToString (this.value' 10' NumberFormatter.Style.Exponential' -1);  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToExponential,The following statement contains a magic number: if (fractionDigits2 < 0 || fractionDigits2 > 20)  	throw new JavaScriptException (this.Engine' "RangeError"' "toExponential() argument must be between 0 and 20.");  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToExponential,The following statement contains a magic number: return NumberFormatter.ToString (this.value' 10' NumberFormatter.Style.Exponential' fractionDigits2);  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToFixed,The following statement contains a magic number: if (fractionDigits < 0 || fractionDigits > 20)  	throw new JavaScriptException (this.Engine' "RangeError"' "toFixed() argument must be between 0 and 20.");  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToFixed,The following statement contains a magic number: return NumberFormatter.ToString (this.value' 10' NumberFormatter.Style.Fixed' fractionDigits);  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToLocaleString,The following statement contains a magic number: return NumberFormatter.ToString (this.value' 10' CultureInfo.CurrentCulture.NumberFormat' NumberFormatter.Style.Regular);  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToPrecision,The following statement contains a magic number: if (precision2 < 1 || precision2 > 21)  	throw new JavaScriptException (this.Engine' "RangeError"' "toPrecision() argument must be between 0 and 21.");  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToPrecision,The following statement contains a magic number: return NumberFormatter.ToString (this.value' 10' NumberFormatter.Style.Precision' precision2);  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToStringJS,The following statement contains a magic number: if (radix < 2 || radix > 36)  	throw new JavaScriptException (this.Engine' "RangeError"' "The radix must be between 2 and 36' inclusive.");  
Magic Number,Jurassic.Library,NumberInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Number\NumberInstance.cs,ToStringJS,The following statement contains a magic number: if (radix < 2 || radix > 36)  	throw new JavaScriptException (this.Engine' "RangeError"' "The radix must be between 2 and 36' inclusive.");  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsInfinity (y) || double.IsInfinity (x)) {  	if (double.IsPositiveInfinity (y) && double.IsPositiveInfinity (x))  		return PI / 4.0;  	if (double.IsPositiveInfinity (y) && double.IsNegativeInfinity (x))  		return 3.0 * PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsPositiveInfinity (x))  		return -PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsNegativeInfinity (x))  		return -3.0 * PI / 4.0;  }  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsInfinity (y) || double.IsInfinity (x)) {  	if (double.IsPositiveInfinity (y) && double.IsPositiveInfinity (x))  		return PI / 4.0;  	if (double.IsPositiveInfinity (y) && double.IsNegativeInfinity (x))  		return 3.0 * PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsPositiveInfinity (x))  		return -PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsNegativeInfinity (x))  		return -3.0 * PI / 4.0;  }  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsInfinity (y) || double.IsInfinity (x)) {  	if (double.IsPositiveInfinity (y) && double.IsPositiveInfinity (x))  		return PI / 4.0;  	if (double.IsPositiveInfinity (y) && double.IsNegativeInfinity (x))  		return 3.0 * PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsPositiveInfinity (x))  		return -PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsNegativeInfinity (x))  		return -3.0 * PI / 4.0;  }  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsInfinity (y) || double.IsInfinity (x)) {  	if (double.IsPositiveInfinity (y) && double.IsPositiveInfinity (x))  		return PI / 4.0;  	if (double.IsPositiveInfinity (y) && double.IsNegativeInfinity (x))  		return 3.0 * PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsPositiveInfinity (x))  		return -PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsNegativeInfinity (x))  		return -3.0 * PI / 4.0;  }  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsInfinity (y) || double.IsInfinity (x)) {  	if (double.IsPositiveInfinity (y) && double.IsPositiveInfinity (x))  		return PI / 4.0;  	if (double.IsPositiveInfinity (y) && double.IsNegativeInfinity (x))  		return 3.0 * PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsPositiveInfinity (x))  		return -PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsNegativeInfinity (x))  		return -3.0 * PI / 4.0;  }  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsInfinity (y) || double.IsInfinity (x)) {  	if (double.IsPositiveInfinity (y) && double.IsPositiveInfinity (x))  		return PI / 4.0;  	if (double.IsPositiveInfinity (y) && double.IsNegativeInfinity (x))  		return 3.0 * PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsPositiveInfinity (x))  		return -PI / 4.0;  	if (double.IsNegativeInfinity (y) && double.IsNegativeInfinity (x))  		return -3.0 * PI / 4.0;  }  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsPositiveInfinity (y) && double.IsPositiveInfinity (x))  	return PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: return PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsPositiveInfinity (y) && double.IsNegativeInfinity (x))  	return 3.0 * PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsPositiveInfinity (y) && double.IsNegativeInfinity (x))  	return 3.0 * PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: return 3.0 * PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: return 3.0 * PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsNegativeInfinity (y) && double.IsPositiveInfinity (x))  	return -PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: return -PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsNegativeInfinity (y) && double.IsNegativeInfinity (x))  	return -3.0 * PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: if (double.IsNegativeInfinity (y) && double.IsNegativeInfinity (x))  	return -3.0 * PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: return -3.0 * PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Atan2,The following statement contains a magic number: return -3.0 * PI / 4.0;  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Round,The following statement contains a magic number: if (number > 0.0)  	return System.Math.Floor (number + 0.5);  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Round,The following statement contains a magic number: return System.Math.Floor (number + 0.5);  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Round,The following statement contains a magic number: if (number >= -0.5) {  	// BitConverter is used to distinguish positive and negative zero.  	if (BitConverter.DoubleToInt64Bits (number) == 0L)  		return 0.0;  	return -0.0;  }  
Magic Number,Jurassic.Library,MathObject,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\MathObject.cs,Round,The following statement contains a magic number: return System.Math.Floor (number + 0.5);  
Magic Number,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,AddProperty,The following statement contains a magic number: if (this.schema.PropertyCount == 16384)  	throw new JavaScriptException (this.engine' "Error"' "Maximum number of named properties reached.");  
Magic Number,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,AddProperty,The following statement contains a magic number: if (propertyIndex >= this.InlinePropertyValues.Length)  	Array.Resize (ref this.propertyValues' this.InlinePropertyValues.Length * 2);  
Magic Number,Jurassic.Library,ObjectInstance,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\Object\ObjectInstance.cs,AddProperty,The following statement contains a magic number: Array.Resize (ref this.propertyValues' this.InlinePropertyValues.Length * 2);  
Missing Default,Jurassic.Compiler,BinderUtilities,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\BinderUtilities.cs,ResolveOverloads,The following switch statement is missing a default case: switch (Type.GetTypeCode (outputType)) {  case TypeCode.Boolean:  	if ((input is bool) == false)  		demeritPoints [i] += disqualification;  	break;  case TypeCode.SByte:  case TypeCode.Int16:  case TypeCode.Int32:  case TypeCode.Int64:  case TypeCode.Byte:  case TypeCode.UInt16:  case TypeCode.UInt32:  case TypeCode.UInt64:  case TypeCode.Single:  case TypeCode.Decimal:  	if (TypeUtilities.IsNumeric (input) == true)  		demeritPoints [i]++;  	else  		demeritPoints [i] += disqualification;  	break;  case TypeCode.Double:  	if (TypeUtilities.IsNumeric (input) == false)  		demeritPoints [i] += disqualification;  	break;  case TypeCode.Char:  	if (TypeUtilities.IsString (input) == true)  		demeritPoints [i]++;  	else  		demeritPoints [i] += disqualification;  	break;  case TypeCode.String:  	if (TypeUtilities.IsString (input) == false && input != Null.Value)  		demeritPoints [i] += disqualification;  	break;  case TypeCode.DateTime:  case TypeCode.Object:  	if (input == null || input == Undefined.Value) {  		demeritPoints [i] += disqualification;  	}  	else if (input == Null.Value) {  		if (outputType.IsValueType == true)  			demeritPoints [i] += disqualification;  	}  	else if (outputType.IsAssignableFrom (input.GetType ()) == false) {  		demeritPoints [i] += disqualification;  	}  	break;  case TypeCode.Empty:  case TypeCode.DBNull:  	throw new NotSupportedException (string.Format ("{0} is not a supported parameter type."' outputType));  }  
Missing Default,Jurassic.Compiler,ReflectionEmitILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\ReflectionEmitILGenerator.cs,LoadInt32,The following switch statement is missing a default case: switch (value) {  case -1:  	this.generator.Emit (OpCodes.Ldc_I4_M1);  	break;  case 0:  	this.generator.Emit (OpCodes.Ldc_I4_0);  	break;  case 1:  	this.generator.Emit (OpCodes.Ldc_I4_1);  	break;  case 2:  	this.generator.Emit (OpCodes.Ldc_I4_2);  	break;  case 3:  	this.generator.Emit (OpCodes.Ldc_I4_3);  	break;  case 4:  	this.generator.Emit (OpCodes.Ldc_I4_4);  	break;  case 5:  	this.generator.Emit (OpCodes.Ldc_I4_5);  	break;  case 6:  	this.generator.Emit (OpCodes.Ldc_I4_6);  	break;  case 7:  	this.generator.Emit (OpCodes.Ldc_I4_7);  	break;  case 8:  	this.generator.Emit (OpCodes.Ldc_I4_8);  	break;  }  
Missing Default,Jurassic.Compiler,EmitHelpers,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\EmitHelpers.cs,EmitValue,The following switch statement is missing a default case: switch (Type.GetTypeCode (value.GetType ())) {  case TypeCode.Boolean:  	generator.LoadBoolean ((bool)value);  	break;  case TypeCode.Byte:  	generator.LoadInt32 ((byte)value);  	break;  case TypeCode.Char:  	generator.LoadInt32 ((char)value);  	break;  case TypeCode.Double:  	generator.LoadDouble ((double)value);  	break;  case TypeCode.Int16:  	generator.LoadInt32 ((short)value);  	break;  case TypeCode.Int32:  	generator.LoadInt32 ((int)value);  	break;  case TypeCode.Int64:  	generator.LoadInt64 ((long)value);  	break;  case TypeCode.SByte:  	generator.LoadInt32 ((sbyte)value);  	break;  case TypeCode.Single:  	generator.LoadDouble ((float)value);  	break;  case TypeCode.String:  	generator.LoadString ((string)value);  	break;  case TypeCode.UInt16:  	generator.LoadInt32 ((ushort)value);  	break;  case TypeCode.UInt32:  	generator.LoadInt32 ((uint)value);  	break;  case TypeCode.UInt64:  	generator.LoadInt64 ((ulong)value);  	break;  case TypeCode.Object:  case TypeCode.Empty:  case TypeCode.DateTime:  case TypeCode.DBNull:  case TypeCode.Decimal:  	throw new NotImplementedException (string.Format ("Cannot emit the value '{0}'"' value));  }  
Missing Default,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,Complete,The following switch statement is missing a default case: switch (clause.Type) {  case ExceptionClauseType.Catch:  	writer.Write (0);  	// Flags  	break;  case ExceptionClauseType.Filter:  	writer.Write (1);  	// Flags  	break;  case ExceptionClauseType.Finally:  	writer.Write (2);  	// Flags  	break;  case ExceptionClauseType.Fault:  	writer.Write (4);  	// Flags  	break;  }  
Missing Default,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckArithmeticOperands,The following switch statement is missing a default case: switch (left) {  case VESType.Int32:  	if (right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || @operator != ArithmeticOperator.Add))  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	PushStackOperand (right);  	break;  case VESType.Int64:  	if (right != VESType.Int64)  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	PushStackOperand (VESType.Int64);  	break;  case VESType.NativeInt:  	if (right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || @operator != ArithmeticOperator.Add))  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	PushStackOperand (right == VESType.ManagedPointer ? VESType.ManagedPointer : VESType.NativeInt);  	break;  case VESType.Float:  	if (right != VESType.Float)  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	PushStackOperand (VESType.Float);  	break;  case VESType.ManagedPointer:  	if (@operator == ArithmeticOperator.Add) {  		if (right != VESType.Int32 && right != VESType.NativeInt)  			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	}  	else if (@operator == ArithmeticOperator.Subtract) {  		if (right != VESType.Int32 && right != VESType.NativeInt && right != VESType.ManagedPointer)  			throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	}  	else  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	PushStackOperand (right == VESType.ManagedPointer ? VESType.NativeInt : VESType.ManagedPointer);  	break;  case VESType.Object:  	throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  }  
Missing Default,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,CheckComparisonOperands,The following switch statement is missing a default case: switch (left) {  case VESType.Int32:  	if (right != VESType.Int32 && right != VESType.NativeInt)  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	break;  case VESType.Int64:  	if (right != VESType.Int64)  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	break;  case VESType.NativeInt:  	if (right != VESType.Int32 && right != VESType.NativeInt && (right != VESType.ManagedPointer || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual)))  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	break;  case VESType.Float:  	if (right != VESType.Float)  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	break;  case VESType.ManagedPointer:  	if (right != VESType.ManagedPointer && (right != VESType.NativeInt || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual)))  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	break;  case VESType.Object:  	if (right != VESType.Object || (@operator != ComparisonOperator.Equal && @operator != ComparisonOperator.NotEqual && @operator != ComparisonOperator.GreaterThanUnsigned))  		throw new InvalidOperationException (string.Format ("Invalid stack operand(s) ({0} {1} {2})."' @operator' left' right));  	break;  }  
Missing Default,Jurassic.Compiler,DynamicILGenerator,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Emit\ILGenerator\DynamicILGenerator.cs,EndCurrentClause,The following switch statement is missing a default case: switch (latestClause.Type) {  case ExceptionClauseType.Catch:  	Leave (exceptionRegion.EndLabel);  	break;  case ExceptionClauseType.Finally:  	EndFinally ();  	break;  case ExceptionClauseType.Filter:  	break;  case ExceptionClauseType.Fault:  	EndFault ();  	break;  }  
Missing Default,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,GenerateStub,The following switch statement is missing a default case: switch (argument.Source) {  case BinderArgumentSource.ScriptEngine:  	generator.LoadArgument (0);  	break;  case BinderArgumentSource.ThisValue:  	generator.LoadArgument (1);  	break;  case BinderArgumentSource.InputParameter:  	generator.LoadArgument (2);  	generator.LoadInt32 (argument.InputParameterIndex);  	generator.LoadArrayElement (typeof(object));  	break;  }  
Missing Default,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,EmitConversionToType,The following switch statement is missing a default case: switch (Type.GetTypeCode (toType)) {  case TypeCode.Boolean:  	EmitConversion.ToBool (generator' PrimitiveType.Any);  	break;  case TypeCode.Byte:  	EmitConversion.ToInt32 (generator' PrimitiveType.Any);  	break;  case TypeCode.Char:  	EmitConversion.ToString (generator' PrimitiveType.Any);  	generator.Duplicate ();  	generator.Call (ReflectionHelpers.String_Length);  	generator.LoadInt32 (1);  	var endOfCharCheck = generator.CreateLabel ();  	generator.BranchIfEqual (endOfCharCheck);  	EmitHelpers.EmitThrow (generator' "TypeError"' "Cannot convert string to char - the string must be exactly one character long");  	generator.DefineLabelPosition (endOfCharCheck);  	generator.LoadInt32 (0);  	generator.Call (ReflectionHelpers.String_GetChars);  	break;  case TypeCode.DBNull:  	throw new NotSupportedException ("DBNull is not a supported parameter type.");  case TypeCode.Decimal:  	EmitConversion.ToNumber (generator' PrimitiveType.Any);  	generator.NewObject (ReflectionHelpers.Decimal_Constructor_Double);  	break;  case TypeCode.Double:  	EmitConversion.ToNumber (generator' PrimitiveType.Any);  	break;  case TypeCode.Empty:  	throw new NotSupportedException ("Empty is not a supported return type.");  case TypeCode.Int16:  	EmitConversion.ToInt32 (generator' PrimitiveType.Any);  	break;  case TypeCode.Int32:  	EmitConversion.ToInt32 (generator' PrimitiveType.Any);  	break;  case TypeCode.Int64:  	EmitConversion.ToNumber (generator' PrimitiveType.Any);  	generator.ConvertToInt64 ();  	break;  case TypeCode.DateTime:  case TypeCode.Object:  	// Check if the type must be unwrapped.  	generator.Duplicate ();  	generator.IsInstance (typeof(Jurassic.Library.ClrInstanceWrapper));  	var endOfUnwrapCheck = generator.CreateLabel ();  	generator.BranchIfFalse (endOfUnwrapCheck);  	// Unwrap the wrapped instance.  	generator.Call (ReflectionHelpers.ClrInstanceWrapper_GetWrappedInstance);  	generator.DefineLabelPosition (endOfUnwrapCheck);  	// Value types must be unboxed.  	if (toType.IsValueType == true) {  		if (convertToAddress == true)  			// Unbox.  			generator.Unbox (toType);  		else  			// Unbox and copy to the stack.  			generator.UnboxAny (toType);  		//// Calling methods on value required the address of the value type' not the value type itself.  		//if (argument.Source == BinderArgumentSource.ThisValue && argument.Type.IsValueType == true)  		//{  		//    var temp = generator.CreateTemporaryVariable(argument.Type);  		//    generator.StoreVariable(temp);  		//    generator.LoadAddressOfVariable(temp);  		//    generator.ReleaseTemporaryVariable(temp);  		//}  	}  	break;  case TypeCode.SByte:  	EmitConversion.ToInt32 (generator' PrimitiveType.Any);  	break;  case TypeCode.Single:  	EmitConversion.ToNumber (generator' PrimitiveType.Any);  	break;  case TypeCode.String:  	EmitConversion.ToString (generator' PrimitiveType.Any);  	break;  case TypeCode.UInt16:  	EmitConversion.ToInt32 (generator' PrimitiveType.Any);  	break;  case TypeCode.UInt32:  	EmitConversion.ToUInt32 (generator' PrimitiveType.Any);  	break;  case TypeCode.UInt64:  	EmitConversion.ToNumber (generator' PrimitiveType.Any);  	generator.ConvertToUnsignedInt64 ();  	break;  }  
Missing Default,Jurassic.Compiler,ClrBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\ClrBinder.cs,EmitConversionToObject,The following switch statement is missing a default case: switch (Type.GetTypeCode (fromType)) {  case TypeCode.Boolean:  	generator.Box (typeof(bool));  	break;  case TypeCode.Byte:  	generator.Box (typeof(int));  	break;  case TypeCode.Char:  	generator.LoadInt32 (1);  	generator.NewObject (ReflectionHelpers.String_Constructor_Char_Int);  	break;  case TypeCode.DBNull:  	throw new NotSupportedException ("DBNull is not a supported return type.");  case TypeCode.Decimal:  	generator.Call (ReflectionHelpers.Decimal_ToDouble);  	generator.Box (typeof(double));  	break;  case TypeCode.Double:  	generator.Box (typeof(double));  	break;  case TypeCode.Empty:  	throw new NotSupportedException ("Empty is not a supported return type.");  case TypeCode.Int16:  	generator.Box (typeof(int));  	break;  case TypeCode.Int32:  	generator.Box (typeof(int));  	break;  case TypeCode.Int64:  	generator.ConvertToDouble ();  	generator.Box (typeof(double));  	break;  case TypeCode.DateTime:  case TypeCode.Object:  	// Check if the type must be wrapped with a ClrInstanceWrapper.  	// Note: if the type is a value type it cannot be a primitive or it would  	// have been handled elsewhere in the switch.  	ILLabel endOfWrapCheck = null;  	if (fromType.IsValueType == false) {  		generator.Duplicate ();  		generator.Call (ReflectionHelpers.TypeUtilities_IsPrimitiveOrObject);  		endOfWrapCheck = generator.CreateLabel ();  		generator.BranchIfTrue (endOfWrapCheck);  	}  	// The type must be wrapped.  	var temp = generator.CreateTemporaryVariable (fromType);  	generator.StoreVariable (temp);  	generator.LoadArgument (0);  	generator.LoadVariable (temp);  	if (fromType.IsValueType == true)  		generator.Box (fromType);  	generator.ReleaseTemporaryVariable (temp);  	generator.NewObject (ReflectionHelpers.ClrInstanceWrapper_Constructor);  	// End of wrap check.  	if (fromType.IsValueType == false)  		generator.DefineLabelPosition (endOfWrapCheck);  	break;  case TypeCode.SByte:  	generator.Box (typeof(int));  	break;  case TypeCode.Single:  	generator.Box (typeof(double));  	break;  case TypeCode.String:  	break;  case TypeCode.UInt16:  	generator.Box (typeof(int));  	break;  case TypeCode.UInt32:  	generator.Box (typeof(uint));  	break;  case TypeCode.UInt64:  	generator.ConvertUnsignedToDouble ();  	generator.Box (typeof(double));  	break;  }  
Missing Default,Jurassic.Compiler,Lexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Lexer\Lexer.cs,ReadNumericLiteral,The following switch statement is missing a default case: switch (status) {  case NumberParser.ParseCoreStatus.NoDigits:  	// If the number consists solely of a period' return that as a token.  	return PunctuatorToken.Dot;  case NumberParser.ParseCoreStatus.NoExponent:  	throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid number."' this.lineNumber' this.Source.Path);  case NumberParser.ParseCoreStatus.InvalidHexLiteral:  	throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid hexidecimal constant."' this.lineNumber' this.Source.Path);  case NumberParser.ParseCoreStatus.OctalLiteral:  	// Octal number are only supported in ECMAScript 3 compatibility mode.  	if (this.engine.CompatibilityMode != CompatibilityMode.ECMAScript3)  		throw new JavaScriptException (this.engine' "SyntaxError"' "Octal numbers are not supported."' this.lineNumber' this.Source.Path);  	break;  case NumberParser.ParseCoreStatus.InvalidOctalLiteral:  	throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid octal constant."' this.lineNumber' this.Source.Path);  }  
Missing Default,Jurassic.Compiler,JSBinder,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Binders\JSBinder.cs,GenerateStub,The following switch statement is missing a default case: switch (argument.Source) {  case BinderArgumentSource.ScriptEngine:  	// Load the "engine" parameter passed by the client.  	generator.LoadArgument (0);  	break;  case BinderArgumentSource.ThisValue:  	// Load the "this" parameter passed by the client.  	generator.LoadArgument (1);  	bool inheritsFromObjectInstance = typeof(ObjectInstance).IsAssignableFrom (argument.Type);  	if (argument.Type.IsClass == true && inheritsFromObjectInstance == false && argument.Type != typeof(string) && argument.Type != typeof(object)) {  		// If the "this" object is an unsupported class' pass it through unmodified.  		generator.CastClass (argument.Type);  	}  	else {  		if (argument.Type != typeof(object)) {  			// If the target "this" object type is not of type object' throw an error if  			// the value is undefined or null.  			generator.Duplicate ();  			var temp = generator.CreateTemporaryVariable (typeof(object));  			generator.StoreVariable (temp);  			generator.LoadArgument (0);  			generator.LoadVariable (temp);  			generator.LoadString (binderMethod.Name);  			generator.Call (ReflectionHelpers.TypeUtilities_VerifyThisObject);  			generator.ReleaseTemporaryVariable (temp);  		}  		// Convert to the target type.  		EmitTypeConversion (generator' typeof(object)' argument.Type);  		if (argument.Type != typeof(ObjectInstance) && inheritsFromObjectInstance == true) {  			// EmitConversionToObjectInstance can emit null if the toType is derived from ObjectInstance.  			// Therefore' if the value emitted is null it means that the "thisObject" is a type derived  			// from ObjectInstance (e.g. FunctionInstance) and the value provided is a different type  			// (e.g. ArrayInstance).  In this case' throw an exception explaining that the function is  			// not generic.  			var endOfThrowLabel = generator.CreateLabel ();  			generator.Duplicate ();  			generator.BranchIfNotNull (endOfThrowLabel);  			generator.LoadArgument (0);  			EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("The method '{0}' is not generic"' binderMethod.Name));  			generator.DefineLabelPosition (endOfThrowLabel);  		}  	}  	break;  case BinderArgumentSource.InputParameter:  	if (argument.InputParameterIndex < argumentCount) {  		// Load the argument onto the stack.  		generator.LoadArgument (2);  		generator.LoadInt32 (argument.InputParameterIndex);  		generator.LoadArrayElement (typeof(object));  		// Get some flags that apply to the parameter.  		var parameterFlags = JSParameterFlags.None;  		var parameterAttribute = argument.GetCustomAttribute<JSParameterAttribute> ();  		if (parameterAttribute != null) {  			if (argument.Type != typeof(ObjectInstance))  				throw new NotImplementedException ("[JSParameter] is only supported for arguments of type ObjectInstance.");  			parameterFlags = parameterAttribute.Flags;  		}  		if ((parameterFlags & JSParameterFlags.DoNotConvert) == 0) {  			// Convert the input parameter to the correct type.  			EmitTypeConversion (generator' typeof(object)' argument);  		}  		else {  			// Don't do argument conversion.  			var endOfThrowLabel = generator.CreateLabel ();  			generator.IsInstance (typeof(ObjectInstance));  			generator.Duplicate ();  			generator.BranchIfNotNull (endOfThrowLabel);  			EmitHelpers.EmitThrow (generator' "TypeError"' string.Format ("Parameter {1} parameter of '{0}' must be an object"' binderMethod.Name' argument.InputParameterIndex));  			generator.DefineLabelPosition (endOfThrowLabel);  		}  	}  	else {  		// The target method has more parameters than we have input values.  		EmitUndefined (generator' argument);  	}  	break;  }  
Missing Default,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateCode,The following switch statement is missing a default case: switch (this.OperatorType) {  // Arithmetic operations.  case OperatorType.Subtract:  case OperatorType.Multiply:  case OperatorType.Divide:  case OperatorType.Modulo:  	EmitConversion.ToNumber (generator' this.Left.ResultType);  	break;  // Bitwise operations.  case OperatorType.BitwiseAnd:  case OperatorType.BitwiseOr:  case OperatorType.BitwiseXor:  case OperatorType.LeftShift:  case OperatorType.SignedRightShift:  case OperatorType.UnsignedRightShift:  	EmitConversion.ToInt32 (generator' this.Left.ResultType);  	break;  // Equality operations.  case OperatorType.Equal:  case OperatorType.StrictlyEqual:  case OperatorType.NotEqual:  case OperatorType.StrictlyNotEqual:  	EmitConversion.ToAny (generator' this.Left.ResultType);  	break;  }  
Missing Default,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateCode,The following switch statement is missing a default case: switch (this.OperatorType) {  // Arithmetic operations.  case OperatorType.Subtract:  case OperatorType.Multiply:  case OperatorType.Divide:  case OperatorType.Modulo:  	EmitConversion.ToNumber (generator' this.Right.ResultType);  	break;  // Bitwise operations.  case OperatorType.BitwiseAnd:  case OperatorType.BitwiseOr:  case OperatorType.BitwiseXor:  	EmitConversion.ToInt32 (generator' this.Right.ResultType);  	break;  case OperatorType.LeftShift:  case OperatorType.SignedRightShift:  case OperatorType.UnsignedRightShift:  	EmitConversion.ToUInt32 (generator' this.Right.ResultType);  	generator.LoadInt32 (0x1F);  	generator.BitwiseAnd ();  	break;  // Equality operations.  case OperatorType.Equal:  case OperatorType.StrictlyEqual:  case OperatorType.NotEqual:  case OperatorType.StrictlyNotEqual:  	EmitConversion.ToAny (generator' this.Right.ResultType);  	break;  }  
Missing Default,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateRelational,The following switch statement is missing a default case: switch (this.OperatorType) {  case OperatorType.LessThan:  	generator.LoadInt32 (0);  	generator.CompareLessThan ();  	break;  case OperatorType.LessThanOrEqual:  	generator.LoadInt32 (1);  	generator.CompareLessThan ();  	break;  case OperatorType.GreaterThan:  	generator.LoadInt32 (0);  	generator.CompareGreaterThan ();  	break;  case OperatorType.GreaterThanOrEqual:  	generator.LoadInt32 (-1);  	generator.CompareGreaterThan ();  	break;  }  
Missing Default,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateRelational,The following switch statement is missing a default case: switch (this.OperatorType) {  case OperatorType.LessThan:  	generator.CompareLessThan ();  	break;  case OperatorType.GreaterThan:  	generator.CompareGreaterThan ();  	break;  case OperatorType.LessThanOrEqual:  	// a <= b   <-->   (a > b) == false  	generator.CompareGreaterThan ();  	generator.LoadBoolean (false);  	generator.CompareEqual ();  	break;  case OperatorType.GreaterThanOrEqual:  	// a >= b   <-->   (a < b) == false  	generator.CompareLessThan ();  	generator.LoadBoolean (false);  	generator.CompareEqual ();  	break;  }  
Missing Default,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateRelational,The following switch statement is missing a default case: switch (this.OperatorType) {  case OperatorType.LessThan:  	generator.CompareLessThan ();  	break;  case OperatorType.GreaterThan:  	generator.CompareGreaterThan ();  	break;  case OperatorType.LessThanOrEqual:  	// a <= b   <-->   (a > b) == false  	generator.CompareGreaterThanUnsigned ();  	generator.LoadBoolean (false);  	generator.CompareEqual ();  	break;  case OperatorType.GreaterThanOrEqual:  	// a >= b   <-->   (a < b) == false  	generator.CompareLessThanUnsigned ();  	generator.LoadBoolean (false);  	generator.CompareEqual ();  	break;  }  
Missing Default,Jurassic.Compiler,BinaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\BinaryExpression.cs,GenerateRelational,The following switch statement is missing a default case: switch (this.OperatorType) {  case OperatorType.LessThan:  	generator.Call (ReflectionHelpers.TypeComparer_LessThan);  	break;  case OperatorType.LessThanOrEqual:  	generator.Call (ReflectionHelpers.TypeComparer_LessThanOrEqual);  	break;  case OperatorType.GreaterThan:  	generator.Call (ReflectionHelpers.TypeComparer_GreaterThan);  	break;  case OperatorType.GreaterThanOrEqual:  	generator.Call (ReflectionHelpers.TypeComparer_GreaterThanOrEqual);  	break;  }  
Missing Default,Jurassic.Compiler,AssignmentExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\AssignmentExpression.cs,GetCompoundBaseOperator,The following switch statement is missing a default case: switch (compoundOperatorType) {  case OperatorType.CompoundAdd:  	return Operator.Add;  case OperatorType.CompoundBitwiseAnd:  	return Operator.BitwiseAnd;  case OperatorType.CompoundBitwiseOr:  	return Operator.BitwiseOr;  case OperatorType.CompoundBitwiseXor:  	return Operator.BitwiseXor;  case OperatorType.CompoundDivide:  	return Operator.Divide;  case OperatorType.CompoundLeftShift:  	return Operator.LeftShift;  case OperatorType.CompoundModulo:  	return Operator.Modulo;  case OperatorType.CompoundMultiply:  	return Operator.Multiply;  case OperatorType.CompoundSignedRightShift:  	return Operator.SignedRightShift;  case OperatorType.CompoundSubtract:  	return Operator.Subtract;  case OperatorType.CompoundUnsignedRightShift:  	return Operator.UnsignedRightShift;  }  
Missing Default,Jurassic.Compiler,UnaryExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\UnaryExpression.cs,GenerateCode,The following switch statement is missing a default case: switch (this.OperatorType) {  case OperatorType.Plus:  case OperatorType.Minus:  	EmitConversion.ToNumber (generator' this.Operand.ResultType);  	break;  case OperatorType.BitwiseNot:  	EmitConversion.ToInt32 (generator' this.Operand.ResultType);  	break;  case OperatorType.LogicalNot:  	EmitConversion.ToBool (generator' this.Operand.ResultType);  	break;  }  
Missing Default,Jurassic.Compiler,OperatorExpression,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Compiler\Expressions\OperatorExpression.cs,FromOperator,The following switch statement is missing a default case: switch (@operator.Type) {  case OperatorType.Grouping:  	return new GroupingExpression (@operator);  case OperatorType.FunctionCall:  	return new FunctionCallExpression (@operator);  case OperatorType.MemberAccess:  case OperatorType.Index:  	return new MemberAccessExpression (@operator);  case OperatorType.New:  	return new NewExpression (@operator);  case OperatorType.PostIncrement:  case OperatorType.PostDecrement:  case OperatorType.PreIncrement:  case OperatorType.PreDecrement:  case OperatorType.Assignment:  case OperatorType.CompoundAdd:  case OperatorType.CompoundBitwiseAnd:  case OperatorType.CompoundBitwiseOr:  case OperatorType.CompoundBitwiseXor:  case OperatorType.CompoundDivide:  case OperatorType.CompoundLeftShift:  case OperatorType.CompoundModulo:  case OperatorType.CompoundMultiply:  case OperatorType.CompoundSignedRightShift:  case OperatorType.CompoundSubtract:  case OperatorType.CompoundUnsignedRightShift:  	return new AssignmentExpression (@operator);  case OperatorType.Conditional:  	return new TernaryExpression (@operator);  case OperatorType.Comma:  	return new ListExpression (@operator);  }  
Missing Default,Jurassic,BigInteger,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\BigInteger.cs,Pow,The following switch statement is missing a default case: switch (exponent) {  case 0:  	return BigInteger.One;  case 1:  	return new BigInteger (radix);  case 2:  	return new BigInteger (radix * radix);  case 3:  	return new BigInteger (radix * radix * radix);  }  
Missing Default,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following switch statement is missing a default case: switch (style) {  case Style.Regular:  	return "0";  case Style.Precision:  	return "0" + numberFormatInfo.NumberDecimalSeparator + new string ('0'' precision - 1);  case Style.Fixed:  	if (precision == 0)  		return "0";  	return "0" + numberFormatInfo.NumberDecimalSeparator + new string ('0'' precision);  case Style.Exponential:  	if (precision <= 0)  		return "0" + exponentSymbol + numberFormatInfo.PositiveSign + "0";  	return "0" + numberFormatInfo.NumberDecimalSeparator + new string ('0'' precision) + exponentSymbol + numberFormatInfo.PositiveSign + "0";  }  
Missing Default,Jurassic,NumberFormatter,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberFormatter.cs,ToString,The following switch statement is missing a default case: switch (style) {  case Style.Precision:  	redundentZeroCount = zeroCount + precision - digitsOutput;  	break;  case Style.Fixed:  	redundentZeroCount = precision - (digitsOutput - zeroCount - integralDigits);  	break;  case Style.Exponential:  	redundentZeroCount = precision - (digitsOutput - zeroCount) + 1;  	break;  }  
Missing Default,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,ParseFloat,The following switch statement is missing a default case: switch (firstChar) {  case '-':  	negative = true;  	firstChar = reader.Read ();  	break;  case '+':  	firstChar = reader.Read ();  	break;  }  
Missing Default,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,CoerceToNumber,The following switch statement is missing a default case: switch (firstChar) {  case '-':  	negative = true;  	firstChar = reader.Read ();  	break;  case '+':  	firstChar = reader.Read ();  	break;  }  
Missing Default,Jurassic,NumberParser,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Core\NumberParser.cs,CoerceToNumber,The following switch statement is missing a default case: switch (status) {  case ParseCoreStatus.NoDigits:  case ParseCoreStatus.NoExponent:  	return double.NaN;  }  
Missing Default,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,ClrStaticTypeWrapper,The following switch statement is missing a default case: switch (Type.GetTypeCode (type)) {  case TypeCode.Int32:  	this.constructBinder = new ClrBinder (ReflectionHelpers.Convert_ToInt32_Double);  	break;  }  
Missing Default,Jurassic.Library,ClrStaticTypeWrapper,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\ClrWrapper\ClrStaticTypeWrapper.cs,PopulateMembers,The following switch statement is missing a default case: switch (member.MemberType) {  case MemberTypes.Method:  	MethodInfo method = (MethodInfo)member;  	List<MethodBase> methodGroup;  	if (methodGroups.TryGetValue (method.Name' out methodGroup) == true)  		methodGroup.Add (method);  	else  		methodGroups.Add (method.Name' new List<MethodBase> () {  			method  		});  	break;  case MemberTypes.Property:  	PropertyInfo property = (PropertyInfo)member;  	var getMethod = property.GetGetMethod ();  	ClrFunction getter = getMethod == null ? null : new ClrFunction (target.Engine.Function.InstancePrototype' new ClrBinder (getMethod));  	var setMethod = property.GetSetMethod ();  	ClrFunction setter = setMethod == null ? null : new ClrFunction (target.Engine.Function.InstancePrototype' new ClrBinder (setMethod));  	target.DefineProperty (property.Name' new PropertyDescriptor (getter' setter' PropertyAttributes.NonEnumerable)' false);  	// Property getters and setters also show up as methods' so remove them here.  	// NOTE: only works if properties are enumerated after methods.  	if (getMethod != null)  		methodGroups.Remove (getMethod.Name);  	if (setMethod != null)  		methodGroups.Remove (setMethod.Name);  	break;  case MemberTypes.Field:  	FieldInfo field = (FieldInfo)member;  	ClrFunction fieldGetter = new ClrFunction (target.Engine.Function.InstancePrototype' new FieldGetterBinder (field));  	ClrFunction fieldSetter = new ClrFunction (target.Engine.Function.InstancePrototype' new FieldSetterBinder (field));  	target.DefineProperty (field.Name' new PropertyDescriptor (fieldGetter' fieldSetter' PropertyAttributes.NonEnumerable)' false);  	break;  case MemberTypes.Constructor:  case MemberTypes.NestedType:  case MemberTypes.Event:  case MemberTypes.TypeInfo:  	// Support not yet implemented.  	break;  }  
Missing Default,Jurassic.Library,StandardConsoleOutput,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\FirebugConsole\StandardConsoleOutput.cs,Log,The following switch statement is missing a default case: switch (style) {  case FirebugConsoleMessageStyle.Information:  	Console.ForegroundColor = ConsoleColor.White;  	break;  case FirebugConsoleMessageStyle.Warning:  	Console.ForegroundColor = ConsoleColor.Yellow;  	break;  case FirebugConsoleMessageStyle.Error:  	Console.ForegroundColor = ConsoleColor.Red;  	break;  }  
Missing Default,Jurassic.Library,JSONLexer,C:\repos\FlorianGrimm_whid\other\jurassic\Jurassic\Library\JSON\JSONLexer.cs,ReadNumericLiteral,The following switch statement is missing a default case: switch (status) {  case NumberParser.ParseCoreStatus.NoDigits:  case NumberParser.ParseCoreStatus.NoExponent:  case NumberParser.ParseCoreStatus.NoFraction:  case NumberParser.ParseCoreStatus.ExponentHasLeadingZero:  	throw new JavaScriptException (this.engine' "SyntaxError"' "Invalid number.");  case NumberParser.ParseCoreStatus.HexLiteral:  case NumberParser.ParseCoreStatus.InvalidHexLiteral:  	throw new JavaScriptException (this.engine' "SyntaxError"' "Hexidecimal literals are not supported in JSON.");  case NumberParser.ParseCoreStatus.OctalLiteral:  case NumberParser.ParseCoreStatus.InvalidOctalLiteral:  	throw new JavaScriptException (this.engine' "SyntaxError"' "Octal literals are not supported in JSON.");  }  
