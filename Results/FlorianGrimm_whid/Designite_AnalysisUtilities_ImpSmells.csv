Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval0,The method has 104 lines of code.
Long Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval1,The method has 159 lines of code.
Long Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The method has 344 lines of code.
Long Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The method has 267 lines of code.
Long Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The method has 233 lines of code.
Long Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The method has 156 lines of code.
Long Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNullary,The method has 117 lines of code.
Long Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,The method has 237 lines of code.
Long Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The method has 201 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,DecreaseBySmallestInterval,The method has 109 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 348 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 104 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 206 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 213 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 134 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 109 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 112 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 172 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IncreaseBySmallestInterval,The method has 109 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyEqual,The method has 160 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyGreaterThan,The method has 159 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyGreaterThanOrEqualTo,The method has 159 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyLessThan,The method has 159 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyLessThanOrEqualTo,The method has 159 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Max,The method has 165 lines of code.
Long Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Min,The method has 165 lines of code.
Long Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyNullary,The method has 108 lines of code.
Long Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,The method has 259 lines of code.
Long Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,TryToGetSimplerLogicalInverse,The method has 131 lines of code.
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,Cyclomatic complexity of the method is 54
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,Cyclomatic complexity of the method is 37
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow2,Cyclomatic complexity of the method is 54
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval0,Cyclomatic complexity of the method is 61
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval1,Cyclomatic complexity of the method is 112
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,Cyclomatic complexity of the method is 147
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,Cyclomatic complexity of the method is 125
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,Cyclomatic complexity of the method is 117
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsJoinedInterval,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,GetIntervalFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,MakeStackSetupInstructionsDeterministic,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,Cyclomatic complexity of the method is 34
Complex Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,SetupReadVariablesFor,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNullary,Cyclomatic complexity of the method is 83
Complex Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,Cyclomatic complexity of the method is 141
Complex Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,Cyclomatic complexity of the method is 117
Complex Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNary,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,GetDefininingExpressionFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,ConvertToUnsigned,Cyclomatic complexity of the method is 33
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,DecreaseBySmallestInterval,Cyclomatic complexity of the method is 79
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 87
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 77
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 40
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 64
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 156
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 157
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 105
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 70
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 72
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,Cyclomatic complexity of the method is 93
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,Cyclomatic complexity of the method is 42
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetMaxValue,Cyclomatic complexity of the method is 39
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetMinValue,Cyclomatic complexity of the method is 39
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetMinusOne,Cyclomatic complexity of the method is 43
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetOne,Cyclomatic complexity of the method is 43
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetZero,Cyclomatic complexity of the method is 43
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IncreaseBySmallestInterval,Cyclomatic complexity of the method is 79
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyEqual,Cyclomatic complexity of the method is 59
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyGreaterThan,Cyclomatic complexity of the method is 59
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyGreaterThanOrEqualTo,Cyclomatic complexity of the method is 59
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyLessThan,Cyclomatic complexity of the method is 59
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNumericallyLessThanOrEqualTo,Cyclomatic complexity of the method is 59
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNegative,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsNonNegative,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsPositive,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IsSmallerThanMinusOne,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Max,Cyclomatic complexity of the method is 59
Complex Method,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Min,Cyclomatic complexity of the method is 59
Complex Method,Microsoft.Cci.Analysis,ExpressionCanonicalizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ExpressionCanonicalizer.cs,GetAsLoadConstant,Cyclomatic complexity of the method is 25
Complex Method,Microsoft.Cci.Analysis,SatSolverHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\SatSolver.cs,AddPhiNodeConstraints,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyNullary,Cyclomatic complexity of the method is 82
Complex Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,Cyclomatic complexity of the method is 88
Complex Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,LongVersionOf,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyUnary,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,TryToGetSimplerLogicalInverse,Cyclomatic complexity of the method is 27
Complex Method,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,GetInverse,Cyclomatic complexity of the method is 30
Complex Method,Microsoft.Cci.Analysis,SingleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\SingleAssignment.cs,ReplaceLocalsWithSSALocals,Cyclomatic complexity of the method is 51
Complex Method,Microsoft.Cci.Analysis,SingleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\SingleAssignment.cs,CreateSSAVariablesAndJoinInformation,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,Cyclomatic complexity of the method is 9
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Interval,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval0,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval1,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsJoinedInterval,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The method has 5 parameters.
Long Identifier,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the parameter constraintsFromParticularPredecessor is 36.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Clone,The length of the statement  "	return new Interval (this.LowerBound' this.UpperBound' excludesMinusOne: this.ExcludesMinusOne' excludesZero: this.ExcludesZero' includesDivisionByZero: this.IncludesDivisionByZero' includesOverflow: this.IncludesOverflow' includesUnderflow: this.IncludesUnderflow); " is 266.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Join,The length of the statement  "	return new Interval (Evaluator.Min (this.LowerBound' other.LowerBound)' Evaluator.Max (this.UpperBound' other.UpperBound)' excludesMinusOne: this.ExcludesMinusOne && other.ExcludesMinusOne' excludesZero: this.ExcludesZero && other.ExcludesZero' includesDivisionByZero: this.IncludesDivisionByZero || other.IncludesDivisionByZero' includesOverflow: this.IncludesOverflow || other.IncludesOverflow' includesUnderflow: this.IncludesUnderflow || other.IncludesUnderflow); " is 467.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The length of the statement  "		if (interval1.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (interval2.LowerBound' interval1.LowerBound)) { " is 128.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The length of the statement  "		if (interval1.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (interval2.UpperBound' interval1.UpperBound)) { " is 125.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The length of the statement  "		if (interval1.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (interval2.UpperBound' interval1.LowerBound)) { " is 128.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The length of the statement  "		if (interval1.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (interval2.UpperBound' interval1.LowerBound)) { " is 128.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The length of the statement  "		if (interval1.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (interval2.LowerBound' interval1.UpperBound)) { " is 125.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The length of the statement  "		if (interval1.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (interval2.LowerBound' interval1.UpperBound)) { " is 125.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval0,The length of the statement  "	//Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time. " is 144.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval0,The length of the statement  "	//Don't bother with an interval' clients are not expect to ask for an interval unless they know the expression is not a compile time constant. " is 142.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval0,The length of the statement  "	//Don't bother with an interval' clients are not expect to ask for an interval unless they know the expression is not a compile time constant. " is 142.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval0,The length of the statement  "			return Narrow (arg' TryToGetAsInterval (definingExpression' referringBlock' joinBlock' definingBlock' mappings) ?? typeInterval' referringBlock' joinBlock' definingBlock' mappings); " is 181.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval0,The length of the statement  "			return Narrow (local' TryToGetAsInterval (definingExpression' referringBlock' joinBlock' definingBlock' mappings) ?? typeInterval' referringBlock' joinBlock' definingBlock' mappings); " is 183.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval1,The length of the statement  "	//Insructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time. " is 143.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval1,The length of the statement  "		var lowerUnderflows = convertedLower == Dummy.Constant || !Evaluator.IsNumericallyEqual (convertedLower' operandInterval.LowerBound); " is 133.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval1,The length of the statement  "		var upperOverflows = convertedUpper == Dummy.Constant || !Evaluator.IsNumericallyEqual (convertedUpper' operandInterval.UpperBound); " is 132.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval1,The length of the statement  "		return new Interval (convertedLower' convertedUpper' includesOverflow: upperOverflows' includesUnderflow: lowerUnderflows' excludesMinusOne: operandInterval.ExcludesMinusOne' excludesZero: operandInterval.ExcludesZero && !lowerUnderflows && !upperOverflows); " is 258.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval1,The length of the statement  "		return new Interval (negatedUpperBound' negatedLowerBound' includesOverflow: lowerOverflows' excludesMinusOne: operandInterval.ExcludesMinusOne' excludesZero: operandInterval.ExcludesZero); " is 189.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "			return TryToGetAsInterval2 (expression' typeInterval' singleton1' operand2' referringBlock' joinBlock' definingBlock' mappings); " is 128.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "			return TryToGetAsInterval2 (expression' typeInterval' operand1' singleton2' referringBlock' joinBlock' definingBlock' mappings); " is 128.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "		return new Interval (lowerBound' upperBound' includesOverflow: upperBoundOverflows' includesUnderflow: lowerBoundUnderflows); " is 125.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.GetZero (expression.Type)' Evaluator.Min (operand1Interval.UpperBound' operand2Interval.UpperBound)); " is 132.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "					return new Interval (Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2Interval.UpperBound)' Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero); " is 246.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "					return new Interval (Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2Interval.UpperBound)' operand1Interval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 241.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "					return new Interval (Evaluator.Negate (operand1Interval.UpperBound)' operand1Interval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 199.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Negate (operand1Interval.UpperBound)' operand1Interval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 199.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2Interval.UpperBound)' Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2Interval.UpperBound)' excludesZero: operand1Interval.ExcludesZero); " is 246.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2Interval.LowerBound)' Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero); " is 246.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (operand1Interval.LowerBound' operand1Interval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 180.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (operand1Interval.LowerBound' Evaluator.Max (Evaluator.Negate (operand1Interval.LowerBound)' operand1Interval.UpperBound)' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 244.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (typeInterval.LowerBound' typeInterval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero' includesOverflow: !operand2Interval.ExcludesMinusOne); " is 226.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (Evaluator.Negate (operand1Interval.UpperBound)' Evaluator.Negate (operand1Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 218.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (typeInterval.LowerBound' typeInterval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero' includesOverflow: !operand2Interval.ExcludesMinusOne); " is 226.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (typeInterval.LowerBound' typeInterval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesOverflow: true); " is 140.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2Interval.UpperBound)' Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2Interval.UpperBound)' excludesZero: operand1Interval.ExcludesZero); " is 246.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "		Contract.Assume (Evaluator.IsNegative (operand1Interval.LowerBound) && Evaluator.IsNegative (operand1Interval.UpperBound)); " is 123.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "					return new Interval (Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2Interval.LowerBound)' Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero); " is 246.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "					return new Interval (operand1Interval.LowerBound' Evaluator.Negate (operand1Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 199.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (operand1Interval.LowerBound' Evaluator.Negate (operand1Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 199.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (Evaluator.Negate (operand1Interval.LowerBound)' Evaluator.Negate (operand1Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 218.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2Interval.LowerBound)' Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2Interval.UpperBound)' excludesZero: operand1Interval.ExcludesZero); " is 246.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "					return new Interval (Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2Interval.LowerBound)' Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero); " is 246.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "					return new Interval (operand1Interval.LowerBound' Evaluator.Negate (operand1Interval.LowerBound)' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 199.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (typeInterval.LowerBound' typeInterval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero' includesOverflow: true); " is 196.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (typeInterval.LowerBound' typeInterval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesDivisionByZero: !operand2Interval.ExcludesZero' includesOverflow: !operand2Interval.ExcludesMinusOne); " is 226.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (typeInterval.LowerBound' typeInterval.UpperBound' excludesZero: operand1Interval.ExcludesZero' includesOverflow: !operand2Interval.ExcludesMinusOne); " is 170.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "						return new Interval (Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2Interval.LowerBound)' Evaluator.Evaluate (operation' typeInterval.LowerBound' operand2Interval.UpperBound)' excludesZero: operand1Interval.ExcludesZero); " is 242.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "		if (llrl == null || lurl == null || llru == null || luru == null || llrl == Dummy.Constant || lurl == Dummy.Constant || llru == Dummy.Constant || luru == Dummy.Constant) { " is 171.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "		return new Interval (lowerBound' upperBound' includesOverflow: upperBoundOverflows' includesUnderflow: lowerBoundUnderflows); " is 125.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "		if (Evaluator.IsNumericallyEqual (operand1' Evaluator.GetMinValue (expression.Type)) && !operand2Interval.ExcludesMinusOne) " is 123.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "			return new Interval (typeInterval.LowerBound' typeInterval.UpperBound' includesDivisionByZero: !operand2Interval.ExcludesZero' includesOverflow: true); " is 151.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Evaluate (operation' operand1' operand2Interval.UpperBound)' Evaluator.Evaluate (operation' operand1' operand2Interval.LowerBound)); " is 163.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Evaluate (operation' operand1' operand2Interval.UpperBound)' operand1' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 158.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Negate (operand1)' Evaluator.Evaluate (operation' operand1' operand2Interval.LowerBound)' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 177.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Evaluate (operation' operand1' operand2Interval.UpperBound)' Evaluator.Evaluate (operation' operand1' operand2Interval.LowerBound)); " is 163.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Evaluate (operation' operand1' operand2Interval.LowerBound)' Evaluator.Evaluate (operation' operand1' operand2Interval.UpperBound)); " is 163.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (operand1' Evaluator.Evaluate (operation' operand1' operand2Interval.UpperBound)' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 158.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Evaluate (operation' operand1' operand2Interval.LowerBound)' Evaluator.Negate (operand1)' includesDivisionByZero: !operand2Interval.ExcludesZero); " is 177.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "				return new Interval (Evaluator.Evaluate (operation' operand1' operand2Interval.LowerBound)' Evaluator.Evaluate (operation' operand1' operand2Interval.UpperBound)); " is 163.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "		if (Evaluator.IsNumericallyLessThan (operand2aLower' operand2Interval.LowerBound) || Evaluator.IsNumericallyLessThan (operand2aUpper' operand2Interval.UpperBound)) " is 163.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "		return new Interval (lowerBound' upperBound' includesOverflow: upperBoundOverflows' includesUnderflow: lowerBoundUnderflows); " is 125.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "			return new Interval (Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2)' Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2)); " is 163.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "			return new Interval (Evaluator.Evaluate (operation' operand1Interval.UpperBound' operand2)' Evaluator.Evaluate (operation' operand1Interval.LowerBound' operand2)); " is 163.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "			return new Interval (Evaluator.GetZero (expression.Type)' Evaluator.GetMinusOne (expression.Type)' includesDivisionByZero: true); " is 129.
Long Statement,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The length of the statement  "			return new Interval (Evaluator.GetZero (expression.Type)' Evaluator.GetMinusOne (expression.Type)' includesDivisionByZero: true); " is 129.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "	//First set up the fall through block map. Note that this map is not quite a subset of the successor map' since we set it up for all  " is 132.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "	//blocks' including blocks that end on an unconditional transfers that do not target the blocks that immediately follow them. " is 125.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "		//We also need to make the order of operands in stack setup instructions deterministic (i.e. operands must appear in the order of the precedessor blocks). " is 154.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "	//First set up the SSA local environment for this block and at the same time see if we actually need to interpret this block again. " is 131.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "				//that is different from the expression that we now get (after we have (again) interpreted "other" blocks that branch back to this block). " is 138.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "					//If newValue contains currentValue' then this is a loop variable and further iterations will not tell us more about it. " is 120.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "		var canon = this.expressionCanonicalizer.GetCanonicalExpression (stackSetupInstruction' (Instruction)stackSetupInstruction.Operand1' stackSetupInstruction.Operand2 as Instruction' stackSetupInstruction.Operand2 as Instruction[]); " is 229.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "		this.mappings.SetCanonicalExpressionFor (stackSetupInstruction' this.expressionCanonicalizer.GetCanonicalExpression (stackSetupInstruction)); " is 141.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "	if (disjunction != null && !(disjunction.Operation.OperationCode == OperationCode.Ldc_I4 && disjunction.Operation.Value is int && 1 == (int)disjunction.Operation.Value)) " is 169.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The length of the statement  "	//Note that this block might be its own successor. The code at the start of this method ensures that the resulting loop terminates. " is 131.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNullary,The length of the statement  "	//Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time. " is 144.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNullary,The length of the statement  "		this.mappings.SetCanonicalExpressionFor (instruction' this.expressionCanonicalizer.GetCanonicalExpression (instruction)); " is 121.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,The length of the statement  "	//Insructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time. " is 143.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,The length of the statement  "		this.mappings.SetCanonicalExpressionFor (unaryInstruction' this.expressionCanonicalizer.GetCanonicalExpression (unaryInstruction' operand1)); " is 141.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,The length of the statement  "			//If the operand has been canonicalized (i.e. if it is side-effect free) we can canonicalize the unary expression and potentially constant fold it. " is 147.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The length of the statement  "			var canonicalExpression = this.expressionCanonicalizer.GetCanonicalExpression (binaryInstruction' canonicalOperand1' canonicalOperand2); " is 136.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The length of the statement  "			branchCondition = this.expressionCanonicalizer.GetCanonicalExpression (binaryInstruction' canonicalOperand1' canonicalOperand2); " is 128.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The length of the statement  "							//We now know this instruction does not affect control flow' so cache the result so that we don't consider this instruction again. " is 130.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The length of the statement  "		//if (this.expressionCanonicalizer.HasCachedEntryFor(operand1) && this.expressionCanonicalizer.HasCachedEntryFor(operand2)) { " is 125.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The length of the statement  "		//  this.mappings.SetCanonicalExpressionFor(binaryInstruction' this.expressionCanonicalizer.GetCanonicalExpression(binaryInstruction' operand1' operand2)); " is 155.
Long Statement,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,UnionOfJoinedValues,The length of the statement  "	return this.expressionCanonicalizer.GetCanonicalExpression (result' (Instruction)result.Operand1' result.Operand2 as Instruction' result.Operand2 as Instruction[]); " is 164.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 32-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.  " is 151.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//These cases push 32 bit or 64 bit values on the stack' depending on the platform' with sign propagation as appropriate.  " is 121.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 32/64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.  " is 154.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.   " is 151.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 32-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.  " is 151.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//These cases push 32 bit or 64 bit values on the stack' depending on the platform' with sign propagation as appropriate.  " is 121.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 32/64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.  " is 154.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.   " is 151.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 32-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.  " is 151.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 32-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.  " is 151.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//These cases push 32 bit or 64 bit values on the stack' depending on the platform' with sign propagation as appropriate.  " is 121.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 32/64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.  " is 154.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	//The operations then treat the 64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.   " is 151.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "			if (Evaluator.IsNumericallyLessThan (operand1' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (operand1' interval2.UpperBound)) " is 140.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "			if (Evaluator.IsNumericallyLessThan (operand1' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (operand1' interval2.UpperBound)) " is 140.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "			if (Evaluator.IsNumericallyLessThan (operand2' interval1.LowerBound) || Evaluator.IsNumericallyGreaterThan (operand2' interval1.UpperBound)) " is 140.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "			if (Evaluator.IsNumericallyLessThan (interval1.UpperBound' operand2) || Evaluator.IsNumericallyGreaterThan (interval1.LowerBound' operand2)) " is 140.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "	bool floatingPoint = operand1.Type.TypeCode == PrimitiveTypeCode.Float32 || operand1.Type.TypeCode == PrimitiveTypeCode.Float64; " is 128.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "		if (interval1 != null && interval2 != null && interval1.LowerBound != Dummy.Constant && interval2.UpperBound != Dummy.Constant) " is 127.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "		if (interval1 != null && interval2 != null && interval1.UpperBound != Dummy.Constant && interval2.LowerBound != Dummy.Constant) " is 127.
Long Statement,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The length of the statement  "			if (Evaluator.IsNumericallyLessThan (interval1.UpperBound' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (interval1.LowerBound' interval2.UpperBound)) " is 164.
Long Statement,Microsoft.Cci.Analysis,SatSolverHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\SatSolver.cs,GetSolverExpressionFor,The length of the statement  "		if (listOfConjunctions != null && expression.Type.TypeCode == PrimitiveTypeCode.Boolean && expression.Operation.OperationCode == OperationCode.Nop && expression.Operation.Value is INamedEntity) { " is 195.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,The length of the statement  "	bool operand1IsOne = compileTimeConstant1 != null && (operand1IsZero ? false : MetadataExpressionHelper.IsIntegralOne (compileTimeConstant1)); " is 142.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,The length of the statement  "	bool operand1IsMinusOne = compileTimeConstant1 != null && ((operand1IsZero || operand1IsOne) ? false : MetadataExpressionHelper.IsIntegralMinusOne (compileTimeConstant1)); " is 171.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,The length of the statement  "	bool operand2IsOne = compileTimeConstant2 != null && (operand1IsZero ? false : MetadataExpressionHelper.IsIntegralOne (compileTimeConstant2)); " is 142.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,The length of the statement  "	bool operand2IsMinusOne = compileTimeConstant2 != null && ((operand2IsZero || operand2IsOne) ? false : MetadataExpressionHelper.IsIntegralMinusOne (compileTimeConstant2)); " is 171.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,The length of the statement  "		if (operand1.Operand1 == operand2.Operand1 && operand1.Operand2 == operand2.Operand2 && operand1.Operation.OperationCode != operand2.Operation.OperationCode && operand2.Operand1 != null && operand1.Operation.OperationCode == GetInverse (operand2.Operation.OperationCode' operand2.Operand1.Type.TypeCode == PrimitiveTypeCode.Float32 || operand2.Operand1.Type.TypeCode == PrimitiveTypeCode.Float64)) { " is 399.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,HoistPhiNodes,The length of the statement  "	bool operand1IsPhiNode = operand1.Operation.OperationCode == OperationCode.Nop && operand1.Operation.Value is INamedEntity; " is 123.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,HoistPhiNodes,The length of the statement  "	bool operand2IsPhiNode = operand2.Operation.OperationCode == OperationCode.Nop && operand2.Operation.Value is INamedEntity; " is 123.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyUnary,The length of the statement  "				OperationCode newOpcode = GetInverse (operation1.OperationCode' operand1.Type.TypeCode == PrimitiveTypeCode.Float32 || operand1.Type.TypeCode == PrimitiveTypeCode.Float64); " is 172.
Long Statement,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,TryToGetSimplerLogicalInverse,The length of the statement  "		OperationCode newOpcode = GetInverse (instruction.Operation.OperationCode' opnd1.Type.TypeCode == PrimitiveTypeCode.Float32 || opnd1.Type.TypeCode == PrimitiveTypeCode.Float64); " is 177.
Long Statement,Microsoft.Cci.Analysis,SingleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\SingleAssignment.cs,CreateSSAVariablesAndJoinInformation,The length of the statement  "			//Now replace the value one more time because this instruction represents both a read (the above replacement) and a write (the replacement below). " is 146.
Complex Conditional,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The conditional expression  "llrl == null || lurl == null || llru == null || luru == null || llrl == Dummy.Constant || lurl == Dummy.Constant || llru == Dummy.Constant || luru == Dummy.Constant"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The conditional expression  "lrl == null || lru == null || lrl == Dummy.Constant || lru == Dummy.Constant"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The conditional expression  "llr == null || lur == null || llr == Dummy.Constant || lur == Dummy.Constant"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The conditional expression  "disjunction != null && !(disjunction.Operation.OperationCode == OperationCode.Ldc_I4 && disjunction.Operation.Value is int && 1 == (int)disjunction.Operation.Value)"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The conditional expression  "operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The conditional expression  "operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The conditional expression  "interval1 != null && interval2 != null && interval1.LowerBound != Dummy.Constant && interval2.UpperBound != Dummy.Constant"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The conditional expression  "interval1 != null && interval2 != null && interval1.UpperBound != Dummy.Constant && interval2.LowerBound != Dummy.Constant"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The conditional expression  "interval1 != null && interval1.IsFinite && interval2 != null && interval2.IsFinite"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,SatSolverHelper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\SatSolver.cs,GetSolverExpressionFor,The conditional expression  "listOfConjunctions != null && expression.Type.TypeCode == PrimitiveTypeCode.Boolean && expression.Operation.OperationCode == OperationCode.Nop && expression.Operation.Value is INamedEntity"  is complex.
Complex Conditional,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,The conditional expression  "operand1.Operand1 == operand2.Operand1 && operand1.Operand2 == operand2.Operand2 && operand1.Operation.OperationCode != operand2.Operation.OperationCode && operand2.Operand1 != null && operand1.Operation.OperationCode == GetInverse (operand2.Operation.OperationCode' operand2.Operand1.Type.TypeCode == PrimitiveTypeCode.Float32 || operand2.Operand1.Type.TypeCode == PrimitiveTypeCode.Float64)"  is complex.
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,MakeStackSetupInstructionsDeterministic,The following statement contains a magic number: for (int i = 0' n = block.OperandStack.Count; i < n; i++) {  	var stackSetupInstruction = block.OperandStack [i];  	predecessorOperands [0] = stackSetupInstruction.Operand1;  	if (pc == 2) {  		Contract.Assume (stackSetupInstruction.Operand2 is Microsoft.Cci.Analysis.Instruction);  		predecessorOperands [1] = (Microsoft.Cci.Analysis.Instruction)stackSetupInstruction.Operand2;  	}  	else {  		Contract.Assume (stackSetupInstruction.Operand2 is Microsoft.Cci.Analysis.Instruction[]);  		var operands2ToN = stackSetupInstruction.Operand2 as Microsoft.Cci.Analysis.Instruction[];  		if (operands2ToN != null) {  			Contract.Assume (operands2ToN.Length == pc - 1);  			for (int k = 1; k < pc; k++)  				predecessorOperands [k] = operands2ToN [k - 1];  		}  	}  	Array.Sort (predecessorOperands' (x' y) => ((int)x.Operation.Offset) - (int)y.Operation.Offset);  	stackSetupInstruction.Operand1 = predecessorOperands [0];  	if (pc == 2)  		stackSetupInstruction.Operand2 = predecessorOperands [1];  	else {  		var operands2ToN = stackSetupInstruction.Operand2 as Microsoft.Cci.Analysis.Instruction[];  		Contract.Assume (operands2ToN != null);  		Contract.Assume (pc == operands2ToN.Length);  		for (int k = 1; k < pc; k++)  			operands2ToN [k - 1] = predecessorOperands [k];  	}  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,MakeStackSetupInstructionsDeterministic,The following statement contains a magic number: for (int i = 0' n = block.OperandStack.Count; i < n; i++) {  	var stackSetupInstruction = block.OperandStack [i];  	predecessorOperands [0] = stackSetupInstruction.Operand1;  	if (pc == 2) {  		Contract.Assume (stackSetupInstruction.Operand2 is Microsoft.Cci.Analysis.Instruction);  		predecessorOperands [1] = (Microsoft.Cci.Analysis.Instruction)stackSetupInstruction.Operand2;  	}  	else {  		Contract.Assume (stackSetupInstruction.Operand2 is Microsoft.Cci.Analysis.Instruction[]);  		var operands2ToN = stackSetupInstruction.Operand2 as Microsoft.Cci.Analysis.Instruction[];  		if (operands2ToN != null) {  			Contract.Assume (operands2ToN.Length == pc - 1);  			for (int k = 1; k < pc; k++)  				predecessorOperands [k] = operands2ToN [k - 1];  		}  	}  	Array.Sort (predecessorOperands' (x' y) => ((int)x.Operation.Offset) - (int)y.Operation.Offset);  	stackSetupInstruction.Operand1 = predecessorOperands [0];  	if (pc == 2)  		stackSetupInstruction.Operand2 = predecessorOperands [1];  	else {  		var operands2ToN = stackSetupInstruction.Operand2 as Microsoft.Cci.Analysis.Instruction[];  		Contract.Assume (operands2ToN != null);  		Contract.Assume (pc == operands2ToN.Length);  		for (int k = 1; k < pc; k++)  			operands2ToN [k - 1] = predecessorOperands [k];  	}  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,MakeStackSetupInstructionsDeterministic,The following statement contains a magic number: if (pc == 2) {  	Contract.Assume (stackSetupInstruction.Operand2 is Microsoft.Cci.Analysis.Instruction);  	predecessorOperands [1] = (Microsoft.Cci.Analysis.Instruction)stackSetupInstruction.Operand2;  }  else {  	Contract.Assume (stackSetupInstruction.Operand2 is Microsoft.Cci.Analysis.Instruction[]);  	var operands2ToN = stackSetupInstruction.Operand2 as Microsoft.Cci.Analysis.Instruction[];  	if (operands2ToN != null) {  		Contract.Assume (operands2ToN.Length == pc - 1);  		for (int k = 1; k < pc; k++)  			predecessorOperands [k] = operands2ToN [k - 1];  	}  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,MakeStackSetupInstructionsDeterministic,The following statement contains a magic number: if (pc == 2)  	stackSetupInstruction.Operand2 = predecessorOperands [1];  else {  	var operands2ToN = stackSetupInstruction.Operand2 as Microsoft.Cci.Analysis.Instruction[];  	Contract.Assume (operands2ToN != null);  	Contract.Assume (pc == operands2ToN.Length);  	for (int k = 1; k < pc; k++)  		operands2ToN [k - 1] = predecessorOperands [k];  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The following statement contains a magic number: if (!this.lastStatementWasUnconditionalTransfer) {  	var fallThroughBlock = block.FallThroughBlock as BasicBlock;  	if (fallThroughBlock != null) {  		//it might be null if this block is the very last one and it erroneously does not end on an unconditional branch.  		var i = successors.Find (fallThroughBlock);  		if (i >= 0) {  			this.liveSuccessorBlocks.Add (fallThroughBlock);  			if (this.constraints.Count > 0) {  				while (block.ConstraintsAtExit.Count <= i)  					block.ConstraintsAtExit.Add (new List<Instruction> (4));  				var constraintsAtExit = block.ConstraintsAtExit [i];  				Contract.Assume (constraintsAtExit != null);  				constraintsAtExit.Clear ();  				constraintsAtExit.AddRange (this.constraints);  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The following statement contains a magic number: if (fallThroughBlock != null) {  	//it might be null if this block is the very last one and it erroneously does not end on an unconditional branch.  	var i = successors.Find (fallThroughBlock);  	if (i >= 0) {  		this.liveSuccessorBlocks.Add (fallThroughBlock);  		if (this.constraints.Count > 0) {  			while (block.ConstraintsAtExit.Count <= i)  				block.ConstraintsAtExit.Add (new List<Instruction> (4));  			var constraintsAtExit = block.ConstraintsAtExit [i];  			Contract.Assume (constraintsAtExit != null);  			constraintsAtExit.Clear ();  			constraintsAtExit.AddRange (this.constraints);  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The following statement contains a magic number: if (i >= 0) {  	this.liveSuccessorBlocks.Add (fallThroughBlock);  	if (this.constraints.Count > 0) {  		while (block.ConstraintsAtExit.Count <= i)  			block.ConstraintsAtExit.Add (new List<Instruction> (4));  		var constraintsAtExit = block.ConstraintsAtExit [i];  		Contract.Assume (constraintsAtExit != null);  		constraintsAtExit.Clear ();  		constraintsAtExit.AddRange (this.constraints);  	}  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The following statement contains a magic number: if (this.constraints.Count > 0) {  	while (block.ConstraintsAtExit.Count <= i)  		block.ConstraintsAtExit.Add (new List<Instruction> (4));  	var constraintsAtExit = block.ConstraintsAtExit [i];  	Contract.Assume (constraintsAtExit != null);  	constraintsAtExit.Clear ();  	constraintsAtExit.AddRange (this.constraints);  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The following statement contains a magic number: while (block.ConstraintsAtExit.Count <= i)  	block.ConstraintsAtExit.Add (new List<Instruction> (4));  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,Interpret,The following statement contains a magic number: block.ConstraintsAtExit.Add (new List<Instruction> (4));  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNullary,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	this.mappings.SetCanonicalExpressionFor (instruction' this.expressionCanonicalizer.GetCanonicalExpression (instruction));  	break;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	Contract.Assume (operation.Value is uint);  	//This is an informally specified property of the Metadata model.  	var targetOffset = (uint)instruction.Operation.Value;  	var targetBlock = this.cdfg.BlockFor [targetOffset];  	this.liveSuccessorBlocks.Add (targetBlock);  	this.lastStatementWasUnconditionalTransfer = true;  	var i = this.cdfg.SuccessorsFor (this.currentBlock).Find (targetBlock);  	if (i >= 0) {  		while (this.currentBlock.ConstraintsAtExit.Count <= i)  			this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  		var constraintsForTarget = this.currentBlock.ConstraintsAtExit [i];  		Contract.Assume (constraintsForTarget != null);  		constraintsForTarget.Clear ();  		constraintsForTarget.AddRange (this.constraints);  	}  	break;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	var constval = Evaluator.GetAsCompileTimeConstantValue (instruction);  	this.mappings.SetCompileTimeConstantValueFor (instruction' constval);  	var constLoad = this.expressionCanonicalizer.GetAsCanonicalizedLoadConstant (constval' instruction);  	this.mappings.SetCanonicalExpressionFor (instruction' constLoad);  	this.mappings.SetCompileTimeConstantValueFor (constLoad' constval);  	break;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var variable = operation.Value as INamedEntity;  	var constantValue = variable == null ? null : this.mappings.GetCompileTimeConstantValueFor (variable);  	if (constantValue != null) {  		this.mappings.SetCompileTimeConstantValueFor (instruction' constantValue);  		constLoad = this.expressionCanonicalizer.GetAsCanonicalizedLoadConstant (constantValue' instruction);  		this.mappings.SetCanonicalExpressionFor (instruction' constLoad);  		this.mappings.SetCompileTimeConstantValueFor (constLoad' constantValue);  	}  	else {  		var definingExpression = variable == null ? null : this.mappings.GetDefiningExpressionFor (variable);  		if (definingExpression != null)  			this.mappings.SetCanonicalExpressionFor (instruction' definingExpression);  		else {  			var canonicalExpr = this.GetCanonicalizedLoadInstruction (operation.Value ?? Dummy.ParameterDefinition);  			this.mappings.SetCanonicalExpressionFor (instruction' canonicalExpr);  		}  	}  	break;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We do NOT attempt to compute the compile time values at this time.  case OperationCode.Ldsfld:  	//TODO: track and map this when not affected by a volatile modifier.  	break;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	break;  //Instructions that transfer control out of the method being interpreted.  case OperationCode.Jmp:  case OperationCode.Rethrow:  case OperationCode.Ret:  	this.lastStatementWasUnconditionalTransfer = true;  	break;  //Instruction modifier to track in the future.  case OperationCode.Volatile_:  	//TODO: track its occurrence and disable any CSE on the next field load. None happens right now.  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNullary,The following statement contains a magic number: if (i >= 0) {  	while (this.currentBlock.ConstraintsAtExit.Count <= i)  		this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  	var constraintsForTarget = this.currentBlock.ConstraintsAtExit [i];  	Contract.Assume (constraintsForTarget != null);  	constraintsForTarget.Clear ();  	constraintsForTarget.AddRange (this.constraints);  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNullary,The following statement contains a magic number: while (this.currentBlock.ConstraintsAtExit.Count <= i)  	this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretNullary,The following statement contains a magic number: this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that cause or depend on side-effects. We'll keep them as is.  case OperationCode.Box:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Callvirt:  case OperationCode.Initobj:  case OperationCode.Ldobj:  case OperationCode.Localloc:  case OperationCode.Mkrefany:  case OperationCode.Newarr:  case OperationCode.Newobj:  case OperationCode.Pop:  case OperationCode.Stsfld:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  	break;  //Insructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Isinst:  case OperationCode.Ldlen:  case OperationCode.Ldvirtftn:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  //TODO: If we track object contents' we might be able to know the value of this at compile time.  case OperationCode.Sizeof:  	this.mappings.SetCanonicalExpressionFor (unaryInstruction' this.expressionCanonicalizer.GetCanonicalExpression (unaryInstruction' operand1));  	break;  //Instructions that conditionally affect control flow. We keep them as is' but update the control flow appropriately.  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  	operand1.Type = operand1.Type.PlatformType.SystemBoolean;  	var canonicalOperand1 = this.mappings.GetCanonicalExpressionFor (operand1);  	if (canonicalOperand1 != null) {  		var cv1 = this.TryToGetCompileTimeConstantValueFor (canonicalOperand1);  		if (cv1 != null) {  			if (MetadataExpressionHelper.IsIntegralNonzero (cv1))  				break;  			this.lastStatementWasUnconditionalTransfer = true;  		}  		else {  			var result = this.mappings.CheckIfExpressionIsTrue (canonicalOperand1' block);  			if (result != null) {  				if (result.Value)  					break;  				this.lastStatementWasUnconditionalTransfer = true;  			}  		}  		canonicalOperand1 = this.ConvertUnionIntoConditionIfPossible (canonicalOperand1' block);  		canonicalOperand1 = this.expressionCanonicalizer.GetCanonicalExpression (new Instruction () {  			Operation = new Operation () {  				OperationCode = OperationCode.Not  			}'  			Type = operand1.Type  		}' operand1);  	}  	goto addTargetToLiveSuccessorSet;  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	operand1.Type = operand1.Type.PlatformType.SystemBoolean;  	canonicalOperand1 = this.mappings.GetCanonicalExpressionFor (operand1);  	if (canonicalOperand1 != null) {  		var cv1 = this.TryToGetCompileTimeConstantValueFor (canonicalOperand1);  		if (cv1 != null) {  			if (MetadataExpressionHelper.IsIntegralZero (cv1))  				break;  			this.lastStatementWasUnconditionalTransfer = true;  		}  		else {  			var result = this.mappings.CheckIfExpressionIsTrue (canonicalOperand1' block);  			if (result != null) {  				if (!result.Value)  					break;  				this.lastStatementWasUnconditionalTransfer = true;  			}  		}  		canonicalOperand1 = this.ConvertUnionIntoConditionIfPossible (canonicalOperand1' block);  	}  	addTargetToLiveSuccessorSet:  	Contract.Assume (unaryInstruction.Operation.Value is uint);  	//This is an informally specified property of the Metadata model.  	var targetOffset = (uint)unaryInstruction.Operation.Value;  	var targetBlock = this.cdfg.BlockFor [targetOffset];  	var i = this.cdfg.SuccessorsFor (this.currentBlock).Find (targetBlock);  	if (i >= 0) {  		while (this.currentBlock.ConstraintsAtExit.Count <= i)  			this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  		var constraintsForTarget = this.currentBlock.ConstraintsAtExit [i];  		Contract.Assume (constraintsForTarget != null);  		constraintsForTarget.Clear ();  		constraintsForTarget.AddRange (this.constraints);  		if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  			constraintsForTarget.Add (canonicalOperand1 ?? operand1);  	}  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean) {  		if (canonicalOperand1 != null) {  			var invertedBranchCondition = this.expressionCanonicalizer.GetCanonicalExpression (new Instruction () {  				Operation = new Operation {  					OperationCode = OperationCode.Not  				}'  				Type = operand1.Type  			}' canonicalOperand1);  			this.constraints.Add (invertedBranchCondition);  		}  		else {  			this.constraints.Add (new Instruction () {  				Operation = new Operation {  					OperationCode = OperationCode.Not  				}'  				Operand1 = operand1'  				Type = operand1.Type  			});  		}  	}  	this.liveSuccessorBlocks.Add (targetBlock);  	break;  //Instructions that are side-effect free and that could result in concrete compile time values.  //We attempt to compute the compile time values.  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Dup:  case OperationCode.Neg:  case OperationCode.Not:  	canonicalOperand1 = this.mappings.GetCanonicalExpressionFor (operand1);  	if (canonicalOperand1 != null) {  		//If the operand has been canonicalized (i.e. if it is side-effect free) we can canonicalize the unary expression and potentially constant fold it.  		var canonicalExpression = this.expressionCanonicalizer.GetCanonicalExpression (unaryInstruction' canonicalOperand1);  		this.mappings.SetCanonicalExpressionFor (unaryInstruction' canonicalExpression);  		var cv1 = this.TryToGetCompileTimeConstantValueFor (operand1);  		if (cv1 != null) {  			var cr = Evaluator.Evaluate (operation' cv1);  			if (cr != null) {  				this.mappings.SetCompileTimeConstantValueFor (unaryInstruction' cr);  				this.mappings.SetCompileTimeConstantValueFor (canonicalExpression' cr);  			}  		}  	}  	break;  //Instructions that can be cached in the absence of volatility' aliasing and multiple writes.  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  	//TODO: track the values that pointers point to  	break;  //Instructions that affect the SSA environment.  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	var variable = operation.Value as INamedEntity;  	if (variable != null) {  		var cv1 = this.TryToGetCompileTimeConstantValueFor (operand1);  		if (cv1 != null) {  			var canon = this.GetCanonicalizedLoadInstruction (variable);  			canon = this.expressionCanonicalizer.GetAsCanonicalizedLoadConstant (cv1' canon);  			this.mappings.SetDefininingExpressionFor (variable' canon);  			this.mappings.SetCompileTimeConstantValueFor (variable' cv1);  			this.mappings.SetCompileTimeConstantValueFor (canon' cv1);  		}  		else {  			var canon = this.mappings.GetCanonicalExpressionFor (operand1);  			if (canon != null) {  				var oldExpr = this.mappings.GetDefiningExpressionFor (variable);  				if (oldExpr == null || !this.mappings.IsRecursive (oldExpr)) {  					this.mappings.SetDefininingExpressionFor (variable' canon);  					if (oldExpr != null && Evaluator.Contains (canon' oldExpr)) {  						this.mappings.SetIsRecursive (canon);  						if (this.constraints.Count > 0 && this.constraints [0] != null) {  							this.constraints [0] = Purger.Purge (this.constraints [0]' variable' this.expressionCanonicalizer);  						}  					}  				}  			}  		}  	}  	break;  //Instructions that transfer control out of the method being interpreted.  case OperationCode.Ret:  case OperationCode.Throw:  	this.lastStatementWasUnconditionalTransfer = true;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,The following statement contains a magic number: if (i >= 0) {  	while (this.currentBlock.ConstraintsAtExit.Count <= i)  		this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  	var constraintsForTarget = this.currentBlock.ConstraintsAtExit [i];  	Contract.Assume (constraintsForTarget != null);  	constraintsForTarget.Clear ();  	constraintsForTarget.AddRange (this.constraints);  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		constraintsForTarget.Add (canonicalOperand1 ?? operand1);  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,The following statement contains a magic number: while (this.currentBlock.ConstraintsAtExit.Count <= i)  	this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretUnary,The following statement contains a magic number: this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,ConvertUnionIntoConditionIfPossible,The following statement contains a magic number: if (block.ConstraintsAtEntry.Count != 2)  	return expression;  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side-effect free and cacheable and that could result in compile time values.  //We attempt to compute the compile time values.  case OperationCode.Add:  	goto case OperationCode.Add_Ovf_Un;  case OperationCode.Add_Ovf:  	goto case OperationCode.Add_Ovf_Un;  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	var canonicalOperand1 = this.mappings.GetCanonicalExpressionFor (operand1);  	var canonicalOperand2 = this.mappings.GetCanonicalExpressionFor (operand2);  	if (canonicalOperand1 != null && canonicalOperand2 != null) {  		//Both operands are side effect free' so we can try to canonicalize the binary expression and perhaps constant fold it.  		var canonicalExpression = this.expressionCanonicalizer.GetCanonicalExpression (binaryInstruction' canonicalOperand1' canonicalOperand2);  		this.mappings.SetCanonicalExpressionFor (binaryInstruction' canonicalExpression);  		var cv1 = this.TryToGetCompileTimeConstantValueFor (operand1);  		if (cv1 != null) {  			var cv2 = this.TryToGetCompileTimeConstantValueFor (operand2);  			if (cv2 != null) {  				var cr = Evaluator.Evaluate (operation' cv1' cv2);  				if (cr != null) {  					this.mappings.SetCompileTimeConstantValueFor (binaryInstruction' cr);  					this.mappings.SetCompileTimeConstantValueFor (canonicalExpression' cr);  					break;  				}  			}  			else {  				var cr = Evaluator.Evaluate (operation' cv1' operand2' this.mappings);  				if (cr != null) {  					this.mappings.SetCompileTimeConstantValueFor (binaryInstruction' cr);  					this.mappings.SetCompileTimeConstantValueFor (canonicalExpression' cr);  					break;  				}  			}  		}  		else {  			var cv2 = this.TryToGetCompileTimeConstantValueFor (operand2);  			if (cv2 != null) {  				var cr = Evaluator.Evaluate (operation' operand1' cv2' this.mappings);  				if (cr != null) {  					this.mappings.SetCompileTimeConstantValueFor (canonicalExpression' cr);  					this.mappings.SetCompileTimeConstantValueFor (binaryInstruction' cr);  					break;  				}  			}  			else {  				var cr = Evaluator.Evaluate (operation' operand1' operand2' this.mappings);  				if (cr != null) {  					this.mappings.SetCompileTimeConstantValueFor (binaryInstruction' cr);  					this.mappings.SetCompileTimeConstantValueFor (canonicalExpression' cr);  					break;  				}  			}  		}  	}  	break;  //Instructions that conditionally affect control flow  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	Contract.Assume (binaryInstruction.Operation.Value is uint);  	//This is an informally specified property of the Metadata model.  	var targetOffset = (uint)binaryInstruction.Operation.Value;  	var targetBlock = this.cdfg.BlockFor [targetOffset];  	canonicalOperand1 = this.mappings.GetCanonicalExpressionFor (operand1);  	canonicalOperand2 = this.mappings.GetCanonicalExpressionFor (operand2);  	Instruction branchCondition = binaryInstruction;  	if (canonicalOperand1 != null && canonicalOperand2 != null) {  		branchCondition = this.expressionCanonicalizer.GetCanonicalExpression (binaryInstruction' canonicalOperand1' canonicalOperand2);  		branchCondition.Type = binaryInstruction.Type.PlatformType.SystemBoolean;  		var cv1 = this.TryToGetCompileTimeConstantValueFor (operand1);  		if (cv1 != null) {  			var cv2 = this.TryToGetCompileTimeConstantValueFor (operand2);  			if (cv2 != null) {  				var cr = Evaluator.Evaluate (operation' cv1' cv2);  				if (cr != null) {  					if (MetadataExpressionHelper.IsIntegralZero (cr)) {  						//We now know this instruction does not affect control flow' so cache the result so that we don't consider this instruction again.  						this.mappings.SetCompileTimeConstantValueFor (binaryInstruction' cr);  						this.mappings.SetCompileTimeConstantValueFor (branchCondition' cr);  						break;  					}  					this.lastStatementWasUnconditionalTransfer = true;  				}  			}  		}  	}  	if (!this.lastStatementWasUnconditionalTransfer) {  		var result = this.mappings.CheckIfExpressionIsTrue (branchCondition' block);  		if (result != null) {  			if (!result.Value)  				break;  			this.lastStatementWasUnconditionalTransfer = true;  		}  	}  	var i = this.cdfg.SuccessorsFor (this.currentBlock).Find (targetBlock);  	if (i >= 0) {  		while (this.currentBlock.ConstraintsAtExit.Count <= i)  			this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  		var constraintsForTarget = this.currentBlock.ConstraintsAtExit [i];  		Contract.Assume (constraintsForTarget != null);  		constraintsForTarget.Clear ();  		constraintsForTarget.AddRange (this.constraints);  		constraintsForTarget.Add (branchCondition);  	}  	var invertedBranchCondition = this.expressionCanonicalizer.GetCanonicalExpression (new Instruction () {  		Operation = new Operation {  			OperationCode = OperationCode.Not  		}'  		Type = binaryInstruction.Type  	}' branchCondition);  	this.constraints.Add (invertedBranchCondition);  	this.liveSuccessorBlocks.Add (targetBlock);  	break;  //Instructions that cause side-effect that we do not currently track.  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Callvirt:  case OperationCode.Cpblk:  case OperationCode.Cpobj:  case OperationCode.Initblk:  case OperationCode.Newobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	break;  //Instructions that are side-effect free and cacheable and that could result in compile time values.  //We do NOT attempt to compute the compile time values at this time.  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelema:  	//if (this.expressionCanonicalizer.HasCachedEntryFor(operand1) && this.expressionCanonicalizer.HasCachedEntryFor(operand2)) {  	//  this.mappings.SetCanonicalExpressionFor(binaryInstruction' this.expressionCanonicalizer.GetCanonicalExpression(binaryInstruction' operand1' operand2));  	//}  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The following statement contains a magic number: if (i >= 0) {  	while (this.currentBlock.ConstraintsAtExit.Count <= i)  		this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  	var constraintsForTarget = this.currentBlock.ConstraintsAtExit [i];  	Contract.Assume (constraintsForTarget != null);  	constraintsForTarget.Clear ();  	constraintsForTarget.AddRange (this.constraints);  	constraintsForTarget.Add (branchCondition);  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The following statement contains a magic number: while (this.currentBlock.ConstraintsAtExit.Count <= i)  	this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,InterpretBinary,The following statement contains a magic number: this.currentBlock.ConstraintsAtExit.Add (new List<Instruction> (4));  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,UnionOfJoinedValues,The following statement contains a magic number: if (n > 0) {  	result.Operand1 = this.GetDefininingExpressionFor (join' predecessors [0]' block);  	if (n > 1) {  		result.Operand2 = this.GetDefininingExpressionFor (join' predecessors [1]' block);  		if (n > 2) {  			var operands2ToN = new Instruction[n - 1];  			operands2ToN [0] = (Instruction)result.Operand2;  			result.Operand2 = operands2ToN;  			for (int i = 1; i < n - 1; i++) {  				operands2ToN [i] = this.GetDefininingExpressionFor (join' predecessors [i + 1]' block);  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,UnionOfJoinedValues,The following statement contains a magic number: if (n > 1) {  	result.Operand2 = this.GetDefininingExpressionFor (join' predecessors [1]' block);  	if (n > 2) {  		var operands2ToN = new Instruction[n - 1];  		operands2ToN [0] = (Instruction)result.Operand2;  		result.Operand2 = operands2ToN;  		for (int i = 1; i < n - 1; i++) {  			operands2ToN [i] = this.GetDefininingExpressionFor (join' predecessors [i + 1]' block);  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,UnionOfJoinedValues,The following statement contains a magic number: if (n > 2) {  	var operands2ToN = new Instruction[n - 1];  	operands2ToN [0] = (Instruction)result.Operand2;  	result.Operand2 = operands2ToN;  	for (int i = 1; i < n - 1; i++) {  		operands2ToN [i] = this.GetDefininingExpressionFor (join' predecessors [i + 1]' block);  	}  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,DecreaseBySmallestInterval,The following statement contains a magic number: switch (operand.Type.TypeCode) {  case PrimitiveTypeCode.Int8:  	Contract.Assume (operand.Value is sbyte);  	var sb = (sbyte)operand.Value;  	if (sb == sbyte.MinValue)  		return operand;  	value = --sb;  	break;  case PrimitiveTypeCode.Int16:  	Contract.Assume (operand.Value is short);  	var s = (short)operand.Value;  	if (s == short.MinValue)  		return operand;  	value = --s;  	break;  case PrimitiveTypeCode.Int32:  	Contract.Assume (operand.Value is int);  	var i = (int)operand.Value;  	if (i == int.MinValue)  		return operand;  	value = --i;  	break;  case PrimitiveTypeCode.Int64:  	Contract.Assume (operand.Value is long);  	var l = (long)operand.Value;  	if (l == long.MinValue)  		return operand;  	value = --l;  	break;  case PrimitiveTypeCode.IntPtr:  	Contract.Assume (operand.Value is IntPtr);  	var iptr = (long)(IntPtr)operand.Value;  	if (iptr == long.MinValue)  		return operand;  	value = (IntPtr)(--iptr);  	break;  case PrimitiveTypeCode.UInt8:  	Contract.Assume (operand.Value is byte);  	var b = (byte)operand.Value;  	if (b == byte.MinValue)  		return operand;  	value = --b;  	break;  case PrimitiveTypeCode.UInt16:  	Contract.Assume (operand.Value is ushort);  	var us = (ushort)operand.Value;  	if (us == ushort.MinValue)  		return operand;  	value = --us;  	break;  case PrimitiveTypeCode.UInt32:  	Contract.Assume (operand.Value is uint);  	var ui = (uint)operand.Value;  	if (ui == uint.MinValue)  		return operand;  	value = --ui;  	break;  case PrimitiveTypeCode.UInt64:  	Contract.Assume (operand.Value is ulong);  	var ul = (ulong)operand.Value;  	if (ul == ulong.MinValue)  		return operand;  	value = --ul;  	break;  case PrimitiveTypeCode.UIntPtr:  	Contract.Assume (operand.Value is UIntPtr);  	var uptr = (ulong)(UIntPtr)operand.Value;  	if (uptr == ulong.MinValue)  		return operand;  	value = (UIntPtr)(--uptr);  	break;  case PrimitiveTypeCode.Float32:  	Contract.Assume (operand.Value is float);  	var f = (float)operand.Value;  	var incr = float.Epsilon;  	var fincr = f - incr;  	while (fincr == f) {  		incr *= 2;  		fincr -= incr;  	}  	if (float.IsNegativeInfinity (fincr))  		return operand;  	value = fincr;  	break;  case PrimitiveTypeCode.Float64:  	Contract.Assume (operand.Value is double);  	var d = (double)operand.Value;  	var incrd = double.Epsilon;  	var dincr = d + incrd;  	while (dincr == d) {  		incrd *= 2;  		dincr += incrd;  	}  	if (double.IsNegativeInfinity (dincr))  		return operand;  	value = dincr;  	break;  default:  	return Dummy.Constant;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,DecreaseBySmallestInterval,The following statement contains a magic number: switch (operand.Type.TypeCode) {  case PrimitiveTypeCode.Int8:  	Contract.Assume (operand.Value is sbyte);  	var sb = (sbyte)operand.Value;  	if (sb == sbyte.MinValue)  		return operand;  	value = --sb;  	break;  case PrimitiveTypeCode.Int16:  	Contract.Assume (operand.Value is short);  	var s = (short)operand.Value;  	if (s == short.MinValue)  		return operand;  	value = --s;  	break;  case PrimitiveTypeCode.Int32:  	Contract.Assume (operand.Value is int);  	var i = (int)operand.Value;  	if (i == int.MinValue)  		return operand;  	value = --i;  	break;  case PrimitiveTypeCode.Int64:  	Contract.Assume (operand.Value is long);  	var l = (long)operand.Value;  	if (l == long.MinValue)  		return operand;  	value = --l;  	break;  case PrimitiveTypeCode.IntPtr:  	Contract.Assume (operand.Value is IntPtr);  	var iptr = (long)(IntPtr)operand.Value;  	if (iptr == long.MinValue)  		return operand;  	value = (IntPtr)(--iptr);  	break;  case PrimitiveTypeCode.UInt8:  	Contract.Assume (operand.Value is byte);  	var b = (byte)operand.Value;  	if (b == byte.MinValue)  		return operand;  	value = --b;  	break;  case PrimitiveTypeCode.UInt16:  	Contract.Assume (operand.Value is ushort);  	var us = (ushort)operand.Value;  	if (us == ushort.MinValue)  		return operand;  	value = --us;  	break;  case PrimitiveTypeCode.UInt32:  	Contract.Assume (operand.Value is uint);  	var ui = (uint)operand.Value;  	if (ui == uint.MinValue)  		return operand;  	value = --ui;  	break;  case PrimitiveTypeCode.UInt64:  	Contract.Assume (operand.Value is ulong);  	var ul = (ulong)operand.Value;  	if (ul == ulong.MinValue)  		return operand;  	value = --ul;  	break;  case PrimitiveTypeCode.UIntPtr:  	Contract.Assume (operand.Value is UIntPtr);  	var uptr = (ulong)(UIntPtr)operand.Value;  	if (uptr == ulong.MinValue)  		return operand;  	value = (UIntPtr)(--uptr);  	break;  case PrimitiveTypeCode.Float32:  	Contract.Assume (operand.Value is float);  	var f = (float)operand.Value;  	var incr = float.Epsilon;  	var fincr = f - incr;  	while (fincr == f) {  		incr *= 2;  		fincr -= incr;  	}  	if (float.IsNegativeInfinity (fincr))  		return operand;  	value = fincr;  	break;  case PrimitiveTypeCode.Float64:  	Contract.Assume (operand.Value is double);  	var d = (double)operand.Value;  	var incrd = double.Epsilon;  	var dincr = d + incrd;  	while (dincr == d) {  		incrd *= 2;  		dincr += incrd;  	}  	if (double.IsNegativeInfinity (dincr))  		return operand;  	value = dincr;  	break;  default:  	return Dummy.Constant;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,DecreaseBySmallestInterval,The following statement contains a magic number: while (fincr == f) {  	incr *= 2;  	fincr -= incr;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,DecreaseBySmallestInterval,The following statement contains a magic number: incr *= 2;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,DecreaseBySmallestInterval,The following statement contains a magic number: while (dincr == d) {  	incrd *= 2;  	dincr += incrd;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,DecreaseBySmallestInterval,The following statement contains a magic number: incrd *= 2;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  	break;  case OperationCode.And:  	break;  case OperationCode.Ceq:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	break;  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  	goto case OperationCode.Bgt;  case OperationCode.Clt:  case OperationCode.Clt_Un:  	goto case OperationCode.Blt;  case OperationCode.Div:  	if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 1;  			resultType = operand1.Type.PlatformType.SystemInt32;  		}  		else {  			resultValue = 1L;  			resultType = operand1.Type.PlatformType.SystemInt64;  		}  	}  	break;  case OperationCode.Div_Un:  	if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 1u;  			resultType = operand1.Type.PlatformType.SystemUInt32;  		}  		else {  			resultValue = 1UL;  			resultType = operand1.Type.PlatformType.SystemUInt64;  		}  	}  	break;  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  	break;  case OperationCode.Or:  	break;  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	break;  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	if (operand1 == operand2 && !floatingPoint) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 0;  			resultType = operand1.Type.PlatformType.SystemInt32;  		}  		else {  			resultValue = 0L;  			resultType = operand1.Type.PlatformType.SystemInt64;  		}  	}  	break;  //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	if (operand1 == operand2) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (operation.OperationCode == OperationCode.Beq || operation.OperationCode == OperationCode.Beq_S)  		break;  	goto case OperationCode.Bgt;  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval2 != null && interval1.LowerBound != Dummy.Constant && interval2.UpperBound != Dummy.Constant)  		return NullUnlessTrue (Evaluator.Evaluate (operation' interval1.LowerBound' interval2.UpperBound));  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	if (operand1 == operand2) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	goto case OperationCode.Blt;  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval2 != null && interval1.UpperBound != Dummy.Constant && interval2.LowerBound != Dummy.Constant)  		return NullUnlessTrue (Evaluator.Evaluate (operation' interval1.UpperBound' interval2.LowerBound));  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval1.IsFinite && interval2 != null && interval2.IsFinite) {  		if (Evaluator.IsNumericallyLessThan (interval1.UpperBound' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (interval1.LowerBound' interval2.UpperBound))  			return new MetadataConstant () {  				Value = true'  				Type = operand1.Type.PlatformType.SystemBoolean  			};  	}  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  	break;  case OperationCode.And:  	break;  case OperationCode.Ceq:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	break;  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  	goto case OperationCode.Bgt;  case OperationCode.Clt:  case OperationCode.Clt_Un:  	goto case OperationCode.Blt;  case OperationCode.Div:  	if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 1;  			resultType = operand1.Type.PlatformType.SystemInt32;  		}  		else {  			resultValue = 1L;  			resultType = operand1.Type.PlatformType.SystemInt64;  		}  	}  	break;  case OperationCode.Div_Un:  	if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 1u;  			resultType = operand1.Type.PlatformType.SystemUInt32;  		}  		else {  			resultValue = 1UL;  			resultType = operand1.Type.PlatformType.SystemUInt64;  		}  	}  	break;  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  	break;  case OperationCode.Or:  	break;  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	break;  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	if (operand1 == operand2 && !floatingPoint) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 0;  			resultType = operand1.Type.PlatformType.SystemInt32;  		}  		else {  			resultValue = 0L;  			resultType = operand1.Type.PlatformType.SystemInt64;  		}  	}  	break;  //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	if (operand1 == operand2) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (operation.OperationCode == OperationCode.Beq || operation.OperationCode == OperationCode.Beq_S)  		break;  	goto case OperationCode.Bgt;  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval2 != null && interval1.LowerBound != Dummy.Constant && interval2.UpperBound != Dummy.Constant)  		return NullUnlessTrue (Evaluator.Evaluate (operation' interval1.LowerBound' interval2.UpperBound));  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	if (operand1 == operand2) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	goto case OperationCode.Blt;  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval2 != null && interval1.UpperBound != Dummy.Constant && interval2.LowerBound != Dummy.Constant)  		return NullUnlessTrue (Evaluator.Evaluate (operation' interval1.UpperBound' interval2.LowerBound));  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval1.IsFinite && interval2 != null && interval2.IsFinite) {  		if (Evaluator.IsNumericallyLessThan (interval1.UpperBound' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (interval1.LowerBound' interval2.UpperBound))  			return new MetadataConstant () {  				Value = true'  				Type = operand1.Type.PlatformType.SystemBoolean  			};  	}  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  	break;  case OperationCode.And:  	break;  case OperationCode.Ceq:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	break;  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  	goto case OperationCode.Bgt;  case OperationCode.Clt:  case OperationCode.Clt_Un:  	goto case OperationCode.Blt;  case OperationCode.Div:  	if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 1;  			resultType = operand1.Type.PlatformType.SystemInt32;  		}  		else {  			resultValue = 1L;  			resultType = operand1.Type.PlatformType.SystemInt64;  		}  	}  	break;  case OperationCode.Div_Un:  	if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 1u;  			resultType = operand1.Type.PlatformType.SystemUInt32;  		}  		else {  			resultValue = 1UL;  			resultType = operand1.Type.PlatformType.SystemUInt64;  		}  	}  	break;  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  	break;  case OperationCode.Or:  	break;  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	break;  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	if (operand1 == operand2 && !floatingPoint) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 0;  			resultType = operand1.Type.PlatformType.SystemInt32;  		}  		else {  			resultValue = 0L;  			resultType = operand1.Type.PlatformType.SystemInt64;  		}  	}  	break;  //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	if (operand1 == operand2) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (operation.OperationCode == OperationCode.Beq || operation.OperationCode == OperationCode.Beq_S)  		break;  	goto case OperationCode.Bgt;  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval2 != null && interval1.LowerBound != Dummy.Constant && interval2.UpperBound != Dummy.Constant)  		return NullUnlessTrue (Evaluator.Evaluate (operation' interval1.LowerBound' interval2.UpperBound));  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	if (operand1 == operand2) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	goto case OperationCode.Blt;  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval2 != null && interval1.UpperBound != Dummy.Constant && interval2.LowerBound != Dummy.Constant)  		return NullUnlessTrue (Evaluator.Evaluate (operation' interval1.UpperBound' interval2.LowerBound));  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval1.IsFinite && interval2 != null && interval2.IsFinite) {  		if (Evaluator.IsNumericallyLessThan (interval1.UpperBound' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (interval1.LowerBound' interval2.UpperBound))  			return new MetadataConstant () {  				Value = true'  				Type = operand1.Type.PlatformType.SystemBoolean  			};  	}  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  	if (TypeHelper.SizeOfType (operand1.Type) == 4) {  		resultValue = 1;  		resultType = operand1.Type.PlatformType.SystemInt32;  	}  	else {  		resultValue = 1L;  		resultType = operand1.Type.PlatformType.SystemInt64;  	}  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 4) {  	resultValue = 1;  	resultType = operand1.Type.PlatformType.SystemInt32;  }  else {  	resultValue = 1L;  	resultType = operand1.Type.PlatformType.SystemInt64;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  	if (TypeHelper.SizeOfType (operand1.Type) == 4) {  		resultValue = 1u;  		resultType = operand1.Type.PlatformType.SystemUInt32;  	}  	else {  		resultValue = 1UL;  		resultType = operand1.Type.PlatformType.SystemUInt64;  	}  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 4) {  	resultValue = 1u;  	resultType = operand1.Type.PlatformType.SystemUInt32;  }  else {  	resultValue = 1UL;  	resultType = operand1.Type.PlatformType.SystemUInt64;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: if (operand1 == operand2 && !floatingPoint) {  	if (TypeHelper.SizeOfType (operand1.Type) == 4) {  		resultValue = 0;  		resultType = operand1.Type.PlatformType.SystemInt32;  	}  	else {  		resultValue = 0L;  		resultType = operand1.Type.PlatformType.SystemInt64;  	}  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 4) {  	resultValue = 0;  	resultType = operand1.Type.PlatformType.SystemInt32;  }  else {  	resultValue = 0L;  	resultType = operand1.Type.PlatformType.SystemInt64;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	value = operation.Value;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	value = operation.Value;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	value = operation.Value;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	value = operation.Value;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	value = operation.Value;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	value = operation.Value;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	value = operation.Value;  	break;  default:  	Contract.Assume (false);  	break;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: value = 2;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: value = 3;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: value = 4;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: value = 5;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: value = 6;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: value = 7;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,GetAsCompileTimeConstantValue,The following statement contains a magic number: value = 8;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IncreaseBySmallestInterval,The following statement contains a magic number: switch (operand.Type.TypeCode) {  case PrimitiveTypeCode.Int8:  	Contract.Assume (operand.Value is sbyte);  	var sb = (sbyte)operand.Value;  	if (sb == sbyte.MaxValue)  		return operand;  	value = ++sb;  	break;  case PrimitiveTypeCode.Int16:  	Contract.Assume (operand.Value is short);  	var s = (short)operand.Value;  	if (s == short.MaxValue)  		return operand;  	value = ++s;  	break;  case PrimitiveTypeCode.Int32:  	Contract.Assume (operand.Value is int);  	var i = (int)operand.Value;  	if (i == int.MaxValue)  		return operand;  	value = ++i;  	break;  case PrimitiveTypeCode.Int64:  	Contract.Assume (operand.Value is long);  	var l = (long)operand.Value;  	if (l == long.MaxValue)  		return operand;  	value = ++l;  	break;  case PrimitiveTypeCode.IntPtr:  	Contract.Assume (operand.Value is IntPtr);  	var iptr = (long)(IntPtr)operand.Value;  	if (iptr == long.MaxValue)  		return operand;  	value = (IntPtr)(++iptr);  	break;  case PrimitiveTypeCode.UInt8:  	Contract.Assume (operand.Value is byte);  	var b = (byte)operand.Value;  	if (b == byte.MaxValue)  		return operand;  	value = ++b;  	break;  case PrimitiveTypeCode.UInt16:  	Contract.Assume (operand.Value is ushort);  	var us = (ushort)operand.Value;  	if (us == ushort.MaxValue)  		return operand;  	value = ++us;  	break;  case PrimitiveTypeCode.UInt32:  	Contract.Assume (operand.Value is uint);  	var ui = (uint)operand.Value;  	if (ui == uint.MaxValue)  		return operand;  	value = ++ui;  	break;  case PrimitiveTypeCode.UInt64:  	Contract.Assume (operand.Value is ulong);  	var ul = (ulong)operand.Value;  	if (ul == ulong.MaxValue)  		return operand;  	value = ++ul;  	break;  case PrimitiveTypeCode.UIntPtr:  	Contract.Assume (operand.Value is UIntPtr);  	var uptr = (ulong)(UIntPtr)operand.Value;  	if (uptr == ulong.MaxValue)  		return operand;  	value = (UIntPtr)(++uptr);  	break;  case PrimitiveTypeCode.Float32:  	Contract.Assume (operand.Value is float);  	var f = (float)operand.Value;  	var incr = float.Epsilon;  	var fincr = f + incr;  	while (fincr == f) {  		incr *= 2;  		fincr += incr;  	}  	if (float.IsPositiveInfinity (fincr))  		return operand;  	value = fincr;  	break;  case PrimitiveTypeCode.Float64:  	Contract.Assume (operand.Value is double);  	var d = (double)operand.Value;  	var incrd = double.Epsilon;  	var dincr = d + incrd;  	while (dincr == d) {  		incrd *= 2;  		dincr += incrd;  	}  	if (double.IsPositiveInfinity (dincr))  		return operand;  	value = dincr;  	break;  default:  	return Dummy.Constant;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IncreaseBySmallestInterval,The following statement contains a magic number: switch (operand.Type.TypeCode) {  case PrimitiveTypeCode.Int8:  	Contract.Assume (operand.Value is sbyte);  	var sb = (sbyte)operand.Value;  	if (sb == sbyte.MaxValue)  		return operand;  	value = ++sb;  	break;  case PrimitiveTypeCode.Int16:  	Contract.Assume (operand.Value is short);  	var s = (short)operand.Value;  	if (s == short.MaxValue)  		return operand;  	value = ++s;  	break;  case PrimitiveTypeCode.Int32:  	Contract.Assume (operand.Value is int);  	var i = (int)operand.Value;  	if (i == int.MaxValue)  		return operand;  	value = ++i;  	break;  case PrimitiveTypeCode.Int64:  	Contract.Assume (operand.Value is long);  	var l = (long)operand.Value;  	if (l == long.MaxValue)  		return operand;  	value = ++l;  	break;  case PrimitiveTypeCode.IntPtr:  	Contract.Assume (operand.Value is IntPtr);  	var iptr = (long)(IntPtr)operand.Value;  	if (iptr == long.MaxValue)  		return operand;  	value = (IntPtr)(++iptr);  	break;  case PrimitiveTypeCode.UInt8:  	Contract.Assume (operand.Value is byte);  	var b = (byte)operand.Value;  	if (b == byte.MaxValue)  		return operand;  	value = ++b;  	break;  case PrimitiveTypeCode.UInt16:  	Contract.Assume (operand.Value is ushort);  	var us = (ushort)operand.Value;  	if (us == ushort.MaxValue)  		return operand;  	value = ++us;  	break;  case PrimitiveTypeCode.UInt32:  	Contract.Assume (operand.Value is uint);  	var ui = (uint)operand.Value;  	if (ui == uint.MaxValue)  		return operand;  	value = ++ui;  	break;  case PrimitiveTypeCode.UInt64:  	Contract.Assume (operand.Value is ulong);  	var ul = (ulong)operand.Value;  	if (ul == ulong.MaxValue)  		return operand;  	value = ++ul;  	break;  case PrimitiveTypeCode.UIntPtr:  	Contract.Assume (operand.Value is UIntPtr);  	var uptr = (ulong)(UIntPtr)operand.Value;  	if (uptr == ulong.MaxValue)  		return operand;  	value = (UIntPtr)(++uptr);  	break;  case PrimitiveTypeCode.Float32:  	Contract.Assume (operand.Value is float);  	var f = (float)operand.Value;  	var incr = float.Epsilon;  	var fincr = f + incr;  	while (fincr == f) {  		incr *= 2;  		fincr += incr;  	}  	if (float.IsPositiveInfinity (fincr))  		return operand;  	value = fincr;  	break;  case PrimitiveTypeCode.Float64:  	Contract.Assume (operand.Value is double);  	var d = (double)operand.Value;  	var incrd = double.Epsilon;  	var dincr = d + incrd;  	while (dincr == d) {  		incrd *= 2;  		dincr += incrd;  	}  	if (double.IsPositiveInfinity (dincr))  		return operand;  	value = dincr;  	break;  default:  	return Dummy.Constant;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IncreaseBySmallestInterval,The following statement contains a magic number: while (fincr == f) {  	incr *= 2;  	fincr += incr;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IncreaseBySmallestInterval,The following statement contains a magic number: incr *= 2;  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IncreaseBySmallestInterval,The following statement contains a magic number: while (dincr == d) {  	incrd *= 2;  	dincr += incrd;  }  
Magic Number,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,IncreaseBySmallestInterval,The following statement contains a magic number: incrd *= 2;  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (tag == 0) {  	tag = 1;  	var operand1 = expression.Operand1 as Instruction;  	if (operand1 != null) {  		if (this.IsRecursive (operand1))  			tag = 2;  		else {  			var operand2 = expression.Operand2 as Instruction;  			if (operand2 != null) {  				if (this.IsRecursive (operand2))  					tag = 2;  			}  			else {  				var operand2toN = expression.Operand2 as Instruction[];  				if (operand2toN != null) {  					for (int i = 0' n = operand2toN.Length; i < n; i++) {  						var operandi = operand2toN [i];  						Contract.Assume (operandi != null);  						if (this.IsRecursive (operandi)) {  							tag = 2;  							break;  						}  					}  				}  			}  		}  	}  	this.recursiveExpressions [expression] = tag;  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (tag == 0) {  	tag = 1;  	var operand1 = expression.Operand1 as Instruction;  	if (operand1 != null) {  		if (this.IsRecursive (operand1))  			tag = 2;  		else {  			var operand2 = expression.Operand2 as Instruction;  			if (operand2 != null) {  				if (this.IsRecursive (operand2))  					tag = 2;  			}  			else {  				var operand2toN = expression.Operand2 as Instruction[];  				if (operand2toN != null) {  					for (int i = 0' n = operand2toN.Length; i < n; i++) {  						var operandi = operand2toN [i];  						Contract.Assume (operandi != null);  						if (this.IsRecursive (operandi)) {  							tag = 2;  							break;  						}  					}  				}  			}  		}  	}  	this.recursiveExpressions [expression] = tag;  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (tag == 0) {  	tag = 1;  	var operand1 = expression.Operand1 as Instruction;  	if (operand1 != null) {  		if (this.IsRecursive (operand1))  			tag = 2;  		else {  			var operand2 = expression.Operand2 as Instruction;  			if (operand2 != null) {  				if (this.IsRecursive (operand2))  					tag = 2;  			}  			else {  				var operand2toN = expression.Operand2 as Instruction[];  				if (operand2toN != null) {  					for (int i = 0' n = operand2toN.Length; i < n; i++) {  						var operandi = operand2toN [i];  						Contract.Assume (operandi != null);  						if (this.IsRecursive (operandi)) {  							tag = 2;  							break;  						}  					}  				}  			}  		}  	}  	this.recursiveExpressions [expression] = tag;  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (operand1 != null) {  	if (this.IsRecursive (operand1))  		tag = 2;  	else {  		var operand2 = expression.Operand2 as Instruction;  		if (operand2 != null) {  			if (this.IsRecursive (operand2))  				tag = 2;  		}  		else {  			var operand2toN = expression.Operand2 as Instruction[];  			if (operand2toN != null) {  				for (int i = 0' n = operand2toN.Length; i < n; i++) {  					var operandi = operand2toN [i];  					Contract.Assume (operandi != null);  					if (this.IsRecursive (operandi)) {  						tag = 2;  						break;  					}  				}  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (operand1 != null) {  	if (this.IsRecursive (operand1))  		tag = 2;  	else {  		var operand2 = expression.Operand2 as Instruction;  		if (operand2 != null) {  			if (this.IsRecursive (operand2))  				tag = 2;  		}  		else {  			var operand2toN = expression.Operand2 as Instruction[];  			if (operand2toN != null) {  				for (int i = 0' n = operand2toN.Length; i < n; i++) {  					var operandi = operand2toN [i];  					Contract.Assume (operandi != null);  					if (this.IsRecursive (operandi)) {  						tag = 2;  						break;  					}  				}  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (operand1 != null) {  	if (this.IsRecursive (operand1))  		tag = 2;  	else {  		var operand2 = expression.Operand2 as Instruction;  		if (operand2 != null) {  			if (this.IsRecursive (operand2))  				tag = 2;  		}  		else {  			var operand2toN = expression.Operand2 as Instruction[];  			if (operand2toN != null) {  				for (int i = 0' n = operand2toN.Length; i < n; i++) {  					var operandi = operand2toN [i];  					Contract.Assume (operandi != null);  					if (this.IsRecursive (operandi)) {  						tag = 2;  						break;  					}  				}  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (this.IsRecursive (operand1))  	tag = 2;  else {  	var operand2 = expression.Operand2 as Instruction;  	if (operand2 != null) {  		if (this.IsRecursive (operand2))  			tag = 2;  	}  	else {  		var operand2toN = expression.Operand2 as Instruction[];  		if (operand2toN != null) {  			for (int i = 0' n = operand2toN.Length; i < n; i++) {  				var operandi = operand2toN [i];  				Contract.Assume (operandi != null);  				if (this.IsRecursive (operandi)) {  					tag = 2;  					break;  				}  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (this.IsRecursive (operand1))  	tag = 2;  else {  	var operand2 = expression.Operand2 as Instruction;  	if (operand2 != null) {  		if (this.IsRecursive (operand2))  			tag = 2;  	}  	else {  		var operand2toN = expression.Operand2 as Instruction[];  		if (operand2toN != null) {  			for (int i = 0' n = operand2toN.Length; i < n; i++) {  				var operandi = operand2toN [i];  				Contract.Assume (operandi != null);  				if (this.IsRecursive (operandi)) {  					tag = 2;  					break;  				}  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (this.IsRecursive (operand1))  	tag = 2;  else {  	var operand2 = expression.Operand2 as Instruction;  	if (operand2 != null) {  		if (this.IsRecursive (operand2))  			tag = 2;  	}  	else {  		var operand2toN = expression.Operand2 as Instruction[];  		if (operand2toN != null) {  			for (int i = 0' n = operand2toN.Length; i < n; i++) {  				var operandi = operand2toN [i];  				Contract.Assume (operandi != null);  				if (this.IsRecursive (operandi)) {  					tag = 2;  					break;  				}  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: tag = 2;  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (operand2 != null) {  	if (this.IsRecursive (operand2))  		tag = 2;  }  else {  	var operand2toN = expression.Operand2 as Instruction[];  	if (operand2toN != null) {  		for (int i = 0' n = operand2toN.Length; i < n; i++) {  			var operandi = operand2toN [i];  			Contract.Assume (operandi != null);  			if (this.IsRecursive (operandi)) {  				tag = 2;  				break;  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (operand2 != null) {  	if (this.IsRecursive (operand2))  		tag = 2;  }  else {  	var operand2toN = expression.Operand2 as Instruction[];  	if (operand2toN != null) {  		for (int i = 0' n = operand2toN.Length; i < n; i++) {  			var operandi = operand2toN [i];  			Contract.Assume (operandi != null);  			if (this.IsRecursive (operandi)) {  				tag = 2;  				break;  			}  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (this.IsRecursive (operand2))  	tag = 2;  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: tag = 2;  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (operand2toN != null) {  	for (int i = 0' n = operand2toN.Length; i < n; i++) {  		var operandi = operand2toN [i];  		Contract.Assume (operandi != null);  		if (this.IsRecursive (operandi)) {  			tag = 2;  			break;  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: for (int i = 0' n = operand2toN.Length; i < n; i++) {  	var operandi = operand2toN [i];  	Contract.Assume (operandi != null);  	if (this.IsRecursive (operandi)) {  		tag = 2;  		break;  	}  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: if (this.IsRecursive (operandi)) {  	tag = 2;  	break;  }  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: tag = 2;  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,IsRecursive,The following statement contains a magic number: return tag == 2;  
Magic Number,Microsoft.Cci.Analysis,ValueMappings,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ValueMappings.cs,SetIsRecursive,The following statement contains a magic number: this.recursiveExpressions [expression] = 2;  
Duplicate Code,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,TryToGetSimplerLogicalInverse,The method contains a code clone-set at the following line numbers (starting from the method definition): ((8' 38)' (52' 82))
Missing Default,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The following switch statement is missing a default case: switch (operationCode) {  //interval == cv  case OperationCode.Beq:  case OperationCode.Beq_S:  	interval.lowerBound = cv;  	interval.upperBound = cv;  	interval.excludesMinusOne |= !MetadataExpressionHelper.IsIntegralMinusOne (cv);  	interval.excludesZero |= !MetadataExpressionHelper.IsIntegralZero (cv);  	break;  //interval >= cv  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	if (interval.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (cv' interval.LowerBound)) {  		interval.lowerBound = cv;  		interval.includesUnderflow = false;  	}  	interval.excludesMinusOne |= !Evaluator.IsNegative (cv);  	interval.excludesZero |= Evaluator.IsPositive (cv);  	break;  //interval > cv  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (interval.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (cv' interval.LowerBound)) {  		interval.lowerBound = Evaluator.IncreaseBySmallestInterval (cv);  		interval.includesUnderflow = false;  	}  	interval.excludesMinusOne |= !Evaluator.IsNegative (cv);  	interval.excludesZero |= !Evaluator.IsNegative (cv);  	break;  //interval <= cv  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	if (interval.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (cv' interval.UpperBound)) {  		interval.upperBound = cv;  		interval.includesOverflow = false;  	}  	interval.excludesMinusOne |= Evaluator.IsNegative (cv) && !MetadataExpressionHelper.IsIntegralMinusOne (cv);  	interval.excludesZero |= Evaluator.IsNegative (cv);  	break;  //interval < cv  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (interval.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (cv' interval.UpperBound)) {  		interval.upperBound = Evaluator.DecreaseBySmallestInterval (cv);  		interval.includesOverflow = false;  	}  	interval.excludesMinusOne |= !Evaluator.IsPositive (cv) && !MetadataExpressionHelper.IsIntegralMinusOne (cv);  	interval.excludesZero |= !Evaluator.IsPositive (cv);  	break;  //interval != cv  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (Evaluator.IsNumericallyEqual (interval.LowerBound' cv))  		interval.lowerBound = Evaluator.IncreaseBySmallestInterval (cv);  	if (Evaluator.IsNumericallyEqual (interval.UpperBound' cv))  		interval.upperBound = Evaluator.DecreaseBySmallestInterval (cv);  	if (MetadataExpressionHelper.IsIntegralMinusOne (cv))  		interval.excludesMinusOne = true;  	if (MetadataExpressionHelper.IsIntegralZero (cv))  		interval.excludesZero = true;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow,The following switch statement is missing a default case: switch (operationCode) {  //interval == interval2  case OperationCode.Beq:  case OperationCode.Beq_S:  	if (interval1.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (interval2.LowerBound' interval1.LowerBound)) {  		interval1.lowerBound = interval2.LowerBound;  		interval1.includesUnderflow = false;  	}  	if (interval1.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (interval2.UpperBound' interval1.UpperBound)) {  		interval1.upperBound = interval2.UpperBound;  		interval1.includesOverflow = false;  	}  	interval1.excludesMinusOne = interval2.ExcludesMinusOne;  	interval1.excludesZero |= interval2.ExcludesZero;  	break;  //interval >= interval2  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	if (interval1.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (interval2.UpperBound' interval1.LowerBound)) {  		interval1.lowerBound = interval2.UpperBound;  		interval1.includesUnderflow = false;  	}  	break;  //interval > interval2  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (interval1.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (interval2.UpperBound' interval1.LowerBound)) {  		interval1.lowerBound = Evaluator.IncreaseBySmallestInterval (interval2.UpperBound);  		interval1.includesUnderflow = false;  	}  	break;  //interval <= interval2  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	if (interval1.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (interval2.LowerBound' interval1.UpperBound)) {  		interval1.upperBound = interval2.LowerBound;  		interval1.includesOverflow = false;  	}  	break;  //interval < interval2  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (interval1.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (interval2.LowerBound' interval1.UpperBound)) {  		interval1.upperBound = Evaluator.DecreaseBySmallestInterval (interval2.LowerBound);  		interval1.includesOverflow = false;  	}  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,Narrow2,The following switch statement is missing a default case: switch (operationCode) {  //cv == interval  case OperationCode.Beq:  case OperationCode.Beq_S:  	interval.lowerBound = cv;  	interval.upperBound = cv;  	interval.excludesMinusOne |= !MetadataExpressionHelper.IsIntegralMinusOne (cv);  	interval.excludesZero |= !MetadataExpressionHelper.IsIntegralZero (cv);  	break;  // cv >= interval  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	if (interval.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (cv' interval.UpperBound)) {  		interval.upperBound = cv;  		interval.includesOverflow = false;  	}  	interval.excludesMinusOne |= Evaluator.IsNegative (cv) && !MetadataExpressionHelper.IsIntegralMinusOne (cv);  	interval.excludesZero |= Evaluator.IsNegative (cv);  	break;  //cv > interval  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (interval.UpperBound == Dummy.Constant || Evaluator.IsNumericallyLessThan (cv' interval.UpperBound)) {  		interval.upperBound = Evaluator.DecreaseBySmallestInterval (cv);  		interval.includesOverflow = false;  	}  	interval.excludesMinusOne |= Evaluator.IsNegative (cv);  	interval.excludesZero |= !Evaluator.IsPositive (cv);  	break;  //cv <= interval  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	if (interval.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (cv' interval.LowerBound)) {  		interval.lowerBound = cv;  		interval.includesUnderflow = false;  	}  	interval.excludesMinusOne |= !Evaluator.IsNegative (cv);  	interval.excludesZero |= Evaluator.IsPositive (cv);  	break;  //cv < interval  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (interval.LowerBound == Dummy.Constant || Evaluator.IsNumericallyGreaterThan (cv' interval.LowerBound)) {  		interval.lowerBound = Evaluator.IncreaseBySmallestInterval (cv);  		interval.includesUnderflow = false;  	}  	interval.excludesMinusOne |= !Evaluator.IsNegative (cv) || MetadataExpressionHelper.IsIntegralMinusOne (cv);  	interval.excludesZero |= !Evaluator.IsNegative (cv);  	break;  // cv != interval  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (Evaluator.IsNumericallyEqual (interval.LowerBound' cv))  		interval.lowerBound = Evaluator.IncreaseBySmallestInterval (cv);  	if (Evaluator.IsNumericallyEqual (interval.UpperBound' cv))  		interval.upperBound = Evaluator.DecreaseBySmallestInterval (cv);  	if (MetadataExpressionHelper.IsIntegralMinusOne (cv))  		interval.excludesMinusOne = true;  	if (MetadataExpressionHelper.IsIntegralZero (cv))  		interval.excludesZero = true;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  	op = add_ovf;  	break;  case OperationCode.Mul:  	op = mul_ovf;  	break;  case OperationCode.Sub:  	op = sub_ovf;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,TryToGetAsInterval2,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  	op = add_ovf;  	break;  case OperationCode.Mul:  	op = mul_ovf;  	break;  case OperationCode.Sub:  	op = sub_ovf;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Interval,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractDomains\Intervals.cs,GetIntervalFor,The following switch statement is missing a default case: switch (type.TypeCode) {  case PrimitiveTypeCode.Int16:  	return mappings.Int16Interval;  case PrimitiveTypeCode.Int32:  	return mappings.Int32Interval;  case PrimitiveTypeCode.Int64:  	return mappings.Int64Interval;  case PrimitiveTypeCode.Int8:  	return mappings.Int8Interval;  case PrimitiveTypeCode.UInt16:  	return mappings.UInt16Interval;  case PrimitiveTypeCode.UInt32:  	return mappings.UInt32Interval;  case PrimitiveTypeCode.UInt64:  	return mappings.UInt64Interval;  case PrimitiveTypeCode.UInt8:  	return mappings.UInt8Interval;  }  
Missing Default,Microsoft.Cci.Analysis,AbstractInterpreter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\AbstractInterpretation.cs,SetupReadVariablesFor,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S: {  	var variable = operation.Value as INamedEntity;  	if (variable == null)  		break;  	//happens when ldarg_0 refers to the this pointer of an instance method  	var key = (uint)variable.Name.UniqueKey;  	if (!writtenVariables.Contains (key)) {  		this.readVariables.Add (block.Offset' variable);  		var definingExpression = this.mappings.GetDefiningExpressionFor (variable);  		if (definingExpression == null) {  			definingExpression = this.GetCanonicalizedLoadInstruction (operation.Value ?? Dummy.ParameterDefinition);  			this.mappings.SetDefininingExpressionFor (variable' definingExpression);  		}  		this.inputExpressions.Add (block.Offset' key' definingExpression);  	}  	break;  }  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S: {  	var variable = operation.Value as INamedEntity;  	Contract.Assume (variable != null);  	writtenVariables.Add ((uint)variable.Name.UniqueKey);  	break;  }  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operand1.Type.TypeCode) {  //these cases all push a 32-bit value on the operand stack' with sign propagation as appropriate.   //The operations then treat the 32-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.   case PrimitiveTypeCode.Boolean:  	Contract.Assume (operand1.Value is bool);  	var u4 = ((bool)operand1.Value) ? 1u : 0u;  	var i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt8:  	Contract.Assume (operand1.Value is byte);  	u4 = (byte)operand1.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.Char:  	Contract.Assume (operand1.Value is char);  	u4 = (char)operand1.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt16:  	Contract.Assume (operand1.Value is ushort);  	u4 = (ushort)operand1.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt32:  	Contract.Assume (operand1.Value is uint);  	u4 = (uint)operand1.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.Int8:  	Contract.Assume (operand1.Value is sbyte);  	i4 = (int)(sbyte)operand1.Value;  	u4 = (byte)i4;  	goto do4;  case PrimitiveTypeCode.Int16:  	Contract.Assume (operand1.Value is short);  	i4 = (short)operand1.Value;  	u4 = (ushort)i4;  	goto do4;  case PrimitiveTypeCode.Int32:  	Contract.Assume (operand1.Value is int);  	i4 = (int)operand1.Value;  	u4 = (uint)i4;  	do4:  	return Evaluate (operation' u4' i4' operand2);  //These cases push 32 bit or 64 bit values on the stack' depending on the platform' with sign propagation as appropriate.   //The operations then treat the 32/64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.   case PrimitiveTypeCode.IntPtr:  	Contract.Assume (operand1.Value is IntPtr);  	var i8 = (long)(IntPtr)operand1.Value;  	var u8 = (ulong)(IntPtr)operand1.Value;  	goto do8;  case PrimitiveTypeCode.UIntPtr:  	Contract.Assume (operand1.Value is IntPtr);  	i8 = (long)(IntPtr)operand1.Value;  	u8 = (ulong)(IntPtr)operand1.Value;  	goto do8;  //These cases push 64 bit values on the stack' with sign propagation as appropriate.   //The operations then treat the 64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.    case PrimitiveTypeCode.Int64:  	Contract.Assume (operand1.Value is long);  	i8 = (long)operand1.Value;  	u8 = (ulong)i8;  	goto do8;  case PrimitiveTypeCode.UInt64:  	Contract.Assume (operand1.Value is ulong);  	u8 = (ulong)operand1.Value;  	i8 = (long)u8;  	do8:  	return Evaluate (operation' u8' i8' operand2);  case PrimitiveTypeCode.Float32:  	Contract.Assume (operand1.Value is float);  	var f = (float)operand1.Value;  	double d = (double)f;  	i8 = (long)(int)f;  	u8 = (ulong)(uint)(int)f;  	goto doDouble;  case PrimitiveTypeCode.Float64:  	Contract.Assume (operand1.Value is double);  	d = (double)operand1.Value;  	i8 = (long)d;  	u8 = (ulong)i8;  	doDouble:  	return Evaluate (operation' d' operand2);  case PrimitiveTypeCode.Pointer:  case PrimitiveTypeCode.Reference:  	//TODO: we might know that the pointer is 0  	return Dummy.Constant;  //We only known the value of the pointer at runtime.  case PrimitiveTypeCode.String:  case PrimitiveTypeCode.NotPrimitive:  	//TODO: might be able to remove a castclass and fold an isinst.  	return Dummy.Constant;  //We only known the value of the pointer at runtime.  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operand2.Type.TypeCode) {  //these cases all push a 32-bit value on the operand stack' with sign propagation as appropriate.   //The operations then treat the 32-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.   case PrimitiveTypeCode.Boolean:  	Contract.Assume (operand2.Value is bool);  	var u4 = ((bool)operand2.Value) ? 1u : 0u;  	var i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt8:  	Contract.Assume (operand2.Value is byte);  	u4 = (byte)operand2.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.Char:  	Contract.Assume (operand2.Value is char);  	u4 = (char)operand2.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt16:  	Contract.Assume (operand2.Value is ushort);  	u4 = (ushort)operand2.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt32:  	Contract.Assume (operand2.Value is uint);  	u4 = (uint)operand2.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.Int8:  	Contract.Assume (operand2.Value is sbyte);  	i4 = (int)(sbyte)operand2.Value;  	u4 = (byte)i4;  	goto do4;  case PrimitiveTypeCode.Int16:  	Contract.Assume (operand2.Value is short);  	i4 = (short)operand2.Value;  	u4 = (ushort)i4;  	goto do4;  case PrimitiveTypeCode.Int32:  	Contract.Assume (operand2.Value is int);  	i4 = (int)operand2.Value;  	u4 = (uint)i4;  	do4:  	return Evaluate (operation' operand2.Type.PlatformType' u41' i41' u4' i4);  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operand2.Type.TypeCode) {  //these cases all push a 32-bit value on the operand stack' with sign propagation as appropriate.   //The operations then treat the 32-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.   case PrimitiveTypeCode.Boolean:  	Contract.Assume (operand2.Value is bool);  	var u4 = ((bool)operand2.Value) ? 1u : 0u;  	var i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt8:  	Contract.Assume (operand2.Value is byte);  	u4 = (byte)operand2.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.Char:  	Contract.Assume (operand2.Value is char);  	u4 = (char)operand2.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt16:  	Contract.Assume (operand2.Value is ushort);  	u4 = (ushort)operand2.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.UInt32:  	Contract.Assume (operand2.Value is uint);  	u4 = (uint)operand2.Value;  	i4 = (int)u4;  	goto do4;  case PrimitiveTypeCode.Int8:  	Contract.Assume (operand2.Value is sbyte);  	i4 = (int)(sbyte)operand2.Value;  	u4 = (byte)i4;  	goto do4;  case PrimitiveTypeCode.Int16:  	Contract.Assume (operand2.Value is short);  	i4 = (short)operand2.Value;  	u4 = (ushort)i4;  	goto do4;  case PrimitiveTypeCode.Int32:  	Contract.Assume (operand2.Value is int);  	i4 = (int)operand2.Value;  	u4 = (uint)i4;  	do4:  	long i8 = i4;  	ulong u8 = u4;  	goto do8;  //These cases push 32 bit or 64 bit values on the stack' depending on the platform' with sign propagation as appropriate.   //The operations then treat the 32/64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.   case PrimitiveTypeCode.IntPtr:  	Contract.Assume (operand2.Value is IntPtr);  	i8 = (long)(IntPtr)operand2.Value;  	u8 = (ulong)(IntPtr)operand2.Value;  	goto do8;  case PrimitiveTypeCode.UIntPtr:  	Contract.Assume (operand2.Value is IntPtr);  	i8 = (long)(IntPtr)operand2.Value;  	u8 = (ulong)(IntPtr)operand2.Value;  	goto do8;  //These cases push 64 bit values on the stack' with sign propagation as appropriate.   //The operations then treat the 64-bit value as either signed or unsigned' based on the operation code' regardless of how the value got onto the stack.    case PrimitiveTypeCode.Int64:  	Contract.Assume (operand2.Value is long);  	i8 = (long)operand2.Value;  	u8 = (ulong)i8;  	goto do8;  case PrimitiveTypeCode.UInt64:  	Contract.Assume (operand2.Value is ulong);  	u8 = (ulong)operand2.Value;  	i8 = (long)u8;  	goto do8;  	do8:  	return Evaluate (operation' operand2.Type.PlatformType' u81' i81' u8' i8);  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operand2.Type.TypeCode) {  case PrimitiveTypeCode.Float32:  	Contract.Assume (operand2.Value is float);  	var f = (float)operand2.Value;  	var d2 = (double)f;  	goto doDouble;  case PrimitiveTypeCode.Float64:  	Contract.Assume (operand2.Value is double);  	d2 = (double)operand2.Value;  	doDouble:  	return Evaluate (operation' operand2.Type.PlatformType' d1' d2);  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  	resultValue = i41 + i42;  	break;  case OperationCode.Add_Ovf:  	var i8 = i41 + (long)i42;  	var i4 = (int)i8;  	if (i8 != (long)i4)  		return Dummy.Constant;  	//known to fail.  	resultValue = i4;  	break;  case OperationCode.Add_Ovf_Un:  	var u8 = u41 + (ulong)u42;  	var u4 = (uint)u8;  	if (u8 != (ulong)u4)  		return Dummy.Constant;  	//known to fail  	resultValue = (int)u4;  	break;  case OperationCode.And:  	resultValue = i41 & i42;  	break;  case OperationCode.Ceq:  	resultValue = i41 == i42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Cgt:  	resultValue = i41 > i42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Cgt_Un:  	resultValue = u41 > u42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Clt:  	resultValue = i41 < i42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Clt_Un:  	resultValue = u41 < u42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Div:  	if (i42 == 0)  		return Dummy.Constant;  	//known to fail.  	if (i41 == int.MinValue && i42 == -1)  		return Dummy.Constant;  	//known to fail.  	resultValue = i41 / i42;  	break;  case OperationCode.Div_Un:  	if (u42 == 0)  		return Dummy.Constant;  	//known to fail.  	resultValue = u41 / u42;  	break;  case OperationCode.Mul:  	resultValue = i41 * i42;  	break;  case OperationCode.Mul_Ovf:  	i4 = i41 * i42;  	if (i4 == int.MinValue && (i41 == -1 || i42 == -1))  		return Dummy.Constant;  	//This can happen when the other value is int.MinValue'   	//in which case there is an overflow and this operation is known to fail.  	if (i42 != 0 && i4 / i42 != i41)  		return Dummy.Constant;  	//known to fail.  	resultValue = i4;  	break;  case OperationCode.Mul_Ovf_Un:  	u4 = u41 * u42;  	if (u42 != 0 && u4 / u42 != u41)  		return Dummy.Constant;  	//known to fail.  	resultValue = u4;  	break;  case OperationCode.Or:  	resultValue = i41 | i42;  	break;  case OperationCode.Rem:  	if (i42 == 0)  		return Dummy.Constant;  	//known to fail.  	resultValue = i41 % i42;  	break;  case OperationCode.Rem_Un:  	if (u42 == 0)  		return Dummy.Constant;  	//known to fail.  	resultValue = u41 % u42;  	break;  case OperationCode.Shl:  	resultValue = i41 << i42;  	break;  case OperationCode.Shr:  	resultValue = i41 >> i42;  	break;  case OperationCode.Shr_Un:  	resultValue = u41 >> i42;  	break;  case OperationCode.Sub:  	resultValue = i41 - i42;  	break;  case OperationCode.Sub_Ovf:  	i4 = i41 - i42;  	if (i41 < 0) {  		if (i42 > 0) {  			if (i4 > i41)  				return Dummy.Constant;  			//known to fail.  		}  	}  	else if (i42 < 0) {  		if (i4 < i41)  			return Dummy.Constant;  		//known to fail.  	}  	resultValue = i4;  	break;  case OperationCode.Sub_Ovf_Un:  	if (u41 < u42)  		return Dummy.Constant;  	//known to fail  	u4 = u41 - u42;  	resultValue = (int)u4;  	break;  case OperationCode.Xor:  	resultValue = i41 ^ i42;  	break;  //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  	resultValue = i41 == i42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bge:  case OperationCode.Bge_S:  	resultValue = i41 >= i42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	resultValue = u41 >= u42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bgt:  case OperationCode.Bgt_S:  	resultValue = i41 > i42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	resultValue = u41 > u42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  	resultValue = i41 <= i42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	resultValue = u41 <= u42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Blt:  case OperationCode.Blt_S:  	resultValue = i41 < i42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	resultValue = u41 < u42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	resultValue = u41 != u42;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Nop:  	if (i41 == i42)  		resultValue = i41;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  	resultValue = i81 + i82;  	break;  case OperationCode.Add_Ovf:  	var i8 = i81 + i82;  	if (i81 < 0) {  		if (i82 < 0) {  			if (i8 > i81)  				return Dummy.Constant;  			//known to fail.  		}  	}  	else if (i82 > 0) {  		if (i8 < i81)  			return Dummy.Constant;  		//known to fail.  	}  	resultValue = i8;  	break;  case OperationCode.Add_Ovf_Un:  	var u8 = u81 + u82;  	if (u8 < u81)  		return Dummy.Constant;  	//known to fail  	resultValue = (long)u8;  	break;  case OperationCode.And:  	resultValue = i81 & i82;  	break;  case OperationCode.Ceq:  	resultValue = i81 == i82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Cgt:  	resultValue = i81 > i82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Cgt_Un:  	resultValue = u81 > u82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Clt:  	resultValue = i81 < i82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Clt_Un:  	resultValue = u81 < u82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Div:  	if (i82 == 0)  		return Dummy.Constant;  	//known to fail.  	if (i81 == long.MinValue && i82 == -1)  		return Dummy.Constant;  	//known to fail.  	resultValue = i81 / i82;  	break;  case OperationCode.Div_Un:  	if (u82 == 0)  		return Dummy.Constant;  	//known to fail.  	resultValue = u81 / u82;  	break;  case OperationCode.Mul:  	resultValue = i81 * i82;  	break;  case OperationCode.Mul_Ovf:  	i8 = i81 * i82;  	if (i8 == long.MinValue && (i81 == -1 || i82 == -1))  		return Dummy.Constant;  	//This can happen when the other value is long.MinValue'   	//in which case there is an overflow and this operation is known to fail.  	if (i82 != 0 && i8 / i82 != i81)  		return Dummy.Constant;  	//known to fail.  	resultValue = i8;  	break;  case OperationCode.Mul_Ovf_Un:  	u8 = u81 * u82;  	if (u82 != 0 && u8 / u82 != u81)  		return Dummy.Constant;  	//known to fail.  	resultValue = u8;  	break;  case OperationCode.Or:  	resultValue = i81 | i82;  	break;  case OperationCode.Rem:  	if (i82 == 0)  		return Dummy.Constant;  	//known to fail.  	resultValue = i81 % i82;  	break;  case OperationCode.Rem_Un:  	if (u82 == 0)  		return Dummy.Constant;  	//known to fail.  	resultValue = u81 % u82;  	break;  case OperationCode.Shl:  	resultValue = i81 << (int)i82;  	break;  case OperationCode.Shr:  	resultValue = i81 >> (int)i82;  	break;  case OperationCode.Shr_Un:  	resultValue = u81 >> (int)i82;  	break;  case OperationCode.Sub:  	resultValue = i81 - i82;  	break;  case OperationCode.Sub_Ovf:  	i8 = i81 - i82;  	if (i81 < 0) {  		if (i82 > 0) {  			if (i8 > i81)  				return Dummy.Constant;  			//known to fail.  		}  	}  	else if (i82 < 0) {  		if (i8 < i81)  			return Dummy.Constant;  		//known to fail.  	}  	resultValue = i8;  	break;  case OperationCode.Sub_Ovf_Un:  	if (u81 < u82)  		return Dummy.Constant;  	//known to fail  	u8 = u81 - u82;  	resultValue = (long)u8;  	break;  case OperationCode.Xor:  	resultValue = i81 ^ i82;  	break;  //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  	resultValue = i81 == i82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bge:  case OperationCode.Bge_S:  	resultValue = i81 >= i82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	resultValue = u81 >= u82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bgt:  case OperationCode.Bgt_S:  	resultValue = i81 > i82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	resultValue = u81 > u82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  	resultValue = i81 <= i82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	resultValue = u81 <= u82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Blt:  case OperationCode.Blt_S:  	resultValue = i81 < i82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	resultValue = u81 < u82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	resultValue = u81 != u82;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Nop:  	if (i81 == i82)  		resultValue = i81;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  	resultValue = d1 + d2;  	break;  case OperationCode.And:  	return Dummy.Constant;  //known to fail. (illegal instruction.)   case OperationCode.Ceq:  	resultValue = d1 == d2;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Cgt:  	resultValue = d1 > d2;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Cgt_Un:  	resultValue = d1 > d2 || double.IsNaN (d1) || double.IsNaN (d2);  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Clt:  	resultValue = d1 < d2;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Clt_Un:  	resultValue = d1 < d2 || double.IsNaN (d1) || double.IsNaN (d2);  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Div:  	resultValue = d1 / d2;  	break;  case OperationCode.Div_Un:  	return Dummy.Constant;  //known to fail. (illegal instruction.)   case OperationCode.Mul:  	resultValue = d1 * d2;  	break;  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  	return Dummy.Constant;  //known to fail. (illegal instruction.)   case OperationCode.Rem:  	resultValue = d1 % d2;  	break;  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	return Dummy.Constant;  //known to fail. (illegal instruction.)   case OperationCode.Sub:  	resultValue = d1 - d2;  	break;  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	return Dummy.Constant;  //known to fail. (illegal instruction.)   //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  	resultValue = d1 == d2;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bge:  case OperationCode.Bge_S:  	resultValue = d1 >= d2;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	resultValue = !(d1 < d2);  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bgt:  case OperationCode.Bgt_S:  	resultValue = d1 > d2;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	resultValue = !(d1 <= d2);  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  	resultValue = d1 <= d2;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	resultValue = !(d1 > d2);  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Blt:  case OperationCode.Blt_S:  	resultValue = d1 < d2;  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	resultValue = !(d1 >= d2);  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	resultValue = !(d1 == d2);  	resultType = platformType.SystemBoolean;  	break;  case OperationCode.Nop:  	if (d1 == d2)  		resultValue = d1;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  	break;  case OperationCode.And:  	if (operand1IsZero)  		return operand1;  	break;  case OperationCode.Ceq:  	break;  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  	goto case OperationCode.Bgt;  case OperationCode.Clt:  case OperationCode.Clt_Un:  	goto case OperationCode.Blt;  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  	if (operand1IsZero)  		return operand1;  	break;  case OperationCode.Or:  	if (operand1IsMinusOne)  		return operand1;  	break;  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	if (operand1IsZero)  		return operand1;  	break;  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  	break;  case OperationCode.Xor:  	break;  //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  	if (interval2 != null && interval2.IsFinite) {  		if (Evaluator.IsNumericallyLessThan (operand1' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (operand1' interval2.UpperBound))  			return new MetadataConstant () {  				Value = false'  				Type = operand1.Type.PlatformType.SystemBoolean  			};  	}  	break;  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (interval2 != null && interval2.UpperBound != Dummy.Constant)  		return NullUnlessTrue (Evaluate (operation' operand1' interval2.UpperBound));  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (interval2 != null && interval2.LowerBound != Dummy.Constant)  		return NullUnlessTrue (Evaluate (operation' operand1' interval2.LowerBound));  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (interval2 != null && interval2.IsFinite) {  		if (Evaluator.IsNumericallyLessThan (operand1' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (operand1' interval2.UpperBound))  			return new MetadataConstant () {  				Value = true'  				Type = operand1.Type.PlatformType.SystemBoolean  			};  	}  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Negate,The following switch statement is missing a default case: switch (val.GetTypeCode ()) {  case TypeCode.Double:  	return new MetadataConstant () {  		Value = -val.ToDouble (null)'  		Type = compileTimeConstant.Type  	};  case TypeCode.Int16:  	return new MetadataConstant () {  		Value = (short)-val.ToInt16 (null)'  		Type = compileTimeConstant.Type  	};  case TypeCode.Int32:  	return new MetadataConstant () {  		Value = -val.ToInt32 (null)'  		Type = compileTimeConstant.Type  	};  case TypeCode.Int64:  	return new MetadataConstant () {  		Value = -val.ToInt64 (null)'  		Type = compileTimeConstant.Type  	};  case TypeCode.SByte:  	return new MetadataConstant () {  		Value = (sbyte)-val.ToSByte (null)'  		Type = compileTimeConstant.Type  	};  case TypeCode.Single:  	return new MetadataConstant () {  		Value = -val.ToSingle (null)'  		Type = compileTimeConstant.Type  	};  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  	break;  case OperationCode.And:  	if (operand2IsZero)  		return operand2;  	break;  case OperationCode.Ceq:  	break;  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  	goto case OperationCode.Bgt;  case OperationCode.Clt:  case OperationCode.Clt_Un:  	goto case OperationCode.Blt;  case OperationCode.Div:  case OperationCode.Div_Un:  	if (operand2IsZero)  		return Dummy.Constant;  	//known to fail.  	break;  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  	if (operand2IsZero)  		return operand2;  	break;  case OperationCode.Or:  	break;  case OperationCode.Rem:  case OperationCode.Rem_Un:  	if (operand2IsZero)  		return Dummy.Constant;  	//known to fail.  	break;  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	break;  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  	break;  case OperationCode.Xor:  	break;  //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  	if (interval1 != null && interval1.IsFinite) {  		if (Evaluator.IsNumericallyLessThan (operand2' interval1.LowerBound) || Evaluator.IsNumericallyGreaterThan (operand2' interval1.UpperBound))  			return new MetadataConstant () {  				Value = false'  				Type = operand1.Type.PlatformType.SystemBoolean  			};  	}  	break;  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (interval1 != null && interval1.LowerBound != Dummy.Constant)  		return NullUnlessTrue (Evaluate (operation' interval1.LowerBound' operand2));  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (interval1 != null && interval1.UpperBound != Dummy.Constant)  		return NullUnlessTrue (Evaluate (operation' interval1.UpperBound' operand2));  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (interval1 != null && interval1.IsFinite) {  		if (Evaluator.IsNumericallyLessThan (interval1.UpperBound' operand2) || Evaluator.IsNumericallyGreaterThan (interval1.LowerBound' operand2))  			return new MetadataConstant () {  				Value = true'  				Type = operand1.Type.PlatformType.SystemBoolean  			};  	}  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  	break;  case OperationCode.And:  	break;  case OperationCode.Ceq:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	break;  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  	goto case OperationCode.Bgt;  case OperationCode.Clt:  case OperationCode.Clt_Un:  	goto case OperationCode.Blt;  case OperationCode.Div:  	if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 1;  			resultType = operand1.Type.PlatformType.SystemInt32;  		}  		else {  			resultValue = 1L;  			resultType = operand1.Type.PlatformType.SystemInt64;  		}  	}  	break;  case OperationCode.Div_Un:  	if (operand1 == operand2 && !floatingPoint && interval1 != null && interval1.ExcludesZero) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 1u;  			resultType = operand1.Type.PlatformType.SystemUInt32;  		}  		else {  			resultValue = 1UL;  			resultType = operand1.Type.PlatformType.SystemUInt64;  		}  	}  	break;  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  	break;  case OperationCode.Or:  	break;  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	break;  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	if (operand1 == operand2 && !floatingPoint) {  		if (TypeHelper.SizeOfType (operand1.Type) == 4) {  			resultValue = 0;  			resultType = operand1.Type.PlatformType.SystemInt32;  		}  		else {  			resultValue = 0L;  			resultType = operand1.Type.PlatformType.SystemInt64;  		}  	}  	break;  //These instructions result in no values' but it is interesting to know the values of their conditions.  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  	if (operand1 == operand2) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (operation.OperationCode == OperationCode.Beq || operation.OperationCode == OperationCode.Beq_S)  		break;  	goto case OperationCode.Bgt;  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval2 != null && interval1.LowerBound != Dummy.Constant && interval2.UpperBound != Dummy.Constant)  		return NullUnlessTrue (Evaluator.Evaluate (operation' interval1.LowerBound' interval2.UpperBound));  	break;  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  	if (operand1 == operand2) {  		resultValue = true;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	goto case OperationCode.Blt;  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval2 != null && interval1.UpperBound != Dummy.Constant && interval2.LowerBound != Dummy.Constant)  		return NullUnlessTrue (Evaluator.Evaluate (operation' interval1.UpperBound' interval2.LowerBound));  	break;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (operand1 == operand2 && !floatingPoint) {  		resultValue = false;  		resultType = operand1.Type.PlatformType.SystemBoolean;  	}  	if (interval1 != null && interval1.IsFinite && interval2 != null && interval2.IsFinite) {  		if (Evaluator.IsNumericallyLessThan (interval1.UpperBound' interval2.LowerBound) || Evaluator.IsNumericallyGreaterThan (interval1.LowerBound' interval2.UpperBound))  			return new MetadataConstant () {  				Value = true'  				Type = operand1.Type.PlatformType.SystemBoolean  			};  	}  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Evaluator,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Evaluator.cs,Evaluate,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Nop:  	var phiVar = operation.Value as INamedEntity;  	if (phiVar == null)  		return null;  	;  	//We have a phi node. If all operands are constants and are moreover equal' we can reduce the phi node to a constant.  	var cv1 = mappings.GetCompileTimeConstantValueFor (operand1' block);  	if (cv1 == null)  		return null;  	foreach (var operandi in operands2toN) {  		Contract.Assume (operandi != null);  		var cvi = mappings.GetCompileTimeConstantValueFor (operandi' block);  		if (cvi == null)  			return null;  		if (!Evaluator.IsNumericallyEqual (cv1' cvi))  			return null;  	}  	return cv1;  }  
Missing Default,Microsoft.Cci.Analysis,ExpressionCanonicalizer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\ExpressionCanonicalizer.cs,GetAsLoadConstant,The following switch statement is missing a default case: switch (tc) {  case TypeCode.Boolean:  case TypeCode.SByte:  case TypeCode.Byte:  case TypeCode.Char:  case TypeCode.Int16:  case TypeCode.UInt16:  case TypeCode.Int32:  case TypeCode.UInt32:  case TypeCode.Int64:  	long n = convertible.ToInt64 (null);  	if (int.MinValue <= n && n <= int.MaxValue)  		result = new Instruction () {  			Operation = new Operation () {  				OperationCode = OperationCode.Ldc_I4'  				Value = (int)n'  				Location = location  			}  		};  	else  		result = new Instruction () {  			Operation = new Operation () {  				OperationCode = OperationCode.Ldc_I8'  				Value = n'  				Location = location  			}  		};  	break;  case TypeCode.UInt64:  	result = new Instruction () {  		Operation = new Operation () {  			OperationCode = OperationCode.Ldc_I8'  			Value = (long)convertible.ToUInt64 (null)'  			Location = location  		}  	};  	break;  case TypeCode.Single:  	result = new Instruction () {  		Operation = new Operation () {  			OperationCode = OperationCode.Ldc_R4'  			Value = convertible.ToSingle (null)'  			Location = location  		}  	};  	break;  case TypeCode.Double:  	result = new Instruction () {  		Operation = new Operation () {  			OperationCode = OperationCode.Ldc_R8'  			Value = convertible.ToDouble (null)'  			Location = location  		}  	};  	break;  case TypeCode.String:  	result = new Instruction () {  		Operation = new Operation () {  			OperationCode = OperationCode.Ldstr'  			Value = convertible.ToString (null)'  			Location = location  		}  	};  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Purger,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Purger.cs,PurgeBinary,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.And:  case OperationCode.Or:  	if (operand1 == null)  		return operand2;  	if (operand2 == null)  		return operand1;  	if (operand1 != instruction.Operand1 || operand2 != instruction.Operand2)  		return canonicalizer.GetCanonicalExpression (instruction' operand1' operand2);  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyNullary,The following switch statement is missing a default case: switch (oldOp.OperationCode) {  case OperationCode.Ldarga_S:  	newCode = OperationCode.Ldarga;  	break;  case OperationCode.Ldloca_S:  	newCode = OperationCode.Ldloca;  	break;  case OperationCode.Br_S:  	newCode = OperationCode.Br;  	break;  case OperationCode.Leave_S:  	newCode = OperationCode.Leave;  	break;  case OperationCode.Ldc_I4_0:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_1:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_2:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_3:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_4:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_5:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_6:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_7:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_8:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_M1:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldc_I4_S:  	newCode = OperationCode.Ldc_I4;  	break;  case OperationCode.Ldarg_0:  	newCode = OperationCode.Ldarg;  	break;  case OperationCode.Ldarg_1:  	newCode = OperationCode.Ldarg;  	break;  case OperationCode.Ldarg_2:  	newCode = OperationCode.Ldarg;  	break;  case OperationCode.Ldarg_3:  	newCode = OperationCode.Ldarg;  	break;  case OperationCode.Ldarg_S:  	newCode = OperationCode.Ldarg;  	break;  case OperationCode.Ldloc_0:  	newCode = OperationCode.Ldloc;  	break;  case OperationCode.Ldloc_1:  	newCode = OperationCode.Ldloc;  	break;  case OperationCode.Ldloc_2:  	newCode = OperationCode.Ldloc;  	break;  case OperationCode.Ldloc_3:  	newCode = OperationCode.Ldloc;  	break;  case OperationCode.Ldloc_S:  	newCode = OperationCode.Ldloc;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyNullary,The following switch statement is missing a default case: switch (newCode) {  case OperationCode.Ldarg:  case OperationCode.Ldloc:  	var localOrParameter = oldOp.Value as INamedEntity;  	if (localOrParameter == null)  		break;  	var definingExpression = mappings.GetDefiningExpressionFor (localOrParameter);  	if (definingExpression != null)  		return definingExpression;  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyBinary,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  	if (operand1IsZero)  		return operand2;  	if (operand2IsZero)  		return operand1;  	//TODO: factor out common mults/divs/etc (subject to overflow checks).  	break;  case OperationCode.And:  	if (operand1IsZero)  		return operand1;  	if (operand2IsZero)  		return operand2;  	if (operand1IsMinusOne)  		return operand2;  	if (operand2IsMinusOne)  		return operand1;  	if (operand1.Operation.OperationCode == OperationCode.Not && operand2.Operation.OperationCode == OperationCode.Not) {  		var opnd11 = operand1.Operand1 as Instruction;  		var opnd21 = operand2.Operand1 as Instruction;  		Contract.Assume (opnd11 != null && opnd21 != null);  		var or = new Operation () {  			OperationCode = OperationCode.Or'  			Location = operation.Location'  			Offset = operation.Offset  		};  		var orInst = new Instruction () {  			Operation = or'  			Operand1 = opnd11'  			Operand2 = opnd21'  			Type = instruction.Type  		};  		var not = new Operation {  			OperationCode = OperationCode.Not'  			Location = operation.Location'  			Offset = operation.Offset  		};  		return new Instruction () {  			Operation = not'  			Operand1 = orInst'  			Type = instruction.Type  		};  	}  	break;  case OperationCode.Ceq:  	//If one of the operands is const 0 and the other is a boolean expression' invert the boolean expression  	if (operand2IsZero && operand1.Type.TypeCode == PrimitiveTypeCode.Boolean) {  		var not = new Operation () {  			Location = instruction.Operation.Location'  			Offset = instruction.Operation.Offset'  			OperationCode = OperationCode.Not  		};  		instruction = new Instruction () {  			Operation = not'  			Operand1 = operand1'  			Type = instruction.Type  		};  		return SimplifyUnary (instruction' mappings' canonicalizer);  	}  	else if (operand1IsZero && operand2.Type.TypeCode == PrimitiveTypeCode.Boolean) {  		var not = new Operation () {  			Location = instruction.Operation.Location'  			Offset = instruction.Operation.Offset'  			OperationCode = OperationCode.Not  		};  		instruction = new Instruction () {  			Operation = not'  			Operand1 = operand2'  			Type = instruction.Type  		};  		return SimplifyUnary (instruction' mappings' canonicalizer);  	}  	else {  		operation = new Operation () {  			Location = instruction.Operation.Location'  			Offset = instruction.Operation.Offset'  			OperationCode = OperationCode.Beq  		};  	}  	break;  case OperationCode.Cgt:  	operation = new Operation () {  		Location = instruction.Operation.Location'  		Offset = instruction.Operation.Offset'  		OperationCode = OperationCode.Bgt  	};  	break;  case OperationCode.Cgt_Un:  	operation = new Operation () {  		Location = instruction.Operation.Location'  		Offset = instruction.Operation.Offset'  		OperationCode = OperationCode.Bgt_Un  	};  	break;  case OperationCode.Clt:  	operation = new Operation () {  		Location = instruction.Operation.Location'  		Offset = instruction.Operation.Offset'  		OperationCode = OperationCode.Blt  	};  	break;  case OperationCode.Clt_Un:  	operation = new Operation () {  		Location = instruction.Operation.Location'  		Offset = instruction.Operation.Offset'  		OperationCode = OperationCode.Blt_Un  	};  	break;  case OperationCode.Div:  case OperationCode.Div_Un:  	if (operand2IsOne)  		return operand1;  	break;  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  	if (operand1IsOne)  		return operand2;  	if (operand2IsOne)  		return operand1;  	break;  case OperationCode.Or:  	if (operand1IsZero)  		return operand2;  	if (operand2IsZero)  		return operand1;  	if (operand1.Operation.OperationCode == OperationCode.Not && operand2.Operation.OperationCode == OperationCode.Not) {  		var opnd11 = operand1.Operand1 as Instruction;  		var opnd21 = operand2.Operand1 as Instruction;  		Contract.Assume (opnd11 != null && opnd21 != null);  		var and = new Operation () {  			OperationCode = OperationCode.And'  			Location = operation.Location'  			Offset = operation.Offset  		};  		var andInst = new Instruction () {  			Operation = and'  			Operand1 = opnd11'  			Operand2 = opnd21'  			Type = instruction.Type  		};  		var not = new Operation {  			OperationCode = OperationCode.Not'  			Location = operation.Location'  			Offset = operation.Offset  		};  		return new Instruction () {  			Operation = not'  			Operand1 = andInst'  			Type = instruction.Type  		};  	}  	if (operand1.Operand1 == operand2.Operand1 && operand1.Operand2 == operand2.Operand2 && operand1.Operation.OperationCode != operand2.Operation.OperationCode && operand2.Operand1 != null && operand1.Operation.OperationCode == GetInverse (operand2.Operation.OperationCode' operand2.Operand1.Type.TypeCode == PrimitiveTypeCode.Float32 || operand2.Operand1.Type.TypeCode == PrimitiveTypeCode.Float64)) {  		return canonicalizer.GetAsCanonicalizedLoadConstant (new MetadataConstant () {  			Value = true'  			Type = instruction.Type  		}' instruction);  	}  	break;  case OperationCode.Rem:  case OperationCode.Rem_Un:  	break;  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	if (operand2IsZero)  		return operand1;  	break;  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  	if (operand2IsZero)  		return operand1;  	break;  case OperationCode.Xor:  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  	if (operand1IsZero && operand2.Type.TypeCode == PrimitiveTypeCode.Boolean) {  		var operand2inv = TryToGetSimplerLogicalInverse (operand2);  		if (operand2inv != null)  			return operand2inv;  	}  	else if (operand2IsZero && operand1.Type.TypeCode == PrimitiveTypeCode.Boolean) {  		var operand1inv = TryToGetSimplerLogicalInverse (operand1);  		if (operand1inv != null)  			return operand1inv;  	}  	goto case OperationCode.Bge_S;  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	if (operand1IsZero && operand2.Type.TypeCode == PrimitiveTypeCode.Boolean)  		return operand2;  	if (operand2IsZero && operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		return operand1;  	goto case OperationCode.Bge_S;  case OperationCode.Bge_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_S:  case OperationCode.Blt_Un_S:  	operation = new Operation () {  		Location = operation.Location'  		Offset = operation.Offset'  		OperationCode = LongVersionOf (operation.OperationCode)'  		Value = operation.Value  	};  	break;  }  
Missing Default,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyUnary,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Neg:  	if (operand.Operation.OperationCode == OperationCode.Neg) {  		Contract.Assume (operand.Operand1 is Instruction);  		return (Instruction)operand.Operand1;  	}  	//TODO: if the operand is a binary operation with arithmetic operands where one of them is a Neg  	//distribute the neg over the binary operation' if doing so is safe w.r.t. overflow.  	break;  case OperationCode.Not:  	var simplerInverse = TryToGetSimplerLogicalInverse (operand);  	if (simplerInverse != null)  		return simplerInverse;  	if (operand != operand1) {  		var operation1 = operand1.Operation;  		switch (operation1.OperationCode) {  		case OperationCode.Bne_Un:  		case OperationCode.Bne_Un_S:  		case OperationCode.Beq:  		case OperationCode.Beq_S:  			OperationCode newOpcode = GetInverse (operation1.OperationCode' operand1.Type.TypeCode == PrimitiveTypeCode.Float32 || operand1.Type.TypeCode == PrimitiveTypeCode.Float64);  			return new Instruction () {  				Operation = new Operation () {  					OperationCode = newOpcode'  					Offset = operation.Offset'  					Location = operation.Location  				}'  				Operand1 = operand1.Operand1'  				Operand2 = operand1.Operand2  			};  		}  	}  	return new Instruction () {  		Operation = operation'  		Operand1 = operand  	};  }  
Missing Default,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,SimplifyUnary,The following switch statement is missing a default case: switch (operation1.OperationCode) {  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  case OperationCode.Beq:  case OperationCode.Beq_S:  	OperationCode newOpcode = GetInverse (operation1.OperationCode' operand1.Type.TypeCode == PrimitiveTypeCode.Float32 || operand1.Type.TypeCode == PrimitiveTypeCode.Float64);  	return new Instruction () {  		Operation = new Operation () {  			OperationCode = newOpcode'  			Offset = operation.Offset'  			Location = operation.Location  		}'  		Operand1 = operand1.Operand1'  		Operand2 = operand1.Operand2  	};  }  
Missing Default,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,TryToGetSimplerLogicalInverse,The following switch statement is missing a default case: switch (instruction.Operation.OperationCode) {  case OperationCode.Not:  	Contract.Assume (instruction.Operand1 is Instruction);  	return (Instruction)instruction.Operand1;  case OperationCode.And: {  	var opnd1 = instruction.Operand1 as Instruction;  	var opnd2 = instruction.Operand2 as Instruction;  	Contract.Assume (opnd1 != null && opnd2 != null);  	var opnd1inv = TryToGetSimplerLogicalInverse (opnd1);  	var opnd2inv = TryToGetSimplerLogicalInverse (opnd2);  	if (opnd1inv == null) {  		if (opnd2inv == null)  			return null;  		var not = new Operation () {  			OperationCode = OperationCode.Not'  			Location = opnd1.Operation.Location'  			Offset = opnd1.Operation.Offset  		};  		opnd1inv = new Instruction () {  			Operation = not'  			Operand1 = opnd1'  			Type = instruction.Type  		};  	}  	else if (opnd2inv == null) {  		var not = new Operation () {  			OperationCode = OperationCode.Not'  			Location = opnd2.Operation.Location'  			Offset = opnd2.Operation.Offset  		};  		opnd2inv = new Instruction () {  			Operation = not'  			Operand1 = opnd2'  			Type = instruction.Type  		};  	}  	var or = new Operation () {  		OperationCode = OperationCode.Or'  		Location = instruction.Operation.Location'  		Offset = instruction.Operation.Offset  	};  	return new Instruction () {  		Operation = or'  		Operand1 = opnd1inv'  		Operand2 = opnd2inv'  		Type = instruction.Type  	};  }  case OperationCode.Or: {  	var opnd1 = instruction.Operand1 as Instruction;  	var opnd2 = instruction.Operand2 as Instruction;  	Contract.Assume (opnd1 != null && opnd2 != null);  	var opnd1inv = TryToGetSimplerLogicalInverse (opnd1);  	var opnd2inv = TryToGetSimplerLogicalInverse (opnd2);  	if (opnd1inv == null) {  		if (opnd2inv == null)  			return null;  		var not = new Operation () {  			OperationCode = OperationCode.Not'  			Location = opnd1.Operation.Location'  			Offset = opnd1.Operation.Offset  		};  		opnd1inv = new Instruction () {  			Operation = not'  			Operand1 = opnd1'  			Type = instruction.Type  		};  	}  	else if (opnd2inv == null) {  		var not = new Operation () {  			OperationCode = OperationCode.Not'  			Location = opnd2.Operation.Location'  			Offset = opnd2.Operation.Offset  		};  		opnd2inv = new Instruction () {  			Operation = not'  			Operand1 = opnd2'  			Type = instruction.Type  		};  	}  	var and = new Operation () {  		OperationCode = OperationCode.And'  		Location = instruction.Operation.Location'  		Offset = instruction.Operation.Offset  	};  	return new Instruction () {  		Operation = and'  		Operand1 = opnd1inv'  		Operand2 = opnd2inv'  		Type = instruction.Type  	};  }  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bge_Un:  case OperationCode.Bgt:  case OperationCode.Bgt_Un:  case OperationCode.Ble:  case OperationCode.Ble_Un:  case OperationCode.Blt:  case OperationCode.Blt_Un:  case OperationCode.Bne_Un:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un: {  	var opnd1 = instruction.Operand1 as Instruction;  	var opnd2 = instruction.Operand2 as Instruction;  	Contract.Assume (opnd1 != null && opnd2 != null);  	OperationCode newOpcode = GetInverse (instruction.Operation.OperationCode' opnd1.Type.TypeCode == PrimitiveTypeCode.Float32 || opnd1.Type.TypeCode == PrimitiveTypeCode.Float64);  	if (newOpcode != instruction.Operation.OperationCode) {  		var cmp = new Operation () {  			OperationCode = newOpcode'  			Location = instruction.Operation.Location'  			Offset = instruction.Operation.Offset  		};  		return new Instruction () {  			Operation = cmp'  			Operand1 = opnd1'  			Operand2 = opnd2'  			Type = instruction.Type  		};  	}  	break;  }  }  
Missing Default,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,GetInverse,The following switch statement is missing a default case: switch (operationCode) {  case OperationCode.Beq:  	return OperationCode.Bne_Un;  case OperationCode.Bge:  	return OperationCode.Blt_Un;  case OperationCode.Bge_Un:  	return OperationCode.Blt;  case OperationCode.Bgt:  	return OperationCode.Ble_Un;  case OperationCode.Bgt_Un:  	return OperationCode.Ble;  case OperationCode.Ble:  	return OperationCode.Bgt_Un;  case OperationCode.Ble_Un:  	return OperationCode.Bgt;  case OperationCode.Blt:  	return OperationCode.Bge_Un;  case OperationCode.Blt_Un:  	return OperationCode.Bge;  case OperationCode.Bne_Un:  	return OperationCode.Beq;  case OperationCode.Ceq:  	return OperationCode.Bne_Un;  case OperationCode.Cgt:  	return OperationCode.Ble_Un;  case OperationCode.Cgt_Un:  	return OperationCode.Ble;  case OperationCode.Clt:  	return OperationCode.Bge_Un;  case OperationCode.Clt_Un:  	return OperationCode.Bge;  }  
Missing Default,Microsoft.Cci.Analysis,Simplifier,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\Simplifier.cs,GetInverse,The following switch statement is missing a default case: switch (operationCode) {  case OperationCode.Beq:  	return OperationCode.Bne_Un;  case OperationCode.Bge:  	return OperationCode.Blt;  case OperationCode.Bge_Un:  	return OperationCode.Blt_Un;  case OperationCode.Bgt:  	return OperationCode.Ble;  case OperationCode.Bgt_Un:  	return OperationCode.Ble_Un;  case OperationCode.Ble:  	return OperationCode.Bgt;  case OperationCode.Ble_Un:  	return OperationCode.Bgt_Un;  case OperationCode.Blt:  	return OperationCode.Bge;  case OperationCode.Blt_Un:  	return OperationCode.Bge_Un;  case OperationCode.Bne_Un:  	return OperationCode.Beq;  case OperationCode.Ceq:  	return OperationCode.Bne_Un;  case OperationCode.Cgt:  	return OperationCode.Ble;  case OperationCode.Cgt_Un:  	return OperationCode.Ble;  case OperationCode.Clt:  	return OperationCode.Bge;  case OperationCode.Clt_Un:  	return OperationCode.Bge_Un;  }  
Missing Default,Microsoft.Cci.Analysis,SingleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\SingleAssignment.cs,ReplaceLocalsWithSSALocals,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Starg:  case OperationCode.Starg_S:  	Contract.Assume (operation.Value is SSAParameterDefinition);  	var ssaParam = (SSAParameterDefinition)operation.Value;  	ssaVariableFor [ssaParam.OriginalParameter] = ssaParam;  	break;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	Contract.Assume (operation.Value is SSALocalDefinition);  	var ssaLocal = (SSALocalDefinition)operation.Value;  	ssaVariableFor [ssaLocal.OriginalLocal] = ssaLocal;  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var ssaVar = ssaVariableFor [operation.Value ?? Dummy.ParameterDefinition];  	if (ssaVar != null)  		instruction.Operation = new SSAOperation (operation' ssaVar);  	break;  }  
Missing Default,Microsoft.Cci.Analysis,SingleAssigner,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\AnalyisUtilities\SingleAssignment.cs,CreateSSAVariablesAndJoinInformation,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	var ssaVariable = this.ssaVariableFor [operation.Value ?? Dummy.ParameterDefinition];  	if (ssaVariable != null)  		//The variable has already been defined in this block' use its new identity.  		instruction.Operation = new SSAOperation (operation' ssaVariable);  	else  		//Create a new identity for this variable.  		this.ReplaceWithNewSSAValue (instruction);  	//Now replace the value one more time because this instruction represents both a read (the above replacement) and a write (the replacement below).  	this.ReplaceWithNewSSAValue (instruction);  	break;  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  	//Assign to new variable  	this.ReplaceWithNewSSAValue (instruction);  	break;  //case OperationCode.Stind_I:  //case OperationCode.Stind_I1:  //case OperationCode.Stind_I2:  //case OperationCode.Stind_I4:  //case OperationCode.Stind_I8:  //case OperationCode.Stind_R4:  //case OperationCode.Stind_R8:  //case OperationCode.Stind_Ref:  //These could potentially write to locals. In that case the SSA constructed by this algorithm is inaccurate.  //Such coding patterns are very rare and fixing the inaccuracy at this level is very expensive.  //Consequently we leave it to the client to either fix the inaccuracy itself' or to detect situations where  //a stind could write to a local and to report them as errors.  }  
