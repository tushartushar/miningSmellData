Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,The method has 289 lines of code.
Long Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The method has 676 lines of code.
Long Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The method has 228 lines of code.
Complex Method,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateBlocksForBranchTargetsAndFallthroughs,Cyclomatic complexity of the method is 47
Complex Method,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,GetInstruction,Cyclomatic complexity of the method is 55
Complex Method,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupDominanceFrontier,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupImmediateDominators,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,Cyclomatic complexity of the method is 274
Complex Method,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,InitializeArgumentsAndPushReturnResult,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,FillInTypes,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,Cyclomatic complexity of the method is 607
Complex Method,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,Cyclomatic complexity of the method is 25
Long Parameter List,Microsoft.Cci.Analysis,ControlAndDataFlowGraph,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\Graph.cs,ControlAndDataFlowGraph,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,TypeInferencer,The method has 5 parameters.
Long Identifier,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the parameter lastInstructionWasUnconditionalTransfer is 39.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateBlocksForBranchTargetsAndFallthroughs,The length of the statement  "			//The code following these instructions will be dead unless its a branch target' but we may as well end the basic block with the transfer. " is 138.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the statement  "		//This is formally specified in the Metadata model' but the checker does not yet understand it well enough to prove this. " is 121.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the statement  "			currentBlock.Instructions = new Sublist<Instruction> (instructions' startingInstruction' instructions.Count - startingInstruction); " is 131.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the statement  "		instructions.Add (this.GetInstruction (ilOperation' currentBlock' successorEdges' out lastInstructionWasUnconditionalTransfer)); " is 128.
Long Statement,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,CreateSuccessorEdges,The length of the statement  "		currentBlock.Instructions = new Sublist<Instruction> (instructions' startingInstruction' instructions.Count - startingInstruction); " is 131.
Long Statement,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowQueries.cs,DominanceFrontierFor,The length of the statement  "	return new Sublist<BasicBlock> (this.dominanceFrontier' basicBlock.firstDominanceFrontierNode' basicBlock.dominanceFrontierCount); " is 130.
Long Statement,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupImmediateDominators,The length of the statement  "	//Note this is an adaptation of the algorithm in Cooper' Keith D.; Harvey' Timothy J.; and Kennedy' Ken (2001). A Simple' Fast Dominance Algorithm " is 146.
Long Statement,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupImmediateDominators,The length of the statement  "			//We iterate in reverse post order so that a block always has its immediateDominator field filled in before we get to any of its successors. " is 140.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,The length of the statement  "	if (this.cdfg.AllBlocks.Count == 1 && this.cdfg.AllBlocks [0] != null && this.cdfg.AllBlocks [0].Instructions.Count <= 1) " is 121.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,AddStackSetup,The length of the statement  "	block.OperandStack = new Sublist<Instruction> (this.operandStackSetupInstructions' this.operandStackSetupInstructions.Count - 1' 1); " is 132.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,DequeueBlockAndSetupDataFlow,The length of the statement  "		//The block might already be in the queue' but we can deal with this more efficiently by checking blocksAlreadyVisited when dequeueing. " is 135.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The length of the statement  "		successor.OperandStack = new Sublist<Instruction> (this.operandStackSetupInstructions' startingCount' operandStackSetupInstructions.Count - startingCount); " is 155.
Long Statement,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The length of the statement  "		//This is an optimistic assumption. It should be true for any well formed PE file. We are content to crash given bad input. " is 123.
Long Statement,Microsoft.Cci.Analysis,Stack,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\Graph.cs,Pop,The length of the statement  "	//This is an optimistic assumption. Clients have to match their Pop and Push calls' but enforcing this convention via contracts is too verbose. " is 143.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,DequeueBlockAndFillInItsTypes,The length of the statement  "	//The block either has no operand stack setup instructions' or we presume that a predecessor block has already assigned types to them. " is 134.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,DequeueBlockAndFillInItsTypes,The length of the statement  "		//The block might already be in the queue' but we can deal with this more efficiently by checking blocksAlreadyVisited when dequeueing. " is 135.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		if (instruction.Operand1.Type.TypeCode == PrimitiveTypeCode.Boolean && ((Instruction)instruction.Operand2).Type.TypeCode == PrimitiveTypeCode.Boolean) { " is 152.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "			instruction.Type = ManagedPointerType.GetManagedPointerType (this.cfg.MethodBody.MethodDefinition.ContainingType' this.internFactory); " is 134.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory); " is 126.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory); " is 134.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory); " is 134.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory); " is 126.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The length of the statement  "		instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory); " is 126.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is a polymorphic constant. " is 144.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is an enum. " is 129.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the left operand is a polymorphic constant. " is 143.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is an enum. " is 129.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is a polymorphic constant. " is 144.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is an enum. " is 129.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the left operand is a polymorphic constant. " is 143.
Long Statement,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The length of the statement  "		//code generators will tend to make both operands be of the same type. Assume this happened because the right operand is an enum. " is 129.
Magic Number,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupDominanceFrontier,The following statement contains a magic number: foreach (var block in this.cfg.AllBlocks) {  	Contract.Assume (block != null);  	var n = block.predeccessorCount;  	if (n < 2)  		continue;  	for (int i = 0; i < n; i++) {  		Contract.Assume (block.firstPredecessorEdge + i >= 0);  		Contract.Assume (block.firstPredecessorEdge + i < predecessorEdges.Count);  		var pred = predecessorEdges [block.firstPredecessorEdge + i];  		Contract.Assume (pred != null);  		var a = pred;  		while (true) {  			if (a == block.immediateDominator)  				break;  			//Any node that dominates node a will also dominate node block and hence block will not be in its dominance frontier.  			frontierFor.Add (a.Offset' block);  			if (a == a.immediateDominator)  				break;  			//Since there are multiple roots' block can be its own immediate dominator while still having predecessors.  			a = (BasicBlock)a.immediateDominator;  			Contract.Assume (a != null);  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,ControlGraphQueries,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowQueries.cs,SetupDominanceFrontier,The following statement contains a magic number: if (n < 2)  	continue;  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The following statement contains a magic number: if (successor.OperandStack.Count == 0) {  	int n = this.stack.Top;  	if (n < 0)  		return;  	int startingCount = this.operandStackSetupInstructions.Count;  	for (int i = 0; i <= n; i++) {  		var pushInstruction = this.stack.Peek (i);  		this.operandStackSetupInstructions.Add (new Instruction () {  			Operand1 = pushInstruction  		});  	}  	successor.OperandStack = new Sublist<Instruction> (this.operandStackSetupInstructions' startingCount' operandStackSetupInstructions.Count - startingCount);  }  else {  	int n = this.stack.Top;  	Contract.Assume (n == successor.OperandStack.Count - 1);  	//This is an optimistic assumption. It should be true for any well formed PE file. We are content to crash given bad input.  	for (int i = 0; i <= n; i++) {  		var pushInstruction = this.stack.Peek (i);  		var setupInstruction = successor.OperandStack [i];  		if (setupInstruction.Operand2 == null)  			setupInstruction.Operand2 = pushInstruction;  		else {  			var list = setupInstruction.Operand2 as List<Instruction>;  			if (list == null) {  				Contract.Assume (setupInstruction.Operand2 is Instruction);  				list = new List<Instruction> (4);  				list.Add ((Instruction)setupInstruction.Operand2);  			}  			list.Add (pushInstruction);  		}  	}  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The following statement contains a magic number: for (int i = 0; i <= n; i++) {  	var pushInstruction = this.stack.Peek (i);  	var setupInstruction = successor.OperandStack [i];  	if (setupInstruction.Operand2 == null)  		setupInstruction.Operand2 = pushInstruction;  	else {  		var list = setupInstruction.Operand2 as List<Instruction>;  		if (list == null) {  			Contract.Assume (setupInstruction.Operand2 is Instruction);  			list = new List<Instruction> (4);  			list.Add ((Instruction)setupInstruction.Operand2);  		}  		list.Add (pushInstruction);  	}  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The following statement contains a magic number: if (setupInstruction.Operand2 == null)  	setupInstruction.Operand2 = pushInstruction;  else {  	var list = setupInstruction.Operand2 as List<Instruction>;  	if (list == null) {  		Contract.Assume (setupInstruction.Operand2 is Instruction);  		list = new List<Instruction> (4);  		list.Add ((Instruction)setupInstruction.Operand2);  	}  	list.Add (pushInstruction);  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The following statement contains a magic number: if (list == null) {  	Contract.Assume (setupInstruction.Operand2 is Instruction);  	list = new List<Instruction> (4);  	list.Add ((Instruction)setupInstruction.Operand2);  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupStackFor,The following statement contains a magic number: list = new List<Instruction> (4);  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,The following statement contains a magic number: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	this.stack.Push (instruction);  	break;  case OperationCode.Arglist:  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  case OperationCode.Ldsfld:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldsflda:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldftn:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  case OperationCode.Sizeof:  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArrayIndexerInstruction (instruction' this.stack' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Array_Create:  case OperationCode.Array_Create_WithLowerBound:  case OperationCode.Newarr:  	InitializeArrayCreateInstruction (instruction' this.stack' instruction.Operation);  	break;  case OperationCode.Array_Set:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArraySetInstruction (instruction' this.stack' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Box:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Isinst:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldobj:  case OperationCode.Ldflda:  case OperationCode.Ldfld:  case OperationCode.Ldlen:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Mkrefany:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  	instruction.Operand1 = this.stack.Pop ();  	this.stack.Push (instruction);  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  	var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	InitializeArgumentsAndPushReturnResult (instruction' this.stack' signature);  	break;  case OperationCode.Calli:  	var funcPointer = instruction.Operation.Value as IFunctionPointerTypeReference;  	Contract.Assume (funcPointer != null);  	//This is an informally specified property of the Metadata model.  	InitializeArgumentsAndPushReturnResult (instruction' this.stack' funcPointer);  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	var indexAndValue = new Instruction[2];  	indexAndValue [1] = this.stack.Pop ();  	indexAndValue [0] = this.stack.Pop ();  	instruction.Operand2 = indexAndValue;  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Dup:  	var dupop = this.stack.Pop ();  	instruction.Operand1 = dupop;  	this.stack.Push (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Leave:  case OperationCode.Leave_S:  	this.stack.Clear ();  	break;  case OperationCode.Newobj:  	Contract.Assume (instruction.Operation.Value is ISignature);  	//This is an informally specified property of the Metadata model.  	signature = (ISignature)instruction.Operation.Value;  	var numArguments = (int)IteratorHelper.EnumerableCount (signature.Parameters);  	if (numArguments > 0) {  		if (numArguments > 1) {  			numArguments--;  			var arguments = new Instruction[numArguments];  			instruction.Operand2 = arguments;  			for (var i = numArguments - 1; i >= 0; i--)  				arguments [i] = stack.Pop ();  		}  		instruction.Operand1 = stack.Pop ();  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ret:  	if (this.codeIsUnreachable && this.stack.Top < 0)  		break;  	if (this.cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		instruction.Operand1 = this.stack.Pop ();  	break;  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,InitializeArrayCreateInstruction,The following statement contains a magic number: if (rank > 0) {  	if (currentOperation.OperationCode == OperationCode.Array_Create_WithLowerBound)  		rank *= 2;  	rank--;  	if (rank > 0) {  		var indices = new Instruction[rank];  		instruction.Operand2 = indices;  		for (var i = rank; i > 0; i--)  			indices [i - 1] = stack.Pop ();  	}  	instruction.Operand1 = stack.Pop ();  }  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,InitializeArrayCreateInstruction,The following statement contains a magic number: if (currentOperation.OperationCode == OperationCode.Array_Create_WithLowerBound)  	rank *= 2;  
Magic Number,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,InitializeArrayCreateInstruction,The following statement contains a magic number: rank *= 2;  
Magic Number,Microsoft.Cci.Analysis,Stack,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\Graph.cs,Stack,The following statement contains a magic number: if (maxStack <= 0)  	maxStack = 8;  
Magic Number,Microsoft.Cci.Analysis,Stack,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\Graph.cs,Stack,The following statement contains a magic number: maxStack = 8;  
Magic Number,Microsoft.Cci.Analysis,Stack,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\Graph.cs,Push,The following statement contains a magic number: if (this.top >= this.elements.Length - 1) {  	Array.Resize (ref this.elements' this.elements.Length * 2);  	Contract.Assume (Contract.ForAll (0' this.top + 1' i => this.elements [i] != null));  	//this the expected behavior of Array.Resize  }  
Magic Number,Microsoft.Cci.Analysis,Stack,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\Graph.cs,Push,The following statement contains a magic number: Array.Resize (ref this.elements' this.elements.Length * 2);  
Magic Number,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The following statement contains a magic number: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Div:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Rem:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.GetBinaryNumericOperationType (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  	Contract.Assume (instruction.Operand1 != null);  	Contract.Assume (instruction.Operand2 is Instruction);  	if (instruction.Operand1.Type.TypeCode == PrimitiveTypeCode.Boolean && ((Instruction)instruction.Operand2).Type.TypeCode == PrimitiveTypeCode.Boolean) {  		this.stack.Pop ();  		this.stack.Pop ();  		instruction.Type = this.platformType.SystemBoolean;  		this.stack.Push (instruction);  		break;  	}  	goto case OperationCode.Add;  case OperationCode.Add_Ovf_Un:  case OperationCode.Div_Un:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Rem_Un:  case OperationCode.Sub_Ovf_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.GetUnsignedBinaryNumericOperationType (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.Arglist:  	instruction.Type = this.platformType.SystemRuntimeArgumentHandle;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Addr:  	var arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = ManagedPointerType.GetManagedPointerType (arrayType.ElementType' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Create:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = arrayType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Create_WithLowerBound:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank * 2; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = arrayType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Get:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = arrayType.ElementType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Set:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	this.stack.Pop ();  	//The value to set  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Box:  	this.stack.Pop ();  	var typeInBox = instruction.Operation.Value as ITypeReference;  	Contract.Assume (typeInBox != null);  	if (typeInBox.ResolvedType.IsReferenceType)  		instruction.Type = typeInBox.ResolvedType;  	//This typically happens when typeInBox is a type parameter.  	else  		instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  	var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	var methodRef = signature as IMethodReference;  	uint numArguments = IteratorHelper.EnumerableCount (signature.Parameters);  	if (methodRef != null && methodRef.AcceptsExtraArguments)  		numArguments += IteratorHelper.EnumerableCount (methodRef.ExtraParameters);  	for (var i = numArguments; i > 0; i--)  		this.stack.Pop ();  	if (!signature.IsStatic)  		this.stack.Pop ();  	instruction.Type = signature.Type;  	if (signature.Type.TypeCode != PrimitiveTypeCode.Void)  		this.stack.Push (instruction);  	break;  case OperationCode.Calli:  	var funcPointer = instruction.Operation.Value as IFunctionPointerTypeReference;  	Contract.Assume (funcPointer != null);  	//This is an informally specified property of the Metadata model.  	var fp = this.stack.Pop ();  	//The function pointer  	fp.Type = funcPointer;  	numArguments = IteratorHelper.EnumerableCount (funcPointer.Parameters);  	for (var i = numArguments; i > 0; i--)  		this.stack.Pop ();  	if (!funcPointer.IsStatic)  		this.stack.Pop ();  	instruction.Type = funcPointer.Type;  	if (funcPointer.Type.TypeCode != PrimitiveTypeCode.Void)  		this.stack.Push (instruction);  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	if (instruction.Type.ResolvedType.IsValueType || instruction.Type is IGenericParameterReference)  		instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemBoolean;  	this.stack.Push (instruction);  	break;  case OperationCode.Ckfinite:  case OperationCode.Neg:  case OperationCode.Not:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Ldind_I:  case OperationCode.Localloc:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Ldind_I1:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Ldind_I2:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Ldind_I4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Ldind_I8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_U:  case OperationCode.Ldlen:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_U1:  case OperationCode.Ldind_U1:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_U2:  case OperationCode.Ldind_U2:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_U4:  case OperationCode.Ldind_U4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_U8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R_Un:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	if (TypeHelper.SizeOfType (instruction.Operand1.Type) < 4)  		instruction.Type = this.platformType.SystemFloat32;  	else  		instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R4:  case OperationCode.Ldind_R4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R8:  case OperationCode.Ldind_R8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	this.stack.Pop ();  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Dup:  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	var parameter = instruction.Operation.Value as IParameterDefinition;  	if (parameter == null) {  		//this arg  		var containingType = this.cfg.MethodBody.MethodDefinition.ContainingTypeDefinition;  		var namedType = containingType as INamedTypeDefinition;  		if (namedType != null && namedType.IsGeneric)  			instruction.Type = namedType.InstanceType;  		else  			instruction.Type = containingType;  		if (instruction.Type.IsValueType)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	else {  		instruction.Type = parameter.Type;  		if (parameter.IsByReference)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	parameter = instruction.Operation.Value as IParameterDefinition;  	if (parameter == null) {  		//this arg  		instruction.Type = ManagedPointerType.GetManagedPointerType (this.cfg.MethodBody.MethodDefinition.ContainingType' this.internFactory);  	}  	else {  		instruction.Type = ManagedPointerType.GetManagedPointerType (parameter.Type' this.internFactory);  		if (parameter.IsByReference)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_I8:  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_R4:  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_R8:  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldobj:  case OperationCode.Unbox_Any:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I1:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I2:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I8:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_Ref:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	arrayType = instruction.Operand1.Type as IArrayTypeReference;  	if (arrayType != null)  		instruction.Type = arrayType.ElementType;  	else  		//Should only get here if the IL is bad.  		instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_R4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_R8:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U1:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U2:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelema:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldfld:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ((IFieldReference)instruction.Operation.Value).Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldsfld:  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ((IFieldReference)instruction.Operation.Value).Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldflda:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldsflda:  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldftn:  	Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = new FunctionPointerType ((IMethodReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldvirtftn:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = new FunctionPointerType ((IMethodReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldind_Ref:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	var ptr = instruction.Operand1.Type as IPointerTypeReference;  	if (ptr != null)  		instruction.Type = ptr.TargetType;  	else {  		Contract.Assume (instruction.Operand1.Type is IManagedPointerTypeReference);  		//This is an informally specified property of the Metadata model.  		instruction.Type = ((IManagedPointerTypeReference)instruction.Operand1.Type).TargetType;  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var local = instruction.Operation.Value as ILocalDefinition;  	Contract.Assume (local != null);  	//This is an informally specified property of the Metadata model.  	instruction.Type = local.Type;  	if (local.IsReference)  		instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	local = instruction.Operation.Value as ILocalDefinition;  	Contract.Assume (local != null);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (local.Type' this.internFactory);  	if (local.IsReference)  		instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldnull:  	instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldstr:  	instruction.Type = this.platformType.SystemString;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldtoken:  	if (instruction.Operation.Value is IMethodReference)  		instruction.Type = this.platformType.SystemRuntimeMethodHandle;  	else if (instruction.Operation.Value is ITypeReference)  		instruction.Type = this.platformType.SystemRuntimeTypeHandle;  	else if (instruction.Operation.Value is IFieldReference)  		instruction.Type = this.platformType.SystemRuntimeFieldHandle;  	else {  		//this should never happen in well formed IL.  		instruction.Type = this.platformType.SystemVoid;  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Leave:  case OperationCode.Leave_S:  	this.stack.Clear ();  	break;  case OperationCode.Mkrefany:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemTypedReference;  	this.stack.Push (instruction);  	break;  case OperationCode.Newarr:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Newobj:  	var constructorReference = instruction.Operation.Value as IMethodReference;  	Contract.Assume (constructorReference != null);  	//This is an informally specified property of the Metadata model.  	for (var i = constructorReference.ParameterCount; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = constructorReference.ContainingType;  	this.stack.Push (instruction);  	break;  case OperationCode.Refanytype:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemRuntimeTypeHandle;  	this.stack.Push (instruction);  	break;  case OperationCode.Refanyval:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ret:  	if (this.codeIsUnreachable && this.stack.Top < 0)  		break;  	if (this.cfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		instruction.Operand1 = this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Sizeof:  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Unbox:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  default:  	instruction.Type = this.platformType.SystemVoid;  	break;  }  
Magic Number,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The following statement contains a magic number: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Div:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Rem:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.GetBinaryNumericOperationType (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  	Contract.Assume (instruction.Operand1 != null);  	Contract.Assume (instruction.Operand2 is Instruction);  	if (instruction.Operand1.Type.TypeCode == PrimitiveTypeCode.Boolean && ((Instruction)instruction.Operand2).Type.TypeCode == PrimitiveTypeCode.Boolean) {  		this.stack.Pop ();  		this.stack.Pop ();  		instruction.Type = this.platformType.SystemBoolean;  		this.stack.Push (instruction);  		break;  	}  	goto case OperationCode.Add;  case OperationCode.Add_Ovf_Un:  case OperationCode.Div_Un:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Rem_Un:  case OperationCode.Sub_Ovf_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.GetUnsignedBinaryNumericOperationType (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.Arglist:  	instruction.Type = this.platformType.SystemRuntimeArgumentHandle;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Addr:  	var arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = ManagedPointerType.GetManagedPointerType (arrayType.ElementType' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Create:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = arrayType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Create_WithLowerBound:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank * 2; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = arrayType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Get:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = arrayType.ElementType;  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Set:  	arrayType = instruction.Operation.Value as IArrayTypeReference;  	Contract.Assume (arrayType != null);  	//This is an informally specified property of the Metadata model.  	this.stack.Pop ();  	//The value to set  	for (var i = arrayType.Rank; i > 0; i--)  		this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Box:  	this.stack.Pop ();  	var typeInBox = instruction.Operation.Value as ITypeReference;  	Contract.Assume (typeInBox != null);  	if (typeInBox.ResolvedType.IsReferenceType)  		instruction.Type = typeInBox.ResolvedType;  	//This typically happens when typeInBox is a type parameter.  	else  		instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  	var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	var methodRef = signature as IMethodReference;  	uint numArguments = IteratorHelper.EnumerableCount (signature.Parameters);  	if (methodRef != null && methodRef.AcceptsExtraArguments)  		numArguments += IteratorHelper.EnumerableCount (methodRef.ExtraParameters);  	for (var i = numArguments; i > 0; i--)  		this.stack.Pop ();  	if (!signature.IsStatic)  		this.stack.Pop ();  	instruction.Type = signature.Type;  	if (signature.Type.TypeCode != PrimitiveTypeCode.Void)  		this.stack.Push (instruction);  	break;  case OperationCode.Calli:  	var funcPointer = instruction.Operation.Value as IFunctionPointerTypeReference;  	Contract.Assume (funcPointer != null);  	//This is an informally specified property of the Metadata model.  	var fp = this.stack.Pop ();  	//The function pointer  	fp.Type = funcPointer;  	numArguments = IteratorHelper.EnumerableCount (funcPointer.Parameters);  	for (var i = numArguments; i > 0; i--)  		this.stack.Pop ();  	if (!funcPointer.IsStatic)  		this.stack.Pop ();  	instruction.Type = funcPointer.Type;  	if (funcPointer.Type.TypeCode != PrimitiveTypeCode.Void)  		this.stack.Push (instruction);  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	if (instruction.Type.ResolvedType.IsValueType || instruction.Type is IGenericParameterReference)  		instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemBoolean;  	this.stack.Push (instruction);  	break;  case OperationCode.Ckfinite:  case OperationCode.Neg:  case OperationCode.Not:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Ldind_I:  case OperationCode.Localloc:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Ldind_I1:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Ldind_I2:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Ldind_I4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Ldind_I8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_U:  case OperationCode.Ldlen:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_U1:  case OperationCode.Ldind_U1:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_U2:  case OperationCode.Ldind_U2:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_U4:  case OperationCode.Ldind_U4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_U8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R_Un:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	if (TypeHelper.SizeOfType (instruction.Operand1.Type) < 4)  		instruction.Type = this.platformType.SystemFloat32;  	else  		instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R4:  case OperationCode.Ldind_R4:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Conv_R8:  case OperationCode.Ldind_R8:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	this.stack.Pop ();  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Dup:  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  	var parameter = instruction.Operation.Value as IParameterDefinition;  	if (parameter == null) {  		//this arg  		var containingType = this.cfg.MethodBody.MethodDefinition.ContainingTypeDefinition;  		var namedType = containingType as INamedTypeDefinition;  		if (namedType != null && namedType.IsGeneric)  			instruction.Type = namedType.InstanceType;  		else  			instruction.Type = containingType;  		if (instruction.Type.IsValueType)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	else {  		instruction.Type = parameter.Type;  		if (parameter.IsByReference)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  	parameter = instruction.Operation.Value as IParameterDefinition;  	if (parameter == null) {  		//this arg  		instruction.Type = ManagedPointerType.GetManagedPointerType (this.cfg.MethodBody.MethodDefinition.ContainingType' this.internFactory);  	}  	else {  		instruction.Type = ManagedPointerType.GetManagedPointerType (parameter.Type' this.internFactory);  		if (parameter.IsByReference)  			instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_I8:  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_R4:  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldc_R8:  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldobj:  case OperationCode.Unbox_Any:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemIntPtr;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I1:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I2:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_I8:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemInt64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_Ref:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	arrayType = instruction.Operand1.Type as IArrayTypeReference;  	if (arrayType != null)  		instruction.Type = arrayType.ElementType;  	else  		//Should only get here if the IL is bad.  		instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_R4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_R8:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemFloat64;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U1:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt8;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U2:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt16;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelem_U4:  	this.stack.Pop ();  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldelema:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldfld:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ((IFieldReference)instruction.Operation.Value).Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldsfld:  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ((IFieldReference)instruction.Operation.Value).Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldflda:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldsflda:  	Contract.Assume (instruction.Operation.Value is IFieldReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (((IFieldReference)instruction.Operation.Value).Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldftn:  	Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = new FunctionPointerType ((IMethodReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldvirtftn:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is IMethodReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = new FunctionPointerType ((IMethodReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldind_Ref:  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	var ptr = instruction.Operand1.Type as IPointerTypeReference;  	if (ptr != null)  		instruction.Type = ptr.TargetType;  	else {  		Contract.Assume (instruction.Operand1.Type is IManagedPointerTypeReference);  		//This is an informally specified property of the Metadata model.  		instruction.Type = ((IManagedPointerTypeReference)instruction.Operand1.Type).TargetType;  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var local = instruction.Operation.Value as ILocalDefinition;  	Contract.Assume (local != null);  	//This is an informally specified property of the Metadata model.  	instruction.Type = local.Type;  	if (local.IsReference)  		instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  	local = instruction.Operation.Value as ILocalDefinition;  	Contract.Assume (local != null);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType (local.Type' this.internFactory);  	if (local.IsReference)  		instruction.Type = ManagedPointerType.GetManagedPointerType (instruction.Type' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ldnull:  	instruction.Type = this.platformType.SystemObject;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldstr:  	instruction.Type = this.platformType.SystemString;  	this.stack.Push (instruction);  	break;  case OperationCode.Ldtoken:  	if (instruction.Operation.Value is IMethodReference)  		instruction.Type = this.platformType.SystemRuntimeMethodHandle;  	else if (instruction.Operation.Value is ITypeReference)  		instruction.Type = this.platformType.SystemRuntimeTypeHandle;  	else if (instruction.Operation.Value is IFieldReference)  		instruction.Type = this.platformType.SystemRuntimeFieldHandle;  	else {  		//this should never happen in well formed IL.  		instruction.Type = this.platformType.SystemVoid;  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Leave:  case OperationCode.Leave_S:  	this.stack.Clear ();  	break;  case OperationCode.Mkrefany:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemTypedReference;  	this.stack.Push (instruction);  	break;  case OperationCode.Newarr:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = (ITypeReference)instruction.Operation.Value;  	this.stack.Push (instruction);  	break;  case OperationCode.Newobj:  	var constructorReference = instruction.Operation.Value as IMethodReference;  	Contract.Assume (constructorReference != null);  	//This is an informally specified property of the Metadata model.  	for (var i = constructorReference.ParameterCount; i > 0; i--)  		this.stack.Pop ();  	instruction.Type = constructorReference.ContainingType;  	this.stack.Push (instruction);  	break;  case OperationCode.Refanytype:  	this.stack.Pop ();  	instruction.Type = this.platformType.SystemRuntimeTypeHandle;  	this.stack.Push (instruction);  	break;  case OperationCode.Refanyval:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  case OperationCode.Ret:  	if (this.codeIsUnreachable && this.stack.Top < 0)  		break;  	if (this.cfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		instruction.Operand1 = this.stack.Pop ();  	instruction.Type = this.platformType.SystemVoid;  	break;  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  	this.stack.Pop ();  	this.stack.Pop ();  	Contract.Assume (instruction.Operand1 != null);  	//Assumed because of the informal specification of the DataFlowInferencer  	instruction.Type = instruction.Operand1.Type;  	this.stack.Push (instruction);  	break;  case OperationCode.Sizeof:  	instruction.Type = this.platformType.SystemUInt32;  	this.stack.Push (instruction);  	break;  case OperationCode.Unbox:  	this.stack.Pop ();  	Contract.Assume (instruction.Operation.Value is ITypeReference);  	//This is an informally specified property of the Metadata model.  	instruction.Type = ManagedPointerType.GetManagedPointerType ((ITypeReference)instruction.Operation.Value' this.internFactory);  	this.stack.Push (instruction);  	break;  default:  	instruction.Type = this.platformType.SystemVoid;  	break;  }  
Magic Number,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The following statement contains a magic number: for (var i = arrayType.Rank * 2; i > 0; i--)  	this.stack.Pop ();  
Magic Number,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,InferTypeAndUpdateStack,The following statement contains a magic number: if (TypeHelper.SizeOfType (instruction.Operand1.Type) < 4)  	instruction.Type = this.platformType.SystemFloat32;  else  	instruction.Type = this.platformType.SystemFloat64;  
Missing Default,Microsoft.Cci.Analysis,ControlFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\ControlFlowInferencer.cs,GetInstruction,The following switch statement is missing a default case: switch (ilOperation.OperationCode) {  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	Contract.Assume (ilOperation.Value is uint);  	//This is an informally specified property of the Metadata model.  	var targetOffset = (uint)ilOperation.Value;  	this.blocksThatTarget.Add (targetOffset' currentBlock);  	edges.Add (this.cdfg.BlockFor [targetOffset]);  	break;  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	Contract.Assume (ilOperation.Value is uint);  	//This is an informally specified property of the Metadata model.  	targetOffset = (uint)ilOperation.Value;  	this.blocksThatTarget.Add (targetOffset' currentBlock);  	edges.Add (this.cdfg.BlockFor [targetOffset]);  	isUnconditionalTransfer = true;  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	Contract.Assume (ilOperation.Value is uint);  	//This is an informally specified property of the Metadata model.  	targetOffset = (uint)ilOperation.Value;  	this.blocksThatTarget.Add (targetOffset' currentBlock);  	edges.Add (this.cdfg.BlockFor [targetOffset]);  	break;  case OperationCode.Endfilter:  case OperationCode.Endfinally:  case OperationCode.Jmp:  case OperationCode.Ret:  case OperationCode.Rethrow:  case OperationCode.Throw:  	isUnconditionalTransfer = true;  	break;  case OperationCode.Switch:  	this.AddEdgesForSwitch (ilOperation' currentBlock' edges' instruction);  	break;  }  
Missing Default,Microsoft.Cci.Analysis,DataFlowInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\DataFlowInferencer.cs,SetupDataFlowFor,The following switch statement is missing a default case: switch (instruction.Operation.OperationCode) {  case OperationCode.Add:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.And:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_U4:  case OperationCode.Mul:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Or:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Sub:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Xor:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	this.stack.Push (instruction);  	break;  case OperationCode.Arglist:  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  case OperationCode.Ldsfld:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldsflda:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldftn:  case OperationCode.Ldc_I4:  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  case OperationCode.Ldc_I4_S:  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  case OperationCode.Ldtoken:  case OperationCode.Sizeof:  	this.stack.Push (instruction);  	break;  case OperationCode.Array_Addr:  case OperationCode.Array_Get:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArrayIndexerInstruction (instruction' this.stack' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Array_Create:  case OperationCode.Array_Create_WithLowerBound:  case OperationCode.Newarr:  	InitializeArrayCreateInstruction (instruction' this.stack' instruction.Operation);  	break;  case OperationCode.Array_Set:  	Contract.Assume (instruction.Operation.Value is IArrayTypeReference);  	//This is an informally specified property of the Metadata model.  	InitializeArraySetInstruction (instruction' this.stack' (IArrayTypeReference)instruction.Operation.Value);  	break;  case OperationCode.Beq:  case OperationCode.Beq_S:  case OperationCode.Bge:  case OperationCode.Bge_S:  case OperationCode.Bge_Un:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt:  case OperationCode.Bgt_S:  case OperationCode.Bgt_Un:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble:  case OperationCode.Ble_S:  case OperationCode.Ble_Un:  case OperationCode.Ble_Un_S:  case OperationCode.Blt:  case OperationCode.Blt_S:  case OperationCode.Blt_Un:  case OperationCode.Blt_Un_S:  case OperationCode.Bne_Un:  case OperationCode.Bne_Un_S:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Box:  case OperationCode.Castclass:  case OperationCode.Ckfinite:  case OperationCode.Conv_I:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_R_Un:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U:  case OperationCode.Conv_U1:  case OperationCode.Conv_U2:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  case OperationCode.Isinst:  case OperationCode.Ldind_I:  case OperationCode.Ldind_I1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_U4:  case OperationCode.Ldobj:  case OperationCode.Ldflda:  case OperationCode.Ldfld:  case OperationCode.Ldlen:  case OperationCode.Ldvirtftn:  case OperationCode.Localloc:  case OperationCode.Mkrefany:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Refanytype:  case OperationCode.Refanyval:  case OperationCode.Unbox:  case OperationCode.Unbox_Any:  	instruction.Operand1 = this.stack.Pop ();  	this.stack.Push (instruction);  	break;  case OperationCode.Brfalse:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue:  case OperationCode.Brtrue_S:  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Call:  case OperationCode.Callvirt:  	var signature = instruction.Operation.Value as ISignature;  	Contract.Assume (signature != null);  	//This is an informally specified property of the Metadata model.  	InitializeArgumentsAndPushReturnResult (instruction' this.stack' signature);  	break;  case OperationCode.Calli:  	var funcPointer = instruction.Operation.Value as IFunctionPointerTypeReference;  	Contract.Assume (funcPointer != null);  	//This is an informally specified property of the Metadata model.  	InitializeArgumentsAndPushReturnResult (instruction' this.stack' funcPointer);  	break;  case OperationCode.Cpobj:  case OperationCode.Stfld:  case OperationCode.Stind_I:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Stind_Ref:  case OperationCode.Stobj:  	instruction.Operand2 = this.stack.Pop ();  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  case OperationCode.Stelem:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	var indexAndValue = new Instruction[2];  	indexAndValue [1] = this.stack.Pop ();  	indexAndValue [0] = this.stack.Pop ();  	instruction.Operand2 = indexAndValue;  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Dup:  	var dupop = this.stack.Pop ();  	instruction.Operand1 = dupop;  	this.stack.Push (instruction);  	this.stack.Push (instruction);  	break;  case OperationCode.Endfilter:  case OperationCode.Initobj:  case OperationCode.Pop:  case OperationCode.Starg:  case OperationCode.Starg_S:  case OperationCode.Stloc:  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  case OperationCode.Stloc_S:  case OperationCode.Stsfld:  case OperationCode.Throw:  case OperationCode.Switch:  	instruction.Operand1 = this.stack.Pop ();  	break;  case OperationCode.Leave:  case OperationCode.Leave_S:  	this.stack.Clear ();  	break;  case OperationCode.Newobj:  	Contract.Assume (instruction.Operation.Value is ISignature);  	//This is an informally specified property of the Metadata model.  	signature = (ISignature)instruction.Operation.Value;  	var numArguments = (int)IteratorHelper.EnumerableCount (signature.Parameters);  	if (numArguments > 0) {  		if (numArguments > 1) {  			numArguments--;  			var arguments = new Instruction[numArguments];  			instruction.Operand2 = arguments;  			for (var i = numArguments - 1; i >= 0; i--)  				arguments [i] = stack.Pop ();  		}  		instruction.Operand1 = stack.Pop ();  	}  	this.stack.Push (instruction);  	break;  case OperationCode.Ret:  	if (this.codeIsUnreachable && this.stack.Top < 0)  		break;  	if (this.cdfg.MethodBody.MethodDefinition.Type.TypeCode != PrimitiveTypeCode.Void)  		instruction.Operand1 = this.stack.Pop ();  	break;  }  
Missing Default,Microsoft.Cci.Analysis,TypeInferencer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\ControlAndDataFlowGraph\TypeInferencer.cs,GetBinaryNumericOperationType,The following switch statement is missing a default case: switch (rightTypeCode) {  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  case PrimitiveTypeCode.UInt8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt64:  	//assume that the left operand has an enum type.  	return leftOperand.Type;  }  
