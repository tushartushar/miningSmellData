Implementation smell,Namespace,Class,File,Method,Description
Long Method,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The method has 122 lines of code.
Long Method,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The method has 157 lines of code.
Complex Method,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,Cyclomatic complexity of the method is 29
Complex Method,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,HasBitVectorSort,Cyclomatic complexity of the method is 12
Complex Method,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,Cyclomatic complexity of the method is 102
Complex Method,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,Cyclomatic complexity of the method is 77
Complex Method,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,Cyclomatic complexity of the method is 135
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "	//Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time. " is 144.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "	var operationSize = Math.Max (TypeHelper.SizeOfType (expressionType)' TypeHelper.SizeOfType (operand1.Type)) <= 4 ? 32u : 64u; " is 126.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "	var operationSize = Math.Max (Math.Max (TypeHelper.SizeOfType (expressionType)' TypeHelper.SizeOfType (operand1.Type))' TypeHelper.SizeOfType (operand2.Type)) <= 4 ? 32u : 64u; " is 176.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVAdd (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "			expr = this.solver.MkBVAND (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVSDiv (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 131.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVUDiv (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 131.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVMul (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "			expr = this.solver.MkBVOR (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 129.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVSRem (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 131.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVURem (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 131.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVURem (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 131.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVASHR (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 131.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVLSHR (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 131.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVSub (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "			expr = this.solver.MkBVXOR (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkEq (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 127.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVSGE (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVUGE (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVSGT (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVUGT (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVSLE (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVULE (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVSLT (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkBVULT (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize)); " is 130.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The length of the statement  "		expr = this.solver.MkNot (this.solver.MkEq (this.ConvertToBitVector (operand1' operationSize)' this.ConvertToBitVector (operand2' operationSize))); " is 147.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeImplication,The length of the statement  "	return new ExpressionWrapper (this.solver.MkImplies (operand1.Unwrap<BoolExpr> ()' operand2.Unwrap<BoolExpr> ())' operand1.Type); " is 129.
Long Statement,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,ConvertToBitVector,The length of the statement  "		result = this.solver.MkITE (expr.Unwrap<BoolExpr> ()' this.solver.MkBV (1' 32)' this.solver.MkBV (0' 32)) as BitVecExpr; " is 120.
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: if (result == null) {  	switch (type.TypeCode) {  	case PrimitiveTypeCode.Boolean:  		result = this.solver.BoolSort;  		break;  	case PrimitiveTypeCode.Char:  	case PrimitiveTypeCode.Int16:  	case PrimitiveTypeCode.Int8:  	case PrimitiveTypeCode.UInt16:  	case PrimitiveTypeCode.UInt32:  	case PrimitiveTypeCode.UInt8:  		result = this.GetSortFor (type.PlatformType.SystemInt32);  		break;  	case PrimitiveTypeCode.Int32:  		result = this.solver.MkBitVecSort (32);  		break;  	case PrimitiveTypeCode.UInt64:  		result = this.GetSortFor (type.PlatformType.SystemInt64);  		break;  	case PrimitiveTypeCode.Int64:  		result = this.solver.MkBitVecSort (64);  		break;  	case PrimitiveTypeCode.IntPtr:  	case PrimitiveTypeCode.UIntPtr:  		if (type.PlatformType.PointerSize == 4)  			result = this.GetSortFor (type.PlatformType.SystemInt32);  		else  			result = this.GetSortFor (type.PlatformType.SystemInt64);  		break;  	default:  		result = this.solver.MkUninterpretedSort (TypeHelper.GetTypeName (type));  		break;  	}  	this.typeToSort [key] = result;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: if (result == null) {  	switch (type.TypeCode) {  	case PrimitiveTypeCode.Boolean:  		result = this.solver.BoolSort;  		break;  	case PrimitiveTypeCode.Char:  	case PrimitiveTypeCode.Int16:  	case PrimitiveTypeCode.Int8:  	case PrimitiveTypeCode.UInt16:  	case PrimitiveTypeCode.UInt32:  	case PrimitiveTypeCode.UInt8:  		result = this.GetSortFor (type.PlatformType.SystemInt32);  		break;  	case PrimitiveTypeCode.Int32:  		result = this.solver.MkBitVecSort (32);  		break;  	case PrimitiveTypeCode.UInt64:  		result = this.GetSortFor (type.PlatformType.SystemInt64);  		break;  	case PrimitiveTypeCode.Int64:  		result = this.solver.MkBitVecSort (64);  		break;  	case PrimitiveTypeCode.IntPtr:  	case PrimitiveTypeCode.UIntPtr:  		if (type.PlatformType.PointerSize == 4)  			result = this.GetSortFor (type.PlatformType.SystemInt32);  		else  			result = this.GetSortFor (type.PlatformType.SystemInt64);  		break;  	default:  		result = this.solver.MkUninterpretedSort (TypeHelper.GetTypeName (type));  		break;  	}  	this.typeToSort [key] = result;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: if (result == null) {  	switch (type.TypeCode) {  	case PrimitiveTypeCode.Boolean:  		result = this.solver.BoolSort;  		break;  	case PrimitiveTypeCode.Char:  	case PrimitiveTypeCode.Int16:  	case PrimitiveTypeCode.Int8:  	case PrimitiveTypeCode.UInt16:  	case PrimitiveTypeCode.UInt32:  	case PrimitiveTypeCode.UInt8:  		result = this.GetSortFor (type.PlatformType.SystemInt32);  		break;  	case PrimitiveTypeCode.Int32:  		result = this.solver.MkBitVecSort (32);  		break;  	case PrimitiveTypeCode.UInt64:  		result = this.GetSortFor (type.PlatformType.SystemInt64);  		break;  	case PrimitiveTypeCode.Int64:  		result = this.solver.MkBitVecSort (64);  		break;  	case PrimitiveTypeCode.IntPtr:  	case PrimitiveTypeCode.UIntPtr:  		if (type.PlatformType.PointerSize == 4)  			result = this.GetSortFor (type.PlatformType.SystemInt32);  		else  			result = this.GetSortFor (type.PlatformType.SystemInt64);  		break;  	default:  		result = this.solver.MkUninterpretedSort (TypeHelper.GetTypeName (type));  		break;  	}  	this.typeToSort [key] = result;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  	result = this.solver.BoolSort;  	break;  case PrimitiveTypeCode.Char:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt8:  	result = this.GetSortFor (type.PlatformType.SystemInt32);  	break;  case PrimitiveTypeCode.Int32:  	result = this.solver.MkBitVecSort (32);  	break;  case PrimitiveTypeCode.UInt64:  	result = this.GetSortFor (type.PlatformType.SystemInt64);  	break;  case PrimitiveTypeCode.Int64:  	result = this.solver.MkBitVecSort (64);  	break;  case PrimitiveTypeCode.IntPtr:  case PrimitiveTypeCode.UIntPtr:  	if (type.PlatformType.PointerSize == 4)  		result = this.GetSortFor (type.PlatformType.SystemInt32);  	else  		result = this.GetSortFor (type.PlatformType.SystemInt64);  	break;  default:  	result = this.solver.MkUninterpretedSort (TypeHelper.GetTypeName (type));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  	result = this.solver.BoolSort;  	break;  case PrimitiveTypeCode.Char:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt8:  	result = this.GetSortFor (type.PlatformType.SystemInt32);  	break;  case PrimitiveTypeCode.Int32:  	result = this.solver.MkBitVecSort (32);  	break;  case PrimitiveTypeCode.UInt64:  	result = this.GetSortFor (type.PlatformType.SystemInt64);  	break;  case PrimitiveTypeCode.Int64:  	result = this.solver.MkBitVecSort (64);  	break;  case PrimitiveTypeCode.IntPtr:  case PrimitiveTypeCode.UIntPtr:  	if (type.PlatformType.PointerSize == 4)  		result = this.GetSortFor (type.PlatformType.SystemInt32);  	else  		result = this.GetSortFor (type.PlatformType.SystemInt64);  	break;  default:  	result = this.solver.MkUninterpretedSort (TypeHelper.GetTypeName (type));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Boolean:  	result = this.solver.BoolSort;  	break;  case PrimitiveTypeCode.Char:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt8:  	result = this.GetSortFor (type.PlatformType.SystemInt32);  	break;  case PrimitiveTypeCode.Int32:  	result = this.solver.MkBitVecSort (32);  	break;  case PrimitiveTypeCode.UInt64:  	result = this.GetSortFor (type.PlatformType.SystemInt64);  	break;  case PrimitiveTypeCode.Int64:  	result = this.solver.MkBitVecSort (64);  	break;  case PrimitiveTypeCode.IntPtr:  case PrimitiveTypeCode.UIntPtr:  	if (type.PlatformType.PointerSize == 4)  		result = this.GetSortFor (type.PlatformType.SystemInt32);  	else  		result = this.GetSortFor (type.PlatformType.SystemInt64);  	break;  default:  	result = this.solver.MkUninterpretedSort (TypeHelper.GetTypeName (type));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: result = this.solver.MkBitVecSort (32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: result = this.solver.MkBitVecSort (64);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,GetSortFor,The following statement contains a magic number: if (type.PlatformType.PointerSize == 4)  	result = this.GetSortFor (type.PlatformType.SystemInt32);  else  	result = this.GetSortFor (type.PlatformType.SystemInt64);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  //Instructions that are side effect free and whose results can be cached and reused' but whose result values can never be known at compile time.  case OperationCode.Arglist:  case OperationCode.Ldftn:  case OperationCode.Ldtoken:  case OperationCode.Ldarga:  case OperationCode.Ldarga_S:  case OperationCode.Ldloca:  case OperationCode.Ldloca_S:  case OperationCode.Ldsflda:  	goto default;  //Instructions that transfer control to a successor block.  case OperationCode.Br:  case OperationCode.Br_S:  case OperationCode.Leave:  case OperationCode.Leave_S:  	goto default;  //Instructions that are side-effect free and that result in compile time constant values.  case OperationCode.Ldc_I4:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I4_0:  	expr = this.solver.MkBV (0' 32);  	break;  case OperationCode.Ldc_I4_1:  	expr = this.solver.MkBV (1' 32);  	break;  case OperationCode.Ldc_I4_2:  	expr = this.solver.MkBV (2' 32);  	break;  case OperationCode.Ldc_I4_3:  	expr = this.solver.MkBV (3' 32);  	break;  case OperationCode.Ldc_I4_4:  	expr = this.solver.MkBV (4' 32);  	break;  case OperationCode.Ldc_I4_5:  	expr = this.solver.MkBV (5' 32);  	break;  case OperationCode.Ldc_I4_6:  	expr = this.solver.MkBV (6' 32);  	break;  case OperationCode.Ldc_I4_7:  	expr = this.solver.MkBV (7' 32);  	break;  case OperationCode.Ldc_I4_8:  	expr = this.solver.MkBV (8' 32);  	break;  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBV (-1' 32);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBV ((int)operation.Value' 32);  	break;  case OperationCode.Ldc_I8:  	expr = this.solver.MkBV ((long)operation.Value' 64);  	break;  case OperationCode.Ldc_R4:  case OperationCode.Ldc_R8:  case OperationCode.Ldnull:  case OperationCode.Ldstr:  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  //We attempt to compute the compile time values.  case OperationCode.Ldarg:  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  case OperationCode.Ldarg_S:  case OperationCode.Ldloc:  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  case OperationCode.Ldloc_S:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		expr = this.GetVariableFor (operation.Value as INamedEntity' expressionType);  		break;  	}  	goto default;  //Instructions that are side-effect free and that *could* result in compile time constant values.  case OperationCode.Ldsfld:  	goto default;  case OperationCode.Call:  case OperationCode.Endfinally:  case OperationCode.Newobj:  case OperationCode.Nop:  	goto default;  default:  	expr = this.solver.MkConst (operation.ToString ()' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV ((int)operation.Value' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (0' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (1' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (2' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (2' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (3' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (3' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (4' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (4' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (5' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (5' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (6' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (6' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (7' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (7' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (8' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (8' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV (-1' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV ((int)operation.Value' 32);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkBV ((long)operation.Value' 64);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: switch (operation.OperationCode) {  case OperationCode.Conv_I1:  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_I1_Un:  	expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I2:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_I2_Un:  	expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_I4:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_I4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_I8:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_I8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_R4:  	goto default;  case OperationCode.Conv_R8:  	goto default;  case OperationCode.Conv_U1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_U1_Un:  	expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_U2_Un:  	expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  	break;  case OperationCode.Conv_U4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_U4_Un:  	expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Conv_U8:  case OperationCode.Conv_Ovf_U8:  case OperationCode.Conv_Ovf_U8_Un:  	if (TypeHelper.SizeOfType (operand1.Type) == 8)  		expr = this.ConvertToBitVector (operand1' 64);  	else  		expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  	break;  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_I_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_I8;  	else  		goto case OperationCode.Conv_I4;  case OperationCode.Conv_U:  case OperationCode.Conv_Ovf_U:  case OperationCode.Conv_Ovf_U_Un:  	if (expressionType.PlatformType.PointerSize == 8)  		goto case OperationCode.Conv_U8;  	else  		goto case OperationCode.Conv_U4;  case OperationCode.Conv_R_Un:  	goto default;  case OperationCode.Dup:  	return operand1;  case OperationCode.Neg:  	expr = this.solver.MkBVNeg (this.ConvertToBitVector (operand1' operationSize));  	break;  case OperationCode.Nop:  	var v = operation.Value as INamedEntity;  	if (v != null && !(v.Name is Dummy)) {  		//phi node  		expr = this.GetVariableFor (v' expressionType);  		break;  	}  	goto default;  case OperationCode.Not:  	if (operand1.Type.TypeCode == PrimitiveTypeCode.Boolean)  		expr = this.solver.MkNot (operand1.Unwrap<BoolExpr> ());  	else  		expr = this.solver.MkBVNot (this.ConvertToBitVector (operand1' operationSize));  	break;  default:  	var hashCode = operation.GetHashCode ();  	if (operation is Dummy)  		hashCode = new object ().GetHashCode ();  	expr = this.solver.MkConst ("unary" + hashCode' this.GetSortFor (expressionType));  	break;  }  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkSignExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkSignExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 8)  	expr = this.ConvertToBitVector (operand1' 64);  else  	expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 8)  	expr = this.ConvertToBitVector (operand1' 64);  else  	expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 8)  	expr = this.ConvertToBitVector (operand1' 64);  else  	expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.ConvertToBitVector (operand1' 64);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkSignExt (32' this.ConvertToBitVector (operand1' operationSize));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkZeroExt (24' this.solver.MkExtract (7' 0' this.ConvertToBitVector (operand1' operationSize)));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkZeroExt (16' this.solver.MkExtract (16' 0' this.ConvertToBitVector (operand1' operationSize)));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkExtract (32' 0' this.ConvertToBitVector (operand1' operationSize));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 8)  	expr = this.ConvertToBitVector (operand1' 64);  else  	expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 8)  	expr = this.ConvertToBitVector (operand1' 64);  else  	expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 8)  	expr = this.ConvertToBitVector (operand1' 64);  else  	expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (TypeHelper.SizeOfType (operand1.Type) == 8)  	expr = this.ConvertToBitVector (operand1' 64);  else  	expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.ConvertToBitVector (operand1' 64);  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: expr = this.solver.MkZeroExt (32' this.ConvertToBitVector (operand1' 32));  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (expressionType.PlatformType.PointerSize == 8)  	goto case OperationCode.Conv_I8;  else  	goto case OperationCode.Conv_I4;  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following statement contains a magic number: if (expressionType.PlatformType.PointerSize == 8)  	goto case OperationCode.Conv_U8;  else  	goto case OperationCode.Conv_U4;  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,ConvertToBitVector,The following statement contains a magic number: if (expr.Type.TypeCode == PrimitiveTypeCode.Boolean)  	result = this.solver.MkITE (expr.Unwrap<BoolExpr> ()' this.solver.MkBV (1' 32)' this.solver.MkBV (0' 32)) as BitVecExpr;  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,ConvertToBitVector,The following statement contains a magic number: if (expr.Type.TypeCode == PrimitiveTypeCode.Boolean)  	result = this.solver.MkITE (expr.Unwrap<BoolExpr> ()' this.solver.MkBV (1' 32)' this.solver.MkBV (0' 32)) as BitVecExpr;  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,ConvertToBitVector,The following statement contains a magic number: result = this.solver.MkITE (expr.Unwrap<BoolExpr> ()' this.solver.MkBV (1' 32)' this.solver.MkBV (0' 32)) as BitVecExpr;  
Magic Number,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,ConvertToBitVector,The following statement contains a magic number: result = this.solver.MkITE (expr.Unwrap<BoolExpr> ()' this.solver.MkBV (1' 32)' this.solver.MkBV (0' 32)) as BitVecExpr;  
Missing Default,Z3Wrapper,Wrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,MakeExpression,The following switch statement is missing a default case: switch (operation.OperationCode) {  case OperationCode.Ldc_I4:  	expr = this.solver.MkBool (((int)operation.Value) != 0);  	break;  case OperationCode.Ldc_I4_0:  case OperationCode.Ldc_I4_1:  case OperationCode.Ldc_I4_2:  case OperationCode.Ldc_I4_3:  case OperationCode.Ldc_I4_4:  case OperationCode.Ldc_I4_5:  case OperationCode.Ldc_I4_6:  case OperationCode.Ldc_I4_7:  case OperationCode.Ldc_I4_8:  case OperationCode.Ldc_I4_M1:  	expr = this.solver.MkBool (true);  	break;  case OperationCode.Ldc_I4_S:  	expr = this.solver.MkBool (((int)operation.Value) != 0);  	break;  }  
Missing Default,Z3Wrapper,ContextWrapper,C:\repos\FlorianGrimm_whid\other\ccimetadata\Samples\Z3Wrapper\Wrapper.cs,Check,The following switch statement is missing a default case: switch (this.solverContext.Check ()) {  case Status.SATISFIABLE:  	return true;  case Status.UNSATISFIABLE:  	return false;  }  
