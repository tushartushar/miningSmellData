Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Observable.Extensions.cs,Subscribe,The method has 5 parameters.
Long Parameter List,System.Reactive.Concurrency,SynchronizationContextScheduler,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Concurrency\SynchronizationContextScheduler.cs,Schedule,The method has 5 parameters.
Long Statement,System.Reactive.PlatformServices,SystemClock,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\SystemClock.cs,InitializeSystemClockChanged,The length of the statement  "	return PlatformEnlightenmentProvider.Current.GetService<INotifySystemClockChanged> () ?? new DefaultSystemClockMonitor (); " is 122.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System.Reactive,Observer,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Observer.Extensions.cs,ToObserver,The length of the statement  "	return new AnonymousObserver<T> (x => handler (Notification.CreateOnNext<T> (x))' exception => handler (Notification.CreateOnError<T> (exception))' () => handler (Notification.CreateOnCompleted<T> ())); " is 202.
Long Statement,System.Reactive.Concurrency,ConcurrencyAbstractionLayer,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Concurrency\ConcurrencyAbstractionLayer.cs,Initialize,The length of the statement  "	return PlatformEnlightenmentProvider.Current.GetService<IConcurrencyAbstractionLayer> () ?? new DefaultConcurrencyAbstractionLayer (); " is 134.
Long Statement,System.Reactive.Concurrency,LocalScheduler,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Concurrency\LocalScheduler.TimerQueue.cs,UpdateLongTermProcessingTimer,The length of the statement  "		s_nextLongTermTimer.Disposable = ConcurrencyAbstractionLayer.Current.StartTimer (EvaluateLongTermQueue' null' dueCapped); " is 121.
Long Statement,System.Reactive.Concurrency,Synchronization,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Concurrency\Synchronization.cs,ObserveOn,The length of the statement  "	            return new AnonymousObservable<TSource>(observer => source.Subscribe(new ObserveOnObserver<TSource>(scheduler' observer' null)));" is 129.
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\PriorityQueue.cs,RemoveAt,The following statement contains a magic number: if (_size < _items.Length / 4) {  	var temp = _items;  	_items = new IndexedItem[_items.Length / 2];  	Array.Copy (temp' 0' _items' 0' _size);  }  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\PriorityQueue.cs,RemoveAt,The following statement contains a magic number: if (_size < _items.Length / 4) {  	var temp = _items;  	_items = new IndexedItem[_items.Length / 2];  	Array.Copy (temp' 0' _items' 0' _size);  }  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\PriorityQueue.cs,RemoveAt,The following statement contains a magic number: _items = new IndexedItem[_items.Length / 2];  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\PriorityQueue.cs,Enqueue,The following statement contains a magic number: if (_size >= _items.Length) {  	var temp = _items;  	_items = new IndexedItem[_items.Length * 2];  	Array.Copy (temp' _items' temp.Length);  }  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\PriorityQueue.cs,Enqueue,The following statement contains a magic number: _items = new IndexedItem[_items.Length * 2];  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\ScheduledObserver.cs,EnsureDispatcher,The following statement contains a magic number: if (_dispatcherJob == null) {  	lock (_dispatcherInitGate) {  		if (_dispatcherJob == null) {  			_dispatcherJob = _longRunning.ScheduleLongRunning (Dispatch);  			_disposable.Disposable = new CompositeDisposable (2) {  				_dispatcherJob'  				Disposable.Create (() => _dispatcherEvent.Release ())  			};  		}  	}  }  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\ScheduledObserver.cs,EnsureDispatcher,The following statement contains a magic number: lock (_dispatcherInitGate) {  	if (_dispatcherJob == null) {  		_dispatcherJob = _longRunning.ScheduleLongRunning (Dispatch);  		_disposable.Disposable = new CompositeDisposable (2) {  			_dispatcherJob'  			Disposable.Create (() => _dispatcherEvent.Release ())  		};  	}  }  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\ScheduledObserver.cs,EnsureDispatcher,The following statement contains a magic number: if (_dispatcherJob == null) {  	_dispatcherJob = _longRunning.ScheduleLongRunning (Dispatch);  	_disposable.Disposable = new CompositeDisposable (2) {  		_dispatcherJob'  		Disposable.Create (() => _dispatcherEvent.Release ())  	};  }  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\ScheduledObserver.cs,EnsureDispatcher,The following statement contains a magic number: _disposable.Disposable = new CompositeDisposable (2) {  	_dispatcherJob'  	Disposable.Create (() => _dispatcherEvent.Release ())  };  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\ScheduledObserver.cs,Run,The following statement contains a magic number: try {  	_observer.OnNext (next);  }  catch {  	#pragma  	Interlocked.Exchange (ref _state' FAULTED);  	#pragma  	var nop = default(T);  	while (_queue.TryDequeue (out nop))  		;  	throw;  }  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\ScheduledObserver.cs,Run,The following statement contains a magic number: try {  	_observer.OnNext (next);  }  catch {  	#pragma  	Interlocked.Exchange (ref _state' FAULTED);  	#pragma  	var nop = default(T);  	while (_queue.TryDequeue (out nop))  		;  	throw;  }  
Magic Number,System.Reactive.Concurrency,CurrentThreadScheduler,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Concurrency\CurrentThreadScheduler.cs,Schedule,The following statement contains a magic number: if (queue == null) {  	queue = new SchedulerQueue<TimeSpan> (4);  	queue.Enqueue (si);  	CurrentThreadScheduler.SetQueue (queue);  	try {  		Trampoline.Run (queue);  	}  	finally {  		CurrentThreadScheduler.SetQueue (null);  	}  }  else {  	queue.Enqueue (si);  }  
Magic Number,System.Reactive.Concurrency,CurrentThreadScheduler,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Concurrency\CurrentThreadScheduler.cs,Schedule,The following statement contains a magic number: queue = new SchedulerQueue<TimeSpan> (4);  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: lock (_gate) {  	if (!_disposed) {  		//  		// List<T> doesn't shrink the size of the underlying array but does collapse the array  		// by copying the tail one position to the left of the removal index. We don't need  		// index-based lookup but only ordering for sequential disposal. So' instead of spending  		// cycles on the Array.Copy imposed by Remove' we use a null sentinel value. We also  		// do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.  		//  		var i = _disposables.IndexOf (item);  		if (i >= 0) {  			shouldDispose = true;  			_disposables [i] = null;  			_count--;  			if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  				var old = _disposables;  				_disposables = new List<IDisposable> (_disposables.Capacity / 2);  				foreach (var d in old)  					if (d != null)  						_disposables.Add (d);  			}  		}  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: lock (_gate) {  	if (!_disposed) {  		//  		// List<T> doesn't shrink the size of the underlying array but does collapse the array  		// by copying the tail one position to the left of the removal index. We don't need  		// index-based lookup but only ordering for sequential disposal. So' instead of spending  		// cycles on the Array.Copy imposed by Remove' we use a null sentinel value. We also  		// do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.  		//  		var i = _disposables.IndexOf (item);  		if (i >= 0) {  			shouldDispose = true;  			_disposables [i] = null;  			_count--;  			if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  				var old = _disposables;  				_disposables = new List<IDisposable> (_disposables.Capacity / 2);  				foreach (var d in old)  					if (d != null)  						_disposables.Add (d);  			}  		}  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (!_disposed) {  	//  	// List<T> doesn't shrink the size of the underlying array but does collapse the array  	// by copying the tail one position to the left of the removal index. We don't need  	// index-based lookup but only ordering for sequential disposal. So' instead of spending  	// cycles on the Array.Copy imposed by Remove' we use a null sentinel value. We also  	// do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.  	//  	var i = _disposables.IndexOf (item);  	if (i >= 0) {  		shouldDispose = true;  		_disposables [i] = null;  		_count--;  		if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  			var old = _disposables;  			_disposables = new List<IDisposable> (_disposables.Capacity / 2);  			foreach (var d in old)  				if (d != null)  					_disposables.Add (d);  		}  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (!_disposed) {  	//  	// List<T> doesn't shrink the size of the underlying array but does collapse the array  	// by copying the tail one position to the left of the removal index. We don't need  	// index-based lookup but only ordering for sequential disposal. So' instead of spending  	// cycles on the Array.Copy imposed by Remove' we use a null sentinel value. We also  	// do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.  	//  	var i = _disposables.IndexOf (item);  	if (i >= 0) {  		shouldDispose = true;  		_disposables [i] = null;  		_count--;  		if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  			var old = _disposables;  			_disposables = new List<IDisposable> (_disposables.Capacity / 2);  			foreach (var d in old)  				if (d != null)  					_disposables.Add (d);  		}  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (i >= 0) {  	shouldDispose = true;  	_disposables [i] = null;  	_count--;  	if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  		var old = _disposables;  		_disposables = new List<IDisposable> (_disposables.Capacity / 2);  		foreach (var d in old)  			if (d != null)  				_disposables.Add (d);  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (i >= 0) {  	shouldDispose = true;  	_disposables [i] = null;  	_count--;  	if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  		var old = _disposables;  		_disposables = new List<IDisposable> (_disposables.Capacity / 2);  		foreach (var d in old)  			if (d != null)  				_disposables.Add (d);  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  	var old = _disposables;  	_disposables = new List<IDisposable> (_disposables.Capacity / 2);  	foreach (var d in old)  		if (d != null)  			_disposables.Add (d);  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  	var old = _disposables;  	_disposables = new List<IDisposable> (_disposables.Capacity / 2);  	foreach (var d in old)  		if (d != null)  			_disposables.Add (d);  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: _disposables = new List<IDisposable> (_disposables.Capacity / 2);  
Missing Default,System.Reactive,CheckedObserver,C:\repos\FlorianGrimm_whid\other\rx\Rx\NET\Source\System.Reactive.Core\Reactive\Internal\CheckedObserver.cs,CheckAccess,The following switch statement is missing a default case: switch (Interlocked.CompareExchange (ref _state' BUSY' IDLE)) {  case BUSY:  	throw new InvalidOperationException (Strings_Core.REENTRANCY_DETECTED);  case DONE:  	throw new InvalidOperationException (Strings_Core.OBSERVER_TERMINATED);  }  
