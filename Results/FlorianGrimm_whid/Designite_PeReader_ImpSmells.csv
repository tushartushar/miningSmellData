Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci.MetadataReader,CoreTypes,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\CoreTypes.cs,CoreTypes,The method has 170 lines of code.
Long Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The method has 121 lines of code.
Long Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The method has 108 lines of code.
Long Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeReference,The method has 105 lines of code.
Long Method,Microsoft.Cci.MetadataReader,TypeSpecSignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,TypeSpecSignatureConverter,The method has 121 lines of code.
Long Method,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Redirect,The method has 125 lines of code.
Long Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The method has 480 lines of code.
Long Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The method has 104 lines of code.
Long Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The method has 231 lines of code.
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,NextToken,Cyclomatic complexity of the method is 39
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ParseFullName,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ParseAssemblyName,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithPrimitiveType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,ToString,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetFieldOrPropType,Cyclomatic complexity of the method is 23
Complex Method,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,Cyclomatic complexity of the method is 43
Complex Method,Microsoft.Cci.MetadataReader,CustomAttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,CustomAttributeDecoder,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSecurityAttribute,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.MetadataReader,CoreTypes,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\CoreTypes.cs,CoreTypes,Cyclomatic complexity of the method is 60
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetUninterpretedPESections,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetWin32Resources,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadTypesInNamespace,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeReferenceForToken,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,ResolveModuleTypeRefReference,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetReferenceToAliasedType,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadNestedTypesOfType,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadMembersOf_Module_Type,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetFieldMapping,Cyclomatic complexity of the method is 28
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetFieldSizeIfPossibleToDoSoWithoutResolving,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetDefaultValue,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMarshallingInformation,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,Cyclomatic complexity of the method is 29
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMethodReferenceForToken,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetReferenceForToken,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeReference,Cyclomatic complexity of the method is 42
Complex Method,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleParameters,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.MetadataReader,MethodDefSignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,MethodDefSignatureConverter,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Cci.MetadataReader,TypeSpecSignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,TypeSpecSignatureConverter,Cyclomatic complexity of the method is 85
Complex Method,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Redirect,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Redirect,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Rewrite,Cyclomatic complexity of the method is 40
Complex Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,Cyclomatic complexity of the method is 371
Complex Method,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,Cyclomatic complexity of the method is 94
Complex Method,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Cci.MetadataReader.PEFile,HasCustomAttributeTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToTag,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadPEFileLevelData,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheStreams,Cyclomatic complexity of the method is 36
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,Cyclomatic complexity of the method is 8
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FieldOrPropertyNamedArgumentExpression,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,FieldOrPropertyNamedArgumentExpression,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,CustomAttribute,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,CustomAttribute,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Module,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,Module,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Assembly,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,Assembly,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FieldDefinition,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,FieldDefinition,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalFieldDefinition,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,GlobalFieldDefinition,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodDefinition,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,MethodDefinition,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericMethod,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,NonGenericMethod,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalNonGenericMethod,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,GlobalNonGenericMethod,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethod,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,GenericMethod,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GlobalGenericMethod,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,GlobalGenericMethod,The method has 10 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,EventDefinition,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,EventDefinition,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,PropertyDefinition,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,PropertyDefinition,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,MethodReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Win32Resource,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,Win32Resource,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ResourceReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,ResourceReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Resource,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,Resource,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,CoreTypeReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,CoreTypeReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeRefReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,TypeRefReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NamespaceTypeRefReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeRefReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NonGenericNamespaceTypeRefReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNamespaceTypeRefReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GenericNamespaceTypeRefReference,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReferenceWithoutPrimitiveTypeCode,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NamespaceTypeRefReferenceWithoutPrimitiveTypeCode,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeRefReferenceWithPrimitiveTypeCode,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NamespaceTypeRefReferenceWithPrimitiveTypeCode,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedTypeRefReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NestedTypeRefReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNestedTypeRefReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NonGenericNestedTypeRefReference,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedTypeRefReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GenericNestedTypeRefReference,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NamespaceType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NonGenericNamespaceType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithoutPrimitiveType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NonGenericNamespaceTypeWithoutPrimitiveType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,_Module_Type,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,_Module_Type,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithPrimitiveType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NonGenericNamespaceTypeWithPrimitiveType,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNamespaceType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GenericNamespaceType,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NestedType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNestedType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NonGenericNestedType,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GenericNestedType,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericParameter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GenericParameter,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeParameter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GenericTypeParameter,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericMethodParameter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GenericMethodParameter,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MatrixWithToken,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,MatrixWithToken,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,FunctionPointerTypeWithToken,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,FunctionPointerTypeWithToken,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,Parameter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,Parameter,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterInfo,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,ParameterInfo,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterWithMetadata,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,ParameterWithMetadata,The method has 10 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ParameterWithoutMetadata,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,ParameterWithoutMetadata,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,CreateCoreTypeReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,PEFileToObjectModel,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,WindowsRuntimeMetadataReaderHost,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.MethodBody,LocalVariableDefinition,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,LocalVariableDefinition,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.MethodBody,CilExceptionInformation,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CilExceptionInformation,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,BinarySearchForSlot,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,BinarySearchReference,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ModuleRow,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ModuleRow,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,TypeDefRow,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,TypeDefRow,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodRow,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,MethodRow,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,AssemblyRow,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,AssemblyRow,The method has 9 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefRow,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,AssemblyRefRow,The method has 9 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeRow,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ExportedTypeRow,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,SEHTableEntry,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,SEHTableEntry,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodIL,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,MethodIL,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,TypeDefTableReader,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodTableReader,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MemberRefTableReader,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,CustomAttributeTableReader,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ImplMapTableReader,The method has 5 parameters.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedNamespaceReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,NestedNamespaceReference,The length of the parameter parentModuleNamespaceReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,SafeArrayMarshallingInformation,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,SafeArrayMarshallingInformation,The length of the parameter safeArrayElementUserDefinedSubType is 34.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeNameNamespaceReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NestedNamespaceTypeNameNamespaceReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,NestedNamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.ObjectModelImplementation,RootNamespaceTypeNameNamespaceReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,RootNamespaceTypeNameNamespaceReference,The length of the parameter namespaceTypeNameTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the parameter genericParamConstraintRowIdStart is 32.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the parameter genericParamConstraintRowIdEnd is 30.
Long Identifier,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the parameter specializedNestedTypeReference is 30.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_01010101010101010101010101010101 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00110011001100110011001100110011 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00001111000011110000111100001111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00000000111111110000000011111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_00000000000000001111111111111111 is 37.
Long Identifier,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The length of the parameter MASK_11111111111111111111111111111111 is 37.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetAsNomimalType,The length of the statement  "	var redirectedTypeRef = peFileToObjectModel.ModuleReader.metadataReaderHost.Redirect (peFileToObjectModel.Module' typeRef) as INamespaceTypeReference; " is 150.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetAsNomimalType,The length of the statement  "		var namespaceName = this.GetNamespaceName (peFileToObjectModel.NameTable' redirectedTypeRef.ContainingUnitNamespace as INestedUnitNamespaceReference); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetAsNomimalType,The length of the statement  "			mangledName = peFileToObjectModel.NameTable.GetNameFor (redirectedTypeRef.Name.Value + "`" + redirectedTypeRef.GenericParameterCount); " is 134.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetAsNomimalType,The length of the statement  "		var redirectedNamespaceTypeName = new NamespaceTypeName (peFileToObjectModel.NameTable' namespaceName' mangledName' redirectedTypeRef.Name); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetNamespaceName,The length of the statement  "	var parentNamespaceName = this.GetNamespaceName (nameTable' nestedUnitNamespaceReference.ContainingUnitNamespace as INestedUnitNamespaceReference); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetSpecializedTypeReference,The length of the statement  "		var parentTemplate = this.GetSpecializedTypeReference (peFileToObjectModel' (INamedTypeReference)nestedType.ContainingType' out argumentUsed' mostNested: false); " is 161.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetSpecializedTypeReference,The length of the statement  "		genericArgumentsReferences [i] = this.GenericArguments [i + argumentUsed].GetAsTypeReference (peFileToObjectModel' peFileToObjectModel.Module) ?? Dummy.TypeReference; " is 166.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetSpecializedTypeReference,The length of the statement  "	return new GenericTypeInstanceReference (nominalType' IteratorHelper.GetReadonly (genericArgumentsReferences)' peFileToObjectModel.InternFactory); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,AssemblyQualifiedTypeName,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetAsTypeReference,The length of the statement  "	return this.TypeName.GetAsTypeReference (peFileToObjectModel' new AssemblyReference (peFileToObjectModel' 0' this.AssemblyIdentity' flags)); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The length of the statement  "	if (currPtr + 3 <= this.Length && string.Compare (name' currPtr' "yes"' 0' 3' StringComparison.OrdinalIgnoreCase) == 0) { " is 121.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The length of the statement  "	if (currPtr + 2 <= this.Length && string.Compare (name' currPtr' "no"' 0' 2' StringComparison.OrdinalIgnoreCase) == 0) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The length of the statement  "	if (currPtr + 4 <= this.Length && string.Compare (name' currPtr' "null"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0) { " is 122.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The length of the statement  "		result = ulong.Parse (val' System.Globalization.NumberStyles.HexNumber' System.Globalization.CultureInfo.InvariantCulture); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ParseAssemblyName,The length of the statement  "			while (this.CurrentTypeNameTokenKind != TypeNameTokenKind.Comma && this.CurrentTypeNameTokenKind != TypeNameTokenKind.CloseBracket && this.CurrentTypeNameTokenKind != TypeNameTokenKind.EOS) { " is 191.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MetadataObject,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,GetAttributes,The length of the statement  "		attributes [i] = this.PEFileToObjectModel.GetCustomAttributeAtRow (this' this.TokenValue' customAttributeRowIdStart + i); " is 121.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ScopedContainerMetadataObject,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,GetMatchingMembersNamed,The length of the statement  "	MultiHashtable<InternalMemberType> hashTable = ignoreCase ? this.caseInsensitiveMemberHashTable : this.caseSensitiveMemberHashTable; " is 132.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,ScopedContainerMetadataObject,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,GetMembersNamed,The length of the statement  "	MultiHashtable<InternalMemberType> hashTable = ignoreCase ? this.caseInsensitiveMemberHashTable : this.caseSensitiveMemberHashTable; " is 132.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodDefinition,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.Signature | NameFormattingOptions.TypeParameters); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,MethodReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\BinaryObjectModel.cs,ToString,The length of the statement  "	return MemberHelper.GetMethodSignature (this' NameFormattingOptions.ReturnType | NameFormattingOptions.TypeParameters | NameFormattingOptions.Signature); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NamespaceTypeNameTypeReference,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,Resolve,The length of the statement  "		var retModuleType = assemblyPEFileToObjectModel.ResolveNamespaceTypeDefinition (this.NamespaceFullName' this.MangledTypeName); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GetSpecializedTypeReference,The length of the statement  "		var parentTemplate = this.GetSpecializedTypeReference ((INamedTypeReference)nestedType.ContainingType' out argumentsUsed' outer: false); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GetSpecializedTypeReference,The length of the statement  "		genericArgumentsReferences [i] = this.GetGenericTypeParameterFromOrdinal ((ushort)(i + argumentsUsed)) ?? Dummy.TypeReference; " is 126.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,GenericNestedType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,GetSpecializedTypeReference,The length of the statement  "	return new GenericTypeInstanceReference (nominalType' IteratorHelper.GetReadonly (genericArgumentsReferences)' this.PEFileToObjectModel.InternFactory); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,CreateCoreTypeReference,The length of the statement  "	return new CoreTypeReference (this.PEFileToObjectModel' coreAssemblyReference' namespaceReference' typeName' 0' signatureTypeCode); " is 131.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,CreateCoreTypeReference,The length of the statement  "	return new CoreTypeReference (this.PEFileToObjectModel' coreAssemblyReference' namespaceReference' typeName' genericParameterCount' signatureTypeCode); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,SplitMangledTypeName,The length of the statement  "          genericParamCount = ushort.Parse(mangledTypeName.Substring(index + 1' mangledTypeName.Length - index - 1)' System.Globalization.NumberStyles.Integer'" is 149.
Long Statement,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeCache,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,SplitMangledTypeName,The length of the statement  "	ushort.TryParse (mangledTypeName.Substring (index + 1' mangledTypeName.Length - index - 1)' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture' out genericParamCount); " is 209.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "			return new TypeOfExpression (this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeNameStr)); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "			return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression)); " is 139.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "			// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value " is 125.
Long Statement,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The length of the statement  "			switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) { " is 127.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "		foreach (ITypeDefinitionMember member in attributeType.GetMembersNamed (this.PEFileToObjectModel.NameTable.Ctor' false)) { " is 122.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "		ctorReference = new MethodReference (this.PEFileToObjectModel.ModuleReader.metadataReaderHost' moduleTypeReference' CallingConvention.Default | CallingConvention.HasThis' this.PEFileToObjectModel.PlatformType.SystemVoid' this.PEFileToObjectModel.NameTable.Ctor' 0' this.PEFileToObjectModel.PlatformType.SystemSecurityPermissionsSecurityAction); " is 344.
Long Statement,Microsoft.Cci.MetadataReader,SecurityAttributeDecoder20,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSecurityAttribute,The length of the statement  "			namedArgumentArray [i] = new FieldOrPropertyNamedArgumentExpression (memberName' moduleTypeReference' isField' memberType' value); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,MethodBodyDocument,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,GetTypeFromToken,The length of the statement  "	ITypeReference /*?*/result = this.method.PEFileToObjectModel.GetTypeReferenceFromStandaloneSignatureToken (this.method' standAloneSignatureToken); " is 146.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "			//Look for a lot of different mscorlib types' since an assembly need not reference System.Object or any particular type. " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "			if (tKey != objectKey && tKey != valueTypeKey && tKey != enumKey && tKey != multicastDelegateKey && tKey != arrayKey && tKey != attributeKey && tKey != delegateKey && tKey != iAsyncResultKey && tKey != iCloneableKey && tKey != asyncCallbackKey && tKey != attributeUsageAttributeKey && tKey != paramArrayAttributeKey && tKey != booleanKey && tKey != byteKey && tKey != charKey && tKey != sByteKey && tKey != int16Key && tKey != uint16Key && tKey != int32Key && tKey != uint32Key && tKey != int64Key && tKey != uint64Key && tKey != stringKey && tKey != intPtrKey && tKey != uintPtrKey && tKey != singleKey && tKey != doubleKey && tKey != typedReferenceKey && tKey != typeKey && tKey != dateTimeKey && tKey != decimalKey && tKey != dbNullKey && tKey != runtimeArgumentHandleKey && tKey != runtimeFieldHandleKey && tKey != runtimeMethodHandleKey && tKey != runtimeTypeHandleKey && tKey != argIteratorKey && tKey != voidKey) " is 919.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The length of the statement  "			//Just because this reference looks like a mscorlib type' does not mean that it actually is one. Badly behaved assemblies might reuse mscorlib names. " is 149.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The length of the statement  "		Version version = new Version (assemblyRefRow.MajorVersion' assemblyRefRow.MinorVersion' assemblyRefRow.BuildNumber' assemblyRefRow.RevisionNumber); " is 148.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The length of the statement  "		AssemblyIdentity assemblyIdentity = new AssemblyIdentity (assemblyRefName' cultureName.Value' version' publicKeyTokenArray' string.Empty); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadModuleReferences,The length of the statement  "		ModuleIdentity probedModuleIdentity = this.ModuleReader.metadataReaderHost.ProbeModuleReference (this.Module' moduleIdentity); " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadModuleReferences,The length of the statement  "		uint internedModuleId = (uint)this.ModuleReader.metadataReaderHost.InternFactory.GetModuleInternedKey (probedModuleIdentity); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetAssemblyReferences,The length of the statement  "		this.AssemblyReferences = this.ModuleReader.metadataReaderHost.Redirect (this.Module' IteratorHelper.GetReadonly (arefArray)); " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,FindAssemblyReference,The length of the statement  "	uint assemblyInternedId = (uint)this.ModuleReader.metadataReaderHost.InternFactory.GetAssemblyInternedKey (assemblyIdentity); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,FindAssemblyReference,The length of the statement  "		uint refInternedId = (uint)this.ModuleReader.metadataReaderHost.InternFactory.GetAssemblyInternedKey (assemblyRef.AssemblyIdentity); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetWin32Resources,The length of the statement  "				yield return new Win32Resource (this' typeIdOrName' idOrName' langIdOrName' resourceData.RVAToData' (uint)resourceData.Size' (uint)resourceData.CodePage); " is 154.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,ResolveResource,The length of the statement  "		return new Resource (this' resourceReference.ResourceRowId' resourceReference.Name' resRow.Flags' (resRow.Implementation & TokenTypeIds.RIDMask) != 0); " is 151.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetResourceData,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument (this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value); " is 215.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetResourceData,The length of the statement  "		return new EnumerableMemoryBlockWrapper (this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt (resOffset + sizeof(Int32)' len)); " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetEntryPointMethod,The length of the statement  "		FileReference /*?*/file = this.GetFileReferenceAt (this.PEFileReader.COR20Header.EntryPointTokenOrRVA & TokenTypeIds.RIDMask); " is 126.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetNamespaceForString,The length of the statement  "		NestedNamespace nestedNamespace = new NestedNamespace (this' iNamespaceFullName' iNamespaceFullName' this.RootModuleNamespace); " is 127.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "	NamespaceReference /*?*/retNamespaceReference = this.NamespaceReferenceINameHashtable.Find (moduleReference.InternedModuleId' (uint)iNamespaceFullName.UniqueKey); " is 162.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "		retNamespaceReference = new NestedNamespaceReference (this' iNamespaceName' iNamespaceFullName' parentNamespaceReference); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetNamespaceReferenceForString,The length of the statement  "	this.NamespaceReferenceINameHashtable.Add (moduleReference.InternedModuleId' (uint)iNamespaceFullName.UniqueKey' retNamespaceReference); " is 136.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,PreLoadTypeDefTableLookup,The length of the statement  "		this.NestedTypeTokenTable.Add (TokenTypeIds.TypeDef | nestedClassRow.EnclosingClass' (uint)typeName.UniqueKey' TokenTypeIds.TypeDef | nestedClassRow.NestedClass); " is 162.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,PreLoadTypeDefTableLookup,The length of the statement  "			this.NamespaceTypeTokenTable.Add ((uint)namespaceName.UniqueKey' (uint)typeName.UniqueKey' TokenTypeIds.ExportedType | i); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "			type = new NonGenericNamespaceTypeWithoutPrimitiveType (this' typeName' typeDefRowId' typeDefRow.Flags' moduleNamespace); " is 121.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "			type = new NonGenericNamespaceTypeWithPrimitiveType (this' typeName' typeDefRowId' typeDefRow.Flags' moduleNamespace' signatureTypeCode); " is 137.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateModuleNamespaceType,The length of the statement  "		type = new GenericNamespaceType (this' unmangledTypeName' typeDefRowId' typeDefRow.Flags' moduleNamespace' typeName' genericParamRowIdStart' genericParamRowIdEnd); " is 163.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateModuleNestedType,The length of the statement  "		type = new GenericNestedType (this' unmangledTypeName' typeDefRowId' typeDefRow.Flags' parentModuleType' typeName' genericParamRowIdStart' genericParamRowIdEnd); " is 161.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateExportedNamespaceType,The length of the statement  "	ExportedTypeNamespaceAlias exportedType = new ExportedTypeNamespaceAlias (this' exportedTypeRowId' exportedTypeRow.Flags' moduleNamespace); " is 139.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateExportedNestedType,The length of the statement  "	ExportedTypeNestedAlias exportedType = new ExportedTypeNestedAlias (this' exportedTypeRowId' exportedTypeRow.Flags' parentExportedType); " is 136.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadTypesInNamespace,The length of the statement  "			type = this.CreateModuleNamespaceType (i' typeDefRow' moduleNamespace' MetadataReaderSignatureTypeCode.NotModulePrimitive); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeDefinitionAtRowWorker,The length of the statement  "				this.PEFileReader.ErrorContainer.AddMetadataError (TableIndices.NestedClass' typeDefRowId' MetadataReaderErrorKind.NestedClassParentError); " is 139.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeDefinitionAtRowWorker,The length of the statement  "			var type = this.CreateModuleNamespaceType (typeDefRowId' typeDefRow' parentNamespace' MetadataReaderSignatureTypeCode.NotModulePrimitive); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetExportedTypeAtRowWorker,The length of the statement  "					this.PEFileReader.ErrorContainer.AddMetadataError (TableIndices.ExportedType' exportedTypeRowId' MetadataReaderErrorKind.NestedClassParentError); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,ResolveNestedTypeDefinition,The length of the statement  "		uint typeToken = this.NestedTypeTokenTable.Find (TokenTypeIds.TypeDef | mdParentType.TypeDefRowId' (uint)typeName.UniqueKey); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,TryToResolveAsNamespaceTypeAlias,The length of the statement  "	uint exportedTypeToken = this.NamespaceTypeTokenTable.Find ((uint)namespaceName.UniqueKey' (uint)mangledTypeName.UniqueKey); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,ResolveExportedNestedType,The length of the statement  "	uint exportedTypeToken = this.NestedTypeTokenTable.Find (TokenTypeIds.ExportedType | parentType.ExportedTypeRowId' (uint)typeName.UniqueKey); " is 141.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetGenericParamInfoForType,The length of the statement  "	genericParamRowIdStart = this.PEFileReader.GenericParamTable.FindGenericParametersForType (typeDefRowId' out genericParamCount); " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetInterfaceInfoForType,The length of the statement  "	interfaceRowIdStart = this.PEFileReader.InterfaceImplTable.FindInterfaceImplForType (moduleType.TypeDefRowId' out interfaceCount); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMethodImplInfoForType,The length of the statement  "	methodImplRowIdStart = this.PEFileReader.MethodImplTable.FindMethodsImplForClass (moduleType.TypeDefRowId' out methodImplCount); " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetConstraintInfoForGenericParam,The length of the statement  "	genericParamConstraintRowIdStart = this.PEFileReader.GenericParamConstraintTable.FindConstraintForGenericParam (genericParam.GenericParameterRowId' out constraintCount); " is 169.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetGenericTypeParamAtRow,The length of the statement  "				this.ModuleGenericParamArray [genericParamRowId] = new GenericTypeParameter (this' genericParamRow.Number' genericParamRow.Flags' genericParamName' genericParamRowId' moduleTypeOwner); " is 184.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetGenericMethodParamAtRow,The length of the statement  "				this.ModuleGenericParamArray [genericParamRowId] = new GenericMethodParameter (this' genericParamRow.Number' genericParamRow.Flags' genericParamName' genericParamRowId' moduleMethodOwner); " is 188.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "				moduleTypeRefReference = new NamespaceTypeRefReferenceWithoutPrimitiveTypeCode (this' mangledTypeName' typeRefRowId' moduleReference' namespaceReference' signatureTypeCode == MetadataReaderSignatureTypeCode.ValueType); " is 218.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "				moduleTypeRefReference = new NamespaceTypeRefReferenceWithPrimitiveTypeCode (this' mangledTypeName' typeRefRowId' moduleReference' namespaceReference' signatureTypeCode); " is 170.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "			moduleTypeRefReference = new GenericNamespaceTypeRefReference (this' iTypeName' typeRefRowId' moduleReference' namespaceReference' mangledTypeName' genericParamCount' signatureTypeCode == MetadataReaderSignatureTypeCode.ValueType); " is 231.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "			moduleTypeRefReference = new NonGenericNestedTypeRefReference (this' mangledTypeName' typeRefRowId' moduleReference' parentModuleTypeReference' signatureTypeCode == MetadataReaderSignatureTypeCode.ValueType); " is 208.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateTypeRefReference,The length of the statement  "			moduleTypeRefReference = new GenericNestedTypeRefReference (this' iTypeName' typeRefRowId' moduleReference' parentModuleTypeReference' mangledTypeName' genericParamCount' signatureTypeCode == MetadataReaderSignatureTypeCode.ValueType); " is 235.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetPredefinedTypeRefReferenceAtRowWorker,The length of the statement  "	Debug.Assert (this.ModuleTypeRefReferenceLoadState [typeRefRowId] == LoadState.Uninitialized && this.ModuleTypeRefReferenceArray [typeRefRowId] == null); " is 153.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetPredefinedTypeRefReferenceAtRowWorker,The length of the statement  "	var result = this.CreateTypeRefReference (typeRefRowId' typeRefRow' null' this.AssemblyReferenceArray [resolutionScopeRowId]' signatureTypeCode); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "				this.PEFileReader.ErrorContainer.AddMetadataError (TableIndices.TypeRef' typeRefRowId' MetadataReaderErrorKind.NestedClassParentError); " is 135.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "			typeRefReference = this.CreateTypeRefReference (typeRefRowId' typeRefRow' parentModuleTypeReference' parentModuleTypeReference.ModuleReference' mustBeStruct ? MetadataReaderSignatureTypeCode.ValueType : MetadataReaderSignatureTypeCode.NotModulePrimitive); " is 255.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "			typeRefReference = this.CreateTypeRefReference (typeRefRowId' typeRefRow' null' moduleReference' mustBeStruct ? MetadataReaderSignatureTypeCode.ValueType : MetadataReaderSignatureTypeCode.NotModulePrimitive); " is 208.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeRefReferenceAtRowWorker,The length of the statement  "		var redirectedTypeReference = this.ModuleReader.metadataReaderHost.Redirect (this.Module' typeRefReference) as INamedTypeReference; " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,TryToResolveNamespaceTypeReferenceAsExportedType,The length of the statement  "		//Since we are not able to resolve the assembly reference' we cannot know if the referenced assembly has an alias' so we just give up and return null. " is 150.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetReferenceToAliasedType,The length of the statement  "			ExportedTypeAliasBase /*?*/aliasType = assemblyPEFileToObjectModel.TryToResolveAsNamespaceTypeAlias (namespaceName' mangledTypeName); " is 133.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,UnderlyingModuleTypeSpecReference,The length of the statement  "	TypeSpecSignatureConverter typeSpecSignatureConverter = new TypeSpecSignatureConverter (this' moduleTypeSpecReference' memoryReader); " is 133.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,FindCoreTypeReference,The length of the statement  "	var retModuleType = this.ResolveNamespaceTypeDefinition (coreTypeReference.NamespaceFullName' coreTypeReference.mangledTypeName) as TypeBase; " is 141.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateMethod,The length of the statement  "		moduleMethod = new NonGenericMethod (this' methodName' parentModuleType' methodDefRowId' methodRow.Flags' methodRow.ImplFlags); " is 127.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateMethod,The length of the statement  "		moduleMethod = new GenericMethod (this' methodName' parentModuleType' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' genericParamRowIdStart' genericParamRowIdEnd); " is 170.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateProperty,The length of the statement  "	PropertyDefinition moduleProperty = new PropertyDefinition (this' propertyName' parentModuleType' propertyDefRowId' propertyRow.Flags); " is 135.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadNestedTypesOfType,The length of the statement  "			currType = this.CreateModuleNestedType (nestedClassRow.NestedClass' this.PEFileReader.TypeDefTable [nestedClassRow.NestedClass]' moduleType); " is 141.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadPropertiesOfType,The length of the statement  "		for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyPtrRows; ++propertyIter) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadPropertiesOfType,The length of the statement  "		for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyRows; ++propertyIter) { " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetPropertiesOfType,The length of the statement  "		for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyPtrRows; ++propertyIter) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetPropertiesOfType,The length of the statement  "		for (uint propertyIter = propertyStart; propertyIter < propertyEnd && propertyIter <= numberOfPropertyRows; ++propertyIter) { " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateGlobalField,The length of the statement  "	GlobalFieldDefinition globalField = new GlobalFieldDefinition (this' fieldTypeMembName' this._Module_' fieldDefRowId' fieldRow.Flags' globalFieldName' containingNamespace); " is 172.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateGlobalMethod,The length of the statement  "		GlobalNonGenericMethod globalNGMethod = new GlobalNonGenericMethod (this' methodTypeMembName' this._Module_' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' globalMethodName' containingNamespace); " is 202.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,CreateGlobalMethod,The length of the statement  "		GlobalGenericMethod globalGMethod = new GlobalGenericMethod (this' methodTypeMembName' this._Module_' methodDefRowId' methodRow.Flags' methodRow.ImplFlags' genericParamRowIdStart' genericParamRowIdEnd' globalMethodName' containingNamespace); " is 241.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetGenericParamInfoForMethod,The length of the statement  "	genericParamRowIdStart = this.PEFileReader.GenericParamTable.FindGenericParametersForMethod (methodDefRowId' out genericParamCount); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetFieldSequenceNumber,The length of the statement  "	uint fieldStart = this.PEFileReader.GetFieldInformation (fieldDefinition.OwningModuleType.TypeDefRowId' out fieldCount); " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetSemanticInfoForProperty,The length of the statement  "	methodSemanticRowIdStart = this.PEFileReader.MethodSemanticsTable.FindSemanticMethodsForProperty (propertyRowId' out methodCount); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetSemanticInfoForEvent,The length of the statement  "	methodSemanticRowIdStart = this.PEFileReader.MethodSemanticsTable.FindSemanticMethodsForEvent (eventRowId' out methodCount); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetPropertyGetterOrSetterMethod,The length of the statement  "	this.GetSemanticInfoForProperty (propertyDefinition.PropertyRowId' out methodSemanticRowIdStart' out methodSemanticRowIdEnd); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetPropertyAccessorMethods,The length of the statement  "	this.GetSemanticInfoForProperty (propertyDefinition.PropertyRowId' out methodSemanticRowIdStart' out methodSemanticRowIdEnd); " is 125.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMarshallingInformation,The length of the statement  "	System.Runtime.InteropServices.UnmanagedType unmanagedType = (System.Runtime.InteropServices.UnmanagedType)memoryReader.ReadByte (); " is 132.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMarshallingInformation,The length of the statement  "			System.Runtime.InteropServices.UnmanagedType elementType = (System.Runtime.InteropServices.UnmanagedType)memoryReader.ReadByte (); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetPlatformInvokeInformation,The length of the statement  "	return new PlatformInvokeInformation (implMapRow.PInvokeMapFlags' this.GetNameFromOffset (implMapRow.ImportName)' moduleReference); " is 131.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "					unspecializedFieldReference = new FieldReference (this' memberRefRowId' TypeCache.Unspecialize (parentTypeReference)' name); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "					specializedField = new SpecializedFieldReference (parentTypeReference' unspecializedFieldReference' this.InternFactory); " is 120.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "				MethodReference unspecializedMethodReference = this.UnspecializedMemberReferenceArray [memberRefRowId] as MethodReference; " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "					unspecializedMethodReference = new MethodReference (this' memberRefRowId' TypeCache.Unspecialize (parentTypeReference)' name' firstByte); " is 137.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMemberReferenceAtRowWorker,The length of the statement  "					specializedMethod = new SpecializedMethodReference (parentTypeReference' unspecializedMethodReference' this.InternFactory); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMethodRefSignature,The length of the statement  "	MethodRefSignatureConverter methodRefSigConv = new MethodRefSignatureConverter (this' moduleMethodReference' memoryReader); " is 123.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMethodSpecAtRow,The length of the statement  "	IGenericMethodInstanceReference /*?*/methodSpecReference = this.ModuleMethodSpecHashtable.Find (ownerId' methodSpecRowId); " is 122.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMethodSpecAtRow,The length of the statement  "				methodSpecReference = new GenericMethodInstanceReferenceWithToken (moduleMethod' methodSpecSigConv.GenericTypeArguments' this.InternFactory' methodSpecRowId | TokenTypeIds.MethodSpec); " is 184.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCustomAttributeInfo,The length of the statement  "	customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken (metadataObject.TokenValue' out customAttributeCount); " is 150.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCustomAttributeAtRow,The length of the statement  "						this.CustomAttributeArray [customAttributeRowId] = this.ModuleReader.metadataReaderHost.Rewrite (this.Module' new CustomAttribute (this' customAttributeRowId' moduleMethodReference' null' null)); " is 195.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCustomAttributeAtRow,The length of the statement  "						CustomAttributeDecoder customAttrDecoder = new CustomAttributeDecoder (this' memoryReader' customAttributeRowId' moduleMethodReference); " is 136.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleCustomAttributes,The length of the statement  "	uint customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken (TokenTypeIds.Module | (uint)0x00000001' out customAttributeCount); " is 168.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleCustomAttributes,The length of the statement  "	for (uint customAttributeIter = customAttributeRowIdStart; customAttributeIter < customAttributeRowIdEnd; ++customAttributeIter) { " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetAssemblyCustomAttributes,The length of the statement  "	uint customAttributeRowIdStart = this.PEFileReader.CustomAttributeTable.FindCustomAttributesForToken (TokenTypeIds.Assembly | (uint)0x00000001' out customAttributeCount); " is 170.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetAssemblyCustomAttributes,The length of the statement  "	for (uint customAttributeIter = customAttributeRowIdStart; customAttributeIter < customAttributeRowIdEnd; ++customAttributeIter) { " is 130.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetSecurityAttributeInfo,The length of the statement  "	securityAttributeRowIdStart = this.PEFileReader.DeclSecurityTable.FindSecurityAttributesForToken (metadataObject.TokenValue' out securityAttributeCount); " is 153.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetSecurityAttributeAtRow,The length of the statement  "					this.DeclSecurityArray [securityAttributeRowId] = new SecurityAttribute (this' securityAttributeRowId' (SecurityAction)declSecurity.ActionFlags); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetSecurityAttributeData,The length of the statement  "	SecurityAttributeDecoder20 securityAttrDecoder = new SecurityAttributeDecoder20 (this' memoryReader' securityAttribute); " is 120.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The length of the statement  "			typeRef = this.PEFileToObjectModel.GetTypeSpecReferenceAtRow (this.MetadataOwnerObject' typeRID).UnderlyingModuleTypeReference; " is 127.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleGenericTypeInstanceReference,The length of the statement  "		templateTypeReference = this.PEFileToObjectModel.GetTypeRefReferenceAtRow (templateTypeRowId' headByte == ElementType.ValueType); " is 129.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleGenericTypeInstanceReference,The length of the statement  "			templateTypeReference = new NestedTypeReference (this.PEFileToObjectModel.ModuleReader.metadataReaderHost' nestedTemplate.ContainingType' nestedTemplate.Name' genericArgumentCount' nestedTemplate.IsEnum' nestedTemplate.IsValueType' mangleName: false); " is 251.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleGenericTypeInstanceReference,The length of the statement  "				templateTypeReference = new NamespaceTypeReference (this.PEFileToObjectModel.ModuleReader.metadataReaderHost' namespaceTemplate.ContainingUnitNamespace' namespaceTemplate.Name' genericArgumentCount' namespaceTemplate.IsEnum' namespaceTemplate.IsValueType' mangleName: false); " is 275.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,SpecializeAndOrInstantiate,The length of the statement  "		var containingType = this.SpecializeAndOrInstantiate (0' (INamedTypeReference)nestedTypeReference.ContainingType' ref genericArgumentCount' outer: false); " is 154.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,SpecializeAndOrInstantiate,The length of the statement  "			namedTypeReference = new SpecializedNestedTypeReference (nestedTypeReference' containingType' this.PEFileToObjectModel.InternFactory); " is 134.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,Instantiate,The length of the statement  "	//We cannot compute the intern key of a generic method type parameter before we are able to compute the intern key of the generic method. " is 137.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,Instantiate,The length of the statement  "		return new GenericTypeInstanceReferenceWithToken (typeSpecToken' templateTypeReference' IteratorHelper.GetReadonly (genericArgumentArray)' this.PEFileToObjectModel.InternFactory); " is 179.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,Instantiate,The length of the statement  "		return new GenericTypeInstanceReference (templateTypeReference' IteratorHelper.GetReadonly (genericArgumentArray)' this.PEFileToObjectModel.InternFactory); " is 155.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleMatrixType,The length of the statement  "	return new MatrixWithToken (typeSpecToken' elementType' rank' IteratorHelper.GetReadonly (lowerBounds)' IteratorHelper.GetReadonly (sizes)' this.PEFileToObjectModel.InternFactory); " is 180.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "		IParameterTypeInformation[] moduleParameterArr = this.GetModuleParameterTypeInformations (Dummy.Signature' paramCount - methodParamCount); " is 138.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "		return new FunctionPointerTypeWithToken (typeSpecToken' (CallingConvention)firstByte' isReturnByReference' returnTypeReference' returnCustomModifiers' moduleParameters' moduleVarargsParameters' this.PEFileToObjectModel.InternFactory); " is 234.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleFuntionPointer,The length of the statement  "		return new FunctionPointerType ((CallingConvention)firstByte' isReturnByReference' returnTypeReference' returnCustomModifiers' moduleParameters' moduleVarargsParameters' this.PEFileToObjectModel.InternFactory); " is 210.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeReference,The length of the statement  "		return PointerType.GetPointerType (this.GetTypeReference () ?? Dummy.TypeReference' this.PEFileToObjectModel.InternFactory); " is 124.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeReference,The length of the statement  "		return this.PEFileToObjectModel.GetTypeReferenceForToken (this.MetadataOwnerObject' typeToken' headByte == ElementType.ValueType); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleParameters,The length of the statement  "			moduleParameter = new ParameterWithMetadata (this.PEFileToObjectModel' paramIndex' customModifiers' typeReference' moduleMethod' isByReference' (paramIndex == paramCount - 1) && paramArrayType != null && paramArrayType.IsVector' paramInfo.Value.ParamRowId' paramInfo.Value.ParamName' paramInfo.Value.ParamFlags); " is 312.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleParameters,The length of the statement  "			moduleParameter = new ParameterWithoutMetadata (this.PEFileToObjectModel' paramIndex' customModifiers' typeReference' signatureDefinition' isByReference); " is 154.
Long Statement,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetModuleParameterTypeInformations,The length of the statement  "		var parameterType = new ParameterInfo (this.PEFileToObjectModel' index' customModifiers' typeReference' signature' isByReference); " is 130.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Redirect,The length of the statement  "	if (referringModule == null || referringModule.ContainingAssembly == null || !(referringModule.ContainingAssembly.ContainsForeignTypes)) " is 136.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Redirect,The length of the statement  "	if (string.Equals (this.CoreAssemblySymbolicIdentity.Name.Value' "System.Runtime"' StringComparison.OrdinalIgnoreCase)) { " is 121.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Redirect,The length of the statement  "	if (referringModule == null || referringModule.ContainingAssembly == null || !(referringModule.ContainingAssembly.ContainsForeignTypes)) " is 136.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Redirect,The length of the statement  "		if (namespaceTypeReference.Name == platformType.SystemEventHandler1.Name && namespaceTypeReference.GenericParameterCount == 1) " is 126.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Rewrite,The length of the statement  "	if (referringModule == null || referringModule.ContainingAssembly == null || !(referringModule.ContainingAssembly.ContainsForeignTypes)) " is 136.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Rewrite,The length of the statement  "	//The custom attribute constructor has been redirected from Windows.Foundation.AttributeUsageAttribute' which has a different " is 125.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Rewrite,The length of the statement  "	//set of flags from System.AttributeUsageAttribute for its first and only constructor parameter and also does not have an AllowMultiple property.  " is 145.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Rewrite,The length of the statement  "		namedArgArray [0] = new FieldOrPropertyNamedArgumentExpression (this.AllowMultiple' Dummy.Type' false' this.PlatformType.SystemBoolean' trueVal); " is 145.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,FellowCustomAttributeIncludeAllowMultiple,The length of the statement  "		if (caType != null && caType.Name == this.AllowMultipleAttribute && this.IsWindowsFoundation (caType.ContainingUnitNamespace as INestedUnitNamespaceReference)) " is 159.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The length of the statement  "	if (assemblyIdentity.Name.UniqueKeyIgnoringCase == this.CoreAssemblySymbolicIdentity.Name.UniqueKeyIgnoringCase && assemblyIdentity.Culture == this.CoreAssemblySymbolicIdentity.Culture && IteratorHelper.EnumerablesAreEqual (assemblyIdentity.PublicKeyToken' this.CoreAssemblySymbolicIdentity.PublicKeyToken)) " is 307.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The length of the statement  "	if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255)) " is 160.
Long Statement,Microsoft.Cci.MetadataReader,WindowsRuntimePlatform,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,GetSystemRuntimeInteropServicesWindowsRuntimeSymbolicIdentity,The length of the statement  "		location = Path.Combine (Path.GetDirectoryName (core.Location) ?? ""' "System.Runtime.InteropServices.WindowsRuntime.dll"); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,LocalVariableSignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,GetLocalVariable,The length of the statement  "	return new LocalVariableDefinition (this.OwningMethodBody' customModifiers' isPinned' isByReferenece' index' typeReference); " is 124.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,LoadLocalSignature,The length of the statement  "		MemoryBlock signatureMemoryBlock = this.PEFileToObjectModel.PEFileReader.BlobStream.GetMemoryBlockAt (sigRow.Signature); " is 120.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,LoadLocalSignature,The length of the statement  "		LocalVariableSignatureConverter locVarSigConv = new LocalVariableSignatureConverter (this.PEFileToObjectModel' this.MethodBody' memoryReader); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "	StandAloneSigRow sigRow = this.PEFileToObjectModel.PEFileReader.StandAloneSigTable [standAloneMethodToken & TokenTypeIds.RIDMask]; " is 130.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "	MemoryBlock signatureMemoryBlock = this.PEFileToObjectModel.PEFileReader.BlobStream.GetMemoryBlockAt (signatureBlobOffset); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "	StandAloneMethodSignatureConverter standAloneSigConv = new StandAloneMethodSignatureConverter (this.PEFileToObjectModel' this.MethodDefinition' memoryReader); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,GetStandAloneMethodSignature,The length of the statement  "	return new FunctionPointerType ((CallingConvention)standAloneSigConv.FirstByte' standAloneSigConv.IsReturnByReference' standAloneSigConv.ReturnTypeReference' standAloneSigConv.ReturnCustomModifiers' standAloneSigConv.RequiredParameters' standAloneSigConv.VarArgParameters' this.PEFileToObjectModel.InternFactory); " is 313.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The length of the statement  "			this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateExceptionInformation,The length of the statement  "				ITypeReference /*?*/typeRef = this.PEFileToObjectModel.GetTypeReferenceForToken (this.MethodDefinition' sehTableEntry.ClassTokenOrFilterOffset); " is 144.
Long Statement,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateExceptionInformation,The length of the statement  "			exceptions [i] = new CilExceptionInformation (handlerKind' exceptionType' tryStart' tryEnd' filterDecisionStart' handlerStart' handlerEnd); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.Errors,DirectoryLocation,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Errors.cs,ToString,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "DirectoryLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.directory.ToString ()' this.offset); " is 152.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataStreamLocation,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Errors.cs,ToString,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "MetadataStreamLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.streamName' this.offset); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataLocation,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Errors.cs,ToString,The length of the statement  "	sb.AppendFormat (CultureInfo.InvariantCulture' "MetadataLocation({0}'{1}'{2})"' this.binaryDocument.Location' this.tableIndex.ToString ()' this.rowId); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Errors.cs,AddBinaryError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new BinaryLocation (this.BinaryDocument' offset)' errorKind)); " is 166.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Errors.cs,AddDirectoryError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new DirectoryLocation (this.BinaryDocument' directory' offset)' errorKind)); " is 180.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Errors.cs,AddMetadataStreamError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new MetadataStreamLocation (this.BinaryDocument' streamName' offset)' errorKind)); " is 186.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Errors.cs,AddMetadataError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new MetadataLocation (this.BinaryDocument' tableIndex' rowId)' errorKind)); " is 179.
Long Statement,Microsoft.Cci.MetadataReader.Errors,MetadataErrorContainer,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Errors.cs,AddILError,The length of the statement  "	this.AddMetadataReaderErrorMessage (new MetadataReaderErrorMessage (this.MetadataReader.ErrorsReporter' new ILLocation (this.BinaryDocument' methodDefinition' offset)' errorKind)); " is 180.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenMemberModules,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument' fileRef.FileName.Value); " is 144.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenMemberModules,The length of the statement  "			PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel (this' peFileReader' moduleIdentity' assembly' this.metadataReaderHost.PointerSize); " is 150.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenAssembly,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument); " is 120.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenAssembly,The length of the statement  "			PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel (this' peFileReader' assemblyIdentity' null' this.metadataReaderHost.PointerSize); " is 148.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenModule,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument); " is 120.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenModule,The length of the statement  "			PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel (this' peFileReader' moduleIdentity' null' this.metadataReaderHost.PointerSize); " is 146.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenSnapshot,The length of the statement  "		IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument); " is 120.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenSnapshot,The length of the statement  "			PEFileToObjectModel peFileToObjectModel = new PEFileToObjectModel (this' peFileReader' moduleIdentity' null' this.metadataReaderHost.PointerSize); " is 146.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,GetAssemblyIdentifier,The length of the statement  "	IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.metadataReaderHost.OpenBinaryDocument (binaryDocument); " is 120.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,GetAssemblyIdentifier,The length of the statement  "	Version version = new Version (assemblyRow.MajorVersion' assemblyRow.MinorVersion' assemblyRow.BuildNumber' assemblyRow.RevisionNumber); " is 136.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,GetAssemblyIdentifier,The length of the statement  "	return new AssemblyIdentity (assemblyName' cultureName' version' publicKeyTokenArray' peFileReader.BinaryDocumentMemoryBlock.BinaryDocument.Location); " is 150.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,GetModuleIdentifier,The length of the statement  "	return new ModuleIdentity (moduleName' peFileReader.BinaryDocumentMemoryBlock.BinaryDocument.Location' containingAssemblyIdentity); " is 131.
Long Statement,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,ResolveSerializedTypeName,The length of the statement  "	ITypeReference /*?*/moduleTypeRef = internalAssembly.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeName); " is 121.
Long Statement,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF16WithShortSize,The length of the statement  "	#      string result = new string((sbyte*)(this.CurrentPointer + offset + sizeof(UInt16))' 0' length * sizeof(Char)' Encoding.Unicode);" is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefOrRefTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return TypeDefOrRefTag.TagToTokenTypeArray [typeDefOrRefTag & TypeDefOrRefTag.TagMask] | typeDefOrRefTag >> TypeDefOrRefTag.NumberOfBits; " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasConstantTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasConstantTag.TagToTokenTypeArray [hasConstant & HasConstantTag.TagMask] | hasConstant >> HasConstantTag.NumberOfBits; " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasCustomAttributeTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasCustomAttributeTag.TagToTokenTypeArray [hasCustomAttribute & HasCustomAttributeTag.TagMask] | hasCustomAttribute >> HasCustomAttributeTag.NumberOfBits; " is 161.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasFieldMarshalTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasFieldMarshalTag.TagToTokenTypeArray [hasFieldMarshal & HasFieldMarshalTag.TagMask] | hasFieldMarshal >> HasFieldMarshalTag.NumberOfBits; " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasDeclSecurityTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasDeclSecurityTag.TagToTokenTypeArray [hasDeclSecurity & HasDeclSecurityTag.TagMask] | hasDeclSecurity >> HasDeclSecurityTag.NumberOfBits; " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberRefParentTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return MemberRefParentTag.TagToTokenTypeArray [memberRef & MemberRefParentTag.TagMask] | memberRef >> MemberRefParentTag.NumberOfBits; " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,HasSemanticsTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return HasSemanticsTag.TagToTokenTypeArray [hasSemantic & HasSemanticsTag.TagMask] | hasSemantic >> HasSemanticsTag.NumberOfBits; " is 129.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodDefOrRefTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return MethodDefOrRefTag.TagToTokenTypeArray [methodDefOrRef & MethodDefOrRefTag.TagMask] | methodDefOrRef >> MethodDefOrRefTag.NumberOfBits; " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberForwardedTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return MemberForwardedTag.TagToTokenTypeArray [memberForwarded & MethodDefOrRefTag.TagMask] | memberForwarded >> MethodDefOrRefTag.NumberOfBits; " is 144.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ImplementationTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return ImplementationTag.TagToTokenTypeArray [implementation & ImplementationTag.TagMask] | implementation >> ImplementationTag.NumberOfBits; " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTypeTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return CustomAttributeTypeTag.TagToTokenTypeArray [customAttributeType & CustomAttributeTypeTag.TagMask] | customAttributeType >> CustomAttributeTypeTag.NumberOfBits; " is 166.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ResolutionScopeTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return ResolutionScopeTag.TagToTokenTypeArray [resolutionScope & ResolutionScopeTag.TagMask] | resolutionScope >> ResolutionScopeTag.NumberOfBits; " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeOrMethodDefTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToToken,The length of the statement  "	return TypeOrMethodDefTag.TagToTokenTypeArray [typeOrMethodDef & TypeOrMethodDefTag.TagMask] | typeOrMethodDef >> TypeOrMethodDefTag.NumberOfBits; " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetExtends,The length of the statement  "	uint extends = this.TypeDefTableMemoryReader.PeekReference (rowOffset + this.ExtendsOffset' this.IsTypeDefOrRefRefSizeSmall); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetFieldStart,The length of the statement  "	uint fieldListStart = this.TypeDefTableMemoryReader.PeekReference (rowOffset + this.FieldListOffset' this.IsFieldRefSizeSmall); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodStart,The length of the statement  "	uint methodListStart = this.TypeDefTableMemoryReader.PeekReference (rowOffset + this.MethodListOffset' this.IsMethodRefSizeSmall); " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindTypeContainingMethod,The length of the statement  "	int slot = this.TypeDefTableMemoryReader.BinarySearchForSlot (numOfRows' this.RowSize' this.MethodListOffset' methodDefOrPtrRowId' this.IsMethodRefSizeSmall); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindTypeContainingField,The length of the statement  "	int slot = this.TypeDefTableMemoryReader.BinarySearchForSlot (numOfRows' this.RowSize' this.FieldListOffset' fieldDefOrPtrRowId' this.IsFieldRefSizeSmall); " is 155.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetFieldFor,The length of the statement  "	uint field = this.FieldPtrTableMemoryReader.PeekReference (rowOffset + this.FieldOffset' this.IsFieldTableRowRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetRowIdForFieldDefRow,The length of the statement  "	return (uint)(this.FieldPtrTableMemoryReader.LinearSearchReference (this.RowSize' this.FieldOffset' fieldDefRowId' this.IsFieldTableRowRefSizeSmall) + 1); " is 154.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.FieldTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodFor,The length of the statement  "	uint method = this.MethodPtrTableMemoryReader.PeekReference (rowOffset + this.MethodOffset' this.IsMethodTableRowRefSizeSmall); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetRowIdForMethodDefRow,The length of the statement  "	return (uint)(this.MethodPtrTableMemoryReader.LinearSearchReference (this.RowSize' this.MethodOffset' methodDefRowId' this.IsMethodTableRowRefSizeSmall) + 1); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetParamStart,The length of the statement  "	uint paramListStart = this.MethodTableMemoryReader.PeekReference (rowOffset + this.ParamListOffset' this.IsParamRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.MethodTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 124.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ParamPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetParamFor,The length of the statement  "	uint param = this.ParamPtrTableMemoryReader.PeekReference (rowOffset + this.ParamOffset' this.IsParamTableRowRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindInterfaceImplForType,The length of the statement  "	int foundRowNumber = this.InterfaceImplTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ClassOffset' typeDefRowId' this.IsTypeDefOrRefRefSizeSmall); " is 178.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindInterfaceImplForType,The length of the statement  "	while (startRowNumber > 0 && this.InterfaceImplTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.ClassOffset' this.IsTypeDefOrRefRefSizeSmall) == typeDefRowId) { " is 187.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindInterfaceImplForType,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.InterfaceImplTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.ClassOffset' this.IsTypeDefOrRefRefSizeSmall) == typeDefRowId) { " is 203.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetInterface,The length of the statement  "	uint @interface = this.InterfaceImplTableMemoryReader.PeekReference (rowOffset + this.InterfaceOffset' this.IsTypeDefOrRefRefSizeSmall); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.MemberRefTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ConstantTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetConstantRowId,The length of the statement  "	int foundRowNumber = this.ConstantTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' HasConstantTag.ConvertToTag (parentToken)' this.IsHasConstantRefSizeSmall); " is 202.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.CustomAttributeTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' searchCodedTag' this.IsHasCustomAttributeRefSizeSmall); " is 189.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (startRowNumber > 0 && this.CustomAttributeTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.ParentOffset' this.IsHasCustomAttributeRefSizeSmall) == searchCodedTag) { " is 198.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.CustomAttributeTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.ParentOffset' this.IsHasCustomAttributeRefSizeSmall) == searchCodedTag) { " is 214.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldMarshalTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetFieldMarshalRowId,The length of the statement  "	int foundRowNumber = this.FieldMarshalTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' HasFieldMarshalTag.ConvertToTag (token)' this.IsHasFieldMarshalRefSizeSmall); " is 208.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.DeclSecurityTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' searchCodedTag' this.IsHasDeclSecurityRefSizeSmall); " is 183.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (startRowNumber > 0 && this.DeclSecurityTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.ParentOffset' this.IsHasDeclSecurityRefSizeSmall) == searchCodedTag) { " is 192.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.DeclSecurityTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.ParentOffset' this.IsHasDeclSecurityRefSizeSmall) == searchCodedTag) { " is 208.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ClassLayoutTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetPackingSize,The length of the statement  "	int foundRowNumber = this.ClassLayoutTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' typeRowId' this.IsTypeDefTableRowRefSizeSmall); " is 177.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ClassLayoutTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetClassSize,The length of the statement  "	int foundRowNumber = this.ClassLayoutTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ParentOffset' typeRowId' this.IsTypeDefTableRowRefSizeSmall); " is 177.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldLayoutTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetOffset,The length of the statement  "	int foundRowNumber = this.FieldLayoutTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.FieldOffset' rowId' this.IsFieldTableRowRefSizeSmall); " is 170.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindEventMapRowIdFor,The length of the statement  "	int rowNumber = this.EventMapTableMemoryReader.LinearSearchReference (this.RowSize' this.ParentOffset' typeDefRowId' this.IsTypeDefTableRowRefSizeSmall); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetEventListStartFor,The length of the statement  "	uint eventList = this.EventMapTableMemoryReader.PeekReference (rowOffset + this.EventListOffset' this.IsEventRefSizeSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetEventFor,The length of the statement  "	uint @event = this.EventPtrTableMemoryReader.PeekReference (rowOffset + this.EventOffset' this.IsEventTableRowRefSizeSmall); " is 124.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetEventType,The length of the statement  "	uint eventType = this.EventTableMemoryReader.PeekReference (rowOffset + this.EventTypeOffset' this.IsTypeDefOrRefRefSizeSmall); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindPropertyMapRowIdFor,The length of the statement  "	int rowNumber = this.PropertyMapTableMemoryReader.LinearSearchReference (this.RowSize' this.ParentOffset' typeDefRowId' this.IsTypeDefTableRowRefSizeSmall); " is 156.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetPropertyListStartFor,The length of the statement  "	uint propertyList = this.PropertyMapTableMemoryReader.PeekReference (rowOffset + this.PropertyListOffset' this.IsPropertyRefSizeSmall); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetPropertyFor,The length of the statement  "	uint property = this.PropertyPtrTableMemoryReader.PeekReference (rowOffset + this.PropertyOffset' this.IsPropertyTableRowRefSizeSmall); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.PropertyTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.MethodSemanticsTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.AssociationOffset' searchCodedTag' this.IsHasSemanticRefSizeSmall); " is 187.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (startRowNumber > 0 && this.MethodSemanticsTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.AssociationOffset' this.IsHasSemanticRefSizeSmall) == searchCodedTag) { " is 196.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.MethodSemanticsTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.AssociationOffset' this.IsHasSemanticRefSizeSmall) == searchCodedTag) { " is 212.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindMethodsImplForClass,The length of the statement  "	int foundRowNumber = this.MethodImplTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.ClassOffset' typeDefRowId' this.IsTypeDefTableRowRefSizeSmall); " is 178.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindMethodsImplForClass,The length of the statement  "	while (startRowNumber > 0 && this.MethodImplTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.ClassOffset' this.IsTypeDefTableRowRefSizeSmall) == typeDefRowId) { " is 187.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindMethodsImplForClass,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.MethodImplTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.ClassOffset' this.IsTypeDefTableRowRefSizeSmall) == typeDefRowId) { " is 203.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,TypeSpecTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetSignature,The length of the statement  "	uint signature = this.TypeSpecTableMemoryReader.PeekReference (rowOffset + this.SignatureOffset' this.IsBlobHeapRefSizeSmall); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.ImplMapTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.MemberForwardedOffset' searchCodedTag' this.IsMemberForwardRowRefSizeSmall); " is 188.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FieldRVATableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetFieldRVA,The length of the statement  "	int foundRowNumber = this.FieldRVATableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.FieldOffset' fieldDefRowId' this.IsFieldTableRowRefSizeSmall); " is 175.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetHashValue,The length of the statement  "	uint hashValue = this.FileTableMemoryReader.PeekReference (rowOffset + this.HashValueOffset' this.IsBlobHeapRefSizeSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetNamespace,The length of the statement  "	uint typeNamespace = this.ExportedTypeTableMemoryReader.PeekReference (rowOffset + this.TypeNamespaceOffset' this.IsStringHeapRefSizeSmall); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetImplementation,The length of the statement  "	uint implementation = this.ManifestResourceTableMemoryReader.PeekReference (rowOffset + this.ImplementationOffset' this.IsImplementationRefSizeSmall); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,NestedClassTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindParentTypeDefRowId,The length of the statement  "	int rowNumber = this.NestedClassTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.NestedClassOffset' nestedTypeRowId' this.IsTypeDefTableRowRefSizeSmall); " is 183.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,NestedClassTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindParentTypeDefRowId,The length of the statement  "	return this.NestedClassTableMemoryReader.PeekReference (rowNumber * this.RowSize + this.EnclosingClassOffset' this.IsTypeDefTableRowRefSizeSmall); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	int foundRowNumber = this.GenericParamTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.OwnerOffset' searchCodedTag' this.IsTypeOrMethodDefRefSizeSmall); " is 182.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (startRowNumber > 0 && this.GenericParamTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.OwnerOffset' this.IsTypeOrMethodDefRefSizeSmall) == searchCodedTag) { " is 191.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,BinarySearchTag,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.GenericParamTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.OwnerOffset' this.IsTypeOrMethodDefRefSizeSmall) == searchCodedTag) { " is 207.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindConstraintForGenericParam,The length of the statement  "	int foundRowNumber = this.GenericParamConstraintTableMemoryReader.BinarySearchReference (this.NumberOfRows' this.RowSize' this.OwnerOffset' genericParamRowId' this.IsGenericParamTableRowRefSizeSmall); " is 200.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindConstraintForGenericParam,The length of the statement  "	while (startRowNumber > 0 && this.GenericParamConstraintTableMemoryReader.PeekReference ((startRowNumber - 1) * this.RowSize + this.OwnerOffset' this.IsGenericParamTableRowRefSizeSmall) == genericParamRowId) { " is 209.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FindConstraintForGenericParam,The length of the statement  "	while (endRowNumber + 1 < this.NumberOfRows && this.GenericParamConstraintTableMemoryReader.PeekReference ((endRowNumber + 1) * this.RowSize + this.OwnerOffset' this.IsGenericParamTableRowRefSizeSmall) == genericParamRowId) { " is 225.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetConstraint,The length of the statement  "	uint constraint = this.GenericParamConstraintTableMemoryReader.PeekReference (rowOffset + this.ConstraintOffset' this.IsTypeDefOrRefRefSizeSmall); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadDebugInformationLocationFromDebugTableDirectoryData,The length of the statement  "	var debugDirectoryReader = new MemoryReader (this.DirectoryToMemoryBlock (this.OptionalHeaderDirectoryEntries.DebugTableDirectory)); " is 132.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadDebugInformationLocationFromDebugTableDirectoryData,The length of the statement  "	var dataBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + debugDir.PointerToRawData' debugDir.SizeOfData); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadOptionalHeaderNTAdditionalFields32,The length of the statement  "		this.ErrorContainer.AddBinaryError (memReader.Offset' MetadataReaderErrorKind.OptionalHeaderNTAdditionalFields32TooSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadOptionalHeaderNTAdditionalFields64,The length of the statement  "		this.ErrorContainer.AddBinaryError (memReader.Offset' MetadataReaderErrorKind.OptionalHeaderNTAdditionalFields64TooSmall); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "	MemoryReader memReader = new MemoryReader (this.BinaryDocumentMemoryBlock.Pointer' this.BinaryDocumentMemoryBlock.Length); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "		if (!this.ReadOptionalHeaderStandardFields32 (ref memReader) || !this.ReadOptionalHeaderNTAdditionalFields32 (ref memReader)) { " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "		if (!this.ReadOptionalHeaderStandardFields64 (ref memReader) || !this.ReadOptionalHeaderNTAdditionalFields64 (ref memReader)) { " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadPEFileLevelData,The length of the statement  "	this.Win32ResourceMemoryReader = new MemoryReader (this.DirectoryToMemoryBlock (this.OptionalHeaderDirectoryEntries.ResourceTableDirectory)); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,DirectoryToMemoryBlock,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= directory.RelativeVirtualAddress && directory.RelativeVirtualAddress < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 178.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,DirectoryToMemoryBlock,The length of the statement  "			MemoryBlock retMemBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + sectionHeaderIter.OffsetToRawData + relativeOffset' directory.Size); " is 152.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAToMemoryBlockWithSize,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAToMemoryBlockWithSize,The length of the statement  "			MemoryBlock retMemBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + sectionHeaderIter.OffsetToRawData + relativeOffset' (int)size); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAToMemoryBlock,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAToMemoryBlock,The length of the statement  "			MemoryBlock retMemBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + sectionHeaderIter.OffsetToRawData + relativeOffset' sectionHeaderIter.VirtualSize - relativeOffset); " is 184.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAsInSameSection,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA1 && RVA1 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize && sectionHeaderIter.VirtualAddress <= RVA2 && RVA2 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 241.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAToSubSection,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA + size <= sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAToSubSection,The length of the statement  "			MemoryBlock memBlock = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer + sectionHeaderIter.OffsetToRawData + relativeOffset' size); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAToSubSectionName,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetSizeOfRemainderOfSectionContaining,The length of the statement  "		if (sectionHeaderIter.VirtualAddress <= RVA && RVA < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize) { " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadCOR20Header,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.COR20Header' 0' MetadataReaderErrorKind.NotEnoughSpaceForCOR20HeaderTableDirectory); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.MetadataHeaderTooSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset - sizeof(uint)' MetadataReaderErrorKind.MetadataSignature); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataHeader,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForVersionString); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadStorageHeader,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StorageHeaderTooSmall); " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "			this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StreamHeaderTooSmall); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "		//  Review: Oh well there is no way i can test if we will read correctly. However we can check it after reading and aligning... " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadStreamHeaders,The length of the statement  "			this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStreamHeaderName); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStringStream); " is 148.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForBlobStream); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForGUIDStream); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForBlobStream); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForMetadataStream); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "				this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForMetadataStream); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheStreams,The length of the statement  "			this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' streamHeader.Offset' MetadataReaderErrorKind.UnknownMetadataStream); " is 140.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadCORModuleLevelData,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.NotEnoughSpaceForMetadataDirectory); " is 135.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadCORModuleLevelData,The length of the statement  "	if (!this.ReadMetadataHeader (ref memReader) || !this.ReadStorageHeader (ref memReader) || !this.ReadStreamHeaders (ref memReader) || !this.ProcessAndCacheStreams (ref metadataRoot)) { " is 184.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataRoot,The length of the statement  "	var metadataRoot = new MemoryBlock (this.BinaryDocumentMemoryBlock.Pointer' (int)this.BinaryDocumentMemoryBlock.Length); " is 120.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataRoot,The length of the statement  "	if (!this.ReadMetadataHeader (ref memReader) || !this.ReadStorageHeader (ref memReader) || !this.ReadStreamHeaders (ref memReader) || !this.ProcessAndCacheStreams (ref metadataRoot)) { " is 184.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 0' MetadataReaderErrorKind.MetadataTableHeaderTooSmall); " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 4' MetadataReaderErrorKind.UnknownVersionOfMetadata); " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "	if (this.MetadataStreamKind == MetadataStreamKind.Compressed && (presentTables & (ulong)TableMask.CompressedStreamNotAllowedMask) != 0) { " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.IllegalTablesInCompressedMetadataStream); " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 16' MetadataReaderErrorKind.SomeRequiredTablesNotSorted); " is 126.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		//Carry on regardless. There are/were compiler out there that sort the required tables' but fail to set the bit in SortedTables. " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The length of the statement  "		this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' memReader.Offset' MetadataReaderErrorKind.TableRowCountSpaceTooSmall); " is 139.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int propertyRefSize = rowRefSizeArray [(int)TableIndices.PropertyPtr] > 2 ? 4 : rowRefSizeArray [(int)TableIndices.Property]; " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int typeDefOrRefRefSize = PEFileReader.ComputeCodedTokenSize (TypeDefOrRefTag.LargeRowSize' rowCountArray' TypeDefOrRefTag.TablesReferenced); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasConstantRefSize = PEFileReader.ComputeCodedTokenSize (HasConstantTag.LargeRowSize' rowCountArray' HasConstantTag.TablesReferenced); " is 138.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasCustomAttributeRefSize = PEFileReader.ComputeCodedTokenSize (HasCustomAttributeTag.LargeRowSize' rowCountArray' HasCustomAttributeTag.TablesReferenced); " is 159.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasFieldMarshalRefSize = PEFileReader.ComputeCodedTokenSize (HasFieldMarshalTag.LargeRowSize' rowCountArray' HasFieldMarshalTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasDeclSecurityRefSize = PEFileReader.ComputeCodedTokenSize (HasDeclSecurityTag.LargeRowSize' rowCountArray' HasDeclSecurityTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int memberRefParentRefSize = PEFileReader.ComputeCodedTokenSize (MemberRefParentTag.LargeRowSize' rowCountArray' MemberRefParentTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int hasSemanticsRefSize = PEFileReader.ComputeCodedTokenSize (HasSemanticsTag.LargeRowSize' rowCountArray' HasSemanticsTag.TablesReferenced); " is 141.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int methodDefOrRefRefSize = PEFileReader.ComputeCodedTokenSize (MethodDefOrRefTag.LargeRowSize' rowCountArray' MethodDefOrRefTag.TablesReferenced); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int memberForwardedRefSize = PEFileReader.ComputeCodedTokenSize (MemberForwardedTag.LargeRowSize' rowCountArray' MemberForwardedTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int implementationRefSize = PEFileReader.ComputeCodedTokenSize (ImplementationTag.LargeRowSize' rowCountArray' ImplementationTag.TablesReferenced); " is 147.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int customAttributeTypeRefSize = PEFileReader.ComputeCodedTokenSize (CustomAttributeTypeTag.LargeRowSize' rowCountArray' CustomAttributeTypeTag.TablesReferenced); " is 162.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int resolutionScopeRefSize = PEFileReader.ComputeCodedTokenSize (ResolutionScopeTag.LargeRowSize' rowCountArray' ResolutionScopeTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int typeOrMethodDefRefSize = PEFileReader.ComputeCodedTokenSize (TypeOrMethodDefTag.LargeRowSize' rowCountArray' TypeOrMethodDefTag.TablesReferenced); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int stringHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.StringHeapLarge) == HeapSizeFlag.StringHeapLarge ? 4 : 2; " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int guidHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.GUIDHeapLarge) == HeapSizeFlag.GUIDHeapLarge ? 4 : 2; " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	int blobHeapRefSize = (this.MetadataTableHeader.HeapSizeFlags & HeapSizeFlag.BlobHeapLarge) == HeapSizeFlag.BlobHeapLarge ? 4 : 2; " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ModuleTable = new ModuleTableReader (rowCountArray [(int)TableIndices.Module]' stringHeapRefSize' guidHeapRefSize' currentPointer); " is 136.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.TypeRefTable = new TypeRefTableReader (rowCountArray [(int)TableIndices.TypeRef]' resolutionScopeRefSize' stringHeapRefSize' currentPointer); " is 146.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.TypeDefTable = new TypeDefTableReader (rowCountArray [(int)TableIndices.TypeDef]' fieldRefSize' methodRefSize' typeDefOrRefRefSize' stringHeapRefSize' currentPointer); " is 172.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldPtrTable = new FieldPtrTableReader (rowCountArray [(int)TableIndices.FieldPtr]' rowRefSizeArray [(int)TableIndices.Field]' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldTable = new FieldTableReader (rowCountArray [(int)TableIndices.Field]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 133.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodPtrTable = new MethodPtrTableReader (rowCountArray [(int)TableIndices.MethodPtr]' rowRefSizeArray [(int)TableIndices.Method]' currentPointer); " is 153.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodTable = new MethodTableReader (rowCountArray [(int)TableIndices.Method]' paramRefSize' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 150.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ParamPtrTable = new ParamPtrTableReader (rowCountArray [(int)TableIndices.ParamPtr]' rowRefSizeArray [(int)TableIndices.Param]' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.InterfaceImplTable = new InterfaceImplTableReader (rowCountArray [(int)TableIndices.InterfaceImpl]' rowRefSizeArray [(int)TableIndices.TypeDef]' typeDefOrRefRefSize' currentPointer); " is 187.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MemberRefTable = new MemberRefTableReader (rowCountArray [(int)TableIndices.MemberRef]' memberRefParentRefSize' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 169.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ConstantTable = new ConstantTableReader (rowCountArray [(int)TableIndices.Constant]' hasConstantRefSize' blobHeapRefSize' currentPointer); " is 143.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.CustomAttributeTable = new CustomAttributeTableReader (rowCountArray [(int)TableIndices.CustomAttribute]' hasCustomAttributeRefSize' customAttributeTypeRefSize' blobHeapRefSize' currentPointer); " is 199.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldMarshalTable = new FieldMarshalTableReader (rowCountArray [(int)TableIndices.FieldMarshal]' hasFieldMarshalRefSize' blobHeapRefSize' currentPointer); " is 159.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.DeclSecurityTable = new DeclSecurityTableReader (rowCountArray [(int)TableIndices.DeclSecurity]' hasDeclSecurityRefSize' blobHeapRefSize' currentPointer); " is 159.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ClassLayoutTable = new ClassLayoutTableReader (rowCountArray [(int)TableIndices.ClassLayout]' rowRefSizeArray [(int)TableIndices.TypeDef]' currentPointer); " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldLayoutTable = new FieldLayoutTableReader (rowCountArray [(int)TableIndices.FieldLayout]' rowRefSizeArray [(int)TableIndices.Field]' currentPointer); " is 158.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.StandAloneSigTable = new StandAloneSigTableReader (rowCountArray [(int)TableIndices.StandAloneSig]' blobHeapRefSize' currentPointer); " is 138.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.EventMapTable = new EventMapTableReader (rowCountArray [(int)TableIndices.EventMap]' rowRefSizeArray [(int)TableIndices.TypeDef]' eventRefSize' currentPointer); " is 165.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.EventPtrTable = new EventPtrTableReader (rowCountArray [(int)TableIndices.EventPtr]' rowRefSizeArray [(int)TableIndices.Event]' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.EventTable = new EventTableReader (rowCountArray [(int)TableIndices.Event]' typeDefOrRefRefSize' stringHeapRefSize' currentPointer); " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.PropertyMapTable = new PropertyMapTableReader (rowCountArray [(int)TableIndices.PropertyMap]' rowRefSizeArray [(int)TableIndices.TypeDef]' propertyRefSize' currentPointer); " is 177.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.PropertyPtrTable = new PropertyPtrTableReader (rowCountArray [(int)TableIndices.PropertyPtr]' rowRefSizeArray [(int)TableIndices.Property]' currentPointer); " is 161.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.PropertyTable = new PropertyTableReader (rowCountArray [(int)TableIndices.Property]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodSemanticsTable = new MethodSemanticsTableReader (rowCountArray [(int)TableIndices.MethodSemantics]' rowRefSizeArray [(int)TableIndices.Method]' hasSemanticsRefSize' currentPointer); " is 192.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodImplTable = new MethodImplTableReader (rowCountArray [(int)TableIndices.MethodImpl]' rowRefSizeArray [(int)TableIndices.TypeDef]' methodDefOrRefRefSize' currentPointer); " is 180.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ModuleRefTable = new ModuleRefTableReader (rowCountArray [(int)TableIndices.ModuleRef]' stringHeapRefSize' currentPointer); " is 128.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.TypeSpecTable = new TypeSpecTableReader (rowCountArray [(int)TableIndices.TypeSpec]' blobHeapRefSize' currentPointer); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ImplMapTable = new ImplMapTableReader (rowCountArray [(int)TableIndices.ImplMap]' rowRefSizeArray [(int)TableIndices.ModuleRef]' memberForwardedRefSize' stringHeapRefSize' currentPointer); " is 193.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FieldRVATable = new FieldRVATableReader (rowCountArray [(int)TableIndices.FieldRva]' rowRefSizeArray [(int)TableIndices.Field]' currentPointer); " is 149.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyTable = new AssemblyTableReader (rowCountArray [(int)TableIndices.Assembly]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 142.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyProcessorTable = new AssemblyProcessorTableReader (rowCountArray [(int)TableIndices.AssemblyProcessor]' currentPointer); " is 133.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyRefTable = new AssemblyRefTableReader (rowCountArray [(int)TableIndices.AssemblyRef]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 151.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyRefProcessorTable = new AssemblyRefProcessorTableReader (rowCountArray [(int)TableIndices.AssemblyRefProcessor]' rowRefSizeArray [(int)TableIndices.AssemblyRef]' currentPointer); " is 191.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.AssemblyRefOSTable = new AssemblyRefOSTableReader (rowCountArray [(int)TableIndices.AssemblyRefOS]' rowRefSizeArray [(int)TableIndices.AssemblyRef]' currentPointer); " is 170.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.FileTable = new FileTableReader (rowCountArray [(int)TableIndices.File]' stringHeapRefSize' blobHeapRefSize' currentPointer); " is 130.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ExportedTypeTable = new ExportedTypeTableReader (rowCountArray [(int)TableIndices.ExportedType]' implementationRefSize' stringHeapRefSize' currentPointer); " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.ManifestResourceTable = new ManifestResourceTableReader (rowCountArray [(int)TableIndices.ManifestResource]' implementationRefSize' stringHeapRefSize' currentPointer); " is 172.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.NestedClassTable = new NestedClassTableReader (rowCountArray [(int)TableIndices.NestedClass]' rowRefSizeArray [(int)TableIndices.TypeDef]' currentPointer); " is 160.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.GenericParamTable = new GenericParamTableReader (rowCountArray [(int)TableIndices.GenericParam]' typeOrMethodDefRefSize' stringHeapRefSize' currentPointer); " is 161.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.MethodSpecTable = new MethodSpecTableReader (rowCountArray [(int)TableIndices.MethodSpec]' methodDefOrRefRefSize' blobHeapRefSize' currentPointer); " is 152.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "	this.GenericParamConstraintTable = new GenericParamConstraintTableReader (rowCountArray [(int)TableIndices.GenericParamConstraint]' rowRefSizeArray [(int)TableIndices.GenericParam]' typeDefOrRefRefSize' currentPointer); " is 219.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The length of the statement  "		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' 0' MetadataReaderErrorKind.MetadataTablesTooSmall); " is 123.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataLevelData,The length of the statement  "	if (!this.ReadMetadataTableInformation (ref memReader) || !this.ProcessAndCacheMetadataTableBlocks (memReader.RemainingMemoryBlock)) { " is 134.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetFieldInformation,The length of the statement  "		fieldCount = (this.UseFieldPtrTable ? this.FieldPtrTable.NumberOfRows : this.FieldTable.NumberOfRows) - fieldStartRow + 1; " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodInformation,The length of the statement  "		methodCount = (this.UseMethodPtrTable ? this.MethodPtrTable.NumberOfRows : this.MethodTable.NumberOfRows) - methodStartRow + 1; " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetEventInformation,The length of the statement  "		eventCount = (this.UseEventPtrTable ? this.EventPtrTable.NumberOfRows : this.EventTable.NumberOfRows) - eventStartRow + 1; " is 122.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetPropertyInformation,The length of the statement  "		propertyCount = (this.UsePropertyPtrTable ? this.PropertyPtrTable.NumberOfRows : this.PropertyTable.NumberOfRows) - propertyStartRow + 1; " is 137.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetParamInformation,The length of the statement  "		paramRowCount = (this.UseParamPtrTable ? this.ParamPtrTable.NumberOfRows : this.ParamTable.NumberOfRows) - paramStartRow + 1; " is 125.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetSmallSEHEntries,The length of the statement  "		retSEHEntries [i] = new SEHTableEntry (sehFlags' tryOffset' tryLength' handlerOffset' handlerLength' classTokenOrFilterOffset); " is 127.
Long Statement,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetFatSEHEntries,The length of the statement  "		retSEHEntries [i] = new SEHTableEntry (sehFlags' tryOffset' tryLength' handlerOffset' handlerLength' classTokenOrFilterOffset); " is 127.
Complex Conditional,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,IsEndofIdentifier,The conditional expression  "c == '[' || c == ']' || c == '*' || c == '+' || c == ''' || c == '&' || c == ' ' || char.IsWhiteSpace (c)"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The conditional expression  "tKey != objectKey && tKey != valueTypeKey && tKey != enumKey && tKey != multicastDelegateKey && tKey != arrayKey && tKey != attributeKey && tKey != delegateKey && tKey != iAsyncResultKey && tKey != iCloneableKey && tKey != asyncCallbackKey && tKey != attributeUsageAttributeKey && tKey != paramArrayAttributeKey && tKey != booleanKey && tKey != byteKey && tKey != charKey && tKey != sByteKey && tKey != int16Key && tKey != uint16Key && tKey != int32Key && tKey != uint32Key && tKey != int64Key && tKey != uint64Key && tKey != stringKey && tKey != intPtrKey && tKey != uintPtrKey && tKey != singleKey && tKey != doubleKey && tKey != typedReferenceKey && tKey != typeKey && tKey != dateTimeKey && tKey != decimalKey && tKey != dbNullKey && tKey != runtimeArgumentHandleKey && tKey != runtimeFieldHandleKey && tKey != runtimeMethodHandleKey && tKey != runtimeTypeHandleKey && tKey != argIteratorKey && tKey != voidKey"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,RVAsInSameSection,The conditional expression  "sectionHeaderIter.VirtualAddress <= RVA1 && RVA1 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize && sectionHeaderIter.VirtualAddress <= RVA2 && RVA2 < sectionHeaderIter.VirtualAddress + sectionHeaderIter.VirtualSize"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadCORModuleLevelData,The conditional expression  "!this.ReadMetadataHeader (ref memReader) || !this.ReadStorageHeader (ref memReader) || !this.ReadStreamHeaders (ref memReader) || !this.ProcessAndCacheStreams (ref metadataRoot)"  is complex.
Complex Conditional,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataRoot,The conditional expression  "!this.ReadMetadataHeader (ref memReader) || !this.ReadStorageHeader (ref memReader) || !this.ReadStreamHeaders (ref memReader) || !this.ProcessAndCacheStreams (ref metadataRoot)"  is complex.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanVersion,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenModule,The method has an empty catch block.
Empty Catch Block,Microsoft.Cci,PeReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ModuleReadWriteFactory.cs,OpenSnapshot,The method has an empty catch block.
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 3 <= this.Length && string.Compare (name' currPtr' "yes"' 0' 3' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 3;  	value = true;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 3 <= this.Length && string.Compare (name' currPtr' "yes"' 0' 3' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 3;  	value = true;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 3 <= this.Length && string.Compare (name' currPtr' "yes"' 0' 3' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 3;  	value = true;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: this.CurrentIndex += 3;  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 2 <= this.Length && string.Compare (name' currPtr' "no"' 0' 2' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 2;  	value = false;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 2 <= this.Length && string.Compare (name' currPtr' "no"' 0' 2' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 2;  	value = false;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: if (currPtr + 2 <= this.Length && string.Compare (name' currPtr' "no"' 0' 2' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 2;  	value = false;  	return true;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanYesNo,The following statement contains a magic number: this.CurrentIndex += 2;  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare (name' currPtr' "null"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 4;  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare (name' currPtr' "null"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 4;  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 4 <= this.Length && string.Compare (name' currPtr' "null"' 0' 4' StringComparison.OrdinalIgnoreCase) == 0) {  	this.CurrentIndex += 4;  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: this.CurrentIndex += 4;  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: if (currPtr + 16 > this.Length) {  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: this.CurrentIndex += 16;  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: for (int i = 7; i >= 0; --i) {  	pkToken [i] = (byte)result;  	result >>= 8;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: for (int i = 7; i >= 0; --i) {  	pkToken [i] = (byte)result;  	result >>= 8;  }  
Magic Number,Microsoft.Cci.MetadataReader.ObjectModelImplementation,TypeNameParser,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ScanPublicKeyToken,The following statement contains a magic number: result >>= 8;  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (short)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (int)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (long)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (ushort)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (uint)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (ulong)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (float)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (double)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following statement contains a magic number: if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  	this.decodeFailed = true;  	return (char)0;  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.UInt8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt64:  case PrimitiveTypeCode.Float32:  case PrimitiveTypeCode.Float64:  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  	return new ConstantExpression (type' this.GetPrimitiveValue (type));  case PrimitiveTypeCode.String:  	return new ConstantExpression (type' this.GetSerializedString ());  default:  	var typeDef = type.ResolvedType;  	if (!(typeDef is Dummy)) {  		if (typeDef.IsEnum)  			return new ConstantExpression (type' this.GetPrimitiveValue (typeDef.UnderlyingType));  		type = typeDef;  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemObject)) {  		ITypeReference /*?*/underlyingType = this.GetFieldOrPropType ();  		if (underlyingType == null)  			return null;  		return this.ReadSerializedValue (underlyingType);  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemType)) {  		string /*?*/typeNameStr = this.GetSerializedString ();  		if (typeNameStr == null) {  			return new ConstantExpression (this.PEFileToObjectModel.PlatformType.SystemType' null);  		}  		return new TypeOfExpression (this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeNameStr));  	}  	var vectorType = type as IArrayTypeReference;  	if (vectorType != null) {  		ITypeReference /*?*/elementType = vectorType.ElementType;  		if (elementType == null) {  			this.decodeFailed = true;  			return null;  		}  		int size = this.SignatureMemoryReader.ReadInt32 ();  		if (size == -1) {  			return new ConstantExpression (vectorType' null);  		}  		ExpressionBase[] arrayElements = new ExpressionBase[size];  		for (int i = 0; i < size; ++i) {  			ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  			if (expr == null) {  				this.decodeFailed = true;  				return null;  			}  			arrayElements [i] = expr;  		}  		return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  	}  	else {  		// If the metadata is correct' type must be a reference to an enum type.  		// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  		// We'll let the host deal with this by guessing  		ITypeReference underlyingType;  		switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  		case 1:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  			break;  		case 2:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  			break;  		case 4:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  			break;  		case 8:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  			break;  		default:  			this.decodeFailed = true;  			this.morePermutationsArePossible = false;  			return new ConstantExpression (type' 0);  		}  		return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.UInt8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt64:  case PrimitiveTypeCode.Float32:  case PrimitiveTypeCode.Float64:  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  	return new ConstantExpression (type' this.GetPrimitiveValue (type));  case PrimitiveTypeCode.String:  	return new ConstantExpression (type' this.GetSerializedString ());  default:  	var typeDef = type.ResolvedType;  	if (!(typeDef is Dummy)) {  		if (typeDef.IsEnum)  			return new ConstantExpression (type' this.GetPrimitiveValue (typeDef.UnderlyingType));  		type = typeDef;  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemObject)) {  		ITypeReference /*?*/underlyingType = this.GetFieldOrPropType ();  		if (underlyingType == null)  			return null;  		return this.ReadSerializedValue (underlyingType);  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemType)) {  		string /*?*/typeNameStr = this.GetSerializedString ();  		if (typeNameStr == null) {  			return new ConstantExpression (this.PEFileToObjectModel.PlatformType.SystemType' null);  		}  		return new TypeOfExpression (this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeNameStr));  	}  	var vectorType = type as IArrayTypeReference;  	if (vectorType != null) {  		ITypeReference /*?*/elementType = vectorType.ElementType;  		if (elementType == null) {  			this.decodeFailed = true;  			return null;  		}  		int size = this.SignatureMemoryReader.ReadInt32 ();  		if (size == -1) {  			return new ConstantExpression (vectorType' null);  		}  		ExpressionBase[] arrayElements = new ExpressionBase[size];  		for (int i = 0; i < size; ++i) {  			ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  			if (expr == null) {  				this.decodeFailed = true;  				return null;  			}  			arrayElements [i] = expr;  		}  		return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  	}  	else {  		// If the metadata is correct' type must be a reference to an enum type.  		// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  		// We'll let the host deal with this by guessing  		ITypeReference underlyingType;  		switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  		case 1:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  			break;  		case 2:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  			break;  		case 4:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  			break;  		case 8:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  			break;  		default:  			this.decodeFailed = true;  			this.morePermutationsArePossible = false;  			return new ConstantExpression (type' 0);  		}  		return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  case PrimitiveTypeCode.Int16:  case PrimitiveTypeCode.Int32:  case PrimitiveTypeCode.Int64:  case PrimitiveTypeCode.UInt8:  case PrimitiveTypeCode.UInt16:  case PrimitiveTypeCode.UInt32:  case PrimitiveTypeCode.UInt64:  case PrimitiveTypeCode.Float32:  case PrimitiveTypeCode.Float64:  case PrimitiveTypeCode.Boolean:  case PrimitiveTypeCode.Char:  	return new ConstantExpression (type' this.GetPrimitiveValue (type));  case PrimitiveTypeCode.String:  	return new ConstantExpression (type' this.GetSerializedString ());  default:  	var typeDef = type.ResolvedType;  	if (!(typeDef is Dummy)) {  		if (typeDef.IsEnum)  			return new ConstantExpression (type' this.GetPrimitiveValue (typeDef.UnderlyingType));  		type = typeDef;  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemObject)) {  		ITypeReference /*?*/underlyingType = this.GetFieldOrPropType ();  		if (underlyingType == null)  			return null;  		return this.ReadSerializedValue (underlyingType);  	}  	if (TypeHelper.TypesAreEquivalent (type' this.PEFileToObjectModel.PlatformType.SystemType)) {  		string /*?*/typeNameStr = this.GetSerializedString ();  		if (typeNameStr == null) {  			return new ConstantExpression (this.PEFileToObjectModel.PlatformType.SystemType' null);  		}  		return new TypeOfExpression (this.PEFileToObjectModel' this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeNameStr));  	}  	var vectorType = type as IArrayTypeReference;  	if (vectorType != null) {  		ITypeReference /*?*/elementType = vectorType.ElementType;  		if (elementType == null) {  			this.decodeFailed = true;  			return null;  		}  		int size = this.SignatureMemoryReader.ReadInt32 ();  		if (size == -1) {  			return new ConstantExpression (vectorType' null);  		}  		ExpressionBase[] arrayElements = new ExpressionBase[size];  		for (int i = 0; i < size; ++i) {  			ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  			if (expr == null) {  				this.decodeFailed = true;  				return null;  			}  			arrayElements [i] = expr;  		}  		return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  	}  	else {  		// If the metadata is correct' type must be a reference to an enum type.  		// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  		// We'll let the host deal with this by guessing  		ITypeReference underlyingType;  		switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  		case 1:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  			break;  		case 2:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  			break;  		case 4:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  			break;  		case 8:  			underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  			break;  		default:  			this.decodeFailed = true;  			this.morePermutationsArePossible = false;  			return new ConstantExpression (type' 0);  		}  		return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: if (vectorType != null) {  	ITypeReference /*?*/elementType = vectorType.ElementType;  	if (elementType == null) {  		this.decodeFailed = true;  		return null;  	}  	int size = this.SignatureMemoryReader.ReadInt32 ();  	if (size == -1) {  		return new ConstantExpression (vectorType' null);  	}  	ExpressionBase[] arrayElements = new ExpressionBase[size];  	for (int i = 0; i < size; ++i) {  		ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  		if (expr == null) {  			this.decodeFailed = true;  			return null;  		}  		arrayElements [i] = expr;  	}  	return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  }  else {  	// If the metadata is correct' type must be a reference to an enum type.  	// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  	// We'll let the host deal with this by guessing  	ITypeReference underlyingType;  	switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  	case 1:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  		break;  	case 2:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  		break;  	case 4:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  		break;  	case 8:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  		break;  	default:  		this.decodeFailed = true;  		this.morePermutationsArePossible = false;  		return new ConstantExpression (type' 0);  	}  	return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: if (vectorType != null) {  	ITypeReference /*?*/elementType = vectorType.ElementType;  	if (elementType == null) {  		this.decodeFailed = true;  		return null;  	}  	int size = this.SignatureMemoryReader.ReadInt32 ();  	if (size == -1) {  		return new ConstantExpression (vectorType' null);  	}  	ExpressionBase[] arrayElements = new ExpressionBase[size];  	for (int i = 0; i < size; ++i) {  		ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  		if (expr == null) {  			this.decodeFailed = true;  			return null;  		}  		arrayElements [i] = expr;  	}  	return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  }  else {  	// If the metadata is correct' type must be a reference to an enum type.  	// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  	// We'll let the host deal with this by guessing  	ITypeReference underlyingType;  	switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  	case 1:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  		break;  	case 2:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  		break;  	case 4:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  		break;  	case 8:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  		break;  	default:  		this.decodeFailed = true;  		this.morePermutationsArePossible = false;  		return new ConstantExpression (type' 0);  	}  	return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: if (vectorType != null) {  	ITypeReference /*?*/elementType = vectorType.ElementType;  	if (elementType == null) {  		this.decodeFailed = true;  		return null;  	}  	int size = this.SignatureMemoryReader.ReadInt32 ();  	if (size == -1) {  		return new ConstantExpression (vectorType' null);  	}  	ExpressionBase[] arrayElements = new ExpressionBase[size];  	for (int i = 0; i < size; ++i) {  		ExpressionBase /*?*/expr = this.ReadSerializedValue (elementType);  		if (expr == null) {  			this.decodeFailed = true;  			return null;  		}  		arrayElements [i] = expr;  	}  	return new ArrayExpression (vectorType' new EnumerableArrayWrapper<ExpressionBase' IMetadataExpression> (arrayElements' Dummy.Expression));  }  else {  	// If the metadata is correct' type must be a reference to an enum type.  	// Problem is' that without resolving this reference' it is not possible to know how many bytes to consume for the enum value  	// We'll let the host deal with this by guessing  	ITypeReference underlyingType;  	switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  	case 1:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  		break;  	case 2:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  		break;  	case 4:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  		break;  	case 8:  		underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  		break;  	default:  		this.decodeFailed = true;  		this.morePermutationsArePossible = false;  		return new ConstantExpression (type' 0);  	}  	return new ConstantExpression (type' this.GetPrimitiveValue (underlyingType));  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  case 1:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  	break;  case 2:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  	break;  case 4:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  	break;  case 8:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  	break;  default:  	this.decodeFailed = true;  	this.morePermutationsArePossible = false;  	return new ConstantExpression (type' 0);  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  case 1:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  	break;  case 2:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  	break;  case 4:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  	break;  case 8:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  	break;  default:  	this.decodeFailed = true;  	this.morePermutationsArePossible = false;  	return new ConstantExpression (type' 0);  }  
Magic Number,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,ReadSerializedValue,The following statement contains a magic number: switch (this.PEFileToObjectModel.ModuleReader.metadataReaderHost.GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum (type)) {  case 1:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt8;  	break;  case 2:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt16;  	break;  case 4:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt32;  	break;  case 8:  	underlyingType = this.PEFileToObjectModel.PlatformType.SystemInt64;  	break;  default:  	this.decodeFailed = true;  	this.morePermutationsArePossible = false;  	return new ConstantExpression (type' 0);  }  
Magic Number,Microsoft.Cci.MetadataReader,CustomAttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,CustomAttributeDecoder,The following statement contains a magic number: if (2 <= (int)this.SignatureMemoryReader.RemainingBytes) {  	ushort numOfNamedArgs = this.SignatureMemoryReader.ReadUInt16 ();  	if (numOfNamedArgs > 0) {  		namedArgumentArray = new IMetadataNamedArgument[numOfNamedArgs];  		for (i = 0; i < numOfNamedArgs; ++i) {  			if (0 >= (int)this.SignatureMemoryReader.RemainingBytes)  				break;  			bool isField = this.SignatureMemoryReader.ReadByte () == SerializationType.Field;  			ITypeReference /*?*/memberType = this.GetFieldOrPropType ();  			if (memberType == null) {  				//  Error...  				return;  			}  			string /*?*/memberStr = this.GetSerializedString ();  			if (memberStr == null)  				return;  			IName memberName = this.PEFileToObjectModel.NameTable.GetNameFor (memberStr);  			ExpressionBase /*?*/value = this.ReadSerializedValue (memberType);  			if (value == null) {  				//  Error...  				return;  			}  			ITypeReference /*?*/moduleTypeRef = attributeConstructor.ContainingType;  			if (moduleTypeRef == null) {  				//  Error...  				return;  			}  			FieldOrPropertyNamedArgumentExpression namedArg = new FieldOrPropertyNamedArgumentExpression (memberName' moduleTypeRef' isField' memberType' value);  			namedArgumentArray [i] = namedArg;  		}  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: lock (GlobalLock.LockingObject) {  	INameTable nameTable = this.NameTable;  	PeReader peReader = this.ModuleReader;  	int systemKey = nameTable.System.UniqueKey;  	int objectKey = nameTable.Object.UniqueKey;  	int valueTypeKey = nameTable.ValueType.UniqueKey;  	int enumKey = nameTable.Enum.UniqueKey;  	int multicastDelegateKey = nameTable.MulticastDelegate.UniqueKey;  	int arrayKey = nameTable.Array.UniqueKey;  	int attributeKey = nameTable.Attribute.UniqueKey;  	int delegateKey = nameTable.Delegate.UniqueKey;  	int iAsyncResultKey = peReader.IAsyncResult.UniqueKey;  	int iCloneableKey = peReader.ICloneable.UniqueKey;  	int asyncCallbackKey = peReader.AsyncCallback.UniqueKey;  	int attributeUsageAttributeKey = nameTable.AttributeUsageAttribute.UniqueKey;  	int paramArrayAttributeKey = peReader.ParamArrayAttribute.UniqueKey;  	int booleanKey = nameTable.Boolean.UniqueKey;  	int byteKey = nameTable.Byte.UniqueKey;  	int charKey = nameTable.Char.UniqueKey;  	int sByteKey = nameTable.SByte.UniqueKey;  	int int16Key = nameTable.Int16.UniqueKey;  	int uint16Key = nameTable.UInt16.UniqueKey;  	int int32Key = nameTable.Int32.UniqueKey;  	int uint32Key = nameTable.UInt32.UniqueKey;  	int int64Key = nameTable.Int64.UniqueKey;  	int uint64Key = nameTable.UInt64.UniqueKey;  	int stringKey = nameTable.String.UniqueKey;  	int intPtrKey = nameTable.IntPtr.UniqueKey;  	int uintPtrKey = nameTable.UIntPtr.UniqueKey;  	int singleKey = nameTable.Single.UniqueKey;  	int doubleKey = nameTable.Double.UniqueKey;  	int typedReferenceKey = nameTable.TypedReference.UniqueKey;  	int typeKey = nameTable.Type.UniqueKey;  	int dateTimeKey = nameTable.DateTime.UniqueKey;  	int decimalKey = nameTable.Decimal.UniqueKey;  	int dbNullKey = nameTable.DBNull.UniqueKey;  	int runtimeArgumentHandleKey = peReader.RuntimeArgumentHandle.UniqueKey;  	int runtimeFieldHandleKey = peReader.RuntimeFieldHandle.UniqueKey;  	int runtimeMethodHandleKey = peReader.RuntimeMethodHandle.UniqueKey;  	int runtimeTypeHandleKey = peReader.RuntimeTypeHandle.UniqueKey;  	int argIteratorKey = peReader.ArgIterator.UniqueKey;  	int voidKey = nameTable.Void.UniqueKey;  	int mscorlibKey = peReader.Mscorlib.UniqueKey;  	int systemRuntimeKey = peReader.System_Runtime.UniqueKey;  	TypeRefTableReader trTable = this.PEFileReader.TypeRefTable;  	var hitCounts = new uint[trTable.NumberOfRows];  	for (uint i = 1; i <= trTable.NumberOfRows; i++) {  		TypeRefRow tr = trTable [i];  		IName nsName = this.GetNameFromOffset (tr.Namespace);  		if (nsName.UniqueKey != systemKey)  			continue;  		int tKey = this.GetNameFromOffset (tr.Name).UniqueKey;  		//Look for a lot of different mscorlib types' since an assembly need not reference System.Object or any particular type.  		if (tKey != objectKey && tKey != valueTypeKey && tKey != enumKey && tKey != multicastDelegateKey && tKey != arrayKey && tKey != attributeKey && tKey != delegateKey && tKey != iAsyncResultKey && tKey != iCloneableKey && tKey != asyncCallbackKey && tKey != attributeUsageAttributeKey && tKey != paramArrayAttributeKey && tKey != booleanKey && tKey != byteKey && tKey != charKey && tKey != sByteKey && tKey != int16Key && tKey != uint16Key && tKey != int32Key && tKey != uint32Key && tKey != int64Key && tKey != uint64Key && tKey != stringKey && tKey != intPtrKey && tKey != uintPtrKey && tKey != singleKey && tKey != doubleKey && tKey != typedReferenceKey && tKey != typeKey && tKey != dateTimeKey && tKey != decimalKey && tKey != dbNullKey && tKey != runtimeArgumentHandleKey && tKey != runtimeFieldHandleKey && tKey != runtimeMethodHandleKey && tKey != runtimeTypeHandleKey && tKey != argIteratorKey && tKey != voidKey)  			continue;  		uint resolutionScopeKind = (tr.ResolutionScope & TokenTypeIds.TokenTypeMask);  		if (resolutionScopeKind != TokenTypeIds.AssemblyRef)  			continue;  		uint resolutionScopeRowId = (tr.ResolutionScope & TokenTypeIds.RIDMask);  		//Just because this reference looks like a mscorlib type' does not mean that it actually is one. Badly behaved assemblies might reuse mscorlib names.  		//We therefore count the number of references and hope that mscorlib has a majority.  		hitCounts [resolutionScopeRowId - 1]++;  		if (tKey == enumKey)  			this.SystemEnumAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  		else if (tKey == valueTypeKey)  			this.SystemValueTypeAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  		else if (tKey == multicastDelegateKey)  			this.SystemMulticastDelegateAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  		else if (tKey == typeKey)  			this.SystemTypeAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  		else if (tKey == paramArrayAttributeKey)  			this.SystemParamArrayAttributeAssembly = this.AssemblyReferenceArray [resolutionScopeRowId];  	}  	uint maxHits = 0;  	uint rowWithMaxHits = 0;  	for (uint i = 0; i < hitCounts.Length; i++) {  		if (hitCounts [i] > maxHits) {  			maxHits = hitCounts [i];  			rowWithMaxHits = i;  		}  	}  	if (maxHits > 0) {  		return this.AssemblyReferenceArray [rowWithMaxHits + 1].AssemblyIdentity;  	}  	TypeDefTableReader tdTable = this.PEFileReader.TypeDefTable;  	for (uint i = 1; i <= tdTable.NumberOfRows; i++) {  		TypeDefRow td = tdTable [i];  		IName nsName = this.GetNameFromOffset (td.Namespace);  		if (nsName.UniqueKey != systemKey)  			continue;  		int tKey = this.GetNameFromOffset (td.Name).UniqueKey;  		//if you're mscorlib' you have to define System.Object  		if (tKey != objectKey)  			continue;  		AssemblyIdentity /*?*/result = this.Module.ModuleIdentity as AssemblyIdentity;  		if (result != null)  			return result;  		//TODO: error  		break;  	}  	AssemblyRefTableReader arTable = this.PEFileReader.AssemblyRefTable;  	for (uint i = 1; i <= arTable.NumberOfRows; i++) {  		AssemblyRefRow ar = arTable [i];  		int key = this.GetNameFromOffset (ar.Name).UniqueKey;  		if (key != systemRuntimeKey)  			continue;  		var identity = this.AssemblyReferenceArray [i].AssemblyIdentity;  		if (identity.Version.Major >= 4)  			return identity;  	}  	for (uint i = 1; i <= arTable.NumberOfRows; i++) {  		AssemblyRefRow ar = arTable [i];  		int key = this.GetNameFromOffset (ar.Name).UniqueKey;  		if (key != mscorlibKey)  			continue;  		return this.AssemblyReferenceArray [i].AssemblyIdentity;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: for (uint i = 1; i <= arTable.NumberOfRows; i++) {  	AssemblyRefRow ar = arTable [i];  	int key = this.GetNameFromOffset (ar.Name).UniqueKey;  	if (key != systemRuntimeKey)  		continue;  	var identity = this.AssemblyReferenceArray [i].AssemblyIdentity;  	if (identity.Version.Major >= 4)  		return identity;  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCoreAssemblySymbolicIdentity,The following statement contains a magic number: if (identity.Version.Major >= 4)  	return identity;  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The following statement contains a magic number: for (uint i = 1; i <= numberOfAssemblyReferences; ++i) {  	AssemblyRefRow assemblyRefRow = this.PEFileReader.AssemblyRefTable [i];  	IName assemblyRefName = this.GetNameFromOffset (assemblyRefRow.Name);  	IName cultureName = this.GetNameFromOffset (assemblyRefRow.Culture);  	Version version = new Version (assemblyRefRow.MajorVersion' assemblyRefRow.MinorVersion' assemblyRefRow.BuildNumber' assemblyRefRow.RevisionNumber);  	byte[] publicKeyTokenArray = TypeCache.EmptyByteArray;  	if (assemblyRefRow.PublicKeyOrToken != 0) {  		var publicKeyOrTokenArray = this.PEFileReader.BlobStream [assemblyRefRow.PublicKeyOrToken];  		if ((assemblyRefRow.Flags & AssemblyFlags.PublicKey) == AssemblyFlags.PublicKey && publicKeyOrTokenArray.Length > 0) {  			publicKeyTokenArray = UnitHelper.ComputePublicKeyToken (publicKeyOrTokenArray);  		}  		else {  			publicKeyTokenArray = publicKeyOrTokenArray;  		}  		if (publicKeyTokenArray.Length != 8) {  			//  Error  		}  	}  	AssemblyIdentity assemblyIdentity = new AssemblyIdentity (assemblyRefName' cultureName.Value' version' publicKeyTokenArray' string.Empty);  	AssemblyReference assemblyReference = new AssemblyReference (this' i' assemblyIdentity' assemblyRefRow.Flags);  	assemblyRefList [i] = assemblyReference;  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The following statement contains a magic number: if (assemblyRefRow.PublicKeyOrToken != 0) {  	var publicKeyOrTokenArray = this.PEFileReader.BlobStream [assemblyRefRow.PublicKeyOrToken];  	if ((assemblyRefRow.Flags & AssemblyFlags.PublicKey) == AssemblyFlags.PublicKey && publicKeyOrTokenArray.Length > 0) {  		publicKeyTokenArray = UnitHelper.ComputePublicKeyToken (publicKeyOrTokenArray);  	}  	else {  		publicKeyTokenArray = publicKeyOrTokenArray;  	}  	if (publicKeyTokenArray.Length != 8) {  		//  Error  	}  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,LoadAssemblyReferences,The following statement contains a magic number: if (publicKeyTokenArray.Length != 8) {  	//  Error  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (resource.IsInExternalFile) {  	IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument (this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value);  	if (binaryDocumentMemoryBlock == null) {  		//  Error. File not present  		return TypeCache.EmptyByteArray;  	}  	return new EnumerableBinaryDocumentMemoryBlockWrapper (binaryDocumentMemoryBlock);  }  else {  	uint resOffset = this.PEFileReader.ManifestResourceTable.GetOffset (resource.ResourceRowId);  	if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4) {  		//  MDError:  		return TypeCache.EmptyByteArray;  	}  	uint len = this.PEFileReader.ResourceMemoryReader.PeekUInt32 ((int)resOffset);  	if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4 + len) {  		//  MDError:  		return TypeCache.EmptyByteArray;  	}  	return new EnumerableMemoryBlockWrapper (this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt (resOffset + sizeof(Int32)' len));  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (resource.IsInExternalFile) {  	IBinaryDocumentMemoryBlock /*?*/binaryDocumentMemoryBlock = this.ModuleReader.metadataReaderHost.OpenBinaryDocument (this.PEFileReader.BinaryDocumentMemoryBlock.BinaryDocument' resource.ExternalFile.FileName.Value);  	if (binaryDocumentMemoryBlock == null) {  		//  Error. File not present  		return TypeCache.EmptyByteArray;  	}  	return new EnumerableBinaryDocumentMemoryBlockWrapper (binaryDocumentMemoryBlock);  }  else {  	uint resOffset = this.PEFileReader.ManifestResourceTable.GetOffset (resource.ResourceRowId);  	if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4) {  		//  MDError:  		return TypeCache.EmptyByteArray;  	}  	uint len = this.PEFileReader.ResourceMemoryReader.PeekUInt32 ((int)resOffset);  	if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4 + len) {  		//  MDError:  		return TypeCache.EmptyByteArray;  	}  	return new EnumerableMemoryBlockWrapper (this.PEFileReader.ResourceMemoryReader.GetMemoryBlockAt (resOffset + sizeof(Int32)' len));  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4) {  	//  MDError:  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetResourceData,The following statement contains a magic number: if (this.PEFileReader.ResourceMemoryReader.Length < resOffset + 4 + len) {  	//  MDError:  	return TypeCache.EmptyByteArray;  }  
Magic Number,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The following statement contains a magic number: while (this.SignatureMemoryReader.NotEndOfBytes) {  	byte header = this.SignatureMemoryReader.PeekByte (0);  	if (header == ElementType.Pinned) {  		this.SignatureMemoryReader.SkipBytes (1);  		isPinned = true;  		continue;  	}  	if (header != ElementType.RequiredModifier && header != ElementType.OptionalModifier)  		break;  	this.SignatureMemoryReader.SkipBytes (1);  	uint typeDefOrRefEncoded = (uint)this.SignatureMemoryReader.ReadCompressedUInt32 ();  	uint typeToken = TypeDefOrRefTag.ConvertToToken (typeDefOrRefEncoded);  	uint tokenType = typeToken & TokenTypeIds.TokenTypeMask;  	uint typeRID = typeToken & TokenTypeIds.RIDMask;  	ITypeReference /*?*/typeRef = null;  	if (tokenType == TokenTypeIds.TypeDef)  		typeRef = this.PEFileToObjectModel.GetTypeDefinitionAtRow (typeRID);  	else if (tokenType == TokenTypeIds.TypeRef)  		typeRef = this.PEFileToObjectModel.GetTypeRefReferenceAtRow (typeRID);  	else  		typeRef = this.PEFileToObjectModel.GetTypeSpecReferenceAtRow (this.MetadataOwnerObject' typeRID).UnderlyingModuleTypeReference;  	if (typeRef == null) {  		//  Error...  		continue;  	}  	if (customModifier != null && customModifierList == null) {  		customModifierList = new List<ICustomModifier> (4);  		customModifierList.Add (customModifier);  	}  	customModifier = new CustomModifier (header == ElementType.OptionalModifier' typeRef);  	if (customModifierList != null)  		customModifierList.Add (customModifier);  }  
Magic Number,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The following statement contains a magic number: if (customModifier != null && customModifierList == null) {  	customModifierList = new List<ICustomModifier> (4);  	customModifierList.Add (customModifier);  }  
Magic Number,Microsoft.Cci.MetadataReader,SignatureConverter,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetCustomModifiers,The following statement contains a magic number: customModifierList = new List<ICustomModifier> (4);  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,WindowsRuntimeMetadataReaderHost,The following statement contains a magic number: Contract.Requires (pointerSize == 0 || pointerSize == 4 || pointerSize == 8);  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,WindowsRuntimeMetadataReaderHost,The following statement contains a magic number: Contract.Requires (pointerSize == 0 || pointerSize == 4 || pointerSize == 8);  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255))  	return this.CoreAssemblySymbolicIdentity;  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255))  	return this.CoreAssemblySymbolicIdentity;  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255))  	return this.CoreAssemblySymbolicIdentity;  
Magic Number,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,UnifyAssembly,The following statement contains a magic number: if (string.Equals (assemblyIdentity.Name.Value' "mscorlib"' StringComparison.OrdinalIgnoreCase) && assemblyIdentity.Version == new Version (255' 255' 255' 255))  	return this.CoreAssemblySymbolicIdentity;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	object /*?*/value = null;  	uint offset = (uint)memReader.Offset;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Nop:  	case OperationCode.Break:  		break;  	case OperationCode.Ldarg_0:  	case OperationCode.Ldarg_1:  	case OperationCode.Ldarg_2:  	case OperationCode.Ldarg_3:  		value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  		break;  	case OperationCode.Ldloc_0:  	case OperationCode.Ldloc_1:  	case OperationCode.Ldloc_2:  	case OperationCode.Ldloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  		break;  	case OperationCode.Stloc_0:  	case OperationCode.Stloc_1:  	case OperationCode.Stloc_2:  	case OperationCode.Stloc_3:  		value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  		break;  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  		value = this.GetParameter (memReader.ReadByte ());  		break;  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  		value = this.GetLocal (memReader.ReadByte ());  		break;  	case OperationCode.Ldnull:  		break;  	case OperationCode.Ldc_I4_M1:  		value = -1;  		break;  	case OperationCode.Ldc_I4_0:  		value = 0;  		break;  	case OperationCode.Ldc_I4_1:  		value = 1;  		break;  	case OperationCode.Ldc_I4_2:  		value = 2;  		break;  	case OperationCode.Ldc_I4_3:  		value = 3;  		break;  	case OperationCode.Ldc_I4_4:  		value = 4;  		break;  	case OperationCode.Ldc_I4_5:  		value = 5;  		break;  	case OperationCode.Ldc_I4_6:  		value = 6;  		break;  	case OperationCode.Ldc_I4_7:  		value = 7;  		break;  	case OperationCode.Ldc_I4_8:  		value = 8;  		break;  	case OperationCode.Ldc_I4_S:  		value = (int)memReader.ReadSByte ();  		break;  	case OperationCode.Ldc_I4:  		value = memReader.ReadInt32 ();  		break;  	case OperationCode.Ldc_I8:  		value = memReader.ReadInt64 ();  		break;  	case OperationCode.Ldc_R4:  		value = memReader.ReadSingle ();  		break;  	case OperationCode.Ldc_R8:  		value = memReader.ReadDouble ();  		break;  	case OperationCode.Dup:  	case OperationCode.Pop:  		break;  	case OperationCode.Jmp:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Call:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Calli:  		value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ret:  		break;  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  		{  			uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  		{  			uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (jumpOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = jumpOffset;  		}  		break;  	case OperationCode.Switch:  		{  			uint numTargets = memReader.ReadUInt32 ();  			uint[] result = new uint[numTargets];  			uint asOffset = memReader.Offset + numTargets * 4;  			for (int i = 0; i < numTargets; i++) {  				uint targetAddress = memReader.ReadUInt32 () + asOffset;  				if (targetAddress >= this.EndOfMethodOffset) {  					//  Error...  				}  				result [i] = targetAddress;  			}  			value = result;  		}  		break;  	case OperationCode.Ldind_I1:  	case OperationCode.Ldind_U1:  	case OperationCode.Ldind_I2:  	case OperationCode.Ldind_U2:  	case OperationCode.Ldind_I4:  	case OperationCode.Ldind_U4:  	case OperationCode.Ldind_I8:  	case OperationCode.Ldind_I:  	case OperationCode.Ldind_R4:  	case OperationCode.Ldind_R8:  	case OperationCode.Ldind_Ref:  	case OperationCode.Stind_Ref:  	case OperationCode.Stind_I1:  	case OperationCode.Stind_I2:  	case OperationCode.Stind_I4:  	case OperationCode.Stind_I8:  	case OperationCode.Stind_R4:  	case OperationCode.Stind_R8:  	case OperationCode.Add:  	case OperationCode.Sub:  	case OperationCode.Mul:  	case OperationCode.Div:  	case OperationCode.Div_Un:  	case OperationCode.Rem:  	case OperationCode.Rem_Un:  	case OperationCode.And:  	case OperationCode.Or:  	case OperationCode.Xor:  	case OperationCode.Shl:  	case OperationCode.Shr:  	case OperationCode.Shr_Un:  	case OperationCode.Neg:  	case OperationCode.Not:  	case OperationCode.Conv_I1:  	case OperationCode.Conv_I2:  	case OperationCode.Conv_I4:  	case OperationCode.Conv_I8:  	case OperationCode.Conv_R4:  	case OperationCode.Conv_R8:  	case OperationCode.Conv_U4:  	case OperationCode.Conv_U8:  		break;  	case OperationCode.Callvirt:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null) {  				// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  				// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  				// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   				if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  					cilOpCode = OperationCode.Array_Set;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  					cilOpCode = OperationCode.Array_Get;  					value = arrayType;  				}  				else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  					cilOpCode = OperationCode.Array_Addr;  					value = arrayType;  				}  				else {  					value = methodReference;  				}  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldstr:  		value = this.GetUserStringForToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newobj:  		{  			IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  			IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  			if (arrayType != null && !arrayType.IsVector) {  				uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  				if (numParam != arrayType.Rank)  					cilOpCode = OperationCode.Array_Create_WithLowerBound;  				else  					cilOpCode = OperationCode.Array_Create;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		break;  	case OperationCode.Castclass:  	case OperationCode.Isinst:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_R_Un:  		break;  	case OperationCode.Unbox:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Throw:  		break;  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  		value = this.GetField (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  		value = this.GetField (memReader.ReadUInt32 ());  		var fieldRef = value as FieldReference;  		if (fieldRef != null)  			fieldRef.isStatic = true;  		break;  	case OperationCode.Stobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1_Un:  	case OperationCode.Conv_Ovf_I2_Un:  	case OperationCode.Conv_Ovf_I4_Un:  	case OperationCode.Conv_Ovf_I8_Un:  	case OperationCode.Conv_Ovf_U1_Un:  	case OperationCode.Conv_Ovf_U2_Un:  	case OperationCode.Conv_Ovf_U4_Un:  	case OperationCode.Conv_Ovf_U8_Un:  	case OperationCode.Conv_Ovf_I_Un:  	case OperationCode.Conv_Ovf_U_Un:  		break;  	case OperationCode.Box:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Newarr:  		{  			var elementType = this.GetType (memReader.ReadUInt32 ());  			if (elementType != null)  				value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  			else  				value = Dummy.ArrayType;  		}  		break;  	case OperationCode.Ldlen:  		break;  	case OperationCode.Ldelema:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldelem_I1:  	case OperationCode.Ldelem_U1:  	case OperationCode.Ldelem_I2:  	case OperationCode.Ldelem_U2:  	case OperationCode.Ldelem_I4:  	case OperationCode.Ldelem_U4:  	case OperationCode.Ldelem_I8:  	case OperationCode.Ldelem_I:  	case OperationCode.Ldelem_R4:  	case OperationCode.Ldelem_R8:  	case OperationCode.Ldelem_Ref:  	case OperationCode.Stelem_I:  	case OperationCode.Stelem_I1:  	case OperationCode.Stelem_I2:  	case OperationCode.Stelem_I4:  	case OperationCode.Stelem_I8:  	case OperationCode.Stelem_R4:  	case OperationCode.Stelem_R8:  	case OperationCode.Stelem_Ref:  		break;  	case OperationCode.Ldelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Stelem:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Unbox_Any:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_Ovf_I1:  	case OperationCode.Conv_Ovf_U1:  	case OperationCode.Conv_Ovf_I2:  	case OperationCode.Conv_Ovf_U2:  	case OperationCode.Conv_Ovf_I4:  	case OperationCode.Conv_Ovf_U4:  	case OperationCode.Conv_Ovf_I8:  	case OperationCode.Conv_Ovf_U8:  		break;  	case OperationCode.Refanyval:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ckfinite:  		break;  	case OperationCode.Mkrefany:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldtoken:  		value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  		break;  	case OperationCode.Conv_U2:  	case OperationCode.Conv_U1:  	case OperationCode.Conv_I:  	case OperationCode.Conv_Ovf_I:  	case OperationCode.Conv_Ovf_U:  	case OperationCode.Add_Ovf:  	case OperationCode.Add_Ovf_Un:  	case OperationCode.Mul_Ovf:  	case OperationCode.Mul_Ovf_Un:  	case OperationCode.Sub_Ovf:  	case OperationCode.Sub_Ovf_Un:  	case OperationCode.Endfinally:  		break;  	case OperationCode.Leave:  		{  			uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Leave_S:  		{  			uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  			if (leaveOffset >= this.EndOfMethodOffset) {  				//  Error...  			}  			value = leaveOffset;  		}  		break;  	case OperationCode.Stind_I:  	case OperationCode.Conv_U:  	case OperationCode.Arglist:  	case OperationCode.Ceq:  	case OperationCode.Cgt:  	case OperationCode.Cgt_Un:  	case OperationCode.Clt:  	case OperationCode.Clt_Un:  		break;  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  		value = this.GetMethod (memReader.ReadUInt32 ());  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  		value = this.GetParameter (memReader.ReadUInt16 ());  		break;  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		value = this.GetLocal (memReader.ReadUInt16 ());  		break;  	case OperationCode.Localloc:  		break;  	case OperationCode.Endfilter:  		break;  	case OperationCode.Unaligned_:  		value = memReader.ReadByte ();  		break;  	case OperationCode.Volatile_:  	case OperationCode.Tail_:  		break;  	case OperationCode.Initobj:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Constrained_:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Cpblk:  	case OperationCode.Initblk:  		break;  	case OperationCode.No_:  		value = (OperationCheckFlags)memReader.ReadByte ();  		break;  	case OperationCode.Rethrow:  		break;  	case OperationCode.Sizeof:  		value = this.GetType (memReader.ReadUInt32 ());  		break;  	case OperationCode.Refanytype:  	case OperationCode.Readonly_:  		break;  	default:  		this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  		break;  	}  	instrList [instructionNumber++] = new CilInstruction (cilOpCode' document' offset' value);  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Nop:  case OperationCode.Break:  	break;  case OperationCode.Ldarg_0:  case OperationCode.Ldarg_1:  case OperationCode.Ldarg_2:  case OperationCode.Ldarg_3:  	value = this.GetParameter ((uint)(cilOpCode - OperationCode.Ldarg_0));  	break;  case OperationCode.Ldloc_0:  case OperationCode.Ldloc_1:  case OperationCode.Ldloc_2:  case OperationCode.Ldloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Ldloc_0));  	break;  case OperationCode.Stloc_0:  case OperationCode.Stloc_1:  case OperationCode.Stloc_2:  case OperationCode.Stloc_3:  	value = this.GetLocal ((uint)(cilOpCode - OperationCode.Stloc_0));  	break;  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  	value = this.GetParameter (memReader.ReadByte ());  	break;  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  	value = this.GetLocal (memReader.ReadByte ());  	break;  case OperationCode.Ldnull:  	break;  case OperationCode.Ldc_I4_M1:  	value = -1;  	break;  case OperationCode.Ldc_I4_0:  	value = 0;  	break;  case OperationCode.Ldc_I4_1:  	value = 1;  	break;  case OperationCode.Ldc_I4_2:  	value = 2;  	break;  case OperationCode.Ldc_I4_3:  	value = 3;  	break;  case OperationCode.Ldc_I4_4:  	value = 4;  	break;  case OperationCode.Ldc_I4_5:  	value = 5;  	break;  case OperationCode.Ldc_I4_6:  	value = 6;  	break;  case OperationCode.Ldc_I4_7:  	value = 7;  	break;  case OperationCode.Ldc_I4_8:  	value = 8;  	break;  case OperationCode.Ldc_I4_S:  	value = (int)memReader.ReadSByte ();  	break;  case OperationCode.Ldc_I4:  	value = memReader.ReadInt32 ();  	break;  case OperationCode.Ldc_I8:  	value = memReader.ReadInt64 ();  	break;  case OperationCode.Ldc_R4:  	value = memReader.ReadSingle ();  	break;  case OperationCode.Ldc_R8:  	value = memReader.ReadDouble ();  	break;  case OperationCode.Dup:  case OperationCode.Pop:  	break;  case OperationCode.Jmp:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Call:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Calli:  	value = this.GetFunctionPointerType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ret:  	break;  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  	{  		uint jumpOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  	{  		uint jumpOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (jumpOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = jumpOffset;  	}  	break;  case OperationCode.Switch:  	{  		uint numTargets = memReader.ReadUInt32 ();  		uint[] result = new uint[numTargets];  		uint asOffset = memReader.Offset + numTargets * 4;  		for (int i = 0; i < numTargets; i++) {  			uint targetAddress = memReader.ReadUInt32 () + asOffset;  			if (targetAddress >= this.EndOfMethodOffset) {  				//  Error...  			}  			result [i] = targetAddress;  		}  		value = result;  	}  	break;  case OperationCode.Ldind_I1:  case OperationCode.Ldind_U1:  case OperationCode.Ldind_I2:  case OperationCode.Ldind_U2:  case OperationCode.Ldind_I4:  case OperationCode.Ldind_U4:  case OperationCode.Ldind_I8:  case OperationCode.Ldind_I:  case OperationCode.Ldind_R4:  case OperationCode.Ldind_R8:  case OperationCode.Ldind_Ref:  case OperationCode.Stind_Ref:  case OperationCode.Stind_I1:  case OperationCode.Stind_I2:  case OperationCode.Stind_I4:  case OperationCode.Stind_I8:  case OperationCode.Stind_R4:  case OperationCode.Stind_R8:  case OperationCode.Add:  case OperationCode.Sub:  case OperationCode.Mul:  case OperationCode.Div:  case OperationCode.Div_Un:  case OperationCode.Rem:  case OperationCode.Rem_Un:  case OperationCode.And:  case OperationCode.Or:  case OperationCode.Xor:  case OperationCode.Shl:  case OperationCode.Shr:  case OperationCode.Shr_Un:  case OperationCode.Neg:  case OperationCode.Not:  case OperationCode.Conv_I1:  case OperationCode.Conv_I2:  case OperationCode.Conv_I4:  case OperationCode.Conv_I8:  case OperationCode.Conv_R4:  case OperationCode.Conv_R8:  case OperationCode.Conv_U4:  case OperationCode.Conv_U8:  	break;  case OperationCode.Callvirt:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null) {  			// For Get()' Set() and Address() on arrays' the runtime provides method implementations.  			// Hence' CCI2 replaces these with pseudo instructions Array_Set' Array_Get and Array_Addr.  			// All other methods on arrays will not use pseudo instruction and will have methodReference as their operand.   			if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Set.UniqueKey) {  				cilOpCode = OperationCode.Array_Set;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Get.UniqueKey) {  				cilOpCode = OperationCode.Array_Get;  				value = arrayType;  			}  			else if (methodReference.Name.UniqueKey == this.PEFileToObjectModel.NameTable.Address.UniqueKey) {  				cilOpCode = OperationCode.Array_Addr;  				value = arrayType;  			}  			else {  				value = methodReference;  			}  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Cpobj:  case OperationCode.Ldobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldstr:  	value = this.GetUserStringForToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Newobj:  	{  		IMethodReference methodReference = this.GetMethod (memReader.ReadUInt32 ());  		IArrayTypeReference /*?*/arrayType = methodReference.ContainingType as IArrayTypeReference;  		if (arrayType != null && !arrayType.IsVector) {  			uint numParam = IteratorHelper.EnumerableCount (methodReference.Parameters);  			if (numParam != arrayType.Rank)  				cilOpCode = OperationCode.Array_Create_WithLowerBound;  			else  				cilOpCode = OperationCode.Array_Create;  			value = arrayType;  		}  		else {  			value = methodReference;  		}  	}  	break;  case OperationCode.Castclass:  case OperationCode.Isinst:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_R_Un:  	break;  case OperationCode.Unbox:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Throw:  	break;  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  	value = this.GetField (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  	value = this.GetField (memReader.ReadUInt32 ());  	var fieldRef = value as FieldReference;  	if (fieldRef != null)  		fieldRef.isStatic = true;  	break;  case OperationCode.Stobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1_Un:  case OperationCode.Conv_Ovf_I2_Un:  case OperationCode.Conv_Ovf_I4_Un:  case OperationCode.Conv_Ovf_I8_Un:  case OperationCode.Conv_Ovf_U1_Un:  case OperationCode.Conv_Ovf_U2_Un:  case OperationCode.Conv_Ovf_U4_Un:  case OperationCode.Conv_Ovf_U8_Un:  case OperationCode.Conv_Ovf_I_Un:  case OperationCode.Conv_Ovf_U_Un:  	break;  case OperationCode.Box:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Newarr:  	{  		var elementType = this.GetType (memReader.ReadUInt32 ());  		if (elementType != null)  			value = Vector.GetVector (elementType' PEFileToObjectModel.InternFactory);  		else  			value = Dummy.ArrayType;  	}  	break;  case OperationCode.Ldlen:  	break;  case OperationCode.Ldelema:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldelem_I1:  case OperationCode.Ldelem_U1:  case OperationCode.Ldelem_I2:  case OperationCode.Ldelem_U2:  case OperationCode.Ldelem_I4:  case OperationCode.Ldelem_U4:  case OperationCode.Ldelem_I8:  case OperationCode.Ldelem_I:  case OperationCode.Ldelem_R4:  case OperationCode.Ldelem_R8:  case OperationCode.Ldelem_Ref:  case OperationCode.Stelem_I:  case OperationCode.Stelem_I1:  case OperationCode.Stelem_I2:  case OperationCode.Stelem_I4:  case OperationCode.Stelem_I8:  case OperationCode.Stelem_R4:  case OperationCode.Stelem_R8:  case OperationCode.Stelem_Ref:  	break;  case OperationCode.Ldelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Stelem:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Unbox_Any:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_Ovf_I1:  case OperationCode.Conv_Ovf_U1:  case OperationCode.Conv_Ovf_I2:  case OperationCode.Conv_Ovf_U2:  case OperationCode.Conv_Ovf_I4:  case OperationCode.Conv_Ovf_U4:  case OperationCode.Conv_Ovf_I8:  case OperationCode.Conv_Ovf_U8:  	break;  case OperationCode.Refanyval:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ckfinite:  	break;  case OperationCode.Mkrefany:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldtoken:  	value = this.GetRuntimeHandleFromToken (memReader.ReadUInt32 ());  	break;  case OperationCode.Conv_U2:  case OperationCode.Conv_U1:  case OperationCode.Conv_I:  case OperationCode.Conv_Ovf_I:  case OperationCode.Conv_Ovf_U:  case OperationCode.Add_Ovf:  case OperationCode.Add_Ovf_Un:  case OperationCode.Mul_Ovf:  case OperationCode.Mul_Ovf_Un:  case OperationCode.Sub_Ovf:  case OperationCode.Sub_Ovf_Un:  case OperationCode.Endfinally:  	break;  case OperationCode.Leave:  	{  		uint leaveOffset = (uint)(memReader.Offset + 4 + memReader.ReadInt32 ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Leave_S:  	{  		uint leaveOffset = (uint)(memReader.Offset + 1 + memReader.ReadSByte ());  		if (leaveOffset >= this.EndOfMethodOffset) {  			//  Error...  		}  		value = leaveOffset;  	}  	break;  case OperationCode.Stind_I:  case OperationCode.Conv_U:  case OperationCode.Arglist:  case OperationCode.Ceq:  case OperationCode.Cgt:  case OperationCode.Cgt_Un:  case OperationCode.Clt:  case OperationCode.Clt_Un:  	break;  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  	value = this.GetMethod (memReader.ReadUInt32 ());  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  	value = this.GetParameter (memReader.ReadUInt16 ());  	break;  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	value = this.GetLocal (memReader.ReadUInt16 ());  	break;  case OperationCode.Localloc:  	break;  case OperationCode.Endfilter:  	break;  case OperationCode.Unaligned_:  	value = memReader.ReadByte ();  	break;  case OperationCode.Volatile_:  case OperationCode.Tail_:  	break;  case OperationCode.Initobj:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Constrained_:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Cpblk:  case OperationCode.Initblk:  	break;  case OperationCode.No_:  	value = (OperationCheckFlags)memReader.ReadByte ();  	break;  case OperationCode.Rethrow:  	break;  case OperationCode.Sizeof:  	value = this.GetType (memReader.ReadUInt32 ());  	break;  case OperationCode.Refanytype:  case OperationCode.Readonly_:  	break;  default:  	this.PEFileToObjectModel.PEFileReader.ErrorContainer.AddILError (this.MethodDefinition' offset' MetadataReaderErrorKind.UnknownILInstruction);  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: value = 2;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: value = 3;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: value = 4;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: value = 5;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: value = 6;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: value = 7;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The following statement contains a magic number: value = 8;  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	count++;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  	case OperationCode.Ldc_I4_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Leave_S:  	case OperationCode.Unaligned_:  	case OperationCode.No_:  		memReader.SkipBytes (1);  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		memReader.SkipBytes (2);  		break;  	case OperationCode.Ldc_I4:  	case OperationCode.Jmp:  	case OperationCode.Call:  	case OperationCode.Calli:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  	case OperationCode.Callvirt:  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  	case OperationCode.Ldstr:  	case OperationCode.Newobj:  	case OperationCode.Castclass:  	case OperationCode.Isinst:  	case OperationCode.Unbox:  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  	case OperationCode.Stobj:  	case OperationCode.Box:  	case OperationCode.Newarr:  	case OperationCode.Ldelema:  	case OperationCode.Ldelem:  	case OperationCode.Stelem:  	case OperationCode.Unbox_Any:  	case OperationCode.Refanyval:  	case OperationCode.Mkrefany:  	case OperationCode.Ldtoken:  	case OperationCode.Leave:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Initobj:  	case OperationCode.Constrained_:  	case OperationCode.Sizeof:  	case OperationCode.Ldc_R4:  		memReader.SkipBytes (4);  		break;  	case OperationCode.Ldc_I8:  	case OperationCode.Ldc_R8:  		memReader.SkipBytes (8);  		break;  	case OperationCode.Switch:  		int numTargets = (int)memReader.ReadUInt32 ();  		memReader.SkipBytes (4 * numTargets);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	count++;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  	case OperationCode.Ldc_I4_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Leave_S:  	case OperationCode.Unaligned_:  	case OperationCode.No_:  		memReader.SkipBytes (1);  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		memReader.SkipBytes (2);  		break;  	case OperationCode.Ldc_I4:  	case OperationCode.Jmp:  	case OperationCode.Call:  	case OperationCode.Calli:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  	case OperationCode.Callvirt:  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  	case OperationCode.Ldstr:  	case OperationCode.Newobj:  	case OperationCode.Castclass:  	case OperationCode.Isinst:  	case OperationCode.Unbox:  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  	case OperationCode.Stobj:  	case OperationCode.Box:  	case OperationCode.Newarr:  	case OperationCode.Ldelema:  	case OperationCode.Ldelem:  	case OperationCode.Stelem:  	case OperationCode.Unbox_Any:  	case OperationCode.Refanyval:  	case OperationCode.Mkrefany:  	case OperationCode.Ldtoken:  	case OperationCode.Leave:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Initobj:  	case OperationCode.Constrained_:  	case OperationCode.Sizeof:  	case OperationCode.Ldc_R4:  		memReader.SkipBytes (4);  		break;  	case OperationCode.Ldc_I8:  	case OperationCode.Ldc_R8:  		memReader.SkipBytes (8);  		break;  	case OperationCode.Switch:  		int numTargets = (int)memReader.ReadUInt32 ();  		memReader.SkipBytes (4 * numTargets);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	count++;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  	case OperationCode.Ldc_I4_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Leave_S:  	case OperationCode.Unaligned_:  	case OperationCode.No_:  		memReader.SkipBytes (1);  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		memReader.SkipBytes (2);  		break;  	case OperationCode.Ldc_I4:  	case OperationCode.Jmp:  	case OperationCode.Call:  	case OperationCode.Calli:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  	case OperationCode.Callvirt:  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  	case OperationCode.Ldstr:  	case OperationCode.Newobj:  	case OperationCode.Castclass:  	case OperationCode.Isinst:  	case OperationCode.Unbox:  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  	case OperationCode.Stobj:  	case OperationCode.Box:  	case OperationCode.Newarr:  	case OperationCode.Ldelema:  	case OperationCode.Ldelem:  	case OperationCode.Stelem:  	case OperationCode.Unbox_Any:  	case OperationCode.Refanyval:  	case OperationCode.Mkrefany:  	case OperationCode.Ldtoken:  	case OperationCode.Leave:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Initobj:  	case OperationCode.Constrained_:  	case OperationCode.Sizeof:  	case OperationCode.Ldc_R4:  		memReader.SkipBytes (4);  		break;  	case OperationCode.Ldc_I8:  	case OperationCode.Ldc_R8:  		memReader.SkipBytes (8);  		break;  	case OperationCode.Switch:  		int numTargets = (int)memReader.ReadUInt32 ();  		memReader.SkipBytes (4 * numTargets);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: while (memReader.NotEndOfBytes) {  	count++;  	OperationCode cilOpCode = memReader.ReadOpcode ();  	switch (cilOpCode) {  	case OperationCode.Ldarg_S:  	case OperationCode.Ldarga_S:  	case OperationCode.Starg_S:  	case OperationCode.Ldloc_S:  	case OperationCode.Ldloca_S:  	case OperationCode.Stloc_S:  	case OperationCode.Ldc_I4_S:  	case OperationCode.Br_S:  	case OperationCode.Brfalse_S:  	case OperationCode.Brtrue_S:  	case OperationCode.Beq_S:  	case OperationCode.Bge_S:  	case OperationCode.Bgt_S:  	case OperationCode.Ble_S:  	case OperationCode.Blt_S:  	case OperationCode.Bne_Un_S:  	case OperationCode.Bge_Un_S:  	case OperationCode.Bgt_Un_S:  	case OperationCode.Ble_Un_S:  	case OperationCode.Blt_Un_S:  	case OperationCode.Leave_S:  	case OperationCode.Unaligned_:  	case OperationCode.No_:  		memReader.SkipBytes (1);  		break;  	case OperationCode.Ldarg:  	case OperationCode.Ldarga:  	case OperationCode.Starg:  	case OperationCode.Ldloc:  	case OperationCode.Ldloca:  	case OperationCode.Stloc:  		memReader.SkipBytes (2);  		break;  	case OperationCode.Ldc_I4:  	case OperationCode.Jmp:  	case OperationCode.Call:  	case OperationCode.Calli:  	case OperationCode.Br:  	case OperationCode.Brfalse:  	case OperationCode.Brtrue:  	case OperationCode.Beq:  	case OperationCode.Bge:  	case OperationCode.Bgt:  	case OperationCode.Ble:  	case OperationCode.Blt:  	case OperationCode.Bne_Un:  	case OperationCode.Bge_Un:  	case OperationCode.Bgt_Un:  	case OperationCode.Ble_Un:  	case OperationCode.Blt_Un:  	case OperationCode.Callvirt:  	case OperationCode.Cpobj:  	case OperationCode.Ldobj:  	case OperationCode.Ldstr:  	case OperationCode.Newobj:  	case OperationCode.Castclass:  	case OperationCode.Isinst:  	case OperationCode.Unbox:  	case OperationCode.Ldfld:  	case OperationCode.Ldflda:  	case OperationCode.Stfld:  	case OperationCode.Ldsfld:  	case OperationCode.Ldsflda:  	case OperationCode.Stsfld:  	case OperationCode.Stobj:  	case OperationCode.Box:  	case OperationCode.Newarr:  	case OperationCode.Ldelema:  	case OperationCode.Ldelem:  	case OperationCode.Stelem:  	case OperationCode.Unbox_Any:  	case OperationCode.Refanyval:  	case OperationCode.Mkrefany:  	case OperationCode.Ldtoken:  	case OperationCode.Leave:  	case OperationCode.Ldftn:  	case OperationCode.Ldvirtftn:  	case OperationCode.Initobj:  	case OperationCode.Constrained_:  	case OperationCode.Sizeof:  	case OperationCode.Ldc_R4:  		memReader.SkipBytes (4);  		break;  	case OperationCode.Ldc_I8:  	case OperationCode.Ldc_R8:  		memReader.SkipBytes (8);  		break;  	case OperationCode.Switch:  		int numTargets = (int)memReader.ReadUInt32 ();  		memReader.SkipBytes (4 * numTargets);  		break;  	default:  		break;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  case OperationCode.Ldc_I4_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  case OperationCode.Leave_S:  case OperationCode.Unaligned_:  case OperationCode.No_:  	memReader.SkipBytes (1);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	memReader.SkipBytes (2);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Jmp:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  case OperationCode.Callvirt:  case OperationCode.Cpobj:  case OperationCode.Ldobj:  case OperationCode.Ldstr:  case OperationCode.Newobj:  case OperationCode.Castclass:  case OperationCode.Isinst:  case OperationCode.Unbox:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  case OperationCode.Stobj:  case OperationCode.Box:  case OperationCode.Newarr:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Stelem:  case OperationCode.Unbox_Any:  case OperationCode.Refanyval:  case OperationCode.Mkrefany:  case OperationCode.Ldtoken:  case OperationCode.Leave:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Initobj:  case OperationCode.Constrained_:  case OperationCode.Sizeof:  case OperationCode.Ldc_R4:  	memReader.SkipBytes (4);  	break;  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R8:  	memReader.SkipBytes (8);  	break;  case OperationCode.Switch:  	int numTargets = (int)memReader.ReadUInt32 ();  	memReader.SkipBytes (4 * numTargets);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  case OperationCode.Ldc_I4_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  case OperationCode.Leave_S:  case OperationCode.Unaligned_:  case OperationCode.No_:  	memReader.SkipBytes (1);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	memReader.SkipBytes (2);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Jmp:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  case OperationCode.Callvirt:  case OperationCode.Cpobj:  case OperationCode.Ldobj:  case OperationCode.Ldstr:  case OperationCode.Newobj:  case OperationCode.Castclass:  case OperationCode.Isinst:  case OperationCode.Unbox:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  case OperationCode.Stobj:  case OperationCode.Box:  case OperationCode.Newarr:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Stelem:  case OperationCode.Unbox_Any:  case OperationCode.Refanyval:  case OperationCode.Mkrefany:  case OperationCode.Ldtoken:  case OperationCode.Leave:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Initobj:  case OperationCode.Constrained_:  case OperationCode.Sizeof:  case OperationCode.Ldc_R4:  	memReader.SkipBytes (4);  	break;  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R8:  	memReader.SkipBytes (8);  	break;  case OperationCode.Switch:  	int numTargets = (int)memReader.ReadUInt32 ();  	memReader.SkipBytes (4 * numTargets);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  case OperationCode.Ldc_I4_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  case OperationCode.Leave_S:  case OperationCode.Unaligned_:  case OperationCode.No_:  	memReader.SkipBytes (1);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	memReader.SkipBytes (2);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Jmp:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  case OperationCode.Callvirt:  case OperationCode.Cpobj:  case OperationCode.Ldobj:  case OperationCode.Ldstr:  case OperationCode.Newobj:  case OperationCode.Castclass:  case OperationCode.Isinst:  case OperationCode.Unbox:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  case OperationCode.Stobj:  case OperationCode.Box:  case OperationCode.Newarr:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Stelem:  case OperationCode.Unbox_Any:  case OperationCode.Refanyval:  case OperationCode.Mkrefany:  case OperationCode.Ldtoken:  case OperationCode.Leave:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Initobj:  case OperationCode.Constrained_:  case OperationCode.Sizeof:  case OperationCode.Ldc_R4:  	memReader.SkipBytes (4);  	break;  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R8:  	memReader.SkipBytes (8);  	break;  case OperationCode.Switch:  	int numTargets = (int)memReader.ReadUInt32 ();  	memReader.SkipBytes (4 * numTargets);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: switch (cilOpCode) {  case OperationCode.Ldarg_S:  case OperationCode.Ldarga_S:  case OperationCode.Starg_S:  case OperationCode.Ldloc_S:  case OperationCode.Ldloca_S:  case OperationCode.Stloc_S:  case OperationCode.Ldc_I4_S:  case OperationCode.Br_S:  case OperationCode.Brfalse_S:  case OperationCode.Brtrue_S:  case OperationCode.Beq_S:  case OperationCode.Bge_S:  case OperationCode.Bgt_S:  case OperationCode.Ble_S:  case OperationCode.Blt_S:  case OperationCode.Bne_Un_S:  case OperationCode.Bge_Un_S:  case OperationCode.Bgt_Un_S:  case OperationCode.Ble_Un_S:  case OperationCode.Blt_Un_S:  case OperationCode.Leave_S:  case OperationCode.Unaligned_:  case OperationCode.No_:  	memReader.SkipBytes (1);  	break;  case OperationCode.Ldarg:  case OperationCode.Ldarga:  case OperationCode.Starg:  case OperationCode.Ldloc:  case OperationCode.Ldloca:  case OperationCode.Stloc:  	memReader.SkipBytes (2);  	break;  case OperationCode.Ldc_I4:  case OperationCode.Jmp:  case OperationCode.Call:  case OperationCode.Calli:  case OperationCode.Br:  case OperationCode.Brfalse:  case OperationCode.Brtrue:  case OperationCode.Beq:  case OperationCode.Bge:  case OperationCode.Bgt:  case OperationCode.Ble:  case OperationCode.Blt:  case OperationCode.Bne_Un:  case OperationCode.Bge_Un:  case OperationCode.Bgt_Un:  case OperationCode.Ble_Un:  case OperationCode.Blt_Un:  case OperationCode.Callvirt:  case OperationCode.Cpobj:  case OperationCode.Ldobj:  case OperationCode.Ldstr:  case OperationCode.Newobj:  case OperationCode.Castclass:  case OperationCode.Isinst:  case OperationCode.Unbox:  case OperationCode.Ldfld:  case OperationCode.Ldflda:  case OperationCode.Stfld:  case OperationCode.Ldsfld:  case OperationCode.Ldsflda:  case OperationCode.Stsfld:  case OperationCode.Stobj:  case OperationCode.Box:  case OperationCode.Newarr:  case OperationCode.Ldelema:  case OperationCode.Ldelem:  case OperationCode.Stelem:  case OperationCode.Unbox_Any:  case OperationCode.Refanyval:  case OperationCode.Mkrefany:  case OperationCode.Ldtoken:  case OperationCode.Leave:  case OperationCode.Ldftn:  case OperationCode.Ldvirtftn:  case OperationCode.Initobj:  case OperationCode.Constrained_:  case OperationCode.Sizeof:  case OperationCode.Ldc_R4:  	memReader.SkipBytes (4);  	break;  case OperationCode.Ldc_I8:  case OperationCode.Ldc_R8:  	memReader.SkipBytes (8);  	break;  case OperationCode.Switch:  	int numTargets = (int)memReader.ReadUInt32 ();  	memReader.SkipBytes (4 * numTargets);  	break;  default:  	break;  }  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: memReader.SkipBytes (2);  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: memReader.SkipBytes (4);  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: memReader.SkipBytes (8);  
Magic Number,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,CountCilInstructions,The following statement contains a magic number: memReader.SkipBytes (4 * numTargets);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 8) | this.PeekByte (offset + 1);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: numberOfBytesRead = 2;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = -1;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = offset + 1;  	result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.PeekByte (offsetIter) << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: result |= (this.PeekByte (offsetIter) << 8);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedInt32,The following statement contains a magic number: numberOfBytesRead = 4;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	numberOfBytesRead = 1;  }  else if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  	numberOfBytesRead = 2;  }  else if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: result = (uint)((headerByte & 0x3f) << 8) | this.PeekByte ((int)offset + 1);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: numberOfBytesRead = 2;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF) {  	result = 0xFF;  	numberOfBytesRead = 1;  }  else {  	int offsetIter = (int)offset + 1;  	result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  	offsetIter++;  	result |= (uint)(this.PeekByte (offsetIter) << 8);  	offsetIter++;  	result |= (uint)this.PeekByte (offsetIter);  	numberOfBytesRead = 4;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: result = (uint)((headerByte & 0x3f) << 24) | (uint)(this.PeekByte (offsetIter) << 16);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: result |= (uint)(this.PeekByte (offsetIter) << 8);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekCompressedUInt32,The following statement contains a magic number: numberOfBytesRead = 4;  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: for (; ;) {  	b = *pIter++;  	if (b == 0 || pIter == pEnd)  		break;  	if ((b & 0x80) == 0) {  		sb.Append ((char)b);  		continue;  	}  	char ch;  	byte b1 = *pIter++;  	if (b1 == 0 || pIter == pEnd) {  		//Dangling lead byte' do not decompose  		sb.Append ((char)b);  		break;  	}  	if ((b & 0x20) == 0) {  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	}  	else {  		byte b2 = *pIter++;  		if (b2 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			break;  		}  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			byte b3 = *pIter++;  			if (b3 == 0 || pIter == pEnd) {  				//Dangling lead bytes' do not decompose  				sb.Append ((char)((b << 8) | b1));  				sb.Append ((char)b2);  				break;  			}  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			sb.Append ((char)((ch32 >> 10) | 0xD800));  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	sb.Append (ch);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x20) == 0) {  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  }  else {  	byte b2 = *pIter++;  	if (b2 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		break;  	}  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		byte b3 = *pIter++;  		if (b3 == 0 || pIter == pEnd) {  			//Dangling lead bytes' do not decompose  			sb.Append ((char)((b << 8) | b1));  			sb.Append ((char)b2);  			break;  		}  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		sb.Append ((char)((ch32 >> 10) | 0xD800));  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if (b2 == 0 || pIter == pEnd) {  	//Dangling lead bytes' do not decompose  	sb.Append ((char)((b << 8) | b1));  	break;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: sb.Append ((char)((b << 8) | b1));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	byte b3 = *pIter++;  	if (b3 == 0 || pIter == pEnd) {  		//Dangling lead bytes' do not decompose  		sb.Append ((char)((b << 8) | b1));  		sb.Append ((char)b2);  		break;  	}  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if (b3 == 0 || pIter == pEnd) {  	//Dangling lead bytes' do not decompose  	sb.Append ((char)((b << 8) | b1));  	sb.Append ((char)b2);  	break;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: sb.Append ((char)((b << 8) | b1));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: if ((ch32 & 0xFFFF0000) == 0)  	ch = (char)ch32;  else {  	//break up into UTF16 surrogate pair  	sb.Append ((char)((ch32 >> 10) | 0xD800));  	ch = (char)((ch32 & 0x3FF) | 0xDC00);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,PeekUTF8NullTerminated,The following statement contains a magic number: sb.Append ((char)((ch32 >> 10) | 0xD800));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,BinarySearchForSlot,The following statement contains a magic number: while ((endRowNumber - startRowNumber) > 1) {  	if (referenceValue <= startValue)  		return referenceValue == startValue ? startRowNumber : startRowNumber - 1;  	else if (referenceValue >= endValue)  		return referenceValue == endValue ? endRowNumber : endRowNumber + 1;  	int midRowNumber = (startRowNumber + endRowNumber) / 2;  	uint midReferenceValue = this.PeekReference (midRowNumber * rowSize + referenceOffset' isReferenceSmall);  	if (referenceValue > midReferenceValue) {  		startRowNumber = midRowNumber;  		startValue = midReferenceValue;  	}  	else if (referenceValue < midReferenceValue) {  		endRowNumber = midRowNumber;  		endValue = midReferenceValue;  	}  	else  		return midRowNumber;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,BinarySearchReference,The following statement contains a magic number: while (startRowNumber <= endRowNumber) {  	int midRowNumber = (startRowNumber + endRowNumber) / 2;  	uint midReferenceValue = this.PeekReference (midRowNumber * rowSize + referenceOffset' isReferenceSmall);  	if (referenceValue > midReferenceValue)  		startRowNumber = midRowNumber + 1;  	else if (referenceValue < midReferenceValue)  		endRowNumber = midRowNumber - 1;  	else  		return midRowNumber;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadOpcode,The following statement contains a magic number: if (result == 0xFE) {  	result = result << 8 | this.ReadByte ();  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadOpcode,The following statement contains a magic number: result = result << 8 | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: while (bytesToRead > 0) {  	byte b = *pb++;  	bytesToRead--;  	if ((b & 0x80) == 0 || bytesToRead == 0) {  		buffer [j++] = (char)b;  		continue;  	}  	char ch;  	byte b1 = *pb++;  	bytesToRead--;  	if ((b & 0x20) == 0)  		ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			break;  		}  		byte b2 = *pb++;  		bytesToRead--;  		uint ch32;  		if ((b & 0x10) == 0)  			ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  		else {  			if (bytesToRead == 0) {  				//Dangling lead bytes' do not decompose  				buffer [j++] = (char)((b << 8) | b1);  				buffer [j++] = (char)b2;  				break;  			}  			byte b3 = *pb++;  			bytesToRead--;  			ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  		}  		if ((ch32 & 0xFFFF0000) == 0)  			ch = (char)ch32;  		else {  			//break up into UTF16 surrogate pair  			buffer [j++] = (char)((ch32 >> 10) | 0xD800);  			ch = (char)((ch32 & 0x3FF) | 0xDC00);  		}  	}  	buffer [j++] = ch;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x20) == 0)  	ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		break;  	}  	byte b2 = *pb++;  	bytesToRead--;  	uint ch32;  	if ((b & 0x10) == 0)  		ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  	else {  		if (bytesToRead == 0) {  			//Dangling lead bytes' do not decompose  			buffer [j++] = (char)((b << 8) | b1);  			buffer [j++] = (char)b2;  			break;  		}  		byte b3 = *pb++;  		bytesToRead--;  		ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  	}  	if ((ch32 & 0xFFFF0000) == 0)  		ch = (char)ch32;  	else {  		//break up into UTF16 surrogate pair  		buffer [j++] = (char)((ch32 >> 10) | 0xD800);  		ch = (char)((ch32 & 0x3FF) | 0xDC00);  	}  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch = (char)(((b & 0x1F) << 6) | (b1 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if (bytesToRead == 0) {  	//Dangling lead bytes' do not decompose  	buffer [j++] = (char)((b << 8) | b1);  	break;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: buffer [j++] = (char)((b << 8) | b1);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((b & 0x10) == 0)  	ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  else {  	if (bytesToRead == 0) {  		//Dangling lead bytes' do not decompose  		buffer [j++] = (char)((b << 8) | b1);  		buffer [j++] = (char)b2;  		break;  	}  	byte b3 = *pb++;  	bytesToRead--;  	ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if (bytesToRead == 0) {  	//Dangling lead bytes' do not decompose  	buffer [j++] = (char)((b << 8) | b1);  	buffer [j++] = (char)b2;  	break;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: buffer [j++] = (char)((b << 8) | b1);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: ch32 = (uint)(((b & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F));  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: if ((ch32 & 0xFFFF0000) == 0)  	ch = (char)ch32;  else {  	//break up into UTF16 surrogate pair  	buffer [j++] = (char)((ch32 >> 10) | 0xD800);  	ch = (char)((ch32 & 0x3FF) | 0xDC00);  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadUTF8WithSize,The following statement contains a magic number: buffer [j++] = (char)((ch32 >> 10) | 0xD800);  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00)  	result = headerByte;  else if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00)  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  else if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedUInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x40;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x40;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x40;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x80) == 0x00) {  	result = headerByte;  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x40;  }  else if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if ((headerByte & 0x40) == 0x00) {  	result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x2000;  }  else if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: if (headerByte == 0xFF)  	result = -1;  else {  	result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  	if ((result & 0x01) == 0)  		result = result >> 1;  	else  		result = (result >> 1) - 0x20000000;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadCompressedInt32,The following statement contains a magic number: result = ((headerByte & 0x3f) << 24) | (this.ReadByte () << 16) | (this.ReadByte () << 8) | this.ReadByte ();  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadASCIINullTerminated,The following statement contains a magic number: if (b != 0) {  	count <<= 2;  	char[] newBuffer = new char[count];  	for (int copy = 0; copy < j; copy++)  		newBuffer [copy] = buffer [copy];  	buffer = newBuffer;  	goto Restart;  }  
Magic Number,Microsoft.Cci.UtilityDataStructures,MemoryReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\UnmanagedReadWrite.cs,ReadASCIINullTerminated,The following statement contains a magic number: count <<= 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00110011001100110011001100110011) + ((count >> 2) & MASK_00110011001100110011001100110011);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00001111000011110000111100001111) + ((count >> 4) & MASK_00001111000011110000111100001111);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00000000111111110000000011111111) + ((count >> 8) & MASK_00000000111111110000000011111111);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_00000000000000001111111111111111) + ((count >> 16) & MASK_00000000000000001111111111111111);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MetadataTableHeader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,GetNumberOfTablesPresent,The following statement contains a magic number: count = (count & MASK_11111111111111111111111111111111) + ((count >> 32) & MASK_11111111111111111111111111111111);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ModuleTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ModuleTableReader,The following statement contains a magic number: this.IsGUIDHeapRefSizeSmall = guidHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,TypeRefTableReader,The following statement contains a magic number: this.IsResolutionScopeRefSizeSmall = resolutionScopeRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,TypeRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsFieldRefSizeSmall = fieldRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsMethodRefSizeSmall = methodRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeDefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,TypeDefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FieldPtrTableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FieldTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FieldTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodPtrTableReader,The following statement contains a magic number: this.IsMethodTableRowRefSizeSmall = methodTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsParamRefSizeSmall = paramRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ParamPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ParamPtrTableReader,The following statement contains a magic number: this.IsParamTableRowRefSizeSmall = paramTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ParamTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ParamTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,InterfaceImplTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,InterfaceImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,InterfaceImplTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsMemberRefParentRefSizeSmall = memberRefParentRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MemberRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MemberRefTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ConstantTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ConstantTableReader,The following statement contains a magic number: this.IsHasConstantRefSizeSmall = hasConstantRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ConstantTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ConstantTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsHasCustomAttributeRefSizeSmall = hasCustomAttributeRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsCustomAttriubuteTypeRefSizeSmall = customAttributeTypeRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,CustomAttributeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,CustomAttributeTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldMarshalTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FieldMarshalTableReader,The following statement contains a magic number: this.IsHasFieldMarshalRefSizeSmall = hasFieldMarshalRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldMarshalTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FieldMarshalTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,DeclSecurityTableReader,The following statement contains a magic number: this.IsHasDeclSecurityRefSizeSmall = hasDeclSecurityRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,DeclSecurityTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,DeclSecurityTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ClassLayoutTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ClassLayoutTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldLayoutTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FieldLayoutTableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,StandAloneSigTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,StandAloneSigTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,EventMapTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,EventMapTableReader,The following statement contains a magic number: this.IsEventRefSizeSmall = eventRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,EventPtrTableReader,The following statement contains a magic number: this.IsEventTableRowRefSizeSmall = eventTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,EventTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,EventTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,EventTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,PropertyMapTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,PropertyMapTableReader,The following statement contains a magic number: this.IsPropertyRefSizeSmall = propertyRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyPtrTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,PropertyPtrTableReader,The following statement contains a magic number: this.IsPropertyTableRowRefSizeSmall = propertyTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,PropertyTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PropertyTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,PropertyTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodSemanticsTableReader,The following statement contains a magic number: this.IsMethodTableRowRefSizeSmall = methodTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSemanticsTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodSemanticsTableReader,The following statement contains a magic number: this.IsHasSemanticRefSizeSmall = hasSemanticRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodImplTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodImplTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodImplTableReader,The following statement contains a magic number: this.IsMethodDefOrRefRefSizeSmall = methodDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ModuleRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ModuleRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,TypeSpecTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,TypeSpecTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsModuleRefTableRowRefSizeSmall = moduleRefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsMemberForwardRowRefSizeSmall = memberForwardedRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ImplMapTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ImplMapTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FieldRVATableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FieldRVATableReader,The following statement contains a magic number: this.IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,AssemblyTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,AssemblyTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,AssemblyRefTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,AssemblyRefTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefProcessorTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,AssemblyRefProcessorTableReader,The following statement contains a magic number: this.IsAssemblyRefTableRowSizeSmall = assembyRefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,AssemblyRefOSTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,AssemblyRefOSTableReader,The following statement contains a magic number: this.IsAssemblyRefTableRowRefSizeSmall = assembyRefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FileTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,FileTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,FileTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ExportedTypeTableReader,The following statement contains a magic number: this.IsImplementationRefSizeSmall = implementationRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ExportedTypeTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ExportedTypeTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ManifestResourceTableReader,The following statement contains a magic number: this.IsImplementationRefSizeSmall = implementationRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,ManifestResourceTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ManifestResourceTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,NestedClassTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,NestedClassTableReader,The following statement contains a magic number: this.IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GenericParamTableReader,The following statement contains a magic number: this.IsTypeOrMethodDefRefSizeSmall = typeOrMethodDefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GenericParamTableReader,The following statement contains a magic number: this.IsStringHeapRefSizeSmall = stringHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSpecTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodSpecTableReader,The following statement contains a magic number: this.IsMethodDefOrRefRefSizeSmall = methodDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,MethodSpecTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,MethodSpecTableReader,The following statement contains a magic number: this.IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GenericParamConstraintTableReader,The following statement contains a magic number: this.IsGenericParamTableRowRefSizeSmall = genericParamTableRowRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,GenericParamConstraintTableReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GenericParamConstraintTableReader,The following statement contains a magic number: this.IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadDebugInformationLocationFromDebugTableDirectoryData,The following statement contains a magic number: if (ptrToDebugInfo >= this.BinaryDocumentMemoryBlock.Pointer + this.BinaryDocumentMemoryBlock.Length - 28) {  	//TODO: error  	return new PEFileDebugInformation ();  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadDebugInformationLocationFromDebugTableDirectoryData,The following statement contains a magic number: debugDataReader.SkipBytes (16);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadStreamHeaders,The following statement contains a magic number: for (int i = 0; i < numberOfStreams; ++i) {  	if (memReader.RemainingBytes < COR20Constants.MinimumSizeofStreamHeader) {  		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.StreamHeaderTooSmall);  		return false;  	}  	streamHeaders [i].Offset = memReader.ReadUInt32 ();  	streamHeaders [i].Size = memReader.ReadInt32 ();  	//  Review: Oh well there is no way i can test if we will read correctly. However we can check it after reading and aligning...  	streamHeaders [i].Name = memReader.ReadASCIINullTerminated ();  	memReader.Align (4);  	if (memReader.RemainingBytes < 0) {  		this.ErrorContainer.AddDirectoryError (Directories.Cor20HeaderMetaData' memReader.Offset' MetadataReaderErrorKind.NotEnoughSpaceForStreamHeaderName);  		return false;  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadStreamHeaders,The following statement contains a magic number: memReader.Align (4);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: switch (version) {  case 0x00010000:  	validTablesForVersion = (ulong)TableMask.V1_0_TablesMask;  	break;  case 0x00010001:  	validTablesForVersion = (ulong)TableMask.V1_1_TablesMask;  	break;  case 0x00020000:  	validTablesForVersion = (ulong)TableMask.V2_0_TablesMask;  	break;  default:  	this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 4' MetadataReaderErrorKind.UnknownVersionOfMetadata);  	return false;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 4' MetadataReaderErrorKind.UnknownVersionOfMetadata);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if ((presentTables & ~validTablesForVersion) != 0) {  	this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.UnknownTables);  	return false;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.UnknownTables);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if (this.MetadataStreamKind == MetadataStreamKind.Compressed && (presentTables & (ulong)TableMask.CompressedStreamNotAllowedMask) != 0) {  	this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.IllegalTablesInCompressedMetadataStream);  	return false;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 8' MetadataReaderErrorKind.IllegalTablesInCompressedMetadataStream);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: if ((requiredSortedTables & (ulong)this.MetadataTableHeader.SortedTables) != requiredSortedTables) {  	this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 16' MetadataReaderErrorKind.SomeRequiredTablesNotSorted);  	//Carry on regardless. There are/were compiler out there that sort the required tables' but fail to set the bit in SortedTables.  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ReadMetadataTableInformation,The following statement contains a magic number: this.ErrorContainer.AddMetadataStreamError (this.MetadataStreamName' 16' MetadataReaderErrorKind.SomeRequiredTablesNotSorted);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ComputeCodedTokenSize,The following statement contains a magic number: return isAllReferencedTablesSmall ? 2 : 4;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ComputeCodedTokenSize,The following statement contains a magic number: return isAllReferencedTablesSmall ? 2 : 4;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {  	if ((validTables & 0x0000000000000001UL) != 0) {  		uint rowCount = rowCountCompressedArray [arrayIndex++];  		rowCountArray [tableIndex] = rowCount;  		rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  	}  	else {  		rowRefSizeArray [tableIndex] = 2;  	}  	validTables >>= 1;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {  	if ((validTables & 0x0000000000000001UL) != 0) {  		uint rowCount = rowCountCompressedArray [arrayIndex++];  		rowCountArray [tableIndex] = rowCount;  		rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  	}  	else {  		rowRefSizeArray [tableIndex] = 2;  	}  	validTables >>= 1;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: for (int tableIndex = 0' arrayIndex = 0; tableIndex < (int)TableIndices.Count; tableIndex++) {  	if ((validTables & 0x0000000000000001UL) != 0) {  		uint rowCount = rowCountCompressedArray [arrayIndex++];  		rowCountArray [tableIndex] = rowCount;  		rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  	}  	else {  		rowRefSizeArray [tableIndex] = 2;  	}  	validTables >>= 1;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: if ((validTables & 0x0000000000000001UL) != 0) {  	uint rowCount = rowCountCompressedArray [arrayIndex++];  	rowCountArray [tableIndex] = rowCount;  	rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  }  else {  	rowRefSizeArray [tableIndex] = 2;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: if ((validTables & 0x0000000000000001UL) != 0) {  	uint rowCount = rowCountCompressedArray [arrayIndex++];  	rowCountArray [tableIndex] = rowCount;  	rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  }  else {  	rowRefSizeArray [tableIndex] = 2;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: if ((validTables & 0x0000000000000001UL) != 0) {  	uint rowCount = rowCountCompressedArray [arrayIndex++];  	rowCountArray [tableIndex] = rowCount;  	rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  }  else {  	rowRefSizeArray [tableIndex] = 2;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: rowRefSizeArray [tableIndex] = rowCount < MetadataStreamConstants.LargeTableRowCount ? 2 : 4;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,ProcessAndCacheMetadataTableBlocks,The following statement contains a magic number: rowRefSizeArray [tableIndex] = 2;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if ((headByte & CILMethodFlags.ILFormatMask) == CILMethodFlags.ILTinyFormat) {  	int size = headByte >> CILMethodFlags.ILTinyFormatSizeShift;  	return new MethodIL (true' 8' 0x00000000' memReader.GetMemoryBlockAt (0' size)' null);  }  else if ((headByte & CILMethodFlags.ILFormatMask) != CILMethodFlags.ILFatFormat) {  	//  PEFileFormat Error...  	return null;  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: return new MethodIL (true' 8' 0x00000000' memReader.GetMemoryBlockAt (0' size)' null);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (moreSectsPresent) {  	memReader.SkipBytes (codeSize);  	memReader.Align (4);  	byte sectHeader = memReader.ReadByte ();  	if ((sectHeader & CILMethodFlags.SectEHTable) != CILMethodFlags.SectEHTable) {  		//  PEFile Format Error...  		return null;  	}  	bool sectFatFormat = (sectHeader & CILMethodFlags.SectFatFormat) == CILMethodFlags.SectFatFormat;  	int dataSize = memReader.ReadByte ();  	if (sectFatFormat) {  		dataSize += (int)memReader.ReadUInt16 () << 8;  		sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  	}  	else {  		memReader.SkipBytes (2);  		//skip over reserved field  		sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  	}  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: memReader.Align (4);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (sectFatFormat) {  	dataSize += (int)memReader.ReadUInt16 () << 8;  	sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  }  else {  	memReader.SkipBytes (2);  	//skip over reserved field  	sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (sectFatFormat) {  	dataSize += (int)memReader.ReadUInt16 () << 8;  	sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  }  else {  	memReader.SkipBytes (2);  	//skip over reserved field  	sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (sectFatFormat) {  	dataSize += (int)memReader.ReadUInt16 () << 8;  	sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  }  else {  	memReader.SkipBytes (2);  	//skip over reserved field  	sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: if (sectFatFormat) {  	dataSize += (int)memReader.ReadUInt16 () << 8;  	sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  }  else {  	memReader.SkipBytes (2);  	//skip over reserved field  	sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  }  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: dataSize += (int)memReader.ReadUInt16 () << 8;  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: sehTableEntries = PEFileReader.GetFatSEHEntries (memReader' dataSize / 24);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: memReader.SkipBytes (2);  
Magic Number,Microsoft.Cci.MetadataReader.PEFile,PEFileReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileReader.cs,GetMethodIL,The following statement contains a magic number: sehTableEntries = PEFileReader.GetSmallSEHEntries (memReader' dataSize / 12);  
Duplicate Code,Microsoft.Cci.MetadataReader.MethodBody,ILReader,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\ILReader.cs,PopulateCilInstructions,The method contains a code clone-set at the following line numbers (starting from the method definition): ((99' 126)' (232' 259))
Missing Default,Microsoft.Cci.MetadataReader.ObjectModelImplementation,NonGenericNamespaceTypeWithPrimitiveType,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Types.cs,ToString,The following switch statement is missing a default case: switch (this.signatureTypeCode) {  case MetadataReaderSignatureTypeCode.Boolean:  	return "System.Boolean";  case MetadataReaderSignatureTypeCode.Byte:  	return "System.Byte";  case MetadataReaderSignatureTypeCode.Char:  	return "System.Char";  case MetadataReaderSignatureTypeCode.Double:  	return "System.Double";  case MetadataReaderSignatureTypeCode.Int16:  	return "System.Int16";  case MetadataReaderSignatureTypeCode.Int32:  	return "System.Int32";  case MetadataReaderSignatureTypeCode.Int64:  	return "System.Int64";  case MetadataReaderSignatureTypeCode.IntPtr:  	return "System.IntPtr";  case MetadataReaderSignatureTypeCode.Object:  	return "System.Object";  case MetadataReaderSignatureTypeCode.SByte:  	return "System.SByte";  case MetadataReaderSignatureTypeCode.Single:  	return "System.Single";  case MetadataReaderSignatureTypeCode.String:  	return "System.String";  case MetadataReaderSignatureTypeCode.TypedReference:  	return "System.TypedReference";  case MetadataReaderSignatureTypeCode.UInt16:  	return "System.UInt16";  case MetadataReaderSignatureTypeCode.UInt32:  	return "System.UInt32";  case MetadataReaderSignatureTypeCode.UInt64:  	return "System.UInt64";  case MetadataReaderSignatureTypeCode.UIntPtr:  	return "System.UIntPtr";  case MetadataReaderSignatureTypeCode.Void:  	return "System.Void";  }  
Missing Default,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetPrimitiveValue,The following switch statement is missing a default case: switch (type.TypeCode) {  case PrimitiveTypeCode.Int8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (sbyte)0;  	}  	return this.SignatureMemoryReader.ReadSByte ();  case PrimitiveTypeCode.Int16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (short)0;  	}  	return this.SignatureMemoryReader.ReadInt16 ();  case PrimitiveTypeCode.Int32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (int)0;  	}  	return this.SignatureMemoryReader.ReadInt32 ();  case PrimitiveTypeCode.Int64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (long)0;  	}  	return this.SignatureMemoryReader.ReadInt64 ();  case PrimitiveTypeCode.UInt8:  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (byte)0;  	}  	return this.SignatureMemoryReader.ReadByte ();  case PrimitiveTypeCode.UInt16:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ushort)0;  	}  	return this.SignatureMemoryReader.ReadUInt16 ();  case PrimitiveTypeCode.UInt32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (uint)0;  	}  	return this.SignatureMemoryReader.ReadUInt32 ();  case PrimitiveTypeCode.UInt64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (ulong)0;  	}  	return this.SignatureMemoryReader.ReadUInt64 ();  case PrimitiveTypeCode.Float32:  	if (this.SignatureMemoryReader.Offset + 4 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (float)0;  	}  	return this.SignatureMemoryReader.ReadSingle ();  case PrimitiveTypeCode.Float64:  	if (this.SignatureMemoryReader.Offset + 8 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (double)0;  	}  	return this.SignatureMemoryReader.ReadDouble ();  case PrimitiveTypeCode.Boolean: {  	if (this.SignatureMemoryReader.Offset + 1 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return false;  	}  	byte val = this.SignatureMemoryReader.ReadByte ();  	return val == 1;  }  case PrimitiveTypeCode.Char:  	if (this.SignatureMemoryReader.Offset + 2 > this.SignatureMemoryReader.Length) {  		this.decodeFailed = true;  		return (char)0;  	}  	return this.SignatureMemoryReader.ReadChar ();  }  
Missing Default,Microsoft.Cci.MetadataReader,AttributeDecoder,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\Attributes.cs,GetFieldOrPropType,The following switch statement is missing a default case: switch (elementByte) {  case SerializationType.Boolean:  	return this.PEFileToObjectModel.PlatformType.SystemBoolean;  case SerializationType.Char:  	return this.PEFileToObjectModel.PlatformType.SystemChar;  case SerializationType.Int8:  	return this.PEFileToObjectModel.PlatformType.SystemInt8;  case SerializationType.UInt8:  	return this.PEFileToObjectModel.PlatformType.SystemUInt8;  case SerializationType.Int16:  	return this.PEFileToObjectModel.PlatformType.SystemInt16;  case SerializationType.UInt16:  	return this.PEFileToObjectModel.PlatformType.SystemUInt16;  case SerializationType.Int32:  	return this.PEFileToObjectModel.PlatformType.SystemInt32;  case SerializationType.UInt32:  	return this.PEFileToObjectModel.PlatformType.SystemUInt32;  case SerializationType.Int64:  	return this.PEFileToObjectModel.PlatformType.SystemInt64;  case SerializationType.UInt64:  	return this.PEFileToObjectModel.PlatformType.SystemUInt64;  case SerializationType.Single:  	return this.PEFileToObjectModel.PlatformType.SystemFloat32;  case SerializationType.Double:  	return this.PEFileToObjectModel.PlatformType.SystemFloat64;  case SerializationType.String:  	return this.PEFileToObjectModel.PlatformType.SystemString;  case SerializationType.SZArray: {  	ITypeReference /*?*/elementType = this.GetFieldOrPropType ();  	if (elementType == null)  		return null;  	return Vector.GetVector (elementType' this.PEFileToObjectModel.InternFactory);  }  case SerializationType.Type:  	return this.PEFileToObjectModel.PlatformType.SystemType;  case SerializationType.TaggedObject:  	return this.PEFileToObjectModel.PlatformType.SystemObject;  case SerializationType.Enum: {  	string /*?*/typeName = this.GetSerializedString ();  	if (typeName == null)  		return null;  	var result = this.PEFileToObjectModel.GetSerializedTypeNameAsTypeReference (typeName);  	var tnr = result as TypeNameTypeReference;  	if (tnr == null) {  		var specializedNestedType = result as ISpecializedNestedTypeReference;  		if (specializedNestedType != null)  			tnr = specializedNestedType.UnspecializedVersion as TypeNameTypeReference;  	}  	if (tnr != null)  		tnr.IsEnum = true;  	return result;  }  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetUninterpretedPESections,The following switch statement is missing a default case: switch (nameStr) {  case ".text":  case ".sdata":  case ".tls":  case ".rdata":  case ".cover":  case ".rsrc":  case ".reloc":  	continue;  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetTypeReferenceForToken,The following switch statement is missing a default case: switch (tokenType) {  case TokenTypeIds.TypeDef: {  	if (rowId == 0 || rowId > this.PEFileReader.TypeDefTable.NumberOfRows) {  		//  handle Error  	}  	return this.GetTypeDefinitionAtRow (rowId);  }  case TokenTypeIds.TypeRef: {  	if (rowId == 0 || rowId > this.PEFileReader.TypeRefTable.NumberOfRows) {  		//  handle Error  	}  	return this.GetTypeRefReferenceAtRow (rowId' mustBeStruct);  }  case TokenTypeIds.TypeSpec: {  	if (rowId == 0 || rowId > this.PEFileReader.TypeSpecTable.NumberOfRows) {  		//  handle Error  	}  	return this.GetTypeSpecReferenceAtRow (owningObject' rowId).UnderlyingModuleTypeReference;  }  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetReferenceToAliasedType,The following switch statement is missing a default case: switch (tokenType) {  case TokenTypeIds.File: {  	FileReference /*?*/fileRef = this.GetFileReferenceAt (rowId);  	if (fileRef == null)  		return null;  	var module = thisAssembly.FindMemberModuleNamed (fileRef.Name) as Module;  	if (module == null)  		return null;  	var foundType = module.PEFileToObjectModel.ResolveNamespaceTypeDefinition (namespaceName' mangledTypeName);  	if (foundType == null)  		return null;  	return foundType;  }  case TokenTypeIds.ExportedType: {  	ExportedTypeAliasBase /*?*/parentExportedType = this.GetExportedTypeAtRowWorker (rowId);  	if (parentExportedType == null)  		return null;  	var parentModuleType = this.GetReferenceToAliasedType (parentExportedType);  	if (parentModuleType == null)  		return null;  	ITypeDefinition parentType = parentModuleType.ResolvedType;  	if (!(parentType is Dummy)) {  		foreach (ITypeDefinitionMember tdm in parentModuleType.ResolvedType.GetMembersNamed (unmangledTypeName' false)) {  			var modTypeRef = tdm as IMetadataReaderNamedTypeReference;  			if (modTypeRef != null)  				return modTypeRef;  		}  	}  	else {  		NamespaceTypeNameTypeReference /*?*/nstr = parentModuleType as NamespaceTypeNameTypeReference;  		if (nstr != null) {  			var nestedTypeName = new NestedTypeName (this.NameTable' nstr.NamespaceTypeName' mangledTypeName);  			return nestedTypeName.GetAsNamedTypeReference (this' nstr.Module);  		}  		NestedTypeNameTypeReference /*?*/netr = parentModuleType as NestedTypeNameTypeReference;  		if (netr != null) {  			var nestedTypeName = new NestedTypeName (this.NameTable' netr.NestedTypeName' mangledTypeName);  			return nestedTypeName.GetAsNamedTypeReference (this' netr.Module);  		}  	}  	return null;  }  case TokenTypeIds.AssemblyRef: {  	AssemblyReference /*?*/assemRef = this.GetAssemblyReferenceAt (rowId);  	if (assemRef == null)  		return null;  	var internalAssembly = assemRef.ResolvedAssembly as Assembly;  	if (internalAssembly != null) {  		//Since we have already loaded the assembly that is supposed to hold this type' we may as well try and resolve it.  		PEFileToObjectModel assemblyPEFileToObjectModel = internalAssembly.PEFileToObjectModel;  		var type = assemblyPEFileToObjectModel.ResolveNamespaceTypeDefinition (namespaceName' mangledTypeName);  		if (type != null)  			return type;  		//The other assembly (internalAssembly) does not have a namespace type def for this reference.  		//Perhaps it has an alias that forwards to somewhere else... Not very likely happen in practice' I would hope.  		ExportedTypeAliasBase /*?*/aliasType = assemblyPEFileToObjectModel.TryToResolveAsNamespaceTypeAlias (namespaceName' mangledTypeName);  		if (aliasType != null && aliasType != alias)  			return assemblyPEFileToObjectModel.GetReferenceToAliasedType (aliasType);  		//Although we can resolve the target assembly' we can neither resolve the aliased type' nor find a secondary alias.  		//This is mighty strange. Probably the host has fluffed assembly resolution and internalAssembly isn't really the  		//assembly we are looking for. We now have to give up and simply return an unresolved reference.  	}  	string fullTypeName = mangledTypeName.Value;  	if (namespaceName.Value.Length > 0)  		fullTypeName = namespaceName.Value + "." + fullTypeName;  	var parser = new TypeNameParser (this.NameTable' fullTypeName);  	return parser.ParseTypeName ().GetAsTypeReference (this' assemRef) as INamedTypeReference;  }  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetFieldMapping,The following switch statement is missing a default case: switch (this.PEFileReader.RVAToSubSectionName (rva)) {  case ".text":  	sectionKind = PESectionKind.Text;  	break;  case ".sdata":  	sectionKind = PESectionKind.StaticData;  	break;  case ".tls":  	sectionKind = PESectionKind.ThreadLocalStorage;  	break;  case ".rdata":  	sectionKind = PESectionKind.ConstantData;  	break;  case ".cover":  	sectionKind = PESectionKind.CoverageData;  	break;  case ".datax":  	sectionKind = PESectionKind.ExtendedData;  	break;  case ".data":  	sectionKind = PESectionKind.ExtendedData;  	break;  //TODO: instead of an enum' use an IName.  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetFieldSizeIfPossibleToDoSoWithoutResolving,The following switch statement is missing a default case: switch (typeReference.TypeCode) {  case PrimitiveTypeCode.Boolean:  	return sizeof(Boolean);  case PrimitiveTypeCode.Char:  	return sizeof(Char);  case PrimitiveTypeCode.Int16:  	return sizeof(Int16);  case PrimitiveTypeCode.Int32:  	return sizeof(Int32);  case PrimitiveTypeCode.Int8:  	return sizeof(SByte);  case PrimitiveTypeCode.UInt16:  	return sizeof(UInt16);  case PrimitiveTypeCode.UInt32:  	return sizeof(UInt32);  case PrimitiveTypeCode.UInt8:  	return sizeof(Byte);  case PrimitiveTypeCode.Int64:  	return sizeof(Int64);  case PrimitiveTypeCode.UInt64:  	return sizeof(UInt64);  case PrimitiveTypeCode.IntPtr:  	return this.pointerSize;  case PrimitiveTypeCode.UIntPtr:  	return this.pointerSize;  case PrimitiveTypeCode.Float32:  	return sizeof(Single);  case PrimitiveTypeCode.Float64:  	return sizeof(Double);  case PrimitiveTypeCode.Pointer:  	return this.pointerSize;  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetDefaultValue,The following switch statement is missing a default case: switch (constRow.Type) {  case ElementType.Boolean: {  	byte val = memoryReader.ReadByte ();  	return new ConstantExpression (this.PlatformType.SystemBoolean' val != 0);  }  case ElementType.Char:  	return new ConstantExpression (this.PlatformType.SystemChar' memoryReader.ReadChar ());  case ElementType.Int8:  	return new ConstantExpression (this.PlatformType.SystemInt8' memoryReader.ReadSByte ());  case ElementType.Int16:  	return new ConstantExpression (this.PlatformType.SystemInt16' memoryReader.ReadInt16 ());  case ElementType.Int32:  	return new ConstantExpression (this.PlatformType.SystemInt32' memoryReader.ReadInt32 ());  case ElementType.Int64:  	return new ConstantExpression (this.PlatformType.SystemInt64' memoryReader.ReadInt64 ());  case ElementType.UInt8:  	return new ConstantExpression (this.PlatformType.SystemUInt8' memoryReader.ReadByte ());  case ElementType.UInt16:  	return new ConstantExpression (this.PlatformType.SystemUInt16' memoryReader.ReadUInt16 ());  case ElementType.UInt32:  	return new ConstantExpression (this.PlatformType.SystemUInt32' memoryReader.ReadUInt32 ());  case ElementType.UInt64:  	return new ConstantExpression (this.PlatformType.SystemUInt64' memoryReader.ReadUInt64 ());  case ElementType.Single:  	return new ConstantExpression (this.PlatformType.SystemFloat32' memoryReader.ReadSingle ());  case ElementType.Double:  	return new ConstantExpression (this.PlatformType.SystemFloat64' memoryReader.ReadDouble ());  case ElementType.String: {  	int byteLen = memoryReader.Length;  	string /*?*/value;  	if (byteLen == -1) {  		value = null;  	}  	else if (byteLen == 0) {  		value = string.Empty;  	}  	else {  		value = memoryReader.ReadUTF16WithSize (byteLen);  	}  	return new ConstantExpression (this.PlatformType.SystemString' value);  }  case ElementType.Class:  	return new ConstantExpression (this.PlatformType.SystemObject' null);  }  
Missing Default,Microsoft.Cci.MetadataReader,PEFileToObjectModel,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileToObjectModel.cs,GetMethodReferenceForToken,The following switch statement is missing a default case: switch (tokenKind) {  case TokenTypeIds.MethodDef:  	methRef = this.GetMethodDefAtRow (rowId);  	break;  case TokenTypeIds.MethodSpec:  	methRef = this.GetMethodSpecAtRow (owningObject' rowId);  	break;  case TokenTypeIds.MemberRef:  	methRef = this.GetModuleMemberReferenceAtRow (owningObject' rowId) as IMethodReference;  	break;  }  
Missing Default,Microsoft.Cci.MetadataReader,WindowsRuntimeMetadataReaderHost,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\WindowsRuntimeHost.cs,Rewrite,The following switch statement is missing a default case: switch ((int)argConst.Value) {  case 0x00000001:  	clrEnumValue = 0x00001000;  	break;  case 0x00000002:  	clrEnumValue = 0x00000010;  	break;  case 0x00000004:  	clrEnumValue = 0x00000200;  	break;  case 0x00000008:  	clrEnumValue = 0x00000100;  	break;  case 0x00000010:  	clrEnumValue = 0x00000400;  	break;  case 0x00000020:  	clrEnumValue = 0x00000000;  	break;  case 0x00000040:  	clrEnumValue = 0x00000040;  	break;  case 0x00000080:  	clrEnumValue = 0x00000800;  	break;  case 0x00000100:  	clrEnumValue = 0x00000080;  	break;  case 0x00000200:  	clrEnumValue = 0x00000004;  	break;  case 0x00000400:  	clrEnumValue = 0x00000008;  	break;  case 0x00000800:  	clrEnumValue = 0x00000000;  	break;  case -1:  	clrEnumValue = 0x00007FFF;  	break;  }  
Missing Default,Microsoft.Cci.MetadataReader.PEFile,HasCustomAttributeTag,C:\repos\FlorianGrimm_whid\other\ccimetadata\Sources\PeReader\PEFileStructures.cs,ConvertToTag,The following switch statement is missing a default case: switch (tokenType) {  case TokenTypeIds.MethodDef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Method;  case TokenTypeIds.FieldDef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Field;  case TokenTypeIds.TypeRef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeRef;  case TokenTypeIds.TypeDef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeDef;  case TokenTypeIds.ParamDef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Param;  case TokenTypeIds.InterfaceImpl:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.InterfaceImpl;  case TokenTypeIds.MemberRef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.MemberRef;  case TokenTypeIds.Module:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Module;  case TokenTypeIds.Permission:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.DeclSecurity;  case TokenTypeIds.Property:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Property;  case TokenTypeIds.Event:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Event;  case TokenTypeIds.Signature:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.StandAloneSig;  case TokenTypeIds.ModuleRef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ModuleRef;  case TokenTypeIds.TypeSpec:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.TypeSpec;  case TokenTypeIds.Assembly:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.Assembly;  case TokenTypeIds.AssemblyRef:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.AssemblyRef;  case TokenTypeIds.File:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.File;  case TokenTypeIds.ExportedType:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ExportedType;  case TokenTypeIds.ManifestResource:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.ManifestResource;  case TokenTypeIds.GenericParam:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.GenericParameter;  case TokenTypeIds.GenericParamConstraint:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.GenericParameterConstraint;  case TokenTypeIds.MethodSpec:  	return rowId << HasCustomAttributeTag.NumberOfBits | HasCustomAttributeTag.MethodSpec;  }  
