Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Reactive.Linq,QueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\QueryLanguage.Aggregates.cs,SequenceEqual,The method has 126 lines of code.
Complex Method,System.Reactive,ReflectionUtils,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ReflectionUtils.cs,GetEventMethods,Cyclomatic complexity of the method is 12
Complex Method,System.Reactive,TailRecursiveSink,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\TailRecursiveSink.cs,MoveNext,Cyclomatic complexity of the method is 10
Complex Method,System.Reactive.Linq.Observαble,CombineLatestSink,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\CombineLatest.cs,Next,Cyclomatic complexity of the method is 9
Complex Method,System.Reactive.Linq.Observαble,ZipSink,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\Zip.cs,Next,Cyclomatic complexity of the method is 8
Complex Method,System.Reactive.Subjects,Subject,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Subjects\Subject.cs,Subscribe,Cyclomatic complexity of the method is 8
Complex Method,System.Reactive.Threading.Tasks,TaskObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Threading\Tasks\TaskObservableExtensions.cs,ToObservableDone,Cyclomatic complexity of the method is 10
Complex Method,System.Reactive.Threading.Tasks,TaskObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Threading\Tasks\TaskObservableExtensions.cs,ToObservableDone,Cyclomatic complexity of the method is 10
Long Parameter List,System.Reactive,ReflectionUtils,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ReflectionUtils.cs,GetEventMethods,The method has 7 parameters.
Long Parameter List,System.Reactive.Concurrency,EventLoopScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\EventLoopScheduler.cs,SchedulePeriodic,The method has 5 parameters.
Long Parameter List,System.Reactive.Concurrency,HistoricalScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\HistoricalScheduler.cs,ScheduleAbsolute,The method has 5 parameters.
Long Parameter List,System.Reactive.Concurrency,SynchronizationContextScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\SynchronizationContextScheduler.cs,Schedule,The method has 5 parameters.
Long Parameter List,System.Reactive.Concurrency,TaskPoolScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\TaskPoolScheduler.cs,Schedule,The method has 5 parameters.
Long Parameter List,System.Reactive.Concurrency,VirtualTimeScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\VirtualTimeScheduler.cs,ScheduleAbsolute,The method has 5 parameters.
Long Parameter List,System.Reactive.Concurrency,WpfDispatcherScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\WpfDispatcherScheduler.cs,Schedule,The method has 7 parameters.
Long Parameter List,System.Reactive.Concurrency,WpfDispatcherScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\WpfDispatcherScheduler.cs,SchedulePeriodic,The method has 6 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,Replay,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,Generate,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,CombineLatest,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,Zip,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,GroupByUntil,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,GroupJoin,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,Join,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,Generate,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,Generate,The method has 6 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,Generate,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq,IQueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\IQueryLanguage.cs,Generate,The method has 6 parameters.
Long Parameter List,System.Reactive.Linq.Observαble,Generate,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\Generate.cs,Generate,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq.Observαble,Generate,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\Generate.cs,Generate,The method has 6 parameters.
Long Parameter List,System.Reactive.Linq.Observαble,Generate,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\Generate.cs,Generate,The method has 6 parameters.
Long Parameter List,System.Reactive.Linq.Observαble,GroupByUntil,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\GroupByUntil.cs,GroupByUntil,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq.Observαble,GroupJoin,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\GroupJoin.cs,GroupJoin,The method has 5 parameters.
Long Parameter List,System.Reactive.Linq.Observαble,Join,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\Join.cs,Join,The method has 5 parameters.
Long Parameter List,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Observable.Extensions.cs,Subscribe,The method has 5 parameters.
Long Parameter List,System.Reactive.Threading.Tasks,TaskObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Threading\Tasks\TaskObservableExtensions.cs,ToTask,The method has 5 parameters.
Long Statement,System.Reactive,ReflectionUtils,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ReflectionUtils.cs,GetEventMethods,The length of the statement  "			throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' Strings_Linq.COULD_NOT_FIND_STATIC_EVENT' eventName' targetType.FullName)); " is 155.
Long Statement,System.Reactive,ReflectionUtils,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ReflectionUtils.cs,GetEventMethods,The length of the statement  "			throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' Strings_Linq.COULD_NOT_FIND_INSTANCE_EVENT' eventName' targetType.FullName)); " is 157.
Long Statement,System.Reactive,ReflectionUtils,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ReflectionUtils.cs,GetEventMethods,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' Strings_Linq.EVENT_SENDER_NOT_ASSIGNABLE' typeof(TSender).FullName)); " is 149.
Long Statement,System.Reactive,ReflectionUtils,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ReflectionUtils.cs,GetEventMethods,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' Strings_Linq.EVENT_ARGS_NOT_ASSIGNABLE' typeof(TEventArgs).FullName)); " is 150.
Long Statement,System.Reactive,ReflectionUtils,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ReflectionUtils.cs,GetEventEx,The length of the statement  "	return type.GetEvent (name' isStatic ? BindingFlags.Public | BindingFlags.Static : BindingFlags.Public | BindingFlags.Instance); " is 128.
Long Statement,System.Reactive,ObservableQueryProvider,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\ObservableQuery.cs,CreateQuery,The length of the statement  "	var res = Expression.Call (AsQueryable.MakeGenericMethod (typeof(TElement))' Expression.Call (typeof(Observable).GetMethod ("ToEnumerable").MakeGenericMethod (typeof(TElement))' arg0)); " is 185.
Long Statement,System.Reactive.Concurrency,ConcurrencyAbstractionLayer,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\ConcurrencyAbstractionLayer.cs,Initialize,The length of the statement  "	return PlatformEnlightenmentProvider.Current.GetService<IConcurrencyAbstractionLayer> () ?? new DefaultConcurrencyAbstractionLayer (); " is 134.
Long Statement,System.Reactive.Concurrency,Synchronization,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\Synchronization.cs,ObserveOn,The length of the statement  "	            return new AnonymousObservable<TSource>(observer => source.Subscribe(new ObserveOnObserver<TSource>(scheduler' observer' null)));" is 129.
Long Statement,System.Reactive.Concurrency,TaskPoolScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\TaskPoolScheduler.cs,Schedule,The length of the statement  "            }' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnRanToCompletion' taskFactory.Scheduler);" is 144.
Long Statement,System.Reactive.Concurrency,TaskPoolScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\TaskPoolScheduler.cs,SchedulePeriodic,The length of the statement  "                    CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.OnlyOnRanToCompletion' taskFactory.Scheduler" is 139.
Long Statement,System.Reactive.Concurrency,VirtualTimeSchedulerBase,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\VirtualTimeScheduler.cs,AdvanceTo,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' Strings_Linq.CANT_ADVANCE_WHILE_RUNNING' "AdvanceTo")); " is 135.
Long Statement,System.Reactive.Concurrency,VirtualTimeSchedulerBase,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\VirtualTimeScheduler.cs,AdvanceBy,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' Strings_Linq.CANT_ADVANCE_WHILE_RUNNING' "AdvanceBy")); " is 135.
Long Statement,System.Reactive.PlatformServices,SystemClock,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\SystemClock.cs,InitializeSystemClockChanged,The length of the statement  "	return PlatformEnlightenmentProvider.Current.GetService<INotifySystemClockChanged> () ?? new DefaultSystemClockMonitor (); " is 122.
Long Statement,System.Reactive.Linq,QueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\QueryLanguage.Aggregates.cs,Average,The length of the statement  "	            return source.Scan(new { sum = 0F' count = 0L }' // NOTE: Uses a different accumulator type (float)' *not* conform LINQ to Objects." is 131.
Long Statement,System.Reactive.Linq,QueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\QueryLanguage.Aggregates.cs,Average,The length of the statement  "	            return source.Aggregate(new { sum = new float?(0f)' count = 0L }' // NOTE: Uses a different accumulator type (float)' *not* conform LINQ to Objects." is 148.
Long Statement,System.Reactive.Linq,QueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\QueryLanguage.Aggregates.cs,Average,The length of the statement  "                               (prev' cur) => cur != null ? new { sum = checked(prev.sum + cur.GetValueOrDefault())' count = checked(prev.count + 1) } : prev)" is 127.
Long Statement,System.Reactive.Linq,QueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\QueryLanguage.Aggregates.cs,Average,The length of the statement  "                               (prev' cur) => cur != null ? new { sum = checked(prev.sum + cur.GetValueOrDefault())' count = checked(prev.count + 1) } : prev)" is 127.
Long Statement,System.Reactive.Linq,QueryLanguage,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\QueryLanguage.Aggregates.cs,ToDictionary,The length of the statement  "	return new ToDictionary<TSource' TKey' TElement> (source' keySelector' elementSelector' EqualityComparer<TKey>.Default); " is 120.
Long Statement,System.Reactive.Linq.Observαble,Max,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\Max.cs,Run,The length of the statement  "	// LINQ to Objects makes this distinction in order to make [Max|Max] of an empty collection of reference type objects equal to null. " is 132.
Long Statement,System.Reactive.Linq.Observαble,Min,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Linq\Observable\Min.cs,Run,The length of the statement  "	// LINQ to Objects makes this distinction in order to make [Min|Max] of an empty collection of reference type objects equal to null. " is 132.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Long Statement,System,ObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Observable.Extensions.cs,Subscribe,The length of the statement  "	// [OK] Use of unsafe Subscribe: non-pretentious constructor for an observer; this overload is not to be used internally. " is 121.
Magic Number,System.Reactive,Observer,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\Observers.cs,Remove,The following statement contains a magic number: if (_observers.Data.Length == 2) {  	return _observers.Data [1 - i];  }  else {  	return new Observer<T> (_observers.Remove (observer));  }  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\PriorityQueue.cs,RemoveAt,The following statement contains a magic number: if (_size < _items.Length / 4) {  	var temp = _items;  	_items = new IndexedItem[_items.Length / 2];  	Array.Copy (temp' 0' _items' 0' _size);  }  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\PriorityQueue.cs,RemoveAt,The following statement contains a magic number: if (_size < _items.Length / 4) {  	var temp = _items;  	_items = new IndexedItem[_items.Length / 2];  	Array.Copy (temp' 0' _items' 0' _size);  }  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\PriorityQueue.cs,RemoveAt,The following statement contains a magic number: _items = new IndexedItem[_items.Length / 2];  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\PriorityQueue.cs,Enqueue,The following statement contains a magic number: if (_size >= _items.Length) {  	var temp = _items;  	_items = new IndexedItem[_items.Length * 2];  	Array.Copy (temp' _items' temp.Length);  }  
Magic Number,System.Reactive,PriorityQueue,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\PriorityQueue.cs,Enqueue,The following statement contains a magic number: _items = new IndexedItem[_items.Length * 2];  
Magic Number,System.Reactive,ReflectionUtils,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ReflectionUtils.cs,GetEventMethods,The following statement contains a magic number: if (parameters.Length != 2)  	throw new InvalidOperationException (Strings_Linq.EVENT_PATTERN_REQUIRES_TWO_PARAMETERS);  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ScheduledObserver.cs,EnsureDispatcher,The following statement contains a magic number: if (_dispatcherJob == null) {  	lock (_dispatcherInitGate) {  		if (_dispatcherJob == null) {  			_dispatcherJob = _longRunning.ScheduleLongRunning (Dispatch);  			_disposable.Disposable = new CompositeDisposable (2) {  				_dispatcherJob'  				Disposable.Create (() => _dispatcherEvent.Release ())  			};  		}  	}  }  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ScheduledObserver.cs,EnsureDispatcher,The following statement contains a magic number: lock (_dispatcherInitGate) {  	if (_dispatcherJob == null) {  		_dispatcherJob = _longRunning.ScheduleLongRunning (Dispatch);  		_disposable.Disposable = new CompositeDisposable (2) {  			_dispatcherJob'  			Disposable.Create (() => _dispatcherEvent.Release ())  		};  	}  }  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ScheduledObserver.cs,EnsureDispatcher,The following statement contains a magic number: if (_dispatcherJob == null) {  	_dispatcherJob = _longRunning.ScheduleLongRunning (Dispatch);  	_disposable.Disposable = new CompositeDisposable (2) {  		_dispatcherJob'  		Disposable.Create (() => _dispatcherEvent.Release ())  	};  }  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ScheduledObserver.cs,EnsureDispatcher,The following statement contains a magic number: _disposable.Disposable = new CompositeDisposable (2) {  	_dispatcherJob'  	Disposable.Create (() => _dispatcherEvent.Release ())  };  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ScheduledObserver.cs,Run,The following statement contains a magic number: try {  	_observer.OnNext (next);  }  catch {  	#pragma  	Interlocked.Exchange (ref _state' FAULTED);  	#pragma  	var nop = default(T);  	while (_queue.TryDequeue (out nop))  		;  	throw;  }  
Magic Number,System.Reactive,ScheduledObserver,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\ScheduledObserver.cs,Run,The following statement contains a magic number: try {  	_observer.OnNext (next);  }  catch {  	#pragma  	Interlocked.Exchange (ref _state' FAULTED);  	#pragma  	var nop = default(T);  	while (_queue.TryDequeue (out nop))  		;  	throw;  }  
Magic Number,System.Reactive.Concurrency,CurrentThreadScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\CurrentThreadScheduler.cs,Schedule,The following statement contains a magic number: if (queue == null) {  	queue = new SchedulerQueue<TimeSpan> (4);  	queue.Enqueue (si);  	CurrentThreadScheduler.SetQueue (queue);  	try {  		Trampoline.Run (queue);  	}  	finally {  		CurrentThreadScheduler.SetQueue (null);  	}  }  else {  	queue.Enqueue (si);  }  
Magic Number,System.Reactive.Concurrency,CurrentThreadScheduler,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Concurrency\CurrentThreadScheduler.cs,Schedule,The following statement contains a magic number: queue = new SchedulerQueue<TimeSpan> (4);  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: lock (_gate) {  	if (!_disposed) {  		//  		// List<T> doesn't shrink the size of the underlying array but does collapse the array  		// by copying the tail one position to the left of the removal index. We don't need  		// index-based lookup but only ordering for sequential disposal. So' instead of spending  		// cycles on the Array.Copy imposed by Remove' we use a null sentinel value. We also  		// do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.  		//  		var i = _disposables.IndexOf (item);  		if (i >= 0) {  			shouldDispose = true;  			_disposables [i] = null;  			_count--;  			if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  				var old = _disposables;  				_disposables = new List<IDisposable> (_disposables.Capacity / 2);  				foreach (var d in old)  					if (d != null)  						_disposables.Add (d);  			}  		}  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: lock (_gate) {  	if (!_disposed) {  		//  		// List<T> doesn't shrink the size of the underlying array but does collapse the array  		// by copying the tail one position to the left of the removal index. We don't need  		// index-based lookup but only ordering for sequential disposal. So' instead of spending  		// cycles on the Array.Copy imposed by Remove' we use a null sentinel value. We also  		// do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.  		//  		var i = _disposables.IndexOf (item);  		if (i >= 0) {  			shouldDispose = true;  			_disposables [i] = null;  			_count--;  			if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  				var old = _disposables;  				_disposables = new List<IDisposable> (_disposables.Capacity / 2);  				foreach (var d in old)  					if (d != null)  						_disposables.Add (d);  			}  		}  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (!_disposed) {  	//  	// List<T> doesn't shrink the size of the underlying array but does collapse the array  	// by copying the tail one position to the left of the removal index. We don't need  	// index-based lookup but only ordering for sequential disposal. So' instead of spending  	// cycles on the Array.Copy imposed by Remove' we use a null sentinel value. We also  	// do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.  	//  	var i = _disposables.IndexOf (item);  	if (i >= 0) {  		shouldDispose = true;  		_disposables [i] = null;  		_count--;  		if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  			var old = _disposables;  			_disposables = new List<IDisposable> (_disposables.Capacity / 2);  			foreach (var d in old)  				if (d != null)  					_disposables.Add (d);  		}  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (!_disposed) {  	//  	// List<T> doesn't shrink the size of the underlying array but does collapse the array  	// by copying the tail one position to the left of the removal index. We don't need  	// index-based lookup but only ordering for sequential disposal. So' instead of spending  	// cycles on the Array.Copy imposed by Remove' we use a null sentinel value. We also  	// do manual Swiss cheese detection to shrink the list if there's a lot of holes in it.  	//  	var i = _disposables.IndexOf (item);  	if (i >= 0) {  		shouldDispose = true;  		_disposables [i] = null;  		_count--;  		if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  			var old = _disposables;  			_disposables = new List<IDisposable> (_disposables.Capacity / 2);  			foreach (var d in old)  				if (d != null)  					_disposables.Add (d);  		}  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (i >= 0) {  	shouldDispose = true;  	_disposables [i] = null;  	_count--;  	if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  		var old = _disposables;  		_disposables = new List<IDisposable> (_disposables.Capacity / 2);  		foreach (var d in old)  			if (d != null)  				_disposables.Add (d);  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (i >= 0) {  	shouldDispose = true;  	_disposables [i] = null;  	_count--;  	if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  		var old = _disposables;  		_disposables = new List<IDisposable> (_disposables.Capacity / 2);  		foreach (var d in old)  			if (d != null)  				_disposables.Add (d);  	}  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  	var old = _disposables;  	_disposables = new List<IDisposable> (_disposables.Capacity / 2);  	foreach (var d in old)  		if (d != null)  			_disposables.Add (d);  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: if (_disposables.Capacity > SHRINK_THRESHOLD && _count < _disposables.Capacity / 2) {  	var old = _disposables;  	_disposables = new List<IDisposable> (_disposables.Capacity / 2);  	foreach (var d in old)  		if (d != null)  			_disposables.Add (d);  }  
Magic Number,System.Reactive.Disposables,CompositeDisposable,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Disposables\CompositeDisposable.cs,Remove,The following statement contains a magic number: _disposables = new List<IDisposable> (_disposables.Capacity / 2);  
Magic Number,System.Reactive.Subjects,Subject,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Subjects\Subject.cs,OnCompleted,The following statement contains a magic number: do {  	oldObserver = _observer;  	if (oldObserver == DisposedObserver<T>.Instance || oldObserver is DoneObserver<T>)  		break;  	#pragma  }  while (Interlocked.CompareExchange (ref _observer' newObserver' oldObserver) != oldObserver);  
Magic Number,System.Reactive.Subjects,Subject,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Subjects\Subject.cs,OnError,The following statement contains a magic number: do {  	oldObserver = _observer;  	if (oldObserver == DisposedObserver<T>.Instance || oldObserver is DoneObserver<T>)  		break;  	#pragma  }  while (Interlocked.CompareExchange (ref _observer' newObserver' oldObserver) != oldObserver);  
Magic Number,System.Reactive.Subjects,Subject,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Subjects\Subject.cs,Subscribe,The following statement contains a magic number: do {  	oldObserver = _observer;  	if (oldObserver == DisposedObserver<T>.Instance) {  		throw new ObjectDisposedException ("");  	}  	if (oldObserver == DoneObserver<T>.Completed) {  		observer.OnCompleted ();  		return Disposable.Empty;  	}  	var done = oldObserver as DoneObserver<T>;  	if (done != null) {  		observer.OnError (done.Exception);  		return Disposable.Empty;  	}  	if (oldObserver == NopObserver<T>.Instance) {  		newObserver = observer;  	}  	else {  		var obs = oldObserver as Observer<T>;  		if (obs != null) {  			newObserver = obs.Add (observer);  		}  		else {  			newObserver = new Observer<T> (new ImmutableList<IObserver<T>> (new[] {  				oldObserver'  				observer  			}));  		}  	}  	#pragma  }  while (Interlocked.CompareExchange (ref _observer' newObserver' oldObserver) != oldObserver);  
Magic Number,System.Reactive.Subjects,Subject,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Subjects\Subject.cs,Unsubscribe,The following statement contains a magic number: do {  	oldObserver = _observer;  	if (oldObserver == DisposedObserver<T>.Instance || oldObserver is DoneObserver<T>)  		return;  	var obs = oldObserver as Observer<T>;  	if (obs != null) {  		newObserver = obs.Remove (observer);  	}  	else {  		if (oldObserver != observer)  			return;  		newObserver = NopObserver<T>.Instance;  	}  	#pragma  }  while (Interlocked.CompareExchange (ref _observer' newObserver' oldObserver) != oldObserver);  
Missing Default,System.Reactive,CheckedObserver,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\CheckedObserver.cs,CheckAccess,The following switch statement is missing a default case: switch (Interlocked.CompareExchange (ref _state' BUSY' IDLE)) {  case BUSY:  	throw new InvalidOperationException (Strings_Core.REENTRANCY_DETECTED);  case DONE:  	throw new InvalidOperationException (Strings_Core.OBSERVER_TERMINATED);  }  
Missing Default,System.Reactive.PlatformServices,CurrentPlatformEnlightenmentProvider,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Internal\CurrentPlatformEnlightenmentProvider.cs,GetService,The following switch statement is missing a default case: switch ((string)args [0]) {  #if !WINDOWS && !NO_THREAD  case "ThreadPool":  	return (T)(object)ThreadPoolScheduler.Instance;  #elif WINDOWS                      case "ThreadPool":                         return (T)(object)ThreadPoolScheduler.Default; #endif  #if !NO_TPL  case "TaskPool":  	return (T)(object)TaskPoolScheduler.Default;  #endif  case "NewThread":  	return (T)(object)NewThreadScheduler.Default;  }  
Missing Default,System.Reactive.Threading.Tasks,TaskObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Threading\Tasks\TaskObservableExtensions.cs,ToObservableDone,The following switch statement is missing a default case: switch (task.Status) {  case TaskStatus.RanToCompletion:  	subject.OnNext (Unit.Default);  	subject.OnCompleted ();  	break;  case TaskStatus.Faulted:  	subject.OnError (task.Exception.InnerException);  	break;  case TaskStatus.Canceled:  	subject.OnError (new TaskCanceledException (task));  	break;  }  
Missing Default,System.Reactive.Threading.Tasks,TaskObservableExtensions,C:\repos\FlorianGrimm_whid\src\whid\System.Reactive\Threading\Tasks\TaskObservableExtensions.cs,ToObservableDone,The following switch statement is missing a default case: switch (task.Status) {  case TaskStatus.RanToCompletion:  	subject.OnNext (task.Result);  	subject.OnCompleted ();  	break;  case TaskStatus.Faulted:  	subject.OnError (task.Exception.InnerException);  	break;  case TaskStatus.Canceled:  	subject.OnError (new TaskCanceledException (task));  	break;  }  
