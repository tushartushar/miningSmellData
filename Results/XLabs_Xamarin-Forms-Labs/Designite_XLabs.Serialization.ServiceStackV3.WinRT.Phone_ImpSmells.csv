Implementation smell,Namespace,Class,File,Method,Description
Long Method,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The method has 113 lines of code.
Long Method,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,Init,The method has 105 lines of code.
Long Method,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The method has 107 lines of code.
Complex Method,ServiceStack.Text,CsvSerializer<T>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\CsvSerializer.cs,GetWriteFn,Cyclomatic complexity of the method is 11
Complex Method,ServiceStack.Text,CsvWriter<T>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\CsvWriter.cs,Write,Cyclomatic complexity of the method is 11
Complex Method,ServiceStack.Text,JsvFormatter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\JsvFormatter.cs,Format,Cyclomatic complexity of the method is 9
Complex Method,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,ExtractContents,Cyclomatic complexity of the method is 8
Complex Method,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,Cyclomatic complexity of the method is 12
Complex Method,ServiceStack.Text.Common,DeserializeBuiltin<T>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeBuiltin.cs,GetParseFn,Cyclomatic complexity of the method is 35
Complex Method,ServiceStack.Text.Common,DeserializeDictionary<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeDictionary.cs,ParseDictionary,Cyclomatic complexity of the method is 8
Complex Method,ServiceStack.Text.Common,DeserializeSpecializedCollections<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeSpecializedCollections.cs,GetParseFn,Cyclomatic complexity of the method is 8
Complex Method,ServiceStack.Text.Common,DeserializeType<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,ParsePrimitive,Cyclomatic complexity of the method is 16
Complex Method,ServiceStack.Text.Common,TypeAccessor,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,GetSetPropertyMethod,Cyclomatic complexity of the method is 9
Complex Method,ServiceStack.Text.Common,DeserializeTypeRef,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRef.cs,GetTypeAccessorMap,Cyclomatic complexity of the method is 8
Complex Method,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,Cyclomatic complexity of the method is 29
Complex Method,ServiceStack.Text.Common,DeserializeTypeRefJsv,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJsv.cs,StringToType,Cyclomatic complexity of the method is 15
Complex Method,ServiceStack.Text.Common,JsReader<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\JsReader.cs,GetCoreParseFn,Cyclomatic complexity of the method is 22
Complex Method,ServiceStack.Text.Common,JsWriter<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\JsWriter.cs,GetValueTypeToStringMethod,Cyclomatic complexity of the method is 24
Complex Method,ServiceStack.Text.Common,JsWriter<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\JsWriter.cs,GetCoreWriteFn,Cyclomatic complexity of the method is 16
Complex Method,ServiceStack.Text.Common,WriteLists<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteLists.cs,GetWriteFn,Cyclomatic complexity of the method is 10
Complex Method,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,Init,Cyclomatic complexity of the method is 9
Complex Method,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,WriteProperties,Cyclomatic complexity of the method is 15
Complex Method,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,Cyclomatic complexity of the method is 8
Complex Method,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatValue,Cyclomatic complexity of the method is 8
Complex Method,ServiceStack.Text.Support,DoubleConverter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\DoubleConverter.cs,ToExactString,Cyclomatic complexity of the method is 10
Long Parameter List,ServiceStack.Text,JsConfig,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\JsConfig.cs,With,The method has 24 parameters. Parameters: convertObjectTypesIntoStringDictionary' tryToParsePrimitiveTypeValues' tryToParseNumericType' includeNullValues' excludeTypeInfo' includeTypeInfo' emitCamelCaseNames' emitLowercaseUnderscoreNames' dateHandler' timeSpanHandler' preferInterfaces' throwOnDeserializationError' typeAttr' typeWriter' typeFinder' treatEnumAsInteger' alwaysUseUtc' assumeUtc' appendUtcOffset' escapeUnicode' includePublicFields' maxDepth' modelFactory' excludePropertyReferences
Long Parameter List,ServiceStack.Text.Common,DeserializeDictionary<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeDictionary.cs,ParseDictionaryType,The method has 5 parameters. Parameters: value' createMapType' argTypes' keyParseFn' valueParseFn
Long Parameter List,ServiceStack.Text.Common,DeserializeKeyValuePair<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeKeyValuePair.cs,ParseKeyValuePairType,The method has 5 parameters. Parameters: value' createMapType' argTypes' keyParseFn' valueParseFn
Long Parameter List,ServiceStack.Text.Common,TypePropertyWriter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,TypePropertyWriter,The method has 11 parameters. Parameters: propertyName' propertyReflectedName' propertyNameCLSFriendly' propertyNameLowercaseUnderscore' propertyOrder' propertySuppressDefaultConfig' propertySuppressDefaultAttribute' getterFn' writeFn' defaultValue' shouldSerialize
Long Identifier,ServiceStack.Text,CsvConfig,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\CsvConfig.cs,,The length of the parameter DefaultEscapedItemDelimiterString is 33.
Long Identifier,ServiceStack.Text,JsConfig,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\JsConfig.cs,With,The length of the parameter convertObjectTypesIntoStringDictionary is 38.
Long Identifier,ServiceStack.Text,JsConfig,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\JsConfig.cs,,The length of the parameter sConvertObjectTypesIntoStringDictionary is 39.
Long Identifier,ServiceStack.Text,JsConfig,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\JsConfig.cs,,The length of the parameter sTryToParsePrimitiveTypeValues is 30.
Long Identifier,ServiceStack.Text,TranslateListWithElements,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\TranslateListWithElements.cs,,The length of the parameter TranslateConvertibleICollectionCache is 36.
Long Identifier,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,,The length of the parameter DefaultDateTimeFormatWithFraction is 33.
Long Identifier,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,,The length of the parameter DateTimeFormatSecondsUtcOffset is 30.
Long Identifier,ServiceStack.Text.Common,DeserializeDictionary<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeDictionary.cs,ParseDictionary,The length of the parameter tryToParseItemsAsPrimitiveTypes is 31.
Long Identifier,ServiceStack.Text.Common,DeserializeListWithElements<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeListWithElements.cs,ParseGenericList,The length of the parameter tryToParseItemsAsPrimitiveTypes is 31.
Long Identifier,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,Init,The length of the parameter propertySuppressDefaultAttribute is 32.
Long Identifier,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,Init,The length of the parameter propertySuppressDefaultAttribute is 32.
Long Identifier,ServiceStack.Text.Common,TypePropertyWriter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,TypePropertyWriter,The length of the parameter propertyNameLowercaseUnderscore is 31.
Long Identifier,ServiceStack.Text.Common,TypePropertyWriter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,TypePropertyWriter,The length of the parameter propertySuppressDefaultAttribute is 32.
Long Identifier,ServiceStack.Text.Common,TypePropertyWriter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,,The length of the parameter propertySuppressDefaultAttribute is 32.
Long Identifier,ServiceStack.Text.Common,TypePropertyWriter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,,The length of the parameter propertyNameLowercaseUnderscore is 31.
Long Statement,ServiceStack.Text,AssemblyUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\AssemblyUtils.cs,MainInterface,The length of the statement  "				var interfaceType = t.GetTypeInfo().ImplementedInterfaces.FirstOrDefault(i => !t.GetTypeInfo().ImplementedInterfaces.Any(i2 => i2.GetTypeInfo().ImplementedInterfaces.Contains(i))); " is 180.
Long Statement,ServiceStack.Text,AssemblyUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\AssemblyUtils.cs,MainInterface,The length of the statement  "				var interfaceType = t.GetInterfaces().FirstOrDefault(i => !t.GetInterfaces().Any(i2 => i2.GetInterfaces().Contains(i))); " is 120.
Long Statement,ServiceStack.Text,DateTimeExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\DateTimeExtensions.cs,ToStableUniversalTime,The length of the statement  "			// Silverlight 3' 4 and 5 all work ok with DateTime.ToUniversalTime' but have no TimeZoneInfo.ConverTimeToUtc implementation. " is 125.
Long Statement,ServiceStack.Text,JsConfig,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\JsConfig.cs,With,The length of the statement  "                ConvertObjectTypesIntoStringDictionary = convertObjectTypesIntoStringDictionary ?? sConvertObjectTypesIntoStringDictionary' " is 123.
Long Statement,ServiceStack.Text,ReflectionExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\ReflectionExtensions.cs,GetConstructorMethodToCache,The length of the statement  "                var dm = new System.Reflection.Emit.DynamicMethod("MyCtor"' type' Type.EmptyTypes' typeof(ReflectionExtensions).Module' true); " is 126.
Long Statement,ServiceStack.Text,ReflectionExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\ReflectionExtensions.cs,GetSerializableProperties,The length of the statement  "            return publicReadableProperties.Where(prop => !prop.CustomAttributes(false).Any(attr => attr.GetType().Name == IgnoreDataMember)).ToArray(); " is 140.
Long Statement,ServiceStack.Text,ReflectionExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\ReflectionExtensions.cs,GetSerializableFields,The length of the statement  "            return publicFields.Where(prop => !prop.CustomAttributes(false).Any(attr => attr.GetType().Name == IgnoreDataMember)).ToArray(); " is 128.
Long Statement,ServiceStack.Text,TranslateListWithElements,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\TranslateListWithElements.cs,TranslateToConvertibleGenericICollectionCache,The length of the statement  "            if (TranslateConvertibleICollectionCache.TryGetValue(typeKey' out translateToFn)) return translateToFn(from' toInstanceOfType); " is 127.
Long Statement,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseShortestXsdDateTime,The length of the statement  "            if (dateTimeStr.StartsWith(EscapedWcfJsonPrefix' StringComparison.Ordinal) || dateTimeStr.StartsWith(WcfJsonPrefix' StringComparison.Ordinal)) " is 142.
Long Statement,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseShortestXsdDateTime,The length of the statement  "                return DateTime.ParseExact(dateTimeStr' XsdDateTimeFormatSeconds' null' DateTimeStyles.AdjustToUniversal).Prepare(parsedAsUtc:true);  " is 132.
Long Statement,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The length of the statement  "                var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind); " is 130.
Long Statement,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseWcfJsonDateOffset,The length of the statement  "            var timeString = (suffixPos < 0) ? wcfJsonDate : wcfJsonDate.Substring(WcfJsonPrefix.Length' suffixPos - WcfJsonPrefix.Length); " is 127.
Long Statement,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseWcfJsonDateOffset,The length of the statement  "            // REVIEW: DCJS shoves offset in a separate field 'offsetMinutes'' we have the offset in the format' so shouldn't we use it? " is 124.
Long Statement,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,WriteWcfJsonDate,The length of the statement  "                if (JsConfig.DateHandler == JsonDateHandler.TimestampOffset && JsConfig.AppendUtcOffset.HasValue && JsConfig.AppendUtcOffset.Value) " is 131.
Long Statement,ServiceStack.Text.Common,DeserializeDictionary<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeDictionary.cs,VerifyAndGetStartIndex,The length of the statement  "                Tracer.Instance.WriteDebug("WARN: Map definitions should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"' " is 141.
Long Statement,ServiceStack.Text.Common,DeserializeDictionary<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeDictionary.cs,VerifyAndGetStartIndex,The length of the statement  "                    JsWriter.MapStartChar' createMapType != null ? createMapType.Name : "Dictionary<'>"' value.Substring(0' value.Length < 50 ? value.Length : 50)); " is 144.
Long Statement,ServiceStack.Text.Common,DeserializeKeyValuePair<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeKeyValuePair.cs,GetParseMethod,The length of the statement  "            return value => ParseKeyValuePairType(value' createMapType' keyValuePairArgs' keyTypeParseMethod' valueTypeParseMethod); " is 120.
Long Statement,ServiceStack.Text.Common,DeserializeKeyValuePair<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeKeyValuePair.cs,VerifyAndGetStartIndex,The length of the statement  "                Tracer.Instance.WriteDebug("WARN: Map definitions should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"' " is 141.
Long Statement,ServiceStack.Text.Common,DeserializeKeyValuePair<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeKeyValuePair.cs,VerifyAndGetStartIndex,The length of the statement  "                                           JsWriter.MapStartChar' createMapType != null ? createMapType.Name : "Dictionary<'>"' value.Substring(0' value.Length < 50 ? value.Length : 50)); " is 144.
Long Statement,ServiceStack.Text.Common,DeserializeListWithElements<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeListWithElements.cs,ParseGenericList,The length of the statement  "            //but not sure how you'd like to go about caching constructors with parameters -- I would probably build a NewExpression' .Compile to a LambdaExpression and cache " is 162.
Long Statement,ServiceStack.Text.Common,DeserializeList<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeListWithElements.cs,GetParseFn,The length of the statement  "                var parseFn = DeserializeListWithElements<TSerializer>.GetListTypeParseFn(createListType' elementType' supportedTypeParseMethod); " is 129.
Long Statement,ServiceStack.Text.Common,DeserializeType<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,ObjectStringToType,The length of the statement  "                    var dynamicMatch = DeserializeDictionary<TSerializer>.ParseDictionary<string' object>(strType' null' Serializer.UnescapeString' Serializer.UnescapeString); " is 155.
Long Statement,ServiceStack.Text.Common,DeserializeType<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,ParseQuotedPrimitive,The length of the statement  "            if (value.StartsWith(DateTimeSerializer.EscapedWcfJsonPrefix' StringComparison.Ordinal) || value.StartsWith(DateTimeSerializer.WcfJsonPrefix' StringComparison.Ordinal)) " is 168.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRef,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRef.cs,GetSerializationException,The length of the statement  "            var serializationException = new SerializationException(String.Format("Failed to set property '{0}' with '{1}'"' propertyName' propertyValueString)' e); " is 152.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "            for (; index < strType.Length; index++) { var c = strType[index]; if (c >= JsonTypeSerializer.WhiteSpaceFlags.Length || !JsonTypeSerializer.WhiteSpaceFlags[c]) break; } //Whitespace inline " is 188.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                for (; index < strType.Length; index++) { var c = strType[index]; if (c >= JsonTypeSerializer.WhiteSpaceFlags.Length || !JsonTypeSerializer.WhiteSpaceFlags[c]) break; } //Whitespace inline " is 188.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                var propType = possibleTypeInfo && propertyValueStr[0] == '_' ? TypeAccessor.ExtractType(Serializer' propertyValueStr) : null; " is 126.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                        for (; index < strType.Length; index++) { var c = strType[index]; if (c >= JsonTypeSerializer.WhiteSpaceFlags.Length || !JsonTypeSerializer.WhiteSpaceFlags[c]) break; } //Whitespace inline " is 188.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                                for (; index < strType.Length; index++) { var c = strType[index]; if (c >= JsonTypeSerializer.WhiteSpaceFlags.Length || !JsonTypeSerializer.WhiteSpaceFlags[c]) break; } //Whitespace inline " is 188.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                        if (JsConfig.ThrowOnDeserializationError) throw DeserializeTypeRef.GetSerializationException(propertyName' propertyValueStr' propType' e); " is 138.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                        else Tracer.Instance.WriteWarning("WARN: failed to set dynamic property {0} with: {1}"' propertyName' propertyValueStr); " is 120.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                        if (JsConfig.ThrowOnDeserializationError) throw DeserializeTypeRef.GetSerializationException(propertyName' propertyValueStr' typeAccessor.PropertyType' e); " is 155.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                for (; index < strType.Length; index++) { var c = strType[index]; if (c >= JsonTypeSerializer.WhiteSpaceFlags.Length || !JsonTypeSerializer.WhiteSpaceFlags[c]) break; } //Whitespace inline " is 188.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJson,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJson.cs,StringToType,The length of the statement  "                        for (; index < strType.Length; index++) { var c = strType[index]; if (c >= JsonTypeSerializer.WhiteSpaceFlags.Length || !JsonTypeSerializer.WhiteSpaceFlags[c]) break; } //Whitespace inline " is 188.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJsv,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJsv.cs,StringToType,The length of the statement  "                var propType = possibleTypeInfo && propertyValueStr[0] == '_' ? TypeAccessor.ExtractType(Serializer' propertyValueStr) : null; " is 126.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJsv,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJsv.cs,StringToType,The length of the statement  "                        if (JsConfig.ThrowOnDeserializationError) throw DeserializeTypeRef.GetSerializationException(propertyName' propertyValueStr' propType' e); " is 138.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJsv,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJsv.cs,StringToType,The length of the statement  "                        else Tracer.Instance.WriteWarning("WARN: failed to set dynamic property {0} with: {1}"' propertyName' propertyValueStr); " is 120.
Long Statement,ServiceStack.Text.Common,DeserializeTypeRefJsv,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRefJsv.cs,StringToType,The length of the statement  "                        if (JsConfig.ThrowOnDeserializationError) throw DeserializeTypeRef.GetSerializationException(propertyName' propertyValueStr' propType' e); " is 138.
Long Statement,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,GetShouldSerializeMethod,The length of the statement  "            var method = member.DeclaringType.GetMethod("ShouldSerialize" + member.Name' BindingFlags.Instance | BindingFlags.Public' " is 121.
Long Statement,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,GetShouldSerializeMethod,The length of the statement  "            return (method == null || method.ReturnType != typeof(bool)) ? null : (Func<T'bool>)Delegate.CreateDelegate(typeof(Func<T'bool>)' method); " is 138.
Long Statement,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,Init,The length of the statement  "                bool propertySuppressDefaultConfig = defaultValue != null && propertyType.IsValueType() && JsConfig.HasSerializeFn.Contains(propertyType); " is 138.
Long Statement,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,Init,The length of the statement  "                bool propertySuppressDefaultConfig = defaultValue != null && propertyType.IsValueType() && JsConfig.HasSerializeFn.Contains(propertyType); " is 138.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,IsEmptyMap,The length of the statement  "            for (; i < value.Length; i++) { var c = value[i]; if (c >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[c]) break; } //Whitespace inline " is 134.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,ParseJsonString,The length of the statement  "            for (; index < json.Length; index++) { var ch = json[index]; if (ch >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[ch]) break; } //Whitespace inline " is 147.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatMapStartChar,The length of the statement  "            for (; i < value.Length; i++) { var c = value[i]; if (c >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[c]) break; } //Whitespace inline " is 134.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatMapKey,The length of the statement  "            for (; i < value.Length; i++) { var c = value[i]; if (c >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[c]) break; } //Whitespace inline " is 134.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatMapKeySeperator,The length of the statement  "            for (; i < value.Length; i++) { var c = value[i]; if (c >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[c]) break; } //Whitespace inline " is 134.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatItemSeperatorOrMapEndChar,The length of the statement  "            for (; i < value.Length; i++) { var c = value[i]; if (c >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[c]) break; } //Whitespace inline " is 134.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatItemSeperatorOrMapEndChar,The length of the statement  "                for (; i < value.Length; i++) { var c = value[i]; if (c >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[c]) break; } //Whitespace inline " is 134.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatWhitespace,The length of the statement  "            for (; i < value.Length; i++) { var c = value[i]; if (c >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[c]) break; } //Whitespace inline " is 134.
Long Statement,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatValue,The length of the statement  "            for (; i < value.Length; i++) { var c = value[i]; if (c >= WhiteSpaceFlags.Length || !WhiteSpaceFlags[c]) break; } //Whitespace inline " is 134.
Long Statement,ServiceStack.Text.Jsv,JsvTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Jsv\JsvTypeSerializer.cs,WriteString,The length of the statement  "            if(JsState.QueryStringMode && !string.IsNullOrEmpty(value) && value.StartsWith(JsWriter.QuoteString) && value.EndsWith(JsWriter.QuoteString)) " is 141.
Complex Conditional,ServiceStack.Text,JsonObject,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\JsonObject.cs,WriteValue,The conditional expression  "(firstChar == JsWriter.MapStartChar && lastChar == JsWriter.MapEndChar)                      || (firstChar == JsWriter.ListStartChar && lastChar == JsWriter.ListEndChar)                       || JsonUtils.True == strValue                      || JsonUtils.False == strValue                      || NumberRegEx.IsMatch(strValue)"  is complex.
Complex Conditional,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The conditional expression  "charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46"  is complex.
Complex Conditional,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,ToCamelCase,The conditional expression  "firstPart && c0isUpper && (c1isUpper || i == 0)"  is complex.
Complex Conditional,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,ToLowercaseUnderscore,The conditional expression  "Char.IsDigit(t) || (Char.IsLetter(t) && Char.IsLower(t)) || t == '_'"  is complex.
Complex Conditional,ServiceStack.Text.Common,DeserializeType<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,ParseQuotedPrimitive,The conditional expression  "value.Length > 14 && value[10] == 'T' &&                      (value.EndsWithInvariant("Z")                      || value[value.Length - 6] == '+'                      || value[value.Length - 6] == '-')"  is complex.
Complex Conditional,ServiceStack.Text.Common,WriteType<T;TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteType.cs,WriteProperties,The conditional expression  "(propertyValue == null                            || (propertyWriter.propertySuppressDefaultConfig && Equals(propertyWriter.DefaultValue' propertyValue)))                          && !Serializer.IncludeNullValues"  is complex.
Complex Conditional,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatValue,The conditional expression  "valueChar == JsWriter.ItemSeperator                      || valueChar == JsWriter.MapEndChar                      //If it doesn't have quotes it's either a keyword or number so also has a ws boundary                      || (valueChar < WhiteSpaceFlags.Length && WhiteSpaceFlags[valueChar])"  is complex.
Complex Conditional,ServiceStack.Text.Jsv,JsvTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Jsv\JsvTypeSerializer.cs,WriteString,The conditional expression  "JsState.QueryStringMode && !string.IsNullOrEmpty(value) && value.StartsWith(JsWriter.QuoteString) && value.EndsWith(JsWriter.QuoteString)"  is complex.
Empty Catch Block,ServiceStack.Text,AppDomain,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\AssemblyUtils.cs,GetAssemblyListAsync,The method has an empty catch block.
Magic Number,ServiceStack.Text,DateTimeExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\DateTimeExtensions.cs,FromTimeOffsetString,The following statement contains a magic number: if (!offsetString.Contains(":"))                  offsetString = offsetString.Insert(offsetString.Length - 2' ":");
Magic Number,ServiceStack.Text,StreamExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StreamExtensions.cs,WriteTo,The following statement contains a magic number: var data = new byte[4096];
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,DecodeJsv,The following statement contains a magic number: const int endingQuotePos = 2;
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The following statement contains a magic number: foreach (var charCode in Encoding.UTF8.GetBytes(text))  			{    				if (  					charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46     // '-.  					)  				{  					sb.Append((char)charCode);  				}  				else  				{  					sb.Append('%' + charCode.ToString("x2"));  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The following statement contains a magic number: foreach (var charCode in Encoding.UTF8.GetBytes(text))  			{    				if (  					charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46     // '-.  					)  				{  					sb.Append((char)charCode);  				}  				else  				{  					sb.Append('%' + charCode.ToString("x2"));  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The following statement contains a magic number: foreach (var charCode in Encoding.UTF8.GetBytes(text))  			{    				if (  					charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46     // '-.  					)  				{  					sb.Append((char)charCode);  				}  				else  				{  					sb.Append('%' + charCode.ToString("x2"));  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The following statement contains a magic number: foreach (var charCode in Encoding.UTF8.GetBytes(text))  			{    				if (  					charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46     // '-.  					)  				{  					sb.Append((char)charCode);  				}  				else  				{  					sb.Append('%' + charCode.ToString("x2"));  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The following statement contains a magic number: foreach (var charCode in Encoding.UTF8.GetBytes(text))  			{    				if (  					charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46     // '-.  					)  				{  					sb.Append((char)charCode);  				}  				else  				{  					sb.Append('%' + charCode.ToString("x2"));  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The following statement contains a magic number: foreach (var charCode in Encoding.UTF8.GetBytes(text))  			{    				if (  					charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46     // '-.  					)  				{  					sb.Append((char)charCode);  				}  				else  				{  					sb.Append('%' + charCode.ToString("x2"));  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The following statement contains a magic number: foreach (var charCode in Encoding.UTF8.GetBytes(text))  			{    				if (  					charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46     // '-.  					)  				{  					sb.Append((char)charCode);  				}  				else  				{  					sb.Append('%' + charCode.ToString("x2"));  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlEncode,The following statement contains a magic number: foreach (var charCode in Encoding.UTF8.GetBytes(text))  			{    				if (  					charCode >= 65 && charCode <= 90        // A-Z  					|| charCode >= 97 && charCode <= 122    // a-z  					|| charCode >= 48 && charCode <= 57     // 0-9  					|| charCode >= 44 && charCode <= 46     // '-.  					)  				{  					sb.Append((char)charCode);  				}  				else  				{  					sb.Append('%' + charCode.ToString("x2"));  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlDecode,The following statement contains a magic number: for (var i = 0; i < textLength; i++)  			{  				var c = text[i];  				if (c == '+')  				{  					bytes.Add(32);  				}  				else if (c == '%')  				{  					var hexNo = Convert.ToByte(text.Substring(i + 1' 2)' 16);  					bytes.Add(hexNo);  					i += 2;  				}  				else  				{  					bytes.Add((byte)c);  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlDecode,The following statement contains a magic number: for (var i = 0; i < textLength; i++)  			{  				var c = text[i];  				if (c == '+')  				{  					bytes.Add(32);  				}  				else if (c == '%')  				{  					var hexNo = Convert.ToByte(text.Substring(i + 1' 2)' 16);  					bytes.Add(hexNo);  					i += 2;  				}  				else  				{  					bytes.Add((byte)c);  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlDecode,The following statement contains a magic number: for (var i = 0; i < textLength; i++)  			{  				var c = text[i];  				if (c == '+')  				{  					bytes.Add(32);  				}  				else if (c == '%')  				{  					var hexNo = Convert.ToByte(text.Substring(i + 1' 2)' 16);  					bytes.Add(hexNo);  					i += 2;  				}  				else  				{  					bytes.Add((byte)c);  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,UrlDecode,The following statement contains a magic number: for (var i = 0; i < textLength; i++)  			{  				var c = text[i];  				if (c == '+')  				{  					bytes.Add(32);  				}  				else if (c == '%')  				{  					var hexNo = Convert.ToByte(text.Substring(i + 1' 2)' 16);  					bytes.Add(hexNo);  					i += 2;  				}  				else  				{  					bytes.Add((byte)c);  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,HexUnescape,The following statement contains a magic number: for (var i = 0; i < textLength; i++)  			{  				var c = text.Substring(i' 1);  				if (c == "%")  				{  					var hexNo = Convert.ToInt32(text.Substring(i + 1' 2)' 16);  					sb.Append((char)hexNo);  					i += 2;  				}  				else  				{  					sb.Append(c);  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,HexUnescape,The following statement contains a magic number: for (var i = 0; i < textLength; i++)  			{  				var c = text.Substring(i' 1);  				if (c == "%")  				{  					var hexNo = Convert.ToInt32(text.Substring(i + 1' 2)' 16);  					sb.Append((char)hexNo);  					i += 2;  				}  				else  				{  					sb.Append(c);  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,HexUnescape,The following statement contains a magic number: for (var i = 0; i < textLength; i++)  			{  				var c = text.Substring(i' 1);  				if (c == "%")  				{  					var hexNo = Convert.ToInt32(text.Substring(i + 1' 2)' 16);  					sb.Append((char)hexNo);  					i += 2;  				}  				else  				{  					sb.Append(c);  				}  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,ToRot13,The following statement contains a magic number: for (var i = 0; i < array.Length; i++)  			{  				var number = (int)array[i];    				if (number >= 'a' && number <= 'z')  					number += (number > 'm') ? -13 : 13;    				else if (number >= 'A' && number <= 'Z')  					number += (number > 'M') ? -13 : 13;    				array[i] = (char)number;  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,ToRot13,The following statement contains a magic number: for (var i = 0; i < array.Length; i++)  			{  				var number = (int)array[i];    				if (number >= 'a' && number <= 'z')  					number += (number > 'm') ? -13 : 13;    				else if (number >= 'A' && number <= 'Z')  					number += (number > 'M') ? -13 : 13;    				array[i] = (char)number;  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,ToRot13,The following statement contains a magic number: for (var i = 0; i < array.Length; i++)  			{  				var number = (int)array[i];    				if (number >= 'a' && number <= 'z')  					number += (number > 'm') ? -13 : 13;    				else if (number >= 'A' && number <= 'Z')  					number += (number > 'M') ? -13 : 13;    				array[i] = (char)number;  			}
Magic Number,ServiceStack.Text,StringExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\StringExtensions.cs,ToRot13,The following statement contains a magic number: for (var i = 0; i < array.Length; i++)  			{  				var number = (int)array[i];    				if (number >= 'a' && number <= 'z')  					number += (number > 'm') ? -13 : 13;    				else if (number >= 'A' && number <= 'Z')  					number += (number > 'M') ? -13 : 13;    				array[i] = (char)number;  			}
Magic Number,ServiceStack.Text,ConvertibleTypeKey,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\TranslateListWithElements.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				return ((ToInstanceType != null ? ToInstanceType.GetHashCode() : 0) * 397)  					^ (FromElemenetType != null ? FromElemenetType.GetHashCode() : 0);  			}
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseManual,The following statement contains a magic number: if (parts.Length == 2)              {                  var timeStringParts = parts[1].Split('+');                  if (timeStringParts.Length == 2)                  {                      offsetMultiplier = -1;                  }                  else                  {                      timeStringParts = parts[1].Split('-');                      if (timeStringParts.Length == 2)                      {                          offsetMultiplier = 1;                      }                  }                    var timeOffset = timeStringParts.Length == 2 ? timeStringParts[1] : null;                  var timeParts = timeStringParts[0].Split(':');                    if (timeParts.Length == 3)                  {                      int.TryParse(timeParts[0]' out hh);                      int.TryParse(timeParts[1]' out min);                        var secParts = timeParts[2].Split('.');                      int.TryParse(secParts[0]' out ss);                      if (secParts.Length == 2)                      {                          var msStr = secParts[1].PadRight(3' '0');                          ms = int.Parse(msStr.Substring(0' 3));                            if (msStr.Length > 3)                          {                              var subMsStr = msStr.Substring(3);                              subMs = double.Parse(subMsStr) / Math.Pow(10' subMsStr.Length);                          }                      }                  }                    var dateTime = new DateTime(int.Parse(dateParts[0])' int.Parse(dateParts[1])' int.Parse(dateParts[2])' hh' min' ss' ms' dateKind);                  if (subMs != 0)                  {                      dateTime.AddMilliseconds(subMs);                  }                    if (offsetMultiplier != 0 && timeOffset != null)                  {                      timeParts = timeOffset.Split(':');                      if (timeParts.Length == 2)                      {                          hh = int.Parse(timeParts[0]);                          min = int.Parse(timeParts[1]);                      }                      else                      {                          hh = int.Parse(timeOffset.Substring(0' 2));                          min = int.Parse(timeOffset.Substring(2));                      }                        dateTime = dateTime.AddHours(offsetMultiplier * hh);                      dateTime = dateTime.AddMinutes(offsetMultiplier * min);                  }                    return dateTime.ToLocalTime().Prepare();              }
Magic Number,ServiceStack.Text.Common,DateTimeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DateTimeSerializer.cs,ParseDateTimeOffset,The following statement contains a magic number: if (dateTimeOffsetStr.LastIndexOfAny(TimeZoneChars) < 10)              {                  if (!dateTimeOffsetStr.EndsWith("Z")) dateTimeOffsetStr += "Z";  #if __MonoCS__                  // Without that Mono uses a Local timezone))                  dateTimeOffsetStr = dateTimeOffsetStr.Substring(0' dateTimeOffsetStr.Length - 1) + "+00:00";   #endif              }
Magic Number,ServiceStack.Text.Common,DeserializeDictionary<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeDictionary.cs,VerifyAndGetStartIndex,The following statement contains a magic number: if (!Serializer.EatMapStartChar(value' ref index))              {                  //Don't throw ex because some KeyValueDataContractDeserializer don't have '{}'                  Tracer.Instance.WriteDebug("WARN: Map definitions should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"'                      JsWriter.MapStartChar' createMapType != null ? createMapType.Name : "Dictionary<'>"' value.Substring(0' value.Length < 50 ? value.Length : 50));              }
Magic Number,ServiceStack.Text.Common,DeserializeDictionary<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeDictionary.cs,VerifyAndGetStartIndex,The following statement contains a magic number: if (!Serializer.EatMapStartChar(value' ref index))              {                  //Don't throw ex because some KeyValueDataContractDeserializer don't have '{}'                  Tracer.Instance.WriteDebug("WARN: Map definitions should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"'                      JsWriter.MapStartChar' createMapType != null ? createMapType.Name : "Dictionary<'>"' value.Substring(0' value.Length < 50 ? value.Length : 50));              }
Magic Number,ServiceStack.Text.Common,DeserializeDictionary<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeDictionary.cs,GetTypesKey,The following statement contains a magic number: var sb = new StringBuilder(256);
Magic Number,ServiceStack.Text.Common,DeserializeKeyValuePair<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeKeyValuePair.cs,VerifyAndGetStartIndex,The following statement contains a magic number: if (!Serializer.EatMapStartChar(value' ref index))              {                  //Don't throw ex because some KeyValueDataContractDeserializer don't have '{}'                  Tracer.Instance.WriteDebug("WARN: Map definitions should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"'                                             JsWriter.MapStartChar' createMapType != null ? createMapType.Name : "Dictionary<'>"' value.Substring(0' value.Length < 50 ? value.Length : 50));              }
Magic Number,ServiceStack.Text.Common,DeserializeKeyValuePair<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeKeyValuePair.cs,VerifyAndGetStartIndex,The following statement contains a magic number: if (!Serializer.EatMapStartChar(value' ref index))              {                  //Don't throw ex because some KeyValueDataContractDeserializer don't have '{}'                  Tracer.Instance.WriteDebug("WARN: Map definitions should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"'                                             JsWriter.MapStartChar' createMapType != null ? createMapType.Name : "Dictionary<'>"' value.Substring(0' value.Length < 50 ? value.Length : 50));              }
Magic Number,ServiceStack.Text.Common,DeserializeKeyValuePair<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeKeyValuePair.cs,GetTypesKey,The following statement contains a magic number: var sb = new StringBuilder(256);
Magic Number,ServiceStack.Text.Common,DeserializeListWithElements<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeListWithElements.cs,StripList,The following statement contains a magic number: const int endQuotePos = 2;
Magic Number,ServiceStack.Text.Common,DeserializeType<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,ParseQuotedPrimitive,The following statement contains a magic number: if (JsConfig.DateHandler == JsonDateHandler.ISO8601)              {                  // check that we have UTC ISO8601 date:                  // YYYY-MM-DDThh:mm:ssZ                  // YYYY-MM-DDThh:mm:ss+02:00                  // YYYY-MM-DDThh:mm:ss-02:00                  if (value.Length > 14 && value[10] == 'T' &&                      (value.EndsWithInvariant("Z")                      || value[value.Length - 6] == '+'                      || value[value.Length - 6] == '-'))                  {                      return DateTimeSerializer.ParseShortestXsdDateTime(value);                  }              }
Magic Number,ServiceStack.Text.Common,DeserializeType<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,ParseQuotedPrimitive,The following statement contains a magic number: if (JsConfig.DateHandler == JsonDateHandler.ISO8601)              {                  // check that we have UTC ISO8601 date:                  // YYYY-MM-DDThh:mm:ssZ                  // YYYY-MM-DDThh:mm:ss+02:00                  // YYYY-MM-DDThh:mm:ss-02:00                  if (value.Length > 14 && value[10] == 'T' &&                      (value.EndsWithInvariant("Z")                      || value[value.Length - 6] == '+'                      || value[value.Length - 6] == '-'))                  {                      return DateTimeSerializer.ParseShortestXsdDateTime(value);                  }              }
Magic Number,ServiceStack.Text.Common,DeserializeType<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,ParseQuotedPrimitive,The following statement contains a magic number: if (JsConfig.DateHandler == JsonDateHandler.ISO8601)              {                  // check that we have UTC ISO8601 date:                  // YYYY-MM-DDThh:mm:ssZ                  // YYYY-MM-DDThh:mm:ss+02:00                  // YYYY-MM-DDThh:mm:ss-02:00                  if (value.Length > 14 && value[10] == 'T' &&                      (value.EndsWithInvariant("Z")                      || value[value.Length - 6] == '+'                      || value[value.Length - 6] == '-'))                  {                      return DateTimeSerializer.ParseShortestXsdDateTime(value);                  }              }
Magic Number,ServiceStack.Text.Common,DeserializeType<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeType.cs,ParseQuotedPrimitive,The following statement contains a magic number: if (JsConfig.DateHandler == JsonDateHandler.ISO8601)              {                  // check that we have UTC ISO8601 date:                  // YYYY-MM-DDThh:mm:ssZ                  // YYYY-MM-DDThh:mm:ss+02:00                  // YYYY-MM-DDThh:mm:ss-02:00                  if (value.Length > 14 && value[10] == 'T' &&                      (value.EndsWithInvariant("Z")                      || value[value.Length - 6] == '+'                      || value[value.Length - 6] == '-'))                  {                      return DateTimeSerializer.ParseShortestXsdDateTime(value);                  }              }
Magic Number,ServiceStack.Text.Common,DeserializeTypeRef,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRef.cs,CreateSerializationError,The following statement contains a magic number: return new SerializationException(String.Format(              "Type definitions should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"'              JsWriter.MapStartChar' type.Name' strType.Substring(0' strType.Length < 50 ? strType.Length : 50)));
Magic Number,ServiceStack.Text.Common,DeserializeTypeRef,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTypeRef.cs,CreateSerializationError,The following statement contains a magic number: return new SerializationException(String.Format(              "Type definitions should start with a '{0}'' expecting serialized type '{1}'' got string starting with: {2}"'              JsWriter.MapStartChar' type.Name' strType.Substring(0' strType.Length < 50 ? strType.Length : 50)));
Magic Number,ServiceStack.Text.Common,MapKey,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\WriteDictionary.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      return ((KeyType != null ? KeyType.GetHashCode() : 0) * 397) ^ (ValueType != null ? ValueType.GetHashCode() : 0);                  }
Magic Number,XLabs.Serialization.ServiceStack.Common,DeserializeTuple<TSerializer>,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Common\DeserializeTuple.cs,Parse,The following statement contains a magic number: while (index < valueLength)              {                  var keyValue = Serializer.EatMapKey(value' ref index);                  Serializer.EatMapKeySeperator(value' ref index);                  var elementValue = Serializer.EatValue(value' ref index);                  if (keyValue == null) continue;                    var keyIndex = int.Parse(keyValue.Substring(4)) - 1;                  argValues[keyIndex] = Serializer.GetParseFn(genericArgs[keyIndex]).Invoke(elementValue);                    Serializer.EatItemSeperatorOrMapEndChar(value' ref index);              }
Magic Number,ServiceStack.Text.Controller,PathInfo,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Controller\PathInfo.cs,Parse,The following statement contains a magic number: var controllerName = actionParts.Length == 2  									? actionParts[0]  									: null;
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,ParseString,The following statement contains a magic number: if (json[index] != JsonUtils.QuoteChar)                  throw new Exception("Invalid unquoted string starting with: " + json.SafeSubstring(50));
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,ParseString,The following statement contains a magic number: do              {                  char c = json[index];                  if (c == JsonUtils.QuoteChar) break;                  if (c != JsonUtils.EscapeChar) continue;                  c = json[index++];                  if (c == 'u')                  {                      index += 4;                  }              } while (index++ < jsonLength);
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,UnescapeSafeString,The following statement contains a magic number: return value[0] == JsonUtils.QuoteChar && value[value.Length - 1] == JsonUtils.QuoteChar                  ? value.Substring(1' value.Length - 2)                  : value;
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,Unescape,The following statement contains a magic number: for ( ; count < length; )              {                  if (input[count] == JsonUtils.QuoteChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                                          count++;                      start = count;                      continue;                  }                    if (input[count] == JsonUtils.EscapeChar)                  {                      if (start != count)                      {                          output.Append(input' start' count - start);                      }                      start = count;                      count++;                      if (count >= length) continue;                        //we will always be parsing an escaped char here                      var c = input[count];                        switch (c)                      {                          case 'a':                              output.Append('\a');                              count++;                              break;                          case 'b':                              output.Append('\b');                              count++;                              break;                          case 'f':                              output.Append('\f');                              count++;                              break;                          case 'n':                              output.Append('\n');                              count++;                              break;                          case 'r':                              output.Append('\r');                              count++;                              break;                          case 'v':                              output.Append('\v');                              count++;                              break;                          case 't':                              output.Append('\t');                              count++;                              break;                          case 'u':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              {                                  output.Append(c);                              }                              break;                          case 'x':                              if (count + 4 < length)                              {                                  var unicodeString = input.Substring(count+1' 4);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 5;                              }                              else                              if (count + 2 < length)                              {                                  var unicodeString = input.Substring(count+1' 2);                                  var unicodeIntVal = UInt32.Parse(unicodeString' NumberStyles.HexNumber);                                  output.Append(ConvertFromUtf32((int) unicodeIntVal));                                  count += 3;                              }                              else                              {                                  output.Append(input' start' count - start);                              }                              break;                          default:                              output.Append(c);                              count++;                              break;                      }                      start = count;                  }                  else                  {                      count++;                  }              }
Magic Number,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,ConvertFromUtf32,The following statement contains a magic number: return new string(new[] {(char) ((utf32 >> 10) + 0xD800)'                                  (char) (utf32 % 0x0400 + 0xDC00)});
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,WriteString,The following statement contains a magic number: var hexSeqBuffer = new char[4];
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,WriteString,The following statement contains a magic number: for (var i = 0; i < len; i++)              {                  switch (value[i])                  {                      case '\n':                          writer.Write("\\n");                          continue;                        case '\r':                          writer.Write("\\r");                          continue;                        case '\t':                          writer.Write("\\t");                          continue;                        case '"':                      case '\\':                          writer.Write('\\');                          writer.Write(value[i]);                          continue;                        case '\f':                          writer.Write("\\f");                          continue;                        case '\b':                          writer.Write("\\b");                          continue;                  }                    //Is printable char?                  if (value[i] >= 32 && value[i] <= 126)                  {                      writer.Write(value[i]);                      continue;                  }                    // http://json.org/ spec requires any control char to be escaped                  if (JsConfig.EscapeUnicode || char.IsControl(value[i]))                  {                      // Default' turn into a \uXXXX sequence                      IntToHex(value[i]' hexSeqBuffer);                      writer.Write("\\u");                      writer.Write(hexSeqBuffer);                  }                  else                      writer.Write(value[i]);              }
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,WriteString,The following statement contains a magic number: for (var i = 0; i < len; i++)              {                  switch (value[i])                  {                      case '\n':                          writer.Write("\\n");                          continue;                        case '\r':                          writer.Write("\\r");                          continue;                        case '\t':                          writer.Write("\\t");                          continue;                        case '"':                      case '\\':                          writer.Write('\\');                          writer.Write(value[i]);                          continue;                        case '\f':                          writer.Write("\\f");                          continue;                        case '\b':                          writer.Write("\\b");                          continue;                  }                    //Is printable char?                  if (value[i] >= 32 && value[i] <= 126)                  {                      writer.Write(value[i]);                      continue;                  }                    // http://json.org/ spec requires any control char to be escaped                  if (JsConfig.EscapeUnicode || char.IsControl(value[i]))                  {                      // Default' turn into a \uXXXX sequence                      IntToHex(value[i]' hexSeqBuffer);                      writer.Write("\\u");                      writer.Write(hexSeqBuffer);                  }                  else                      writer.Write(value[i]);              }
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,HasAnyEscapeChars,The following statement contains a magic number: for (var i = 0; i < len; i++)  			{  				var c = value[i];                    // non-printable                  if (!(value[i] >= 32 && value[i] <= 126)) return true;    				if (c >= LengthFromLargestChar || !EscapeCharFlags[c]) continue;  				return true;  			}
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,HasAnyEscapeChars,The following statement contains a magic number: for (var i = 0; i < len; i++)  			{  				var c = value[i];                    // non-printable                  if (!(value[i] >= 32 && value[i] <= 126)) return true;    				if (c >= LengthFromLargestChar || !EscapeCharFlags[c]) continue;  				return true;  			}
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,IntToHex,The following statement contains a magic number: for (var i = 0; i < 4; i++)  			{  				var num = intValue % 16;    				if (num < 10)  					hex[3 - i] = (char)('0' + num);  				else  					hex[3 - i] = (char)('A' + (num - 10));    				intValue >>= 4;  			}
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,IntToHex,The following statement contains a magic number: for (var i = 0; i < 4; i++)  			{  				var num = intValue % 16;    				if (num < 10)  					hex[3 - i] = (char)('0' + num);  				else  					hex[3 - i] = (char)('A' + (num - 10));    				intValue >>= 4;  			}
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,IntToHex,The following statement contains a magic number: for (var i = 0; i < 4; i++)  			{  				var num = intValue % 16;    				if (num < 10)  					hex[3 - i] = (char)('0' + num);  				else  					hex[3 - i] = (char)('A' + (num - 10));    				intValue >>= 4;  			}
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,IntToHex,The following statement contains a magic number: for (var i = 0; i < 4; i++)  			{  				var num = intValue % 16;    				if (num < 10)  					hex[3 - i] = (char)('0' + num);  				else  					hex[3 - i] = (char)('A' + (num - 10));    				intValue >>= 4;  			}
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,IntToHex,The following statement contains a magic number: for (var i = 0; i < 4; i++)  			{  				var num = intValue % 16;    				if (num < 10)  					hex[3 - i] = (char)('0' + num);  				else  					hex[3 - i] = (char)('A' + (num - 10));    				intValue >>= 4;  			}
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,IntToHex,The following statement contains a magic number: for (var i = 0; i < 4; i++)  			{  				var num = intValue % 16;    				if (num < 10)  					hex[3 - i] = (char)('0' + num);  				else  					hex[3 - i] = (char)('A' + (num - 10));    				intValue >>= 4;  			}
Magic Number,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,IntToHex,The following statement contains a magic number: for (var i = 0; i < 4; i++)  			{  				var num = intValue % 16;    				if (num < 10)  					hex[3 - i] = (char)('0' + num);  				else  					hex[3 - i] = (char)('A' + (num - 10));    				intValue >>= 4;  			}
Magic Number,ServiceStack.Text.Support,DoubleConverter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\DoubleConverter.cs,ToExactString,The following statement contains a magic number: int exponent = (int)((bits >> 52) & 0x7ffL);
Magic Number,ServiceStack.Text.Support,DoubleConverter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\DoubleConverter.cs,ToExactString,The following statement contains a magic number: if (exponent == 0)  			{  				exponent++;  			}  			// Normal numbers; leave exponent as it is but add extra  			// bit to the front of the mantissa  			else  			{  				mantissa = mantissa | (1L << 52);  			}
Magic Number,ServiceStack.Text.Support,DoubleConverter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\DoubleConverter.cs,ToExactString,The following statement contains a magic number: exponent -= 1075;
Magic Number,ServiceStack.Text.Support,DoubleConverter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\DoubleConverter.cs,ToExactString,The following statement contains a magic number: if (exponent < 0)  			{  				for (int i = 0; i < -exponent; i++)  					ad.MultiplyBy(5);  				ad.Shift(-exponent);  			}  			// Otherwise' we need to repeatedly multiply by 2  			else  			{  				for (int i = 0; i < exponent; i++)  					ad.MultiplyBy(2);  			}
Magic Number,ServiceStack.Text.Support,DoubleConverter,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\DoubleConverter.cs,ToExactString,The following statement contains a magic number: if (exponent < 0)  			{  				for (int i = 0; i < -exponent; i++)  					ad.MultiplyBy(5);  				ad.Shift(-exponent);  			}  			// Otherwise' we need to repeatedly multiply by 2  			else  			{  				for (int i = 0; i < exponent; i++)  					ad.MultiplyBy(2);  			}
Magic Number,ServiceStack.Text.Support,ArbitraryDecimal,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\DoubleConverter.cs,MultiplyBy,The following statement contains a magic number: for (int i = digits.Length - 1; i >= 0; i--)  				{  					int resultDigit = digits[i] * amount + result[i + 1];  					result[i] = (byte)(resultDigit / 10);  					result[i + 1] = (byte)(resultDigit % 10);  				}
Magic Number,ServiceStack.Text.Support,ArbitraryDecimal,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\DoubleConverter.cs,MultiplyBy,The following statement contains a magic number: for (int i = digits.Length - 1; i >= 0; i--)  				{  					int resultDigit = digits[i] * amount + result[i + 1];  					result[i] = (byte)(resultDigit / 10);  					result[i + 1] = (byte)(resultDigit % 10);  				}
Magic Number,ServiceStack.Text.Support,TypePair,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Support\TypePair.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				return ((Args1 != null ? Args1.GetHashCode() : 0)*397) ^ (Arg2 != null ? Arg2.GetHashCode() : 0);  			}
Missing Default,ServiceStack.Text,ReflectionExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\ReflectionExtensions.cs,IsNumericType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))              {                  case TypeCode.Byte:                  case TypeCode.Decimal:                  case TypeCode.Double:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                  case TypeCode.SByte:                  case TypeCode.Single:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                      return true;                    case TypeCode.Object:                      if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))                      {                          return IsNumericType(Nullable.GetUnderlyingType(type));                      }                      if (type.IsEnum)                      {                          return JsConfig.TreatEnumAsInteger || type.IsEnumFlags();                      }                      return false;              }
Missing Default,ServiceStack.Text,ReflectionExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\ReflectionExtensions.cs,IsIntegerType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))              {                  case TypeCode.Byte:                  case TypeCode.Int16:                  case TypeCode.Int32:                  case TypeCode.Int64:                  case TypeCode.SByte:                  case TypeCode.UInt16:                  case TypeCode.UInt32:                  case TypeCode.UInt64:                      return true;                    case TypeCode.Object:                      if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))                      {                          return IsNumericType(Nullable.GetUnderlyingType(type));                      }                      return false;              }
Missing Default,ServiceStack.Text,ReflectionExtensions,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\ReflectionExtensions.cs,IsRealNumberType,The following switch statement is missing a default case: switch (Type.GetTypeCode(type))              {                  case TypeCode.Decimal:                  case TypeCode.Double:                  case TypeCode.Single:                      return true;                    case TypeCode.Object:                      if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(Nullable<>))                      {                          return IsNumericType(Nullable.GetUnderlyingType(type));                      }                      return false;              }
Missing Default,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatMapKey,The following switch statement is missing a default case: switch (valueChar)              {                  //If we are at the end' return.                  case JsWriter.ItemSeperator:                  case JsWriter.MapEndChar:                      return null;                    //Is Within Quotes' i.e. "..."                  case JsWriter.QuoteChar:                      return ParseString(value' ref i);              }
Missing Default,ServiceStack.Text.Json,JsonTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonTypeSerializer.cs,EatValue,The following switch statement is missing a default case: switch (valueChar)              {                  //If we are at the end' return.                  case JsWriter.ItemSeperator:                  case JsWriter.MapEndChar:                      return null;                    //Is Within Quotes' i.e. "..."                  case JsWriter.QuoteChar:                      return ParseString(value' ref i);                    //Is Type/Map' i.e. {...}                  case JsWriter.MapStartChar:                      while (++i < valueLength && endsToEat > 0)                      {                          valueChar = value[i];                            if (valueChar == JsonUtils.EscapeChar)                          {                              i++;                              continue;                          }                            if (valueChar == JsWriter.QuoteChar)                              withinQuotes = !withinQuotes;                            if (withinQuotes)                              continue;                            if (valueChar == JsWriter.MapStartChar)                              endsToEat++;                            if (valueChar == JsWriter.MapEndChar)                              endsToEat--;                      }                      return value.Substring(tokenStartPos' i - tokenStartPos);                    //Is List' i.e. [...]                  case JsWriter.ListStartChar:                      while (++i < valueLength && endsToEat > 0)                      {                          valueChar = value[i];                            if (valueChar == JsonUtils.EscapeChar)                          {                              i++;                              continue;                          }                            if (valueChar == JsWriter.QuoteChar)                              withinQuotes = !withinQuotes;                            if (withinQuotes)                              continue;                            if (valueChar == JsWriter.ListStartChar)                              endsToEat++;                            if (valueChar == JsWriter.ListEndChar)                              endsToEat--;                      }                      return value.Substring(tokenStartPos' i - tokenStartPos);              }
Missing Default,ServiceStack.Text.Json,JsonUtils,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Json\JsonUtils.cs,WriteString,The following switch statement is missing a default case: switch (value[i])                  {                      case '\n':                          writer.Write("\\n");                          continue;                        case '\r':                          writer.Write("\\r");                          continue;                        case '\t':                          writer.Write("\\t");                          continue;                        case '"':                      case '\\':                          writer.Write('\\');                          writer.Write(value[i]);                          continue;                        case '\f':                          writer.Write("\\f");                          continue;                        case '\b':                          writer.Write("\\b");                          continue;                  }
Missing Default,ServiceStack.Text.Jsv,JsvTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Jsv\JsvTypeSerializer.cs,EatMapKey,The following switch statement is missing a default case: switch (valueChar)  			{  				case JsWriter.QuoteChar:  					while (++i < valueLength)  					{  						valueChar = value[i];    						if (valueChar != JsWriter.QuoteChar) continue;    						var isLiteralQuote = i + 1 < valueLength && value[i + 1] == JsWriter.QuoteChar;    						i++; //skip quote  						if (!isLiteralQuote)  							break;  					}  					return value.Substring(tokenStartPos' i - tokenStartPos);    				//Is Type/Map' i.e. {...}  				case JsWriter.MapStartChar:  					var endsToEat = 1;  					var withinQuotes = false;  					while (++i < valueLength && endsToEat > 0)  					{  						valueChar = value[i];    						if (valueChar == JsWriter.QuoteChar)  							withinQuotes = !withinQuotes;    						if (withinQuotes)  							continue;    						if (valueChar == JsWriter.MapStartChar)  							endsToEat++;    						if (valueChar == JsWriter.MapEndChar)  							endsToEat--;  					}  					return value.Substring(tokenStartPos' i - tokenStartPos);  			}
Missing Default,ServiceStack.Text.Jsv,JsvTypeSerializer,C:\repos\XLabs_Xamarin-Forms-Labs\src\Serialization\XLabs.Serialization.ServiceStack.Shared\Jsv\JsvTypeSerializer.cs,EatValue,The following switch statement is missing a default case: switch (valueChar)  			{  				//If we are at the end' return.  				case JsWriter.ItemSeperator:  				case JsWriter.MapEndChar:  					return null;    				//Is Within Quotes' i.e. "..."  				case JsWriter.QuoteChar:  					while (++i < valueLength)  					{  						valueChar = value[i];    						if (valueChar != JsWriter.QuoteChar) continue;    						var isLiteralQuote = i + 1 < valueLength && value[i + 1] == JsWriter.QuoteChar;    						i++; //skip quote  						if (!isLiteralQuote)  							break;  					}  					return value.Substring(tokenStartPos' i - tokenStartPos);    				//Is Type/Map' i.e. {...}  				case JsWriter.MapStartChar:  					while (++i < valueLength && endsToEat > 0)  					{  						valueChar = value[i];    						if (valueChar == JsWriter.QuoteChar)  							withinQuotes = !withinQuotes;    						if (withinQuotes)  							continue;    						if (valueChar == JsWriter.MapStartChar)  							endsToEat++;    						if (valueChar == JsWriter.MapEndChar)  							endsToEat--;  					}  					return value.Substring(tokenStartPos' i - tokenStartPos);    				//Is List' i.e. [...]  				case JsWriter.ListStartChar:  					while (++i < valueLength && endsToEat > 0)  					{  						valueChar = value[i];    						if (valueChar == JsWriter.QuoteChar)  							withinQuotes = !withinQuotes;    						if (withinQuotes)  							continue;    						if (valueChar == JsWriter.ListStartChar)  							endsToEat++;    						if (valueChar == JsWriter.ListEndChar)  							endsToEat--;  					}  					return value.Substring(tokenStartPos' i - tokenStartPos);  			}
