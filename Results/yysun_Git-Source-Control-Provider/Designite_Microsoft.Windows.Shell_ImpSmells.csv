Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,_BuildShellLists,The method has 143 lines of code.
Long Method,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The method has 105 lines of code.
Complex Method,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,_ApplyList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,_BuildShellLists,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,ListContainsShellObject,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,CreateLinkFromJumpTask,Cyclomatic complexity of the method is 10
Complex Method,Standard,HRESULT,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ErrorCodes.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,AreStreamsEqual,Cyclomatic complexity of the method is 8
Complex Method,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,Cyclomatic complexity of the method is 8
Long Parameter List,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,AddCategory,The method has 5 parameters. Parameters: cdl' category' jumpItems' successList' rejectionList
Long Parameter List,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,AddCategory,The method has 6 parameters. Parameters: cdl' category' jumpItems' successList' rejectionList' isHeterogenous
Long Parameter List,Microsoft.Windows.Shell,TaskbarItemInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\TaskbarItemInfo.cs,_WndProc,The method has 5 parameters. Parameters: hwnd' uMsg' wParam' lParam' handled
Long Parameter List,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_WndProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' handled
Long Parameter List,Standard,MessageWindow,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\MessageWindow.cs,MessageWindow,The method has 6 parameters. Parameters: classStyle' style' exStyle' location' name' callback
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,_CreateDIBSection,The method has 6 parameters. Parameters: hdc' bitmapInfo' iUsage' ppvBits' hSection' dwOffset
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,_CreateDIBSectionIntPtr,The method has 6 parameters. Parameters: hdc' bitmapInfo' iUsage' ppvBits' hSection' dwOffset
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,CreateDIBSection,The method has 5 parameters. Parameters: hdc' bitmapInfo' ppvBits' hSection' dwOffset
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,_CreateRoundRectRgn,The method has 6 parameters. Parameters: nLeftRect' nTopRect' nRightRect' nBottomRect' nWidthEllipse' nHeightEllipse
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,CreateRoundRectRgn,The method has 6 parameters. Parameters: nLeftRect' nTopRect' nRightRect' nBottomRect' nWidthEllipse' nHeightEllipse
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,_CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,CreateWindowEx,The method has 12 parameters. Parameters: dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,DwmDefWindowProc,The method has 5 parameters. Parameters: hwnd' msg' wParam' lParam' plResult
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,_GetCurrentThemeName,The method has 6 parameters. Parameters: pszThemeFileName' dwMaxNameChars' pszColorBuff' cchMaxColorChars' pszSizeBuff' cchMaxSizeChars
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,_SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' x' y' cx' cy' uFlags
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,SetWindowPos,The method has 7 parameters. Parameters: hWnd' hWndInsertAfter' x' y' cx' cy' uFlags
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,TrackPopupMenuEx,The method has 6 parameters. Parameters: hmenu' fuFlags' x' y' hwnd' lptpm
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,_UpdateLayeredWindow,The method has 9 parameters. Parameters: hwnd' hdcDst' pptDst' psize' hdcSrc' pptSrc' crKey' pblend' dwFlags
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,_UpdateLayeredWindowIntPtr,The method has 9 parameters. Parameters: hwnd' hdcDst' pptDst' psize' hdcSrc' pptSrc' crKey' pblend' dwFlags
Long Parameter List,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,UpdateLayeredWindow,The method has 9 parameters. Parameters: hwnd' hdcDst' pptDst' psize' hdcSrc' pptSrc' crKey' pblend' dwFlags
Long Parameter List,Standard,IShellFolder,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ShellProvider.cs,ParseDisplayName,The method has 6 parameters. Parameters: hwnd' pbc' pszDisplayName' pchEaten' ppidl' pdwAttributes
Long Parameter List,Standard,IShellFolder,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ShellProvider.cs,GetUIObjectOf,The method has 5 parameters. Parameters: hwndOwner' cidl' apidl' riid' rgfReserved
Long Parameter List,Standard,IShellFolder,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ShellProvider.cs,SetNameOf,The method has 5 parameters. Parameters: hwnd' pidl' pszName' uFlags' ppidlOut
Long Parameter List,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_MatchImage,The method has 5 parameters. Parameters: frame' bitDepth' width' height' bpp
Long Parameter List,Standard,Verify,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Verify.cs,BoundedDoubleInc,The method has 5 parameters. Parameters: lowerBoundInclusive' value' upperBoundInclusive' message' parameter
Long Identifier,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,,The length of the parameter _windowNonClientFrameThickness is 30.
Long Identifier,Microsoft.Windows.Shell,WindowChrome,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChrome.cs,,The length of the parameter IsHitTestVisibleInChromeProperty is 32.
Long Identifier,Standard,HRESULT,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ErrorCodes.cs,,The length of the parameter DESTS_E_NO_MATCHING_ASSOC_HANDLER is 33.
Long Identifier,Standard,PKEY,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ShellProvider.cs,,The length of the parameter AppUserModel_IsDestListSeparator is 32.
Long Identifier,Standard,PKEY,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ShellProvider.cs,,The length of the parameter AppUserModel_RelaunchDisplayNameResource is 40.
Long Identifier,Standard,PKEY,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ShellProvider.cs,,The length of the parameter AppUserModel_RelaunchIconResource is 33.
Long Statement,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,AddCategory,The length of the statement  "            var shellObjectCollection = (IObjectCollection)Activator.CreateInstance(Type.GetTypeFromCLSID(new Guid(CLSID.EnumerableObjectCollection))); " is 139.
Long Statement,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,AddCategory,The length of the statement  "                            rejectionList.Add(new _RejectedJumpItemPair { JumpItem = itemMap.JumpItem' Reason = JumpItemRejectionReason.NoRegisteredHandler }); " is 131.
Long Statement,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,AddCategory,The length of the statement  "                        rejectionList.Add(new _RejectedJumpItemPair { JumpItem = item.JumpItem' Reason = JumpItemRejectionReason.InvalidItem }); " is 120.
Long Statement,Microsoft.Windows.Shell,SystemCommands,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemCommands.cs,ShowSystemMenuPhysicalCoordinates,The length of the statement  "            uint cmd = NativeMethods.TrackPopupMenuEx(hmenu' TPM_LEFTBUTTON | TPM_RETURNCMD' (int)physicalScreenLocation.X' (int)physicalScreenLocation.Y' hwnd' IntPtr.Zero); " is 162.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_InitializeWindowResizeBorderThickness,The length of the statement  "            WindowResizeBorderThickness = new Thickness(frameSizeInDips.Width' frameSizeInDips.Height' frameSizeInDips.Width' frameSizeInDips.Height); " is 138.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_InitializeWindowNonClientFrameThickness,The length of the statement  "            WindowNonClientFrameThickness = new Thickness(frameSizeInDips.Width' frameSizeInDips.Height + captionHeightInDips' frameSizeInDips.Width' frameSizeInDips.Height); " is 162.
Long Statement,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_InitializeCaptionButtonLocation,The length of the statement  "            // For all known themes' the RECT for the maximize box shouldn't add anything to the union of the minimize and close boxes. " is 123.
Long Statement,Microsoft.Windows.Shell,TaskbarItemInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\TaskbarItemInfo.cs,_UpdateThumbnailClipping,The length of the statement  "                Rect logicalClientRc = DpiHelper.DeviceRectToLogical(new Rect(physicalClientRc.Left' physicalClientRc.Top' physicalClientRc.Width' physicalClientRc.Height)); " is 157.
Long Statement,Microsoft.Windows.Shell,TaskbarItemInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\TaskbarItemInfo.cs,_UpdateThumbnailClipping,The length of the statement  "                    Rect logicalClip = new Rect(margin.Left' margin.Top' logicalClientRc.Width - margin.Left - margin.Right' logicalClientRc.Height - margin.Top - margin.Bottom); " is 158.
Long Statement,Microsoft.Windows.Shell,TaskbarItemInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\TaskbarItemInfo.cs,_UpdateThumbnailClipping,The length of the statement  "                    interopRc = new RefRECT((int)physicalClip.Left' (int)physicalClip.Top' (int)physicalClip.Right' (int)physicalClip.Bottom); " is 122.
Long Statement,Microsoft.Windows.Shell,WindowChrome,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChrome.cs,_OnChromeChanged,The length of the statement  "            // There can be a many:1 relationship of to Window to WindowChrome objects' but a 1:1 for a Window and a WindowChromeWorker. " is 124.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetWindow,The length of the statement  "                Utility.AddDependencyPropertyChangeListener(_window' Window.TemplateProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 129.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetWindow,The length of the statement  "                Utility.AddDependencyPropertyChangeListener(_window' Window.FlowDirectionProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 134.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_UnsetWindow,The length of the statement  "                Utility.RemoveDependencyPropertyChangeListener(_window' Window.TemplateProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 132.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_UnsetWindow,The length of the statement  "                Utility.RemoveDependencyPropertyChangeListener(_window' Window.FlowDirectionProperty' _OnWindowPropertyChangedThatRequiresTemplateFixup); " is 137.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "            Rect rcLogicalWindow = DpiHelper.DeviceRectToLogical(new Rect(rcWindow.Left' rcWindow.Top' rcWindow.Width' rcWindow.Height)); " is 125.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "            Rect rcLogicalClient = DpiHelper.DeviceRectToLogical(new Rect(rcAdjustedClient.Left' rcAdjustedClient.Top' rcAdjustedClient.Width' rcAdjustedClient.Height)); " is 157.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "            // This works fine' but if the window is dynamically changing its FlowDirection then this can have really bizarre side effects. " is 127.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "            // This will mostly work if the FlowDirection is dynamically changed' but there aren't many real scenarios that would call for " is 126.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupFrameworkIssues,The length of the statement  "                rootElement.RenderTransform = new MatrixTransform(1' 0' 0' 1' -(nonClientThickness.Left + nonClientThickness.Right)' 0); " is 120.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The length of the statement  "                    // Disabling this for the published code to reduce debug noise.  This will get compiled away for retail binaries anyways. " is 121.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HandleNCRButtonUp,The length of the statement  "                SystemCommands.ShowSystemMenuPhysicalCoordinates(_window' new Point(Utility.GET_X_LPARAM(lParam)' Utility.GET_Y_LPARAM(lParam))); " is 129.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HandleEnterSizeMove,The length of the statement  "                // Realistically we also don't want to update the start position when moving from one docked state to another (or to and from maximized)' " is 137.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HandleEnterSizeMove,The length of the statement  "                // but it's tricky to detect and this is already a workaround for a bug that's fixed in newer versions of the framework. " is 120.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HandleExitSizeMove,The length of the statement  "            // If they did that' then we need to try to update the restore bounds or else WPF will put the window at the maximized location (e.g. (-8'-8)). " is 143.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "                        hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius); " is 135.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "                        Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius); " is 120.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "                        Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius); " is 126.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The length of the statement  "                        Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius); " is 129.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_ExtendGlassFrame,The length of the statement  "                Point deviceTopLeft = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.GlassFrameThickness.Left' _chromeInfo.GlassFrameThickness.Top)); " is 140.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_ExtendGlassFrame,The length of the statement  "                Point deviceBottomRight = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.GlassFrameThickness.Right' _chromeInfo.GlassFrameThickness.Bottom)); " is 148.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "            if (mousePosition.Y >= windowPosition.Top && mousePosition.Y < windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top + _chromeInfo.CaptionHeight) " is 150.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "            else if (mousePosition.Y < windowPosition.Bottom && mousePosition.Y >= windowPosition.Bottom - (int)_chromeInfo.ResizeBorderThickness.Bottom) " is 141.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "            if (mousePosition.X >= windowPosition.Left && mousePosition.X < windowPosition.Left + (int)_chromeInfo.ResizeBorderThickness.Left) " is 130.
Long Statement,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HitTestNca,The length of the statement  "            else if (mousePosition.X < windowPosition.Right && mousePosition.X >= windowPosition.Right - _chromeInfo.ResizeBorderThickness.Right) " is 133.
Long Statement,Standard,HRESULT,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ErrorCodes.cs,Make,The length of the statement  "            Assert.Implies((int)facility != (int)((int)facility & 0x1FF)' facility == Facility.Ese || facility == Facility.WinCodec); " is 121.
Long Statement,Standard,MessageWindow,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\MessageWindow.cs,_Dispose,The length of the statement  "                Dispatcher.BeginInvoke(DispatcherPriority.Normal' (DispatcherOperationCallback)(arg => _DestroyWindow(IntPtr.Zero' className))); " is 128.
Long Statement,Standard,MessageWindow,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\MessageWindow.cs,_Dispose,The length of the statement  "                    Dispatcher.BeginInvoke(DispatcherPriority.Normal' (DispatcherOperationCallback)(arg => _DestroyWindow(hwnd' className))); " is 121.
Long Statement,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,CreateWindowEx,The length of the statement  "            IntPtr ret = _CreateWindowEx(dwExStyle' lpClassName' lpWindowName' dwStyle' x' y' nWidth' nHeight' hWndParent' hMenu' hInstance' lpParam); " is 138.
Long Statement,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,UpdateLayeredWindow,The length of the statement  "            if (!_UpdateLayeredWindowIntPtr(hwnd' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' IntPtr.Zero' crKey' ref pblend' dwFlags)) " is 131.
Long Statement,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GenerateHICON,The length of the statement  "                    drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height); " is 134.
Long Statement,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_GetBestMatch,The length of the statement  "                int currentIconBitDepth = isBitmapIconDecoder ? frames[i].Thumbnail.Format.BitsPerPixel : frames[i].Format.BitsPerPixel; " is 120.
Long Statement,Standard,Verify,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Verify.cs,PropertyIsNotNull,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "The property {0} cannot be null at this time."' name)); " is 136.
Long Statement,Standard,Verify,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Verify.cs,PropertyIsNull,The length of the statement  "                throw new InvalidOperationException(string.Format(CultureInfo.InvariantCulture' "The property {0} must be null at this time."' name)); " is 134.
Long Statement,Standard,Verify,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Verify.cs,BoundedInteger,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' "The integer value must be bounded with [{0}' {1})"' lowerBoundInclusive' upperBoundExclusive)' parameterName); " is 183.
Long Statement,Standard,Verify,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Verify.cs,FileExists,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' "No file exists at \"{0}\""' filePath)' parameterName); " is 127.
Long Statement,Standard,Verify,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Verify.cs,ImplementsInterface,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.InvariantCulture' "The parameter must implement interface {0}."' interfaceType.ToString())' parameterName); " is 161.
Complex Conditional,Microsoft.Windows.Shell,JumpItemsRejectedEventArgs,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,JumpItemsRejectedEventArgs,The conditional expression  "(rejectedItems == null && reasons != null)                  || (reasons == null && rejectedItems != null)                  || (rejectedItems != null && reasons != null && rejectedItems.Count != reasons.Count)"  is complex.
Complex Conditional,Microsoft.Windows.Shell,TaskbarItemInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\TaskbarItemInfo.cs,_CoerceThumbnailClipMargin,The conditional expression  "margin.Left < 0                  || margin.Right < 0                  || margin.Top < 0                  || margin.Bottom < 0"  is complex.
Complex Conditional,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The conditional expression  "a >= 0 && b >= 0 && c >= 0 && d >= 0"  is complex.
Empty Catch Block,Microsoft.Windows.Shell,JumpList,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\JumpList.cs,CreateItemFromJumpPath,The method has an empty catch block.
Empty Catch Block,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The method has an empty catch block.
Empty Catch Block,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GuidTryParse,The method has an empty catch block.
Empty Catch Block,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GuidTryParse,The method has an empty catch block.
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_LegacyInitializeCaptionButtonLocation,The following statement contains a magic number: Rect captionRect = new Rect(0' 0' captionX * 3' captionY);
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,_InitializeWindowCornerRadius,The following statement contains a magic number: switch (UxThemeName.ToUpperInvariant())              {                  case "LUNA":                      cornerRadius = new CornerRadius(6' 6' 0' 0);                      break;                  case "AERO":                      // Aero has two cases.  One with glass and one without...                      if (NativeMethods.DwmIsCompositionEnabled())                      {                          cornerRadius = new CornerRadius(8);                      }                      else                      {                          cornerRadius = new CornerRadius(6' 6' 0' 0);                      }                      break;                  case "CLASSIC":                  case "ZUNE":                  case "ROYALE":                  default:                      cornerRadius = new CornerRadius(0);                      break;              }
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect(-16000' -16000' 100' 100)' ""' _WndProc);
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect(-16000' -16000' 100' 100)' ""' _WndProc);
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect(-16000' -16000' 100' 100)' ""' _WndProc);
Magic Number,Microsoft.Windows.Shell,SystemParameters2,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\SystemParameters2.cs,SystemParameters2,The following statement contains a magic number: _messageHwnd = new MessageWindow((CS)0' WS.OVERLAPPEDWINDOW | WS.DISABLED' (WS_EX)0' new Rect(-16000' -16000' 100' 100)' ""' _WndProc);
Magic Number,Microsoft.Windows.Shell,TaskbarItemInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\TaskbarItemInfo.cs,_UpdateProgressValue,The following statement contains a magic number: const ulong precisionValue = 1000;
Magic Number,Microsoft.Windows.Shell,ThumbButtonInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\ThumbButtonInfo.cs,_CoerceDescription,The following statement contains a magic number: if (text != null && text.Length >= 260)              {                  // Account for the NULL in native LPWSTRs                  text = text.Substring(0' 259);              }
Magic Number,Microsoft.Windows.Shell,ThumbButtonInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\ThumbButtonInfo.cs,_CoerceDescription,The following statement contains a magic number: if (text != null && text.Length >= 260)              {                  // Account for the NULL in native LPWSTRs                  text = text.Substring(0' 259);              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupWindows7Issues,The following statement contains a magic number: if (_blackGlassFixupAttemptCount > 5)              {                  // Don't keep trying if there's an endemic problem with this.                  return;              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The following statement contains a magic number: if (_window.WindowState == WindowState.Maximized || _window.WindowState == WindowState.Minimized)              {                  // Old versions of WPF sometimes force their incorrect idea of the Window's location                  // on the Win32 restore bounds.  If we have reason to think this is the case' then                  // try to undo what WPF did after it has done its thing.                  if (_hasUserMovedWindow)                  {                      _hasUserMovedWindow = false;                      WINDOWPLACEMENT wp = NativeMethods.GetWindowPlacement(_hwnd);                        RECT adjustedDeviceRc = _GetAdjustedWindowRect(new RECT { Bottom = 100' Right = 100 });                      Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical(                          new Point(                              wp.rcNormalPosition.Left - adjustedDeviceRc.Left'                              wp.rcNormalPosition.Top - adjustedDeviceRc.Top));                                            _window.Top = adjustedTopLeft.Y;                      _window.Left = adjustedTopLeft.X;                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_FixupRestoreBounds,The following statement contains a magic number: if (_window.WindowState == WindowState.Maximized || _window.WindowState == WindowState.Minimized)              {                  // Old versions of WPF sometimes force their incorrect idea of the Window's location                  // on the Win32 restore bounds.  If we have reason to think this is the case' then                  // try to undo what WPF did after it has done its thing.                  if (_hasUserMovedWindow)                  {                      _hasUserMovedWindow = false;                      WINDOWPLACEMENT wp = NativeMethods.GetWindowPlacement(_hwnd);                        RECT adjustedDeviceRc = _GetAdjustedWindowRect(new RECT { Bottom = 100' Right = 100 });                      Point adjustedTopLeft = DpiHelper.DevicePixelsToLogical(                          new Point(                              wp.rcNormalPosition.Left - adjustedDeviceRc.Left'                              wp.rcNormalPosition.Top - adjustedDeviceRc.Top));                                            _window.Top = adjustedTopLeft.Y;                      _window.Left = adjustedTopLeft.X;                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HandleSize,The following statement contains a magic number: const int SIZE_MAXIMIZED = 2;
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_SetRoundingRegion,The following statement contains a magic number: if (wpl.showCmd == SW.SHOWMAXIMIZED)              {                  int left;                  int top;                    if (wp.HasValue)                  {                      left = wp.Value.x;                      top = wp.Value.y;                  }                  else                  {                      Rect r = _GetWindowRect();                      left = (int)r.Left;                      top = (int)r.Top;                  }                    IntPtr hMon = NativeMethods.MonitorFromWindow(_hwnd' MONITOR_DEFAULTTONEAREST);                    MONITORINFO mi = NativeMethods.GetMonitorInfo(hMon);                  RECT rcMax = mi.rcWork;                  // The location of maximized window takes into account the border that Windows was                  // going to remove' so we also need to consider it.                  rcMax.Offset(-left' -top);                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      hrgn = NativeMethods.CreateRectRgnIndirect(rcMax);                      NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      Utility.SafeDeleteObject(ref hrgn);                  }              }              else              {                  Size windowSize;                    // Use the size if it's specified.                  if (null != wp && !Utility.IsFlagSet(wp.Value.flags' (int)SWP.NOSIZE))                  {                      windowSize = new Size((double)wp.Value.cx' (double)wp.Value.cy);                  }                  else if (null != wp && (_lastRoundingState == _window.WindowState))                  {                      return;                  }                  else                  {                      windowSize = _GetWindowRect().Size;                  }                    _lastRoundingState = _window.WindowState;                    IntPtr hrgn = IntPtr.Zero;                  try                  {                      double shortestDimension = Math.Min(windowSize.Width' windowSize.Height);                        double topLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopLeft' 0)).X;                      topLeftRadius = Math.Min(topLeftRadius' shortestDimension / 2);                        if (_IsUniform(_chromeInfo.CornerRadius))                      {                          // RoundedRect HRGNs require an additional pixel of padding.                          hrgn = _CreateRoundRectRgn(new Rect(windowSize)' topLeftRadius);                      }                      else                      {                          // We need to combine HRGNs for each of the corners.                          // Create one for each quadrant' but let it overlap into the two adjacent ones                          // by the radius amount to ensure that there aren't corners etched into the middle                          // of the window.                          hrgn = _CreateRoundRectRgn(new Rect(0' 0' windowSize.Width / 2 + topLeftRadius' windowSize.Height / 2 + topLeftRadius)' topLeftRadius);                            double topRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.TopRight' 0)).X;                          topRightRadius = Math.Min(topRightRadius' shortestDimension / 2);                          Rect topRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + topRightRadius' windowSize.Height / 2 + topRightRadius);                          topRightRegionRect.Offset(windowSize.Width / 2 - topRightRadius' 0);                          Assert.AreEqual(topRightRegionRect.Right' windowSize.Width);                            _CreateAndCombineRoundRectRgn(hrgn' topRightRegionRect' topRightRadius);                                                    double bottomLeftRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomLeft' 0)).X;                          bottomLeftRadius = Math.Min(bottomLeftRadius' shortestDimension / 2);                          Rect bottomLeftRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomLeftRadius' windowSize.Height / 2 + bottomLeftRadius);                          bottomLeftRegionRect.Offset(0' windowSize.Height / 2 - bottomLeftRadius);                          Assert.AreEqual(bottomLeftRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomLeftRegionRect' bottomLeftRadius);                                                    double bottomRightRadius = DpiHelper.LogicalPixelsToDevice(new Point(_chromeInfo.CornerRadius.BottomRight' 0)).X;                          bottomRightRadius = Math.Min(bottomRightRadius' shortestDimension / 2);                          Rect bottomRightRegionRect = new Rect(0' 0' windowSize.Width / 2 + bottomRightRadius' windowSize.Height / 2 + bottomRightRadius);                          bottomRightRegionRect.Offset(windowSize.Width / 2 - bottomRightRadius' windowSize.Height / 2 - bottomRightRadius);                          Assert.AreEqual(bottomRightRegionRect.Right' windowSize.Width);                          Assert.AreEqual(bottomRightRegionRect.Bottom' windowSize.Height);                            _CreateAndCombineRoundRectRgn(hrgn' bottomRightRegionRect' bottomRightRadius);                      }                        NativeMethods.SetWindowRgn(_hwnd' hrgn' NativeMethods.IsWindowVisible(_hwnd));                      hrgn = IntPtr.Zero;                  }                  finally                  {                      // Free the memory associated with the HRGN if it wasn't assigned to the HWND.                      Utility.SafeDeleteObject(ref hrgn);                  }              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: if (mousePosition.Y >= windowPosition.Top && mousePosition.Y < windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top + _chromeInfo.CaptionHeight)              {                  onResizeBorder = (mousePosition.Y < (windowPosition.Top + _chromeInfo.ResizeBorderThickness.Top));                  uRow = 0; // top (caption or resize border)              }              else if (mousePosition.Y < windowPosition.Bottom && mousePosition.Y >= windowPosition.Bottom - (int)_chromeInfo.ResizeBorderThickness.Bottom)              {                  uRow = 2; // bottom              }
Magic Number,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_HitTestNca,The following statement contains a magic number: if (mousePosition.X >= windowPosition.Left && mousePosition.X < windowPosition.Left + (int)_chromeInfo.ResizeBorderThickness.Left)              {                  uCol = 0; // left side              }              else if (mousePosition.X < windowPosition.Right && mousePosition.X >= windowPosition.Right - _chromeInfo.ResizeBorderThickness.Right)              {                  uCol = 2; // right side              }
Magic Number,Standard,HRESULT,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ErrorCodes.cs,Make,The following statement contains a magic number: return new HRESULT((uint)((severe ? (1 << 31) : 0) | ((int)facility << 16) | code));
Magic Number,Standard,HRESULT,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ErrorCodes.cs,Make,The following statement contains a magic number: return new HRESULT((uint)((severe ? (1 << 31) : 0) | ((int)facility << 16) | code));
Magic Number,Standard,HRESULT,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\ErrorCodes.cs,GetFacility,The following statement contains a magic number: return (Facility)((errorCode >> 16) & 0x1fff);
Magic Number,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,GetModuleFileName,The following statement contains a magic number: while (true)              {                  int size = _GetModuleFileName(hModule' buffer' buffer.Capacity);                  if (size == 0)                  {                      HRESULT.ThrowLastError();                  }                    // GetModuleFileName returns nSize when it's truncated but does NOT set the last error.                  // MSDN documentation says this has changed in Windows 2000+.                  if (size == buffer.Capacity)                  {                      // Enlarge the buffer and try again.                      buffer.EnsureCapacity(buffer.Capacity * 2);                      continue;                  }                    return buffer.ToString();              }
Magic Number,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,GetWindowLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size)              {                  ret = GetWindowLongPtr64(hwnd' nIndex);              }              else              {                  ret = new IntPtr(GetWindowLongPtr32(hwnd' nIndex));              }
Magic Number,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,SetClassLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size)              {                  return SetClassLongPtr64(hwnd' nIndex' dwNewLong);              }
Magic Number,Standard,NativeMethods,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,SetWindowLongPtr,The following statement contains a magic number: if (8 == IntPtr.Size)              {                  return SetWindowLongPtr64(hwnd' nIndex' dwNewLong);              }
Magic Number,Standard,RECT,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,GetHashCode,The following statement contains a magic number: return (_left << 16 | Utility.LOWORD(_right)) ^ (_top << 16 | Utility.LOWORD(_bottom));
Magic Number,Standard,RECT,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\NativeMethods.cs,GetHashCode,The following statement contains a magic number: return (_left << 16 | Utility.LOWORD(_right)) ^ (_top << 16 | Utility.LOWORD(_bottom));
Magic Number,Standard,ManagedIStream,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\StreamHelper.cs,CopyTo,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,RGB,The following statement contains a magic number: return c.R | (c.G << 8) | (c.B << 16);
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,RGB,The following statement contains a magic number: return c.R | (c.G << 8) | (c.B << 16);
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb(                  (byte)((color & 0xFF000000) >> 24)'                  (byte)((color & 0x00FF0000) >> 16)'                  (byte)((color & 0x0000FF00) >> 8)'                  (byte)((color & 0x000000FF) >> 0));
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb(                  (byte)((color & 0xFF000000) >> 24)'                  (byte)((color & 0x00FF0000) >> 16)'                  (byte)((color & 0x0000FF00) >> 8)'                  (byte)((color & 0x000000FF) >> 0));
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,ColorFromArgbDword,The following statement contains a magic number: return Color.FromArgb(                  (byte)((color & 0xFF000000) >> 24)'                  (byte)((color & 0x00FF0000) >> 16)'                  (byte)((color & 0x0000FF00) >> 8)'                  (byte)((color & 0x000000FF) >> 0));
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,HIWORD,The following statement contains a magic number: return (short)(i >> 16);
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,AreStreamsEqual,The following statement contains a magic number: var leftBuffer = new byte[512];
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,AreStreamsEqual,The following statement contains a magic number: var rightBuffer = new byte[512];
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,GenerateHICON,The following statement contains a magic number: if (bf != null)              {                  bf = GetBestMatch(bf.Decoder.Frames' (int)dimensions.Width' (int)dimensions.Height);              }              else              {                  // Constrain the dimensions based on the aspect ratio.                  var drawingDimensions = new Rect(0' 0' dimensions.Width' dimensions.Height);                    // There's no reason to assume that the requested image dimensions are square.                  double renderRatio = dimensions.Width / dimensions.Height;                  double aspectRatio = image.Width / image.Height;                    // If it's smaller than the requested size' then place it in the middle and pad the image.                  if (image.Width <= dimensions.Width && image.Height <= dimensions.Height)                  {                      drawingDimensions = new Rect((dimensions.Width - image.Width) / 2' (dimensions.Height - image.Height) / 2' image.Width' image.Height);                  }                  else if (renderRatio > aspectRatio)                  {                      double scaledRenderWidth = (image.Width / image.Height) * dimensions.Width;                      drawingDimensions = new Rect((dimensions.Width - scaledRenderWidth) / 2' 0' scaledRenderWidth' dimensions.Height);                  }                  else if (renderRatio < aspectRatio)                  {                      double scaledRenderHeight = (image.Height / image.Width) * dimensions.Height;                      drawingDimensions = new Rect(0' (dimensions.Height - scaledRenderHeight) / 2' dimensions.Width' scaledRenderHeight);                  }                    var dv = new DrawingVisual();                  DrawingContext dc = dv.RenderOpen();                  dc.DrawImage(image' drawingDimensions);                  dc.Close();                    var bmp = new RenderTargetBitmap((int)dimensions.Width' (int)dimensions.Height' 96' 96' PixelFormats.Pbgra32);                  bmp.Render(dv);                  bf = BitmapFrame.Create(bmp);              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_MatchImage,The following statement contains a magic number: int score = 2 * _WeightedAbs(bpp' bitDepth' false) +                      _WeightedAbs(frame.PixelWidth' width' true) +                      _WeightedAbs(frame.PixelHeight' height' true);
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_WeightedAbs,The following statement contains a magic number: if (diff < 0)              {                  diff = (fPunish ? -2 : -1) * diff;              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_GetBestMatch,The following statement contains a magic number: for (int i = 0; i < frames.Count && bestScore != 0; ++i)              {                  int currentIconBitDepth = isBitmapIconDecoder ? frames[i].Thumbnail.Format.BitsPerPixel : frames[i].Format.BitsPerPixel;                    if (currentIconBitDepth == 0)                  {                      currentIconBitDepth = 8;                  }                    int score = _MatchImage(frames[i]' bitDepth' width' height' currentIconBitDepth);                  if (score < bestScore)                  {                      bestIndex = i;                      bestBpp = currentIconBitDepth;                      bestScore = score;                  }                  else if (score == bestScore)                  {                      // Tie breaker: choose the higher color depth.  If that fails' choose first one.                      if (bestBpp < currentIconBitDepth)                      {                          bestIndex = i;                          bestBpp = currentIconBitDepth;                      }                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,CopyStream,The following statement contains a magic number: var buffer = new byte[4096];
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlDecode,The following statement contains a magic number: for (int i = 0; i < length; ++i)              {                  char ch = url[i];                    if (ch == '+')                  {                      decoder.AddByte((byte)' ');                      continue;                  }                    if (ch == '%' && i < length - 2)                  {                      // decode %uXXXX into a Unicode character.                      if (url[i + 1] == 'u' && i < length - 5)                      {                          int a = _HexToInt(url[i + 2]);                          int b = _HexToInt(url[i + 3]);                          int c = _HexToInt(url[i + 4]);                          int d = _HexToInt(url[i + 5]);                          if (a >= 0 && b >= 0 && c >= 0 && d >= 0)                          {                              decoder.AddChar((char)((a << 12) | (b << 8) | (c << 4) | d));                              i += 5;                                continue;                          }                      }                      else                      {                          // decode %XX into a Unicode character.                          int a = _HexToInt(url[i + 1]);                          int b = _HexToInt(url[i + 2]);                            if (a >= 0 && b >= 0)                          {                              decoder.AddByte((byte)((a << 4) | b));                              i += 2;                                continue;                          }                      }                  }                    // Add any 7bit character as a byte.                  if ((ch & 0xFF80) == 0)                  {                      decoder.AddByte((byte)ch);                  }                  else                  {                      decoder.AddChar(ch);                  }              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: if (needsEncoding)              {                  var buffer = new byte[bytes.Length + (unsafeCharCount * 2)];                  int writeIndex = 0;                  foreach (byte b in bytes)                  {                      if (_UrlEncodeIsSafe(b))                      {                          buffer[writeIndex++] = b;                      }                      else if (b == ' ')                      {                          buffer[writeIndex++] = (byte)'+';                      }                      else                      {                          buffer[writeIndex++] = (byte)'%';                          buffer[writeIndex++] = _IntToHex((b >> 4) & 0xF);                          buffer[writeIndex++] = _IntToHex(b & 0xF);                      }                  }                  bytes = buffer;                  Assert.AreEqual(buffer.Length' writeIndex);              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,UrlEncode,The following statement contains a magic number: if (needsEncoding)              {                  var buffer = new byte[bytes.Length + (unsafeCharCount * 2)];                  int writeIndex = 0;                  foreach (byte b in bytes)                  {                      if (_UrlEncodeIsSafe(b))                      {                          buffer[writeIndex++] = b;                      }                      else if (b == ' ')                      {                          buffer[writeIndex++] = (byte)'+';                      }                      else                      {                          buffer[writeIndex++] = (byte)'%';                          buffer[writeIndex++] = _IntToHex((b >> 4) & 0xF);                          buffer[writeIndex++] = _IntToHex(b & 0xF);                      }                  }                  bytes = buffer;                  Assert.AreEqual(buffer.Length' writeIndex);              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: Assert.BoundedInteger(0' n' 16);
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: if (n <= 9)              {                  return (byte)(n + '0');              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_IntToHex,The following statement contains a magic number: return (byte)(n - 10 + 'A');
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_HexToInt,The following statement contains a magic number: if (h >= 'a' && h <= 'f')              {                  return h - 'a' + 10;              }
Magic Number,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_HexToInt,The following statement contains a magic number: if (h >= 'A' && h <= 'F')              {                  return h - 'A' + 10;              }
Missing Default,Microsoft.Windows.Shell,TaskbarItemInfo,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\TaskbarItemInfo.cs,_WndProc,The following switch statement is missing a default case: switch (message)                  {                      case WM.COMMAND:                          if (Utility.HIWORD(wParam.ToInt32()) == THUMBBUTTON.THBN_CLICKED)                          {                              int index = Utility.LOWORD(wParam.ToInt32());                              ThumbButtonInfos[index].InvokeClick();                              handled = true;                          }                          break;                      case WM.SIZE:                          _UpdateThumbnailClipping(_isAttached);                          handled = false;                          break;                  }
Missing Default,Microsoft.Windows.Shell,WindowChromeWorker,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\WindowChromeWorker.cs,_GetHwndState,The following switch statement is missing a default case: switch (wpl.showCmd)              {                  case SW.SHOWMINIMIZED: return WindowState.Minimized;                  case SW.SHOWMAXIMIZED: return WindowState.Maximized;              }
Missing Default,Standard,Utility,C:\repos\yysun_Git-Source-Control-Provider\GitUI\Microsoft.Windows.Shell\Standard\Utilities.cs,_UrlEncodeIsSafe,The following switch statement is missing a default case: switch ((char)b)              {                  case '-':                  case '_':                  case '.':                  case '!':                  //case '~':                  case '*':                  case '\'':                  case '(':                  case ')':                      return true;              }
