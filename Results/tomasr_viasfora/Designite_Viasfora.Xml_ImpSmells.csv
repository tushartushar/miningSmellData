Implementation smell,Namespace,Class,File,Method,Description
Long Method,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,Read,The method has 116 lines of code.
Long Method,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ParseCData,The method has 123 lines of code.
Complex Method,Winterdom.Viasfora.Xml,XmlTagMatchingTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagMatchingTagger.cs,GetTags,Cyclomatic complexity of the method is 9
Complex Method,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SniffMeta,Cyclomatic complexity of the method is 11
Complex Method,Sgml,Group,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,CanContain,Cyclomatic complexity of the method is 9
Complex Method,Sgml,SgmlDtd,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,ParseElementDecl,Cyclomatic complexity of the method is 11
Complex Method,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ParseStartTag,Cyclomatic complexity of the method is 15
Complex Method,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ParseDocType,Cyclomatic complexity of the method is 9
Complex Method,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ParseCData,Cyclomatic complexity of the method is 9
Complex Method,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ValidateContent,Cyclomatic complexity of the method is 9
Long Parameter List,Sgml,Ucs4Decoder,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,Sgml,Ucs4Decoder,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,Sgml,Ucs4DecoderBigEngian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,Sgml,Ucs4DecoderLittleEndian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,Sgml,ElementDecl,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,ElementDecl,The method has 6 parameters. Parameters: name' sto' eto' cm' inclusions' exclusions
Long Parameter List,Sgml,SgmlDtd,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,Parse,The method has 7 parameters. Parameters: baseUri' name' pubid' url' subset' proxy' nt
Long Parameter List,Sgml,SgmlDtd,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,Parse,The method has 7 parameters. Parameters: baseUri' name' pubid' input' subset' proxy' nt
Long Identifier,Winterdom.Viasfora.Xml,XmlTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagger.cs,,The length of the parameter xmlClosingPrefixClassification is 30.
Long Statement,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,Context,The length of the statement  "                    msg = String.Format("\nReferenced on line {0}' position {1} of '{2}' entity at [{3}]"' p.Line' p.LinePosition' p.Name' p.ResolvedUri.AbsolutePath); " is 147.
Long Statement,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The length of the statement  "                uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3]; " is 128.
Long Statement,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,LazyLoadDtd,The length of the statement  "                    this.dtd = SgmlDtd.Parse(baseUri' this.docType' this.pubid' baseUri.AbsoluteUri' this.subset' this.proxy' this.nametable); " is 122.
Complex Conditional,Winterdom.Viasfora.Xml,XmlTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagger.cs,DoXAMLorHTML,The conditional expression  "text.IndexOf('>') >= 0 && lastSpan.HasValue && foundClosingTag && settings.XmlCloseTagEnabled"  is complex.
Complex Conditional,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SkipWhitespace,The conditional expression  "ch != Entity.EOF && (ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')"  is complex.
Complex Conditional,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,ScanToken,The conditional expression  "!nmtoken || ch == '_' || ch == '.' || ch == '-' || ch == ':' || Char.IsLetterOrDigit(ch)"  is complex.
Complex Conditional,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SniffWhitespace,The conditional expression  "ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n'"  is complex.
Complex Conditional,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SniffWhitespace,The conditional expression  "ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n'"  is complex.
Complex Conditional,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SniffName,The conditional expression  "pos < used - 1 && ( Char.IsLetterOrDigit(ch) || ch == '-' || ch == '_' || ch == ':')"  is complex.
Complex Conditional,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SkipWhitespace,The conditional expression  "pos < used - 1 && (ch == ' ' || ch == '\r' || ch == '\n')"  is complex.
Complex Conditional,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,Read,The conditional expression  "!foundRoot && (this.NodeType == XmlNodeType.Element ||                      this.NodeType == XmlNodeType.Text ||                      this.NodeType == XmlNodeType.CDATA)"  is complex.
Complex Conditional,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ParseStartTag,The conditional expression  "aname == "'" || aname == "=" || aname == ":" || aname == ";""  is complex.
Complex Conditional,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ParseText,The conditional expression  "ch == '/' || ch == '!' || ch == '?' || Char.IsLetter(ch)"  is complex.
Complex Conditional,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ExpandEntity,The conditional expression  "ch != Entity.EOF &&                       (Char.IsLetter(ch) || ch == '_' || ch == '-')"  is complex.
Empty Catch Block,Winterdom.Viasfora.Xml,XmlQuickInfoSource,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlQuickInfoSource.cs,ReadXmlUntilEnd,The method has an empty catch block.
Empty Catch Block,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,Open,The method has an empty catch block.
Empty Catch Block,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SniffEncoding,The method has an empty catch block.
Empty Catch Block,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SniffMeta,The method has an empty catch block.
Magic Number,Winterdom.Viasfora.Xml,XmlTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagger.cs,DoXAMLorHTML,The following statement contains a magic number: foreach ( var tagSpan in aggregator.GetTags(spans) ) {          String tagName = tagSpan.Tag.ClassificationType.Classification;          var cs = tagSpan.Span.GetSpans(snapshot)[0];          if ( IsXmlDelimiter(tagName) ) {            String text = cs.GetText();            if ( text.EndsWith("</") ) {              foundClosingTag = true;            } else if ( text == ":" && lastSpan.HasValue && settings.XmlnsPrefixEnabled ) {              var prefixCT = foundClosingTag && settings.XmlCloseTagEnabled                           ? xmlClosingPrefixClassification                           : xmlPrefixClassification;              yield return new TagSpan<ClassificationTag>(lastSpan.Value' prefixCT);            } else if ( text.IndexOf('>') >= 0 && lastSpan.HasValue && foundClosingTag && settings.XmlCloseTagEnabled ) {              yield return new TagSpan<ClassificationTag>(lastSpan.Value' xmlCloseTagClassification);              foundClosingTag = false;            }            lastSpan = null;            lastSpanTagName = null;          } else if ( IsXmlName(tagName) || IsXmlAttribute(tagName) ) {            lastSpan = cs;            lastSpanTagName = tagName;          } else if ( IsRazorTag(tagName) ) {            if ( snapshot.GetText(new Span(cs.Span.Start - 2' 2)) == "</" ) {              yield return new TagSpan<ClassificationTag>(cs' razorCloseTagClassification);            }          }        }
Magic Number,Winterdom.Viasfora.Xml,XmlTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagger.cs,DoXAMLorHTML,The following statement contains a magic number: foreach ( var tagSpan in aggregator.GetTags(spans) ) {          String tagName = tagSpan.Tag.ClassificationType.Classification;          var cs = tagSpan.Span.GetSpans(snapshot)[0];          if ( IsXmlDelimiter(tagName) ) {            String text = cs.GetText();            if ( text.EndsWith("</") ) {              foundClosingTag = true;            } else if ( text == ":" && lastSpan.HasValue && settings.XmlnsPrefixEnabled ) {              var prefixCT = foundClosingTag && settings.XmlCloseTagEnabled                           ? xmlClosingPrefixClassification                           : xmlPrefixClassification;              yield return new TagSpan<ClassificationTag>(lastSpan.Value' prefixCT);            } else if ( text.IndexOf('>') >= 0 && lastSpan.HasValue && foundClosingTag && settings.XmlCloseTagEnabled ) {              yield return new TagSpan<ClassificationTag>(lastSpan.Value' xmlCloseTagClassification);              foundClosingTag = false;            }            lastSpan = null;            lastSpanTagName = null;          } else if ( IsXmlName(tagName) || IsXmlAttribute(tagName) ) {            lastSpan = cs;            lastSpanTagName = tagName;          } else if ( IsRazorTag(tagName) ) {            if ( snapshot.GetText(new Span(cs.Span.Start - 2' 2)) == "</" ) {              yield return new TagSpan<ClassificationTag>(cs' razorCloseTagClassification);            }          }        }
Magic Number,Winterdom.Viasfora.Xml,XmlTagMatchingTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagMatchingTagger.cs,FindClosingTag,The following statement contains a magic number: using ( SgmlReader reader = new SgmlReader() ) {          reader.InputStream = new StringReader(textToSearch);          reader.WhitespaceHandling = WhitespaceHandling.All;          try {            reader.Read();            if ( !reader.IsEmptyElement ) {              // skip all the internal nodes' until the end              while ( reader.Read() ) {                if ( reader.NodeType == XmlNodeType.EndElement && reader.Depth == 1 )                  break;              }              // calculate the new position based on the number of lines              // read in the SgmlReader + the position within that line.              // Note that if there is whitespace after the closing tag              // we'll be positioned on it' so we need to keep track of that.              var origLine = snapshot.GetLineFromPosition(searchStart);              int startOffset = searchStart - origLine.Start.Position;              int newStart = 0;              // tag is on same position as the opening one              if ( reader.LineNumber == 1 ) {                var line = snapshot.GetLineFromPosition(searchStart);                newStart = line.Start.Position + startOffset + reader.LinePosition - 2;              } else {                int newLineNum = origLine.LineNumber + reader.LineNumber - 1;                var newLine = snapshot.GetLineFromLineNumber(newLineNum);                newStart = newLine.Start.Position + reader.LinePosition - 1;              }              newStart -= reader.Name.Length + 3; // </ + element + >                SnapshotSpan? newSpan = new SnapshotSpan(snapshot' newStart' searchFor.Length);              if ( newSpan.Value.GetText() != searchFor ) {                Trace.WriteLine(String.Format("Searching for '{0}'' but found '{1}'."' searchFor' newSpan.Value.GetText()));                newSpan = null;              }              return newSpan;            }          } catch ( Exception ex ) {            Trace.WriteLine(String.Format("Exception while parsing document: {0}."' ex.ToString()));          }        }
Magic Number,Winterdom.Viasfora.Xml,XmlTagMatchingTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagMatchingTagger.cs,FindClosingTag,The following statement contains a magic number: using ( SgmlReader reader = new SgmlReader() ) {          reader.InputStream = new StringReader(textToSearch);          reader.WhitespaceHandling = WhitespaceHandling.All;          try {            reader.Read();            if ( !reader.IsEmptyElement ) {              // skip all the internal nodes' until the end              while ( reader.Read() ) {                if ( reader.NodeType == XmlNodeType.EndElement && reader.Depth == 1 )                  break;              }              // calculate the new position based on the number of lines              // read in the SgmlReader + the position within that line.              // Note that if there is whitespace after the closing tag              // we'll be positioned on it' so we need to keep track of that.              var origLine = snapshot.GetLineFromPosition(searchStart);              int startOffset = searchStart - origLine.Start.Position;              int newStart = 0;              // tag is on same position as the opening one              if ( reader.LineNumber == 1 ) {                var line = snapshot.GetLineFromPosition(searchStart);                newStart = line.Start.Position + startOffset + reader.LinePosition - 2;              } else {                int newLineNum = origLine.LineNumber + reader.LineNumber - 1;                var newLine = snapshot.GetLineFromLineNumber(newLineNum);                newStart = newLine.Start.Position + reader.LinePosition - 1;              }              newStart -= reader.Name.Length + 3; // </ + element + >                SnapshotSpan? newSpan = new SnapshotSpan(snapshot' newStart' searchFor.Length);              if ( newSpan.Value.GetText() != searchFor ) {                Trace.WriteLine(String.Format("Searching for '{0}'' but found '{1}'."' searchFor' newSpan.Value.GetText()));                newSpan = null;              }              return newSpan;            }          } catch ( Exception ex ) {            Trace.WriteLine(String.Format("Exception while parsing document: {0}."' ex.ToString()));          }        }
Magic Number,Winterdom.Viasfora.Xml,XmlTagMatchingTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagMatchingTagger.cs,FindOpeningTag,The following statement contains a magic number: using ( SgmlReader reader = new SgmlReader() ) {          reader.InputStream = new StringReader(textToSearch);          reader.WhitespaceHandling = WhitespaceHandling.All;          try {            Stack<int> openingPositions = new Stack<int>();            while ( reader.Read() ) {              if ( reader.LocalName != searchFor ) {                continue;              }              if ( reader.NodeType == XmlNodeType.Element && !reader.IsEmptyElement ) {                // find close to where the tag starts                int lineNum = reader.LineNumber - 1;                var line = snapshot.GetLineFromLineNumber(lineNum);                int position = line.Start.Position + reader.LinePosition - searchFor.Length;                position = BacktrackToLessThan(snapshot' position);                String textFound = snapshot.GetText(position' 10);                openingPositions.Push(position);              } else if ( reader.NodeType == XmlNodeType.EndElement ) {                if ( openingPositions.Count <= 0 ) {                  // document is malformed' so just get the heck out                  return null;                }                var line = snapshot.GetLineFromLineNumber(reader.LineNumber - 1);                int position = line.Start.Position + reader.LinePosition;                if ( position >= searchEnd ) break;                openingPositions.Pop();              }            }            // done' last            if ( openingPositions.Count > 0 ) {              int position = openingPositions.Pop();              return new SnapshotSpan(snapshot' position' searchFor.Length + 2);            }          } catch ( Exception ex ) {            Trace.WriteLine(String.Format("Exception while parsing document: {0}."' ex.ToString()));          }        }
Magic Number,Winterdom.Viasfora.Xml,XmlTagMatchingTagger,C:\repos\tomasr_viasfora\src\Viasfora.Xml\XmlTagMatchingTagger.cs,FindOpeningTag,The following statement contains a magic number: using ( SgmlReader reader = new SgmlReader() ) {          reader.InputStream = new StringReader(textToSearch);          reader.WhitespaceHandling = WhitespaceHandling.All;          try {            Stack<int> openingPositions = new Stack<int>();            while ( reader.Read() ) {              if ( reader.LocalName != searchFor ) {                continue;              }              if ( reader.NodeType == XmlNodeType.Element && !reader.IsEmptyElement ) {                // find close to where the tag starts                int lineNum = reader.LineNumber - 1;                var line = snapshot.GetLineFromLineNumber(lineNum);                int position = line.Start.Position + reader.LinePosition - searchFor.Length;                position = BacktrackToLessThan(snapshot' position);                String textFound = snapshot.GetText(position' 10);                openingPositions.Push(position);              } else if ( reader.NodeType == XmlNodeType.EndElement ) {                if ( openingPositions.Count <= 0 ) {                  // document is malformed' so just get the heck out                  return null;                }                var line = snapshot.GetLineFromLineNumber(reader.LineNumber - 1);                int position = line.Start.Position + reader.LinePosition;                if ( position >= searchEnd ) break;                openingPositions.Pop();              }            }            // done' last            if ( openingPositions.Count > 0 ) {              int position = openingPositions.Pop();              return new SnapshotSpan(snapshot' position' searchFor.Length + 2);            }          } catch ( Exception ex ) {            Trace.WriteLine(String.Format("Exception while parsing document: {0}."' ex.ToString()));          }        }
Magic Number,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,Open,The following statement contains a magic number: if (Internal) {                  if (this.Literal != null)                      this.stm = new StringReader(this.Literal);              }               else if (this.Uri == null) {                  this.Error("Unresolvable entity '{0}'"' this.Name);              }              else {                  if (baseUri != null) {                      this.resolvedUri = new Uri(baseUri' this.Uri);                  }                  else {                      this.resolvedUri = new Uri(this.Uri);                  }                    Stream stream = null;                  Encoding e = Encoding.Default;                  switch (this.resolvedUri.Scheme) {                      case "file": {                              string path = this.resolvedUri.LocalPath;                              stream = new FileStream(path' FileMode.Open' FileAccess.Read);                          }                          break;                      default:                          //Console.WriteLine("Fetching:" + ResolvedUri.AbsoluteUri);                          HttpWebRequest wr = (HttpWebRequest)WebRequest.Create(ResolvedUri);                          wr.UserAgent = "Mozilla/4.0 (compatible;);";                          wr.Timeout = 10000; // in case this is running in an ASPX page.                          if (Proxy != null) wr.Proxy = new WebProxy(Proxy);                          wr.PreAuthenticate = false;                           // Pass the credentials of the process.                           wr.Credentials = CredentialCache.DefaultCredentials;                             WebResponse resp = wr.GetResponse();                          Uri actual = resp.ResponseUri;                          if (actual.AbsoluteUri != this.resolvedUri.AbsoluteUri) {                              this.resolvedUri = actual;                          }                                                 string contentType = resp.ContentType.ToLower();                          string mimeType = contentType;                          int i = contentType.IndexOf(';');                          if (i >= 0) {                              mimeType = contentType.Substring(0' i);                          }                          if (StringUtilities.EqualsIgnoreCase(mimeType' "text/html")){                              this.Html = true;                          }                            i = contentType.IndexOf("charset");                          e = Encoding.Default;                          if (i >= 0) {                                                              int j = contentType.IndexOf("="' i);                              int k = contentType.IndexOf(";"' j);                              if (k<0) k = contentType.Length;                              if (j > 0) {                                  j++;                                  string charset = contentType.Substring(j' k - j).Trim();                                  try {                                      e = Encoding.GetEncoding(charset);                                  } catch (Exception) {                                  }                              }                          }                          stream = resp.GetResponseStream();                          break;                    }                  this.weOwnTheStream = true;                  HtmlStream html = new HtmlStream(stream' e);                  this.encoding = html.Encoding;                  this.stm = html;              }
Magic Number,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,ExpandCharEntity,The following statement contains a magic number: if (ch == 'x') {                  ch = ReadChar();                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar()) {                      int p = 0;                      if (ch >= '0' && ch <= '9') {                          p = (int)(ch-'0');                      }                       else if (ch >= 'a' && ch <= 'f') {                          p = (int)(ch-'a')+10;                      }                       else if (ch >= 'A' && ch <= 'F') {                          p = (int)(ch-'A')+10;                      }                      else {                          break;//we must be done!                          //Error("Hex digit out of range '{0}'"' (int)ch);                      }                      v = (v*16)+p;                  }              }               else {                                     for (; ch != Entity.EOF && ch != ';'; ch = ReadChar()) {                      if (ch >= '0' && ch <= '9') {                          v = (v*10)+(int)(ch-'0');                      }                       else {                          break; // we must be done!                          //Error("Decimal digit out of range '{0}'"' (int)ch);                      }                  }              }
Magic Number,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,ExpandCharEntity,The following statement contains a magic number: if (ch == 'x') {                  ch = ReadChar();                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar()) {                      int p = 0;                      if (ch >= '0' && ch <= '9') {                          p = (int)(ch-'0');                      }                       else if (ch >= 'a' && ch <= 'f') {                          p = (int)(ch-'a')+10;                      }                       else if (ch >= 'A' && ch <= 'F') {                          p = (int)(ch-'A')+10;                      }                      else {                          break;//we must be done!                          //Error("Hex digit out of range '{0}'"' (int)ch);                      }                      v = (v*16)+p;                  }              }               else {                                     for (; ch != Entity.EOF && ch != ';'; ch = ReadChar()) {                      if (ch >= '0' && ch <= '9') {                          v = (v*10)+(int)(ch-'0');                      }                       else {                          break; // we must be done!                          //Error("Decimal digit out of range '{0}'"' (int)ch);                      }                  }              }
Magic Number,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,ExpandCharEntity,The following statement contains a magic number: if (ch == 'x') {                  ch = ReadChar();                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar()) {                      int p = 0;                      if (ch >= '0' && ch <= '9') {                          p = (int)(ch-'0');                      }                       else if (ch >= 'a' && ch <= 'f') {                          p = (int)(ch-'a')+10;                      }                       else if (ch >= 'A' && ch <= 'F') {                          p = (int)(ch-'A')+10;                      }                      else {                          break;//we must be done!                          //Error("Hex digit out of range '{0}'"' (int)ch);                      }                      v = (v*16)+p;                  }              }               else {                                     for (; ch != Entity.EOF && ch != ';'; ch = ReadChar()) {                      if (ch >= '0' && ch <= '9') {                          v = (v*10)+(int)(ch-'0');                      }                       else {                          break; // we must be done!                          //Error("Decimal digit out of range '{0}'"' (int)ch);                      }                  }              }
Magic Number,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,ExpandCharEntity,The following statement contains a magic number: if (ch == 'x') {                  ch = ReadChar();                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar()) {                      int p = 0;                      if (ch >= '0' && ch <= '9') {                          p = (int)(ch-'0');                      }                       else if (ch >= 'a' && ch <= 'f') {                          p = (int)(ch-'a')+10;                      }                       else if (ch >= 'A' && ch <= 'F') {                          p = (int)(ch-'A')+10;                      }                      else {                          break;//we must be done!                          //Error("Hex digit out of range '{0}'"' (int)ch);                      }                      v = (v*16)+p;                  }              }               else {                                     for (; ch != Entity.EOF && ch != ';'; ch = ReadChar()) {                      if (ch >= '0' && ch <= '9') {                          v = (v*10)+(int)(ch-'0');                      }                       else {                          break; // we must be done!                          //Error("Decimal digit out of range '{0}'"' (int)ch);                      }                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,HtmlStream,The following statement contains a magic number: rawUsed = stm.Read(rawBuffer' 0' 4);
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,HtmlStream,The following statement contains a magic number: if (this.decoder == null) {                  this.decoder = defaultEncoding.GetDecoder();                  rawUsed += stm.Read(rawBuffer' 4' BUFSIZE-4);                                  DecodeBlock();                  // Now sniff to see if there is an XML declaration or HTML <META> tag.                  Decoder sd = SniffEncoding();                  if (sd != null) {                      this.decoder = sd;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,HtmlStream,The following statement contains a magic number: if (this.decoder == null) {                  this.decoder = defaultEncoding.GetDecoder();                  rawUsed += stm.Read(rawBuffer' 4' BUFSIZE-4);                                  DecodeBlock();                  // Now sniff to see if there is an XML declaration or HTML <META> tag.                  Decoder sd = SniffEncoding();                  if (sd != null) {                      this.decoder = sd;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,CopyToMemoryStream,The following statement contains a magic number: int size = 100000;
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,ReadToEnd,The following statement contains a magic number: char[] buffer = new char[100000];
Magic Number,Sgml,Ucs4Decoder,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetCharCount,The following statement contains a magic number: return (count + tempBytes) / 4;
Magic Number,Sgml,Ucs4Decoder,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetChars,The following statement contains a magic number: if (tempBytes > 0) {                  for (; i < 4; i++) {                      temp[i] = bytes[byteIndex];                      byteIndex++;                      byteCount--;                  }                  i = 1;                  GetFullChars(temp' 0' 4' chars' charIndex);                  charIndex++;              } else                  i = 0;
Magic Number,Sgml,Ucs4Decoder,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetChars,The following statement contains a magic number: if (tempBytes > 0) {                  for (; i < 4; i++) {                      temp[i] = bytes[byteIndex];                      byteIndex++;                      byteCount--;                  }                  i = 1;                  GetFullChars(temp' 0' 4' chars' charIndex);                  charIndex++;              } else                  i = 0;
Magic Number,Sgml,Ucs4Decoder,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetChars,The following statement contains a magic number: int j = (tempBytes + byteCount) % 4;
Magic Number,Sgml,Ucs4Decoder,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,UnicodeToUTF16,The following statement contains a magic number: lowerByte = (byte)(0xD7C0 + (code >> 10));
Magic Number,Sgml,Ucs4Decoder,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,UnicodeToUTF16,The following statement contains a magic number: return ((char)((higherByte << 8) | lowerByte));
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new Exception("Invalid character 0x" + code.ToString("x") + " in encoding");                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,Init,The following statement contains a magic number: this.stack = new HWStack(10);
Magic Number,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ParseComment,The following statement contains a magic number: while (i>=0) {                  int j = i+2;                  while (j<value.Length && value[j]=='-')                      j++;                  if (i>0) {                      value = value.Substring(0' i-1)+"-"+value.Substring(j);                  }                   else {                      value = "-"+value.Substring(j);                  }                  i = value.IndexOf("--");              }
Magic Number,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ValidateContent,The following statement contains a magic number: if (this.dtd != null) {                  // See if this element is allowed inside the current element.                  // If it isn't' then auto-close elements until we find one                  // that it is allowed to be in.                                                    string name = this.nametable.Add(node.Name.ToUpper()); // DTD is in upper case                  int i = 0;                  int top = this.stack.Count-2;                  if (node.DtdType != null) {                       // it is a known element' let's see if it's allowed in the                      // current context.                      for (i = top; i>0; i--) {                          Node n = (Node)this.stack[i];                          if (n.IsEmpty)                               continue; // we'll have to pop this one                          ElementDecl f = n.DtdType;                          if (f != null) {                              if (f.Name == this.dtd.Name)                                  break; // can't pop the root element.                              if (f.CanContain(name' this.dtd)) {                                  break;                              }                               else if (!f.EndTagOptional) {                                  // If the end tag is not optional then we can't                                  // auto-close it.  We'll just have to live with the                                  // junk we've found and move on.                                  break;                              }                          }                           else {                              // Since we don't understand this tag anyway'                              // we might as well allow this content!                              break;                          }                      }                  }                  if (i == 0) {                      // Tag was not found or is not allowed anywhere' ignore it and                       // continue on.                  }                  else if (i < top) {                      Node n = (Node)this.stack[top];                      if (i == top - 1 && name == n.Name) {                          // e.g. p not allowed inside p' not an interesting error.                      } else {                          string closing = "";                          for (int k = top; k >= i+1; k--) {                              if (closing != "") closing += "'";                              Node n2 = (Node)this.stack[k];                              closing += "<"+n2.Name+">";                          }                          Log("Element '{0}' not allowed inside '{1}'' closing {2}."'                               name' n.Name' closing);                      }                      this.state = State.AutoClose;                      this.newnode = node;                      Pop(); // save this new node until we pop the others                      this.poptodepth = i+1;                  }              }
Missing Default,Sgml,Entity,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,SetLiteralType,The following switch statement is missing a default case: switch (token) {                  case "CDATA":                      LiteralType = LiteralType.CDATA;                      break;                  case "SDATA":                      LiteralType = LiteralType.SDATA;                      break;                  case "PI":                      LiteralType = LiteralType.PI;                      break;              }
Missing Default,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following switch statement is missing a default case: switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }
Missing Default,Sgml,HtmlStream,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AutoDetectEncoding,The following switch statement is missing a default case: switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }
Missing Default,Sgml,Group,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AddConnector,The following switch statement is missing a default case: switch (c)               {                  case ''':                       gt = GroupType.Sequence;                      break;                  case '|':                      gt = GroupType.Or;                      break;                  case '&':                      gt = GroupType.And;                      break;              }
Missing Default,Sgml,Group,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlParser.cs,AddOccurrence,The following switch statement is missing a default case: switch (c)               {                  case '?':                       o = Occurrence.Optional;                      break;                  case '+':                      o = Occurrence.OneOrMore;                      break;                  case '*':                      o = Occurrence.ZeroOrMore;                      break;              }
Missing Default,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,Read,The following switch statement is missing a default case: switch (this.state) {                      case State.Initial:                          this.state = State.Markup;                          this.current.ReadChar();                          goto case State.Markup;                      case State.Eof:                          if (this.current.Parent != null) {                              this.current.Close();                              this.current = this.current.Parent;                          } else {                                                         return false;                          }                          break;                      case State.EndTag:                          if (this.endTag == (object)this.node.Name) {                              Pop(); // we're done!                              this.state = State.Markup;                              goto case State.Markup;                          }                                               Pop(); // close one element                          foundnode = true;// return another end element.                          break;                      case State.Markup:                          if (this.node.IsEmpty) {                              Pop();                          }                          Node n = this.node;                          foundnode = ParseMarkup();                          break;                      case State.PartialTag:                          Pop(); // remove text node.                          this.state = State.Markup;                          foundnode = ParseTag(this.partial);                          break;                      case State.PseudoStartTag:                          foundnode = ParseStartTag('<');                                                  break;                      case State.AutoClose:                          Pop(); // close next node.                          if (this.stack.Count <= this.poptodepth) {                              this.state = State.Markup;                              if (this.newnode != null) {                                  Push(this.newnode); // now we're ready to start the new node.                                  this.newnode = null;                                  this.state = State.Markup;                              } else if (this.node.NodeType == XmlNodeType.Document) {                                  this.state = State.Eof;                                  goto case State.Eof;                              }                          }                           foundnode = true;                          break;                      case State.CData:                          foundnode = ParseCData();                          break;                      case State.Attr:                          goto case State.AttrValue;                      case State.AttrValue:                          this.state = State.Markup;                          goto case State.Markup;                      case State.Text:                          Pop();                          goto case State.Markup;                      case State.PartialText:                          if (ParseText(this.current.Lastchar' false)) {                              this.node.NodeType = XmlNodeType.Whitespace;                          }                          foundnode = true;                          break;                  }
Missing Default,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ScanName,The following switch statement is missing a default case: switch (this.folding){                  case CaseFolding.ToUpper:                      name = name.ToUpper();                      break;                  case CaseFolding.ToLower:                      name = name.ToLower();                      break;              }
Missing Default,Sgml,SgmlReader,C:\repos\tomasr_viasfora\src\Viasfora.Xml\Sgml\SgmlReader.cs,ParseCData,The following switch statement is missing a default case: switch (this.partial) {                      case '!':                          this.partial = ' '; // and pop the comment next time around                          return ParseComment();                      case '?':                          this.partial = ' '; // and pop the PI next time around                          return ParsePI();                      case '/':                          this.state = State.EndTag;                          return true;    // we are done!                      case ' ':                          break; // means we just needed to pop the Comment' PI or CDATA.                  }
