Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The method has 116 lines of code.
Complex Method,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,Insert,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.Cci.Pdb,PdbConstant,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbConstant.cs,PdbConstant,Cyclomatic complexity of the method is 53
Complex Method,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadTokenToSourceInfo,Cyclomatic complexity of the method is 19
Complex Method,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,LoadManagedFunctions,Cyclomatic complexity of the method is 37
Complex Method,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,CountScopesAndSlots,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,Cyclomatic complexity of the method is 33
Complex Method,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.Cci.Pdb,PdbScope,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbScope.cs,PdbScope,Cyclomatic complexity of the method is 23
Complex Method,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadScopeAndLocals,Cyclomatic complexity of the method is 10
Complex Method,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,Cyclomatic complexity of the method is 14
Complex Method,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineCustomMetadata,Cyclomatic complexity of the method is 9
Complex Method,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineScope,Cyclomatic complexity of the method is 20
Long Parameter List,Microsoft.Cci.Pdb,DataStream,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\DataStream.cs,Read,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFuncsFromDbiModule,The method has 8 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadTokenToSourceInfo,The method has 7 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,CountScopesAndSlots,The method has 6 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbLine,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbLine.cs,PdbLine,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbScope,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbScope.cs,PdbScope,The method has 5 parameters.
Long Parameter List,Microsoft.Cci.Pdb,PdbTokenLine,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbTokenLine.cs,PdbTokenLine,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Pdb,ISymUnmanagedWriter2,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ISymUnmanagedWriter2.cs,DefineDocument,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ISymUnmanagedWriter2,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ISymUnmanagedWriter2.cs,DefineSequencePoints,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,ISymUnmanagedWriter2,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ISymUnmanagedWriter2.cs,DefineLocalVariable2,The method has 9 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineNestedType,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineMethod,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineImportType,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineImportMember,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineEvent,The method has 8 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetEventProps,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineField,The method has 8 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineProperty,The method has 11 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineParam,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetFieldProps,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetPropertyProps,The method has 8 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetParamProps,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataEmit,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,TranslateSigWithScope,The method has 10 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetTypeDefProps,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMembersWithName,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMethodsWithName,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumFieldsWithName,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMethodImpls,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumPermissionSets,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMethodProps,The method has 9 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMemberRefProps,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetEventProps,The method has 12 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetClassLayout,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetPinvokeMap,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumCustomAttributes,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMemberProps,The method has 12 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetFieldProps,The method has 10 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetPropertyProps,The method has 15 parameters.
Long Parameter List,Mono.Cecil.Pdb,IMetaDataImport,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetParamProps,The method has 9 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineNestedType,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineMethod,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineImportType,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineImportMember,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineEvent,The method has 8 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetEventProps,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineField,The method has 8 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineProperty,The method has 11 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,DefineParam,The method has 7 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetFieldProps,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetPropertyProps,The method has 8 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,SetParamProps,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,TranslateSigWithScope,The method has 10 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetTypeDefProps,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMembersWithName,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMethodsWithName,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumFieldsWithName,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumMethodImpls,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumPermissionSets,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMethodProps,The method has 9 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMemberRefProps,The method has 6 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetEventProps,The method has 12 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetClassLayout,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetPinvokeMap,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,EnumCustomAttributes,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetMemberProps,The method has 12 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetFieldProps,The method has 10 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetPropertyProps,The method has 15 parameters.
Long Parameter List,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,GetParamProps,The method has 9 parameters.
Long Parameter List,Mono.Cecil.Pdb,SymWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,CoCreateInstance,The method has 5 parameters.
Long Parameter List,Mono.Cecil.Pdb,SymWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,DefineLocalVariable2,The method has 8 parameters.
Long Parameter List,Mono.Cecil.Pdb,SymWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,DefineSequencePoints,The method has 6 parameters.
Long Statement,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The length of the statement  "	value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24)); " is 133.
Long Statement,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The length of the statement  "	value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56)); " is 310.
Long Statement,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The length of the statement  "	value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24)); " is 134.
Long Statement,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The length of the statement  "	value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56)); " is 311.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "	symbol.scope = !function.scopes.IsNullOrEmpty () ? ReadScopeAndLocals (function.scopes [0]' symbol) : new ScopeDebugInformation { " is 129.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "	if (function.tokenOfMethodWhoseUsingInfoAppliesToThisMethod != method.MetadataToken.ToUInt32 () && function.tokenOfMethodWhoseUsingInfoAppliesToThisMethod != 0) " is 160.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "			symbol.CustomDebugInformations.Add (new StateMachineScopeDebugInformation ((int)iterator_scope.Offset' (int)(iterator_scope.Offset + iterator_scope.Length + 1))); " is 162.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "		var async_debug_info = new AsyncMethodBodyDebugInformation ((int)function.synchronizationInformation.GeneratedCatchHandlerOffset); " is 130.
Long Statement,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,Read,The length of the statement  "		symbol.StateMachineKickOffMethod = (MethodDefinition)method.Module.LookupToken ((int)function.synchronizationInformation.kickoffMethodToken); " is 141.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The length of the statement  "	if (!info.HasSequencePoints && info.scope == null && !info.HasCustomDebugInformations && info.StateMachineKickOffMethod == null) " is 128.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineCustomMetadata,The length of the statement  "			if (!attribute_type.IsTypeOf (compiler_services' "IteratorStateMachineAttribute") && !attribute_type.IsTypeOf (compiler_services' "AsyncStateMachineAttribute")) " is 160.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineAsyncCustomMetadata,The length of the statement  "			async_metadata.WriteUInt32 (info.StateMachineKickOffMethod != null ? info.StateMachineKickOffMethod.MetadataToken.ToUInt32 () : 0); " is 131.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineAsyncCustomMetadata,The length of the statement  "				async_metadata.WriteUInt32 (async_debug_info.MoveNextMethod != null ? async_debug_info.MoveNextMethod.MetadataToken.ToUInt32 () : 0); " is 133.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineScope,The length of the statement  "	if (scope.Import != null && scope.Import.HasTargets && !import_info_to_parent.TryGetValue (info.scope.Import' out import_parent)) { " is 131.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineLocalVariable,The length of the statement  "	writer.DefineLocalVariable2 (variable.Name' variable.Attributes' local_var_token' variable.Index' 0' 0' start_offset' end_offset); " is 130.
Long Statement,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,GetDocument,The length of the statement  "	doc_writer = writer.DefineDocument (document.Url' document.Language.ToGuid ()' document.LanguageVendor.ToGuid ()' document.Type.ToGuid ()); " is 139.
Long Statement,Mono.Cecil.Pdb,PdbReaderProvider,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\PdbHelper.cs,GetSymbolReader,The length of the statement  "	return Mixin.IsPortablePdb (Mixin.GetPdbFileName (fileName)) ? new PortablePdbReaderProvider ().GetSymbolReader (module' fileName) : new NativePdbReaderProvider ().GetSymbolReader (module' fileName); " is 199.
Long Statement,Mono.Cecil.Pdb,PdbReaderProvider,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\PdbHelper.cs,GetSymbolReader,The length of the statement  "	return Mixin.IsPortablePdb (symbolStream) ? new PortablePdbReaderProvider ().GetSymbolReader (module' symbolStream) : new NativePdbReaderProvider ().GetSymbolReader (module' symbolStream); " is 188.
Long Statement,Mono.Cecil.Pdb,SymWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,DefineLocalVariable2,The length of the statement  "	m_writer.DefineLocalVariable2 (name' (int)attributes' sigToken' 1/* ILOffset*/' addr1' addr2' addr3' startOffset' endOffset); " is 125.
Long Statement,Mono.Cecil.Pdb,SymWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\SymWriter.cs,DefineSequencePoints,The length of the statement  "	m_writer.DefineSequencePoints (document.GetUnmanaged ()' offsets.Length' offsets' lines' columns' endLines' endColumns); " is 120.
Complex Conditional,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadScopeAndLocals,The conditional expression  "type != null && !type.IsValueType && value is int && (int)value == 0"  is complex.
Complex Conditional,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The conditional expression  "!info.HasSequencePoints && info.scope == null && !info.HasCustomDebugInformations && info.StateMachineKickOffMethod == null"  is complex.
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt16,The following statement contains a magic number: value = (short)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt16,The following statement contains a magic number: offset += 2;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: value = (int)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt32,The following statement contains a magic number: offset += 4;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: value = (long)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadInt64,The following statement contains a magic number: offset += 8;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt16,The following statement contains a magic number: value = (ushort)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt16,The following statement contains a magic number: offset += 2;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: value = (uint)((buffer [offset + 0] & 0xFF) | (buffer [offset + 1] << 8) | (buffer [offset + 2] << 16) | (buffer [offset + 3] << 24));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt32,The following statement contains a magic number: offset += 4;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: value = (ulong)(((ulong)buffer [offset + 0] & 0xFF) | ((ulong)buffer [offset + 1] << 8) | ((ulong)buffer [offset + 2] << 16) | ((ulong)buffer [offset + 3] << 24) | ((ulong)buffer [offset + 4] << 32) | ((ulong)buffer [offset + 5] << 40) | ((ulong)buffer [offset + 6] << 48) | ((ulong)buffer [offset + 7] << 56));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadUInt64,The following statement contains a magic number: offset += 8;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadFloat,The following statement contains a magic number: offset += 4;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDouble,The following statement contains a magic number: offset += 8;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal (bits [2]' bits [3]' bits [1]' bits [0] < 0' (byte)((bits [0] & 0x00FF0000) >> 16));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal (bits [2]' bits [3]' bits [1]' bits [0] < 0' (byte)((bits [0] & 0x00FF0000) >> 16));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadDecimal,The following statement contains a magic number: return new decimal (bits [2]' bits [3]' bits [1]' bits [0] < 0' (byte)((bits [0] & 0x00FF0000) >> 16));  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadString,The following statement contains a magic number: while (offset + len < buffer.Length && buffer [offset + len] != 0) {  	len += 2;  }  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadString,The following statement contains a magic number: len += 2;  
Magic Number,Microsoft.Cci.Pdb,BitAccess,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitAccess.cs,ReadString,The following statement contains a magic number: offset += len + 2;  
Magic Number,Microsoft.Cci.Pdb,BitSet,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\BitSet.cs,GetBit,The following statement contains a magic number: return ((uint)1 << (index % 32));  
Magic Number,Microsoft.Cci.Pdb,DbiModuleInfo,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\DbiModuleInfo.cs,DbiModuleInfo,The following statement contains a magic number: bits.Align (4);  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))  	throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))  	throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))  	throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: if (!(loadFactorPerc >= 10 && loadFactorPerc <= 100))  	throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: throw new ArgumentOutOfRangeException ("loadFactorPerc"' String.Format ("ArgumentOutOfRange_IntHashTableLoadFactor"' 10' 100));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: this.loadFactorPerc = (loadFactorPerc * 72) / 100;  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,IntHashTable,The following statement contains a magic number: loadsize = (int)(this.loadFactorPerc * hashsize) / 100;  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,InitHash,The following statement contains a magic number: incr = (uint)(1 + (((seed >> 5) + 1) % ((uint)hashsize - 1)));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,expand,The following statement contains a magic number: rehash (GetPrime (1 + buckets.Length * 2));  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,rehash,The following statement contains a magic number: loadsize = (int)(loadFactorPerc * newsize) / 100;  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,Insert,The following statement contains a magic number: if (count >= loadsize) {  	expand ();  } else if (occupancy > loadsize && count > 100) {  	rehash ();  }  
Magic Number,Microsoft.Cci.Pdb,IntHashTable,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\IntHashTable.cs,Insert,The following statement contains a magic number: if (occupancy > loadsize && count > 100) {  	rehash ();  }  
Magic Number,Microsoft.Cci.Pdb,MsfDirectory,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\MsfDirectory.cs,MsfDirectory,The following statement contains a magic number: for (int i = 0; i < directoryRootPages; i++) {  	int pagesInThisPage = pagesToGo <= pagesPerPage ? pagesToGo : pagesPerPage;  	reader.Seek (head.directoryRoot [i]' 0);  	bits.Append (reader.reader' pagesInThisPage * 4);  	pagesToGo -= pagesInThisPage;  }  
Magic Number,Microsoft.Cci.Pdb,MsfDirectory,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\MsfDirectory.cs,MsfDirectory,The following statement contains a magic number: bits.Append (reader.reader' pagesInThisPage * 4);  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		} else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		} else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		} else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		} else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		} else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.LINES: {  		CV_LineSection sec;  		bits.ReadUInt32 (out sec.off);  		bits.ReadUInt16 (out sec.sec);  		bits.ReadUInt16 (out sec.flags);  		bits.ReadUInt32 (out sec.cod);  		int funcIndex = FindFunction (funcs' sec.sec' sec.off);  		if (funcIndex < 0)  			break;  		var func = funcs [funcIndex];  		if (func.lines == null) {  			while (funcIndex > 0) {  				var f = funcs [funcIndex - 1];  				if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex--;  			}  		} else {  			while (funcIndex < funcs.Length - 1 && func.lines != null) {  				var f = funcs [funcIndex + 1];  				if (f.segment != sec.sec || f.address != sec.off)  					break;  				func = f;  				funcIndex++;  			}  		}  		if (func.lines != null)  			break;  		// Count the line blocks.  		int begSym = bits.Position;  		int blocks = 0;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  			bits.Position += linsiz;  			blocks++;  		}  		func.lines = new PdbLines[blocks];  		int block = 0;  		bits.Position = begSym;  		while (bits.Position < endSym) {  			CV_SourceFile file;  			bits.ReadUInt32 (out file.index);  			bits.ReadUInt32 (out file.count);  			bits.ReadUInt32 (out file.linsiz);  			// Size of payload.  			PdbSource src = (PdbSource)checks [(int)file.index];  			PdbLines tmp = new PdbLines (src' file.count);  			func.lines [block++] = tmp;  			PdbLine[] lines = tmp.lines;  			int plin = bits.Position;  			int pcol = bits.Position + 8 * (int)file.count;  			for (int i = 0; i < file.count; i++) {  				CV_Line line;  				CV_Column column = new CV_Column ();  				bits.Position = plin + 8 * i;  				bits.ReadUInt32 (out line.offset);  				bits.ReadUInt32 (out line.flags);  				uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  				uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  				//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  				if ((sec.flags & 1) != 0) {  					bits.Position = pcol + 4 * i;  					bits.ReadUInt16 (out column.offColumnStart);  					bits.ReadUInt16 (out column.offColumnEnd);  				}  				lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  			}  		}  		break;  	}  	}  	bits.Position = endSym;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	} else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	} else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	} else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	} else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	} else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	} else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  	bits.Position += linsiz;  	blocks++;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  	bits.Position += linsiz;  	blocks++;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	PdbSource src = (PdbSource)checks [(int)file.index];  	PdbLines tmp = new PdbLines (src' file.count);  	func.lines [block++] = tmp;  	PdbLine[] lines = tmp.lines;  	int plin = bits.Position;  	int pcol = bits.Position + 8 * (int)file.count;  	for (int i = 0; i < file.count; i++) {  		CV_Line line;  		CV_Column column = new CV_Column ();  		bits.Position = plin + 8 * i;  		bits.ReadUInt32 (out line.offset);  		bits.ReadUInt32 (out line.flags);  		uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  		uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  		//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  		if ((sec.flags & 1) != 0) {  			bits.Position = pcol + 4 * i;  			bits.ReadUInt16 (out column.offColumnStart);  			bits.ReadUInt16 (out column.offColumnEnd);  		}  		lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	PdbSource src = (PdbSource)checks [(int)file.index];  	PdbLines tmp = new PdbLines (src' file.count);  	func.lines [block++] = tmp;  	PdbLine[] lines = tmp.lines;  	int plin = bits.Position;  	int pcol = bits.Position + 8 * (int)file.count;  	for (int i = 0; i < file.count; i++) {  		CV_Line line;  		CV_Column column = new CV_Column ();  		bits.Position = plin + 8 * i;  		bits.ReadUInt32 (out line.offset);  		bits.ReadUInt32 (out line.flags);  		uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  		uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  		//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  		if ((sec.flags & 1) != 0) {  			bits.Position = pcol + 4 * i;  			bits.ReadUInt16 (out column.offColumnStart);  			bits.ReadUInt16 (out column.offColumnEnd);  		}  		lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	PdbSource src = (PdbSource)checks [(int)file.index];  	PdbLines tmp = new PdbLines (src' file.count);  	func.lines [block++] = tmp;  	PdbLine[] lines = tmp.lines;  	int plin = bits.Position;  	int pcol = bits.Position + 8 * (int)file.count;  	for (int i = 0; i < file.count; i++) {  		CV_Line line;  		CV_Column column = new CV_Column ();  		bits.Position = plin + 8 * i;  		bits.ReadUInt32 (out line.offset);  		bits.ReadUInt32 (out line.flags);  		uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  		uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  		//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  		if ((sec.flags & 1) != 0) {  			bits.Position = pcol + 4 * i;  			bits.ReadUInt16 (out column.offColumnStart);  			bits.ReadUInt16 (out column.offColumnEnd);  		}  		lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_SourceFile file;  	bits.ReadUInt32 (out file.index);  	bits.ReadUInt32 (out file.count);  	bits.ReadUInt32 (out file.linsiz);  	// Size of payload.  	PdbSource src = (PdbSource)checks [(int)file.index];  	PdbLines tmp = new PdbLines (src' file.count);  	func.lines [block++] = tmp;  	PdbLine[] lines = tmp.lines;  	int plin = bits.Position;  	int pcol = bits.Position + 8 * (int)file.count;  	for (int i = 0; i < file.count; i++) {  		CV_Line line;  		CV_Column column = new CV_Column ();  		bits.Position = plin + 8 * i;  		bits.ReadUInt32 (out line.offset);  		bits.ReadUInt32 (out line.flags);  		uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  		uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  		//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  		if ((sec.flags & 1) != 0) {  			bits.Position = pcol + 4 * i;  			bits.ReadUInt16 (out column.offColumnStart);  			bits.ReadUInt16 (out column.offColumnEnd);  		}  		lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: for (int i = 0; i < file.count; i++) {  	CV_Line line;  	CV_Column column = new CV_Column ();  	bits.Position = plin + 8 * i;  	bits.ReadUInt32 (out line.offset);  	bits.ReadUInt32 (out line.flags);  	uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  	uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  	//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  	if ((sec.flags & 1) != 0) {  		bits.Position = pcol + 4 * i;  		bits.ReadUInt16 (out column.offColumnStart);  		bits.ReadUInt16 (out column.offColumnEnd);  	}  	lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: for (int i = 0; i < file.count; i++) {  	CV_Line line;  	CV_Column column = new CV_Column ();  	bits.Position = plin + 8 * i;  	bits.ReadUInt32 (out line.offset);  	bits.ReadUInt32 (out line.flags);  	uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  	uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  	//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  	if ((sec.flags & 1) != 0) {  		bits.Position = pcol + 4 * i;  		bits.ReadUInt16 (out column.offColumnStart);  		bits.ReadUInt16 (out column.offColumnEnd);  	}  	lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: for (int i = 0; i < file.count; i++) {  	CV_Line line;  	CV_Column column = new CV_Column ();  	bits.Position = plin + 8 * i;  	bits.ReadUInt32 (out line.offset);  	bits.ReadUInt32 (out line.flags);  	uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  	uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  	//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  	if ((sec.flags & 1) != 0) {  		bits.Position = pcol + 4 * i;  		bits.ReadUInt16 (out column.offColumnStart);  		bits.ReadUInt16 (out column.offColumnEnd);  	}  	lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: bits.Position = plin + 8 * i;  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: if ((sec.flags & 1) != 0) {  	bits.Position = pcol + 4 * i;  	bits.ReadUInt16 (out column.offColumnStart);  	bits.ReadUInt16 (out column.offColumnEnd);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following statement contains a magic number: bits.Position = pcol + 4 * i;  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFuncsFromDbiModule,The following statement contains a magic number: if (sig != 4) {  	throw new PdbDebugException ("Invalid signature. (sig={0})"' sig);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFuncsFromDbiModule,The following statement contains a magic number: bits.Position = 4;  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,The following statement contains a magic number: dir.streams [3].Read (reader' bits);  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadFunctions,The following statement contains a magic number: if (header.snTokenRidMap != 0 && header.snTokenRidMap != 0xffff) {  	dir.streams [header.snTokenRidMap].Read (reader' bits);  	uint[] ridMap = new uint[dir.streams [header.snTokenRidMap].Length / 4];  	bits.ReadUInt32 (ridMap);  	foreach (PdbFunction func in funcs) {  		func.token = 0x06000000 | ridMap [func.token & 0xffffff];  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadTokenToSourceInfo,The following statement contains a magic number: if (sig != 4) {  	throw new PdbDebugException ("Invalid signature. (sig={0})"' sig);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadTokenToSourceInfo,The following statement contains a magic number: bits.Position = 4;  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: while (bits.Position < limit) {  	int sig;  	int siz;  	bits.ReadInt32 (out sig);  	bits.ReadInt32 (out siz);  	int place = bits.Position;  	int endSym = bits.Position + siz;  	switch ((DEBUG_S_SUBSECTION)sig) {  	case DEBUG_S_SUBSECTION.FILECHKSMS:  		while (bits.Position < endSym) {  			CV_FileCheckSum chk;  			int ni = bits.Position - place;  			bits.ReadUInt32 (out chk.name);  			bits.ReadUInt8 (out chk.len);  			bits.ReadUInt8 (out chk.type);  			string name = (string)names [(int)chk.name];  			int guidStream;  			Guid doctypeGuid = DocumentType.Text.ToGuid ();  			Guid languageGuid = Guid.Empty;  			Guid vendorGuid = Guid.Empty;  			if (nameIndex.TryGetValue ("/SRC/FILES/" + name.ToUpperInvariant ()' out guidStream)) {  				var guidBits = new BitAccess (0x100);  				dir.streams [guidStream].Read (reader' guidBits);  				LoadGuidStream (guidBits' out doctypeGuid' out languageGuid' out vendorGuid);  			}  			PdbSource src = new PdbSource (/*(uint)ni'*/name' doctypeGuid' languageGuid' vendorGuid);  			checks.Add (ni' src);  			bits.Position += chk.len;  			bits.Align (4);  		}  		bits.Position = endSym;  		break;  	default:  		bits.Position = endSym;  		break;  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.FILECHKSMS:  	while (bits.Position < endSym) {  		CV_FileCheckSum chk;  		int ni = bits.Position - place;  		bits.ReadUInt32 (out chk.name);  		bits.ReadUInt8 (out chk.len);  		bits.ReadUInt8 (out chk.type);  		string name = (string)names [(int)chk.name];  		int guidStream;  		Guid doctypeGuid = DocumentType.Text.ToGuid ();  		Guid languageGuid = Guid.Empty;  		Guid vendorGuid = Guid.Empty;  		if (nameIndex.TryGetValue ("/SRC/FILES/" + name.ToUpperInvariant ()' out guidStream)) {  			var guidBits = new BitAccess (0x100);  			dir.streams [guidStream].Read (reader' guidBits);  			LoadGuidStream (guidBits' out doctypeGuid' out languageGuid' out vendorGuid);  		}  		PdbSource src = new PdbSource (/*(uint)ni'*/name' doctypeGuid' languageGuid' vendorGuid);  		checks.Add (ni' src);  		bits.Position += chk.len;  		bits.Align (4);  	}  	bits.Position = endSym;  	break;  default:  	bits.Position = endSym;  	break;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: while (bits.Position < endSym) {  	CV_FileCheckSum chk;  	int ni = bits.Position - place;  	bits.ReadUInt32 (out chk.name);  	bits.ReadUInt8 (out chk.len);  	bits.ReadUInt8 (out chk.type);  	string name = (string)names [(int)chk.name];  	int guidStream;  	Guid doctypeGuid = DocumentType.Text.ToGuid ();  	Guid languageGuid = Guid.Empty;  	Guid vendorGuid = Guid.Empty;  	if (nameIndex.TryGetValue ("/SRC/FILES/" + name.ToUpperInvariant ()' out guidStream)) {  		var guidBits = new BitAccess (0x100);  		dir.streams [guidStream].Read (reader' guidBits);  		LoadGuidStream (guidBits' out doctypeGuid' out languageGuid' out vendorGuid);  	}  	PdbSource src = new PdbSource (/*(uint)ni'*/name' doctypeGuid' languageGuid' vendorGuid);  	checks.Add (ni' src);  	bits.Position += chk.len;  	bits.Align (4);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,ReadSourceFileInfo,The following statement contains a magic number: bits.Align (4);  
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.MinCapacity (56);  
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer (reader' 52);  
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: this.magic = new byte[32];  
Magic Number,Microsoft.Cci.Pdb,PdbFileHeader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFileHeader.cs,PdbFileHeader,The following statement contains a magic number: bits.FillBuffer (reader' directoryPages * 4);  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: while (bits.Position < proc.end) {  	ushort siz;  	ushort rec;  	bits.ReadUInt16 (out siz);  	int star = bits.Position;  	int stop = bits.Position + siz;  	bits.Position = star;  	bits.ReadUInt16 (out rec);  	switch ((SYM)rec) {  	case SYM.S_OEM: {  		// 0x0404  		OemSymbol oem;  		bits.ReadGuid (out oem.idOem);  		bits.ReadUInt32 (out oem.typind);  		// internal byte[]   rgl;        // user data' force 4-byte alignment  		if (oem.idOem == msilMetaData) {  			string name = bits.ReadString ();  			if (name == "MD2") {  				byte version;  				bits.ReadUInt8 (out version);  				if (version == 4) {  					byte count;  					bits.ReadUInt8 (out count);  					bits.Align (4);  					while (count-- > 0)  						this.ReadCustomMetadata (bits);  				}  			} else if (name == "asyncMethodInfo") {  				this.synchronizationInformation = new PdbSynchronizationInformation (bits);  			}  			bits.Position = stop;  			break;  		} else {  			throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  			// bits.Position = stop;  		}  	}  	case SYM.S_BLOCK32: {  		BlockSym32 block = new BlockSym32 ();  		bits.ReadUInt32 (out block.parent);  		bits.ReadUInt32 (out block.end);  		bits.ReadUInt32 (out block.len);  		bits.ReadUInt32 (out block.off);  		bits.ReadUInt16 (out block.seg);  		bits.SkipCString (out block.name);  		bits.Position = stop;  		scopes [scope++] = new PdbScope (this.address' block' bits' out slotToken);  		bits.Position = (int)block.end;  		break;  	}  	case SYM.S_MANSLOT:  		slots [slot++] = new PdbSlot (bits);  		bits.Position = stop;  		break;  	case SYM.S_MANCONSTANT:  		constants [constant++] = new PdbConstant (bits);  		bits.Position = stop;  		break;  	case SYM.S_UNAMESPACE:  		bits.ReadCString (out usedNamespaces [usedNs++]);  		bits.Position = stop;  		break;  	case SYM.S_END:  		bits.Position = stop;  		break;  	default: {  		//throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);  		bits.Position = stop;  		break;  	}  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: while (bits.Position < proc.end) {  	ushort siz;  	ushort rec;  	bits.ReadUInt16 (out siz);  	int star = bits.Position;  	int stop = bits.Position + siz;  	bits.Position = star;  	bits.ReadUInt16 (out rec);  	switch ((SYM)rec) {  	case SYM.S_OEM: {  		// 0x0404  		OemSymbol oem;  		bits.ReadGuid (out oem.idOem);  		bits.ReadUInt32 (out oem.typind);  		// internal byte[]   rgl;        // user data' force 4-byte alignment  		if (oem.idOem == msilMetaData) {  			string name = bits.ReadString ();  			if (name == "MD2") {  				byte version;  				bits.ReadUInt8 (out version);  				if (version == 4) {  					byte count;  					bits.ReadUInt8 (out count);  					bits.Align (4);  					while (count-- > 0)  						this.ReadCustomMetadata (bits);  				}  			} else if (name == "asyncMethodInfo") {  				this.synchronizationInformation = new PdbSynchronizationInformation (bits);  			}  			bits.Position = stop;  			break;  		} else {  			throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  			// bits.Position = stop;  		}  	}  	case SYM.S_BLOCK32: {  		BlockSym32 block = new BlockSym32 ();  		bits.ReadUInt32 (out block.parent);  		bits.ReadUInt32 (out block.end);  		bits.ReadUInt32 (out block.len);  		bits.ReadUInt32 (out block.off);  		bits.ReadUInt16 (out block.seg);  		bits.SkipCString (out block.name);  		bits.Position = stop;  		scopes [scope++] = new PdbScope (this.address' block' bits' out slotToken);  		bits.Position = (int)block.end;  		break;  	}  	case SYM.S_MANSLOT:  		slots [slot++] = new PdbSlot (bits);  		bits.Position = stop;  		break;  	case SYM.S_MANCONSTANT:  		constants [constant++] = new PdbConstant (bits);  		bits.Position = stop;  		break;  	case SYM.S_UNAMESPACE:  		bits.ReadCString (out usedNamespaces [usedNs++]);  		bits.Position = stop;  		break;  	case SYM.S_END:  		bits.Position = stop;  		break;  	default: {  		//throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);  		bits.Position = stop;  		break;  	}  	}  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: switch ((SYM)rec) {  case SYM.S_OEM: {  	// 0x0404  	OemSymbol oem;  	bits.ReadGuid (out oem.idOem);  	bits.ReadUInt32 (out oem.typind);  	// internal byte[]   rgl;        // user data' force 4-byte alignment  	if (oem.idOem == msilMetaData) {  		string name = bits.ReadString ();  		if (name == "MD2") {  			byte version;  			bits.ReadUInt8 (out version);  			if (version == 4) {  				byte count;  				bits.ReadUInt8 (out count);  				bits.Align (4);  				while (count-- > 0)  					this.ReadCustomMetadata (bits);  			}  		} else if (name == "asyncMethodInfo") {  			this.synchronizationInformation = new PdbSynchronizationInformation (bits);  		}  		bits.Position = stop;  		break;  	} else {  		throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  		// bits.Position = stop;  	}  }  case SYM.S_BLOCK32: {  	BlockSym32 block = new BlockSym32 ();  	bits.ReadUInt32 (out block.parent);  	bits.ReadUInt32 (out block.end);  	bits.ReadUInt32 (out block.len);  	bits.ReadUInt32 (out block.off);  	bits.ReadUInt16 (out block.seg);  	bits.SkipCString (out block.name);  	bits.Position = stop;  	scopes [scope++] = new PdbScope (this.address' block' bits' out slotToken);  	bits.Position = (int)block.end;  	break;  }  case SYM.S_MANSLOT:  	slots [slot++] = new PdbSlot (bits);  	bits.Position = stop;  	break;  case SYM.S_MANCONSTANT:  	constants [constant++] = new PdbConstant (bits);  	bits.Position = stop;  	break;  case SYM.S_UNAMESPACE:  	bits.ReadCString (out usedNamespaces [usedNs++]);  	bits.Position = stop;  	break;  case SYM.S_END:  	bits.Position = stop;  	break;  default: {  	//throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);  	bits.Position = stop;  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: switch ((SYM)rec) {  case SYM.S_OEM: {  	// 0x0404  	OemSymbol oem;  	bits.ReadGuid (out oem.idOem);  	bits.ReadUInt32 (out oem.typind);  	// internal byte[]   rgl;        // user data' force 4-byte alignment  	if (oem.idOem == msilMetaData) {  		string name = bits.ReadString ();  		if (name == "MD2") {  			byte version;  			bits.ReadUInt8 (out version);  			if (version == 4) {  				byte count;  				bits.ReadUInt8 (out count);  				bits.Align (4);  				while (count-- > 0)  					this.ReadCustomMetadata (bits);  			}  		} else if (name == "asyncMethodInfo") {  			this.synchronizationInformation = new PdbSynchronizationInformation (bits);  		}  		bits.Position = stop;  		break;  	} else {  		throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  		// bits.Position = stop;  	}  }  case SYM.S_BLOCK32: {  	BlockSym32 block = new BlockSym32 ();  	bits.ReadUInt32 (out block.parent);  	bits.ReadUInt32 (out block.end);  	bits.ReadUInt32 (out block.len);  	bits.ReadUInt32 (out block.off);  	bits.ReadUInt16 (out block.seg);  	bits.SkipCString (out block.name);  	bits.Position = stop;  	scopes [scope++] = new PdbScope (this.address' block' bits' out slotToken);  	bits.Position = (int)block.end;  	break;  }  case SYM.S_MANSLOT:  	slots [slot++] = new PdbSlot (bits);  	bits.Position = stop;  	break;  case SYM.S_MANCONSTANT:  	constants [constant++] = new PdbConstant (bits);  	bits.Position = stop;  	break;  case SYM.S_UNAMESPACE:  	bits.ReadCString (out usedNamespaces [usedNs++]);  	bits.Position = stop;  	break;  case SYM.S_END:  	bits.Position = stop;  	break;  default: {  	//throw new PdbDebugException("Unknown SYM: {0}"' (SYM)rec);  	bits.Position = stop;  	break;  }  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (oem.idOem == msilMetaData) {  	string name = bits.ReadString ();  	if (name == "MD2") {  		byte version;  		bits.ReadUInt8 (out version);  		if (version == 4) {  			byte count;  			bits.ReadUInt8 (out count);  			bits.Align (4);  			while (count-- > 0)  				this.ReadCustomMetadata (bits);  		}  	} else if (name == "asyncMethodInfo") {  		this.synchronizationInformation = new PdbSynchronizationInformation (bits);  	}  	bits.Position = stop;  	break;  } else {  	throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  	// bits.Position = stop;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (oem.idOem == msilMetaData) {  	string name = bits.ReadString ();  	if (name == "MD2") {  		byte version;  		bits.ReadUInt8 (out version);  		if (version == 4) {  			byte count;  			bits.ReadUInt8 (out count);  			bits.Align (4);  			while (count-- > 0)  				this.ReadCustomMetadata (bits);  		}  	} else if (name == "asyncMethodInfo") {  		this.synchronizationInformation = new PdbSynchronizationInformation (bits);  	}  	bits.Position = stop;  	break;  } else {  	throw new PdbDebugException ("OEM section: guid={0} ti={1}"' oem.idOem' oem.typind);  	// bits.Position = stop;  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (name == "MD2") {  	byte version;  	bits.ReadUInt8 (out version);  	if (version == 4) {  		byte count;  		bits.ReadUInt8 (out count);  		bits.Align (4);  		while (count-- > 0)  			this.ReadCustomMetadata (bits);  	}  } else if (name == "asyncMethodInfo") {  	this.synchronizationInformation = new PdbSynchronizationInformation (bits);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (name == "MD2") {  	byte version;  	bits.ReadUInt8 (out version);  	if (version == 4) {  		byte count;  		bits.ReadUInt8 (out count);  		bits.Align (4);  		while (count-- > 0)  			this.ReadCustomMetadata (bits);  	}  } else if (name == "asyncMethodInfo") {  	this.synchronizationInformation = new PdbSynchronizationInformation (bits);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (version == 4) {  	byte count;  	bits.ReadUInt8 (out count);  	bits.Align (4);  	while (count-- > 0)  		this.ReadCustomMetadata (bits);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: if (version == 4) {  	byte count;  	bits.ReadUInt8 (out count);  	bits.Align (4);  	while (count-- > 0)  		this.ReadCustomMetadata (bits);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,PdbFunction,The following statement contains a magic number: bits.Align (4);  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: if (version != 4) {  	throw new PdbDebugException ("Unknown custom metadata item version: {0}"' version);  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: bits.Align (4);  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {  case 0:  	this.ReadUsingInfo (bits);  	break;  case 1:  	this.ReadForwardInfo (bits);  	break;  case 2:  	break;  // this.ReadForwardedToModuleInfo(bits); break;  case 3:  	this.ReadIteratorLocals (bits);  	break;  case 4:  	this.ReadForwardIterator (bits);  	break;  // TODO: handle unknown custom metadata' 5 & 6 are new with roslyn' see https://roslyn.codeplex.com/workitem/54  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {  case 0:  	this.ReadUsingInfo (bits);  	break;  case 1:  	this.ReadForwardInfo (bits);  	break;  case 2:  	break;  // this.ReadForwardedToModuleInfo(bits); break;  case 3:  	this.ReadIteratorLocals (bits);  	break;  case 4:  	this.ReadForwardIterator (bits);  	break;  // TODO: handle unknown custom metadata' 5 & 6 are new with roslyn' see https://roslyn.codeplex.com/workitem/54  }  
Magic Number,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following statement contains a magic number: switch (kind) {  case 0:  	this.ReadUsingInfo (bits);  	break;  case 1:  	this.ReadForwardInfo (bits);  	break;  case 2:  	break;  // this.ReadForwardedToModuleInfo(bits); break;  case 3:  	this.ReadIteratorLocals (bits);  	break;  case 4:  	this.ReadForwardIterator (bits);  	break;  // TODO: handle unknown custom metadata' 5 & 6 are new with roslyn' see https://roslyn.codeplex.com/workitem/54  }  
Magic Number,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,WriteString,The following statement contains a magic number: for (int i = 0; i < length; i++) {  	Marshal.WriteInt16 (buffer' offset' str [i]);  	offset += 2;  }  
Magic Number,Mono.Cecil.Pdb,ModuleMetadata,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\ModuleMetadata.cs,WriteString,The following statement contains a magic number: offset += 2;  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: if (data.Length < 24)  	return false;  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: Buffer.BlockCopy (data' 4' guid_bytes' 0' 16);  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: Buffer.BlockCopy (data' 4' guid_bytes' 0' 16);  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ProcessDebugHeader,The following statement contains a magic number: this.age = ReadInt32 (data' 20);  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadInt32,The following statement contains a magic number: return (bytes [start] | (bytes [start + 1] << 8) | (bytes [start + 2] << 16) | (bytes [start + 3] << 24));  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadScopeAndLocals,The following statement contains a magic number: if (!scope.slots.IsNullOrEmpty ()) {  	parent.variables = new Collection<VariableDebugInformation> (scope.slots.Length);  	foreach (PdbSlot slot in scope.slots) {  		if (slot.flags == 1)  			// parameter names  			continue;  		var index = (int)slot.slot;  		var variable = new VariableDebugInformation (index' slot.name);  		if (slot.flags == 4)  			variable.IsDebuggerHidden = true;  		parent.variables.Add (variable);  	}  }  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadScopeAndLocals,The following statement contains a magic number: foreach (PdbSlot slot in scope.slots) {  	if (slot.flags == 1)  		// parameter names  		continue;  	var index = (int)slot.slot;  	var variable = new VariableDebugInformation (index' slot.name);  	if (slot.flags == 4)  		variable.IsDebuggerHidden = true;  	parent.variables.Add (variable);  }  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,ReadScopeAndLocals,The following statement contains a magic number: if (slot.flags == 4)  	variable.IsDebuggerHidden = true;  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The following statement contains a magic number: foreach (var used_namespace in scope.usedNamespaces) {  	ImportTarget target = null;  	var value = used_namespace.Substring (1);  	switch (used_namespace [0]) {  	case 'U':  		target = new ImportTarget (ImportTargetKind.ImportNamespace) {  			@namespace = value  		};  		break;  	case 'T': {  		var type = module.GetType (value' runtimeName: true);  		if (type != null)  			target = new ImportTarget (ImportTargetKind.ImportType) {  				type = type  			};  		break;  	}  	case 'A':  		var index = used_namespace.IndexOf (' ');  		var alias_value = used_namespace.Substring (1' index - 1);  		var alias_target_value = used_namespace.Substring (index + 2);  		switch (used_namespace [index + 1]) {  		case 'U':  			target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) {  				alias = alias_value'  				@namespace = alias_target_value  			};  			break;  		case 'T':  			var type = module.GetType (alias_target_value' runtimeName: true);  			if (type != null)  				target = new ImportTarget (ImportTargetKind.DefineTypeAlias) {  					alias = alias_value'  					type = type  				};  			break;  		}  		break;  	}  	if (target != null)  		import.Targets.Add (target);  }  
Magic Number,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The following statement contains a magic number: switch (used_namespace [0]) {  case 'U':  	target = new ImportTarget (ImportTargetKind.ImportNamespace) {  		@namespace = value  	};  	break;  case 'T': {  	var type = module.GetType (value' runtimeName: true);  	if (type != null)  		target = new ImportTarget (ImportTargetKind.ImportType) {  			type = type  		};  	break;  }  case 'A':  	var index = used_namespace.IndexOf (' ');  	var alias_value = used_namespace.Substring (1' index - 1);  	var alias_target_value = used_namespace.Substring (index + 2);  	switch (used_namespace [index + 1]) {  	case 'U':  		target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) {  			alias = alias_value'  			@namespace = alias_target_value  		};  		break;  	case 'T':  		var type = module.GetType (alias_target_value' runtimeName: true);  		if (type != null)  			target = new ImportTarget (ImportTargetKind.DefineTypeAlias) {  				alias = alias_value'  				type = type  			};  		break;  	}  	break;  }  
Magic Number,Mono.Cecil.Pdb,CustomMetadataWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,CustomMetadataWriter,The following statement contains a magic number: writer.Align (4);  
Magic Number,Mono.Cecil.Pdb,CustomMetadataWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The following statement contains a magic number: writer.Align (4);  
Magic Number,Mono.Cecil.Pdb,CustomMetadataWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,Write,The following statement contains a magic number: writer.Align (4);  
Missing Default,Microsoft.Cci.Pdb,PdbFile,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFile.cs,LoadManagedLines,The following switch statement is missing a default case: switch ((DEBUG_S_SUBSECTION)sig) {  case DEBUG_S_SUBSECTION.LINES: {  	CV_LineSection sec;  	bits.ReadUInt32 (out sec.off);  	bits.ReadUInt16 (out sec.sec);  	bits.ReadUInt16 (out sec.flags);  	bits.ReadUInt32 (out sec.cod);  	int funcIndex = FindFunction (funcs' sec.sec' sec.off);  	if (funcIndex < 0)  		break;  	var func = funcs [funcIndex];  	if (func.lines == null) {  		while (funcIndex > 0) {  			var f = funcs [funcIndex - 1];  			if (f.lines != null || f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex--;  		}  	} else {  		while (funcIndex < funcs.Length - 1 && func.lines != null) {  			var f = funcs [funcIndex + 1];  			if (f.segment != sec.sec || f.address != sec.off)  				break;  			func = f;  			funcIndex++;  		}  	}  	if (func.lines != null)  		break;  	// Count the line blocks.  	int begSym = bits.Position;  	int blocks = 0;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		int linsiz = (int)file.count * (8 + ((sec.flags & 1) != 0 ? 4 : 0));  		bits.Position += linsiz;  		blocks++;  	}  	func.lines = new PdbLines[blocks];  	int block = 0;  	bits.Position = begSym;  	while (bits.Position < endSym) {  		CV_SourceFile file;  		bits.ReadUInt32 (out file.index);  		bits.ReadUInt32 (out file.count);  		bits.ReadUInt32 (out file.linsiz);  		// Size of payload.  		PdbSource src = (PdbSource)checks [(int)file.index];  		PdbLines tmp = new PdbLines (src' file.count);  		func.lines [block++] = tmp;  		PdbLine[] lines = tmp.lines;  		int plin = bits.Position;  		int pcol = bits.Position + 8 * (int)file.count;  		for (int i = 0; i < file.count; i++) {  			CV_Line line;  			CV_Column column = new CV_Column ();  			bits.Position = plin + 8 * i;  			bits.ReadUInt32 (out line.offset);  			bits.ReadUInt32 (out line.flags);  			uint lineBegin = line.flags & (uint)CV_Line_Flags.linenumStart;  			uint delta = (line.flags & (uint)CV_Line_Flags.deltaLineEnd) >> 24;  			//bool statement = ((line.flags & (uint)CV_Line_Flags.fStatement) == 0);  			if ((sec.flags & 1) != 0) {  				bits.Position = pcol + 4 * i;  				bits.ReadUInt16 (out column.offColumnStart);  				bits.ReadUInt16 (out column.offColumnEnd);  			}  			lines [i] = new PdbLine (line.offset' lineBegin' column.offColumnStart' lineBegin + delta' column.offColumnEnd);  		}  	}  	break;  }  }  
Missing Default,Microsoft.Cci.Pdb,PdbFunction,F:\newReposMay17\jbevain_cecil\symbols\pdb\Microsoft.Cci.Pdb\PdbFunction.cs,ReadCustomMetadata,The following switch statement is missing a default case: switch (kind) {  case 0:  	this.ReadUsingInfo (bits);  	break;  case 1:  	this.ReadForwardInfo (bits);  	break;  case 2:  	break;  // this.ReadForwardedToModuleInfo(bits); break;  case 3:  	this.ReadIteratorLocals (bits);  	break;  case 4:  	this.ReadForwardIterator (bits);  	break;  // TODO: handle unknown custom metadata' 5 & 6 are new with roslyn' see https://roslyn.codeplex.com/workitem/54  }  
Missing Default,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The following switch statement is missing a default case: switch (used_namespace [0]) {  case 'U':  	target = new ImportTarget (ImportTargetKind.ImportNamespace) {  		@namespace = value  	};  	break;  case 'T': {  	var type = module.GetType (value' runtimeName: true);  	if (type != null)  		target = new ImportTarget (ImportTargetKind.ImportType) {  			type = type  		};  	break;  }  case 'A':  	var index = used_namespace.IndexOf (' ');  	var alias_value = used_namespace.Substring (1' index - 1);  	var alias_target_value = used_namespace.Substring (index + 2);  	switch (used_namespace [index + 1]) {  	case 'U':  		target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) {  			alias = alias_value'  			@namespace = alias_target_value  		};  		break;  	case 'T':  		var type = module.GetType (alias_target_value' runtimeName: true);  		if (type != null)  			target = new ImportTarget (ImportTargetKind.DefineTypeAlias) {  				alias = alias_value'  				type = type  			};  		break;  	}  	break;  }  
Missing Default,Mono.Cecil.Pdb,NativePdbReader,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbReader.cs,GetImport,The following switch statement is missing a default case: switch (used_namespace [index + 1]) {  case 'U':  	target = new ImportTarget (ImportTargetKind.DefineNamespaceAlias) {  		alias = alias_value'  		@namespace = alias_target_value  	};  	break;  case 'T':  	var type = module.GetType (alias_target_value' runtimeName: true);  	if (type != null)  		target = new ImportTarget (ImportTargetKind.DefineTypeAlias) {  			alias = alias_value'  			type = type  		};  	break;  }  
Missing Default,Mono.Cecil.Pdb,NativePdbWriter,F:\newReposMay17\jbevain_cecil\symbols\pdb\Mono.Cecil.Pdb\NativePdbWriter.cs,DefineScope,The following switch statement is missing a default case: switch (target.Kind) {  case ImportTargetKind.ImportNamespace:  	writer.UsingNamespace ("U" + target.@namespace);  	break;  case ImportTargetKind.ImportType:  	writer.UsingNamespace ("T" + TypeParser.ToParseable (target.type));  	break;  case ImportTargetKind.DefineNamespaceAlias:  	writer.UsingNamespace ("A" + target.Alias + " U" + target.@namespace);  	break;  case ImportTargetKind.DefineTypeAlias:  	writer.UsingNamespace ("A" + target.Alias + " T" + TypeParser.ToParseable (target.type));  	break;  }  
